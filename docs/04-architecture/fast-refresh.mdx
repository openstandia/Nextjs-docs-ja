---
title: Fast Refresh
description: Fast Refreshは、Reactコンポーネントに対する変更を即座にフィードバックしてくれるホットモジュールリロード体験です。
---

Fast Refreshは、ファイルに変更を保存した際に一時的なクライアントサイドの状態を維持しながら、ブラウザページをライブリロードできる、Next.jsに統合されたReactの機能です。これはすべてのNext.jsアプリケーションで**9.4以降**でデフォルトで有効になっています。Fast Refreshが有効な状態では、ほとんどの編集が1秒以内に表示されるべきです。

## 仕組み

- **Reactコンポーネントのみをエクスポートする**ファイルを編集すると、Fast Refreshはそのファイルのコードのみを更新し、コンポーネントを再レンダリングします。ファイル内のスタイル、レンダリングロジック、イベントハンドラ、エフェクトなど何でも編集可能です
- _Reactコンポーネントではない_エクスポートがあるファイルを編集すると、Fast Refreshはそのファイルとそれをインポートする他のファイルを再実行します。たとえば、`Button.js`と`Modal.js`の両方が`theme.js`をインポートしている場合、`theme.js`を編集すると両方のコンポーネントが更新されます
- 最後に、**Reactツリー外のファイルによってインポートされている**ファイルを**編集**した場合、Fast Refreshは**完全なリロードにフォールバック**します。Reactコンポーネントをレンダリングするが、**非Reactコンポーネント**によってインポートされる値もエクスポートするファイルがあるかもしれません。例えば、コンポーネントが定数もエクスポートし、非Reactのユーティリティファイルがそれをインポートしている場合などです。その場合、コンポーネントと非Reactファイルの両方に定数を移行し、それをそれぞれのファイルにインポートすることを検討してください。これにより、Fast Refreshが機能するようになります。他のケースも通常同様に解決できます

## エラーの回復力

### 構文エラー

開発中に構文エラーを作成した場合、エラーを修正してファイルを再保存できます。エラーは自動的に消え、アプリをリロードする必要はありません。**コンポーネントの状態は失われません**。

### 実行時エラー

コンポーネント内で実行時エラーを引き起こす間違いを犯した場合、コンテキストオーバーレイが表示されます。エラーを修正すると、オーバーレイはアプリをリロードせずに自動で消えます。

エラーがレンダリング中に発生しなかった場合、コンポーネントの状態は保持されます。エラーがレンダリング中に発生した場合、Reactは更新されたコードを使用してアプリケーションを再マウントします。

アプリに[エラーバウンダリ](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)がある場合（これは本番環境での健全な失敗のために推奨されます）、レンダリングエラーの後に次の編集で再試行されます。これにより、エラーバウンダリがあると、常にルートアプリの状態にリセットされるのを防ぐことができます。ただし、エラーバウンダリはあまりにも詳細にするべきではないことに注意してください。これはReactが本番環境で使用する機能であり、意図的に設計されるべきです。

## 制限事項

Fast Refreshは、編集中のコンポーネントのローカルReact状態を保持しようとしますが、安全な場合のみです。ファイル編集時にローカル状態が毎回リセットされる可能性がある理由には以下のものがあります：

- ローカル状態はクラスコンポーネントに対しては保持されません（状態を保持するのは関数コンポーネントとHooksのみです）
- 編集中のファイルにReactコンポーネント以外の_他の_エクスポートが含まれている可能性があります
- 場合によっては、ファイルが`HOC(WrappedComponent)`のような高階コンポーネントを呼び出した結果をエクスポートすることがあります。返されたコンポーネントがクラスの場合、その状態はリセットされます
- `export default () => <div />;`のような匿名のアロー関数は、地元のコンポーネントの状態を保持しない原因になります。大規模なコードベースの場合は、[`name-default-component` コードモッド](/docs/pages/building-your-application/upgrading/codemods#name-default-component)を使用することができます。

コードベースのより多くが関数コンポーネントやHooksに移行するにつれて、より多くのケースで状態が保持されることが期待されます。

## ヒント

- Fast Refreshは関数コンポーネント（およびHooks）でReactのローカル状態をデフォルトで保持します
- 状態をリセットし、コンポーネントを再マウントさせたい場合もあるかもしれません。たとえば、マウント時にのみ発生するアニメーションを調整する際に便利です。これを行うには、編集中のファイルの任意の場所に`// @refresh reset`を追加することができます。この指示はファイルにローカルで、Fast Refreshにそのファイルで定義されたコンポーネントを毎回編集時に再マウントするように指示します
- 開発中に編集するコンポーネントに`console.log`や`debugger;`を追加できます
- インポートが大文字と小文字を区別することを忘れないでください。インポートが実際のファイル名と一致しない場合、快速リフレッシュと完全リフレッシュの両方が失敗する可能性があります。たとえば、`'./header'`と`'./Header'`のような違いです

## Fast RefreshとHooks

可能であれば、Fast Refreshは編集間でコンポーネントの状態を保持しようとします。具体的には、`useState`と`useRef`は、引数やフック呼び出しの順序を変更しない限り、以前の値を保持します。

依存関係のあるHooks、たとえば`useEffect`、`useMemo`、`useCallback`は、Fast Refresh中に_常に_更新されます。Fast Refreshが発生している間は、依存関係のリストは無視されます。

たとえば、`useMemo(() => x * 2, [x])`を`useMemo(() => x * 10, [x])`に編集すると、依存関係`x`が変更されなくても再実行されます。Reactがそれをしなければ、編集が画面に反映されないでしょう！

時々、これが予期しない結果を招くことがあります。たとえば、依存する配列が空の`useEffect`でさえ、Fast Refresh中に一度再実行されます。

しかし、Fast Refreshがない場合でも、`useEffect`の再実行に対して耐性のあるコードを書くことはよいプラクティスです。そうすれば、この後に新たな依存関係を導入しやすくなりますし、[React Strict Mode](/docs/pages/api-reference/next-config-js/reactStrictMode)でそれが強制されます。これを有効にすることを強くお勧めします。