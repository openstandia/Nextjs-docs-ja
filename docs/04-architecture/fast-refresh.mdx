---
title: 'Fast Refresh'
description: 'Fast Refreshは、Reactコンポーネントへの編集に対して瞬時にフィードバックを提供するホットモジュールリロード体験です。'
---

Fast Refreshは、Next.jsに統合されたReactの機能で、ファイルを保存する際にクライアントサイドの一時的な状態を保持しつつブラウザページをライブリロードできます。すべてのNext.jsアプリケーションで**9.4以降**のバージョンではデフォルトで有効になっています。Fast Refreshが有効な状態では、多くの編集が1秒以内に反映されます。

## 仕組み

- **Reactコンポーネントのみをエクスポートしているファイル**を編集した場合、Fast Refreshはそのファイルのコードのみを更新し、コンポーネントを再レンダリングします。スタイル、レンダリングロジック、イベントハンドラ、エフェクトなど、そのファイル内のすべてを編集できます
- _Reactコンポーネントではない_ エクスポートを持つファイルを編集すると、Fast Refreshはそのファイルとそれをインポートしている他のファイルを再実行します。たとえば、`Button.js`と`Modal.js`の両方が`theme.js`をインポートしている場合、`theme.js`を編集すると、両方のコンポーネントが更新されます
- 最後に、**React tree外のファイルによってインポートされているファイル**を編集した場合、Fast Refreshは**完全なリロードを行うようにフォールバック**します。Reactコンポーネントをレンダリングするファイルでもあり、同時に**非Reactコンポーネント**によってインポートされる値をエクスポートするファイルがあるかもしれません。たとえば、コンポーネントが定数をエクスポートし、非Reactユーティリティファイルがそれをインポートしている場合です。この場合、定数を別のファイルに移動し、両方のファイルにインポートすることを検討してください。これにより、Fast Refreshが再び機能するようになります。他のケースでも通常、同様の方法で解決できます。

## エラーに対する耐性

### 構文エラー

開発中に構文エラーを発生させた場合、修正してファイルを再保存できます。エラーは自動的に消えるので、アプリをリロードする必要はありません。**コンポーネントの状態は失われません**。

### ランタイムエラー

コンポーネント内でランタイムエラーにつながるミスをした場合、コンテキストに基づくオーバーレイが表示されます。エラーを修正すると、アプリをリロードせずにオーバーレイが自動的に消えます。

エラーがレンダリング中に発生しなかった場合、コンポーネントの状態は保持されます。レンダリング中にエラーが発生した場合、Reactは更新されたコードを使用してアプリケーションをリマウントします。

アプリに[error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)がある場合（本番環境での優雅な失敗に備えて推奨されます）、レンダリングエラー後には次の編集で再度レンダリングを試みます。これは、error boundaryがあると常にrootのアプリ状態にリセットされるのを防ぐことができます。ただし、error boundaryは_あまり_細かくしすぎないように注意してください。本番環境でReactが使用するものであり、常に意図して設計されるべきです。

## 制限事項

Fast Refreshは編集中のコンポーネント内のローカルReact状態を保持しようとしますが、安全な場合に限ります。以下は、ファイルの編集ごとにローカル状態がリセットされる理由のいくつかです：

- ローカル状態はクラスコンポーネントには保持されません（関数コンポーネントとフックのみが状態を保持します）
- 編集しているファイルに、Reactコンポーネント以外のエクスポートがあるかもしれません
- 時々、ファイルが`HOC(WrappedComponent)`のような高階コンポーネントを呼び出した結果をエクスポートする場合があります。もし戻り値のコンポーネントがクラスであれば、その状態はリセットされます
- 無名のアロー関数（例：`export default () => <div />;`）はFast Refreshがローカルコンポーネント状態を保持しない原因になります。大規模なコードベースの場合、[`name-default-component` codemod](/docs/pages/building-your-application/upgrading/codemods#name-default-component)を使用できます。

コードベースの多くが関数コンポーネントとフックに移行するにつれて、より多くのケースで状態が保持されるようになることが期待されます。

## ヒント

- Fast Refreshは、デフォルトで関数コンポーネント（およびフック）内のReactローカル状態を保持します
- 時には状態をリセットし、コンポーネントを再マウントさせたい場合があります。例えば、マウント時にのみ起こるアニメーションを調整している場合などで便利です。その場合、編集しているファイルの任意の場所に`// @refresh reset`を追加できます。この指示はファイルローカルであり、そのファイルに定義されたコンポーネントを毎回編集のたびに再マウントするようにFast Refreshに指示します
- 開発中に編集するコンポーネントに`console.log`や`debugger;`を入れることができます
- インポートは大文字と小文字を区別することを忘れないでください。インポートが実際のファイル名と一致しない場合、Fast Refreshと完全なリフレッシュは失敗することがあります。例えば、`'./header'`と`'./Header'`のように。

## Fast Refreshとフック

可能な限り、Fast Refreshは編集ごとのコンポーネントの状態を保持しようとします。特に、`useState`と`useRef`は、その引数やフック呼び出しの順序を変更しない限り、前の値を保持します。

依存関係を伴うフック、例えば`useEffect`、`useMemo`、`useCallback`などは、Fast Refreshの際に_常に_更新されます。依存関係のリストは、Fast Refreshが発生している間は無視されます。

例えば、`useMemo(() => x * 2, [x])`を`useMemo(() => x * 10, [x])`に編集すると、`x`（依存関係）が変わっていなくても再実行されます。Reactがそれをしなければ、画面に編集内容が反映されません！

時には、これが予期しない結果をもたらすことがあります。例えば、依存関係を持たない空の配列を持つ`useEffect`でも、Fast Refresh中に一度再実行されます。

しかし、たとえFast Refreshがない場合でも、`useEffect`を適宜再実行可能なコードを書くことは良いプラクティスです。後で新しい依存関係を追加しやすくなり、[React Strict Mode](/docs/pages/api-reference/next-config-js/reactStrictMode)にも対応できるため、有効にすることを強くおすすめします。