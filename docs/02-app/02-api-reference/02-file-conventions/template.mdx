---
title: template.js
description: template.jsファイルのAPIリファレンス。
---

**template**ファイルは、[layout](/docs/app/building-your-application/routing/layouts-and-templates#layouts)と似ており、レイアウトやページをラップします。ルートをまたいで状態を保持するレイアウトとは異なり、テンプレートにはユニークなキーが与えられ、子クライアントコンポーネントがナビゲーション時にその状態をリセットします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/template.tsx" switcher
export default function Template({ children }: { children: React.ReactNode }) {
  return <div>{children}</div>
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/template.jsx" switcher
export default function Template({ children }) {
  return <div>{children}</div>
}
```
</TabItem>
</Tabs>


<Image
  alt="template.js特別ファイル"
  srcLight="/docs/light/template-special-file.png"
  srcDark="/docs/dark/template-special-file.png"
  width="1600"
  height="444"
/>

あまり一般的ではありませんが、テンプレートをレイアウトの代わりに使用することを選ぶかもしれません、それは以下のような場合です

- `useEffect`（例えばページビューのログ）や`useState`（例えばページごとのフィードバックフォーム）に依存する機能が必要
- デフォルトのフレームワークの挙動を変更したい。例えば、レイアウト内のサスペンスバウンダリは、レイアウトが初めて読み込まれるときにのみフォールバックを表示し、ページの切り替え時には表示しません。テンプレートでは、各ナビゲーション時にフォールバックが表示されます。

## Props

### `children` (必須)

テンプレートは`children`プロップを受け入れます。例えば

```jsx title="Output"
<Layout>
  {/* テンプレートには自動的にユニークなキーが与えられます。 */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

> **Good to know**:
>
> - デフォルトで、`template`は[Server Component](/docs/app/building-your-application/rendering/server-components)ですが、`"use client"`ディレクティブを使用することで[Client Component](/docs/app/building-your-application/rendering/client-components)としても使用できます
> - ユーザーが`template`を共有するルート間をナビゲートすると、新しいインスタンスのコンポーネントがマウントされ、DOM要素が再作成され、クライアントコンポーネントの状態は保持されず、エフェクトが再同期されます

## バージョン履歴

| バージョン   | 変更内容                |
| --------- | ---------------------- |
| `v13.0.0` | `template`が導入されました |
