---
title: 'template.js'
description: 'template.jsファイルのAPIリファレンス。'
---

**template**ファイルは、[layout](/docs/app/building-your-application/routing/layouts-and-templates#layouts)と同様にレイアウトやページを包みます。layoutはルート間を保持し、状態を維持するのに対し、templateはユニークなキーを持ち、ナビゲーション時に子Client Componentは状態をリセットします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/template.tsx" switcher
export default function Template({ children }: { children: React.ReactNode }) {
  return <div>{children}</div>
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/template.jsx" switcher
export default function Template({ children }) {
  return <div>{children}</div>
}
```
</TabItem>
</Tabs>


<Image
  alt="template.js特殊ファイル"
  srcLight="/docs/light/template-special-file.png"
  srcDark="/docs/dark/template-special-file.png"
  width="1600"
  height="444"
/>

templateを使う理由はあまり一般的ではありませんが、以下のような場合にlayoutよりもtemplateを選ぶことがあります：

- `useEffect`（例：ページビューのログ）の機能と`useState`（例：ページごとのフィードバックフォーム）が必要な場合
- デフォルトのフレームワークの動作を変更したい場合。例えば、layout内のSuspense Boundariesは、Layoutが初めて読み込まれたときにのみフォールバックを表示し、ページ切り替え時には表示しません。templateでは、各ナビゲーション時にフォールバックが表示されます。

## Props

### `children` (必須)

templateは`children`プロップを受け取ります。例えば：

```jsx title="Output"
<Layout>
  {/* templateは自動的にユニークなキーを持たせます。 */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

> **Good to know**:
>
> - デフォルトでは、`template`は[Server Component](/docs/app/building-your-application/rendering/server-components)ですが、`"use client"`ディレクティブを使うことで[Client Component](/docs/app/building-your-application/rendering/client-components)としても使用できます。
> - ユーザーが`template`を共有するルート間をナビゲートする際、新しいインスタンスのコンポーネントがマウントされ、DOM要素が再作成され、記憶域はClient Componentで**保持されず**、エフェクトは再同期されます。

## バージョン履歴

| Version   | Changes                |
| --------- | ---------------------- |
| `v13.0.0` | `template`が導入されました。 |