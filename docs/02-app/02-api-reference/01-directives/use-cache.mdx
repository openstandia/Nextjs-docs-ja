---
title: 'use cache'
description: 'Next.jsアプリケーションでキャッシュデータを使用する方法を学ぶ'
version: 'experimental'
related:
  title: '関連'
  description: '関連するAPI参照を表示する。'
  links:
    - app/api-reference/next-config-js/dynamicIO
    - app/api-reference/next-config-js/cacheLife
    - app/api-reference/functions/cacheTag
    - app/api-reference/functions/revalidateTag
    - app/api-reference/legacy-apis/unstable_cache
---

`use cache`ディレクティブは、コンポーネント、関数、またはファイルをキャッシュすることを示します。ファイルの冒頭に使用すると、そのファイル内のすべての関数がキャッシュ可能であることを示し、関数の冒頭にインラインで使用すると、その関数がキャッシュ可能であることを示します。これは実験的なNext.jsの機能であり、`use client`や`use server`のようなReactのネイティブ機能ではありません。

`next.config.ts`ファイルで`dynamicIO`フラグを使って`use cache`ディレクティブをサポートするように設定します：

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    dynamicIO: true,
  },
}

export default nextConfig
```

> 将来的に、`use cache`ディレクティブは`dynamicIO`フラグとは別に使用できるようになります。

キャッシュは、計算結果やデータ取得結果を保存することでウェブアプリケーションのパフォーマンスを向上させるための手法です。Next.jsでは、キャッシュを利用してアプリケーションのレンダリングパフォーマンスを最適化できます。

特定の非同期操作を明示的にキャッシュし、静的な振る舞いを実現するには、`use cache`ディレクティブを利用します。これにより、非同期データ要求の結果をキャッシュしつつ、必要に応じて動的レンダリングを有効にできます。

`use cache`ディレクティブは、[`unstable_cache`](/docs/app/api-reference/legacy-apis/unstable_cache)関数を置き換えることを目的とした実験的な機能です。`unstable_cache`はJSONデータのキャッシュに限定されており、有効期間やタグを手動で定義する必要がありますが、`use cache`はこれ以上の柔軟性を提供します。React Server Components (RSC) がシリアライズできるものや、データ取得の出力、コンポーネントの出力を含む、より広範なデータをキャッシュできます。

さらに、`use cache`は入力と出力の両方を追跡することで複雑さを自動的に管理し、キャッシュを誤って破壊する可能性を低減します。入力と出力の両方をシリアライズするため、不正確なキャッシュ取得の問題を回避できます。

## `use cache`ディレクティブ {#use-cache-directive}

Next.jsの`use cache`ディレクティブは、ルート全体、コンポーネント、関数の戻り値をキャッシュすることを可能にします。非同期関数がある場合、ファイルの冒頭か関数のスコープ内に`use cache`を追加して、それをキャッシュ可能であることを示します。これにより、Next.jsは戻り値をキャッシュして、後続のレンダリングで再利用できることを伝えます。

```tsx
// ファイルレベル
'use cache'

export default async function Page() {
  // ...
}

// コンポーネントレベル
export async function MyComponent() {
  'use cache'
  return <></>
}

// 関数レベル
export async function getData() {
  'use cache'
  const data = await fetch('/api/data')
  return data
}
```

> **注目情報**: `use cache`ディレクティブを使用する関数は、ステートの変更、DOMの直接操作、一定間隔でコードを実行するタイマーの設定など、副作用を持ってはなりません。

## 再検証 {#revalidating}

デフォルトでは、`use cache`ディレクティブを使用する場合、Next.jsは**[再検証期間](/docs/app/building-your-application/data-fetching/fetching#revalidating-cached-data)を15分に設定**し、ほぼ無限の有効期間を持ちます。これは、頻繁な更新が不要なコンテンツに適しています。

この設定は、頻繁に変わらないコンテンツに便利かもしれませんが、より詳細なキャッシング制御のために`cacheLife`および`cacheTag`APIを使用できます：

- [`cacheLife`](#time-based-revalidation-with-cachelife)：時間に基づく再検証期間のため
- [`cacheTag`](#revalidate-on-demand-with-cachetag)：オンデマンドでの再検証のため

これらのAPIはクライアントとサーバーの両方のキャッシングレイヤーに統合されており、一箇所でキャッシングセマンティクスを設定でき、それが全体に適用されます。

**基本的な例**：

以下の例は、`cacheLife`関数を関数レベルで使用して、関数の出力に1日間の再検証期間を設定する方法を示しています：

```tsx title="app/components/my-component.tsx" highlight={1,5,6}
import { unstable_cacheLife as cacheLife } from 'next/cache'

export async function MyComponent() {
  async function getData() {
    'use cache'
    cacheLife('days')
    const data = await fetch('/api/data')
    return data
  }

  return // Use the data here
}
```

### キャッシュ再検証の仕組み {#how-cache-revalidation-works}

再検証期間が15分に設定されている場合、次のことが起こります：

1. **キャッシュ HIT**: 15分以内にリクエストされると、キャッシュされたデータが提供され、それがキャッシュ HITです。
2. **古いデータ**: リクエストが15分後に発生した場合、キャッシュされた値が提供され続けますが、現在では古いと見なされます。Next.jsはバックグラウンドで新しいキャッシュエントリを再計算します。
3. **キャッシュ MISS**: キャッシュエントリが期限切れになり、その後のリクエストが行われると、Next.jsはこれをキャッシュ MISSとして扱い、データは再計算され、ソースから再度取得されます。

## 時間に基づく再検証と`cacheLife` {#time-based-revalidation-with-cachelife}

`cacheLife`関数は`use cache`ディレクティブが存在する場所でのみ使用でき、キャッシュプロファイルに基づいて時間に基づく再検証期間を定義できます。

`use cache`ディレクティブを使用する場合は、キャッシュプロファイルを常に追加してキャッシュの振る舞いを明示的に定義することをお勧めします。

キャッシュプロファイルは次のプロパティを持つオブジェクトです：

| **プロパティ** | **値**   | **説明**                                                                                   | **要件**                                        |
| -------------- | -------- | ------------------------------------------------------------------------------------------ | ----------------------------------------------- |
| `stale`        | `number` | クライアントがサーバーをチェックせずに値をキャッシュすべき期間                             | 任意                                            |
| `revalidate`   | `number` | サーバーでキャッシュをリフレッシュすべき頻度；再検証中は古い値が提供される可能性があります | 任意                                            |
| `expire`       | `number` | 値が古くなったままでいられる最大期間；`revalidate`よりも長くなければなりません             | 任意 - `revalidate`よりも長くなければなりません |

「stale」プロパティは、特にクライアント側のルーターキャッシングを制御する点で[`staleTimes`](/docs/app/api-reference/next-config-js/staleTimes)設定とは異なります。`staleTimes`は動的および静的データのすべてのインスタンスに影響を与えるグローバル設定ですが、`cacheLife`構成は関数やルートごとに「stale」時間を定義できます。

> **注目情報**: 「stale」プロパティは`Cache-control: max-age`ヘッダーを設定しません。代わりにクライアント側のルーターキャッシュを制御します。

### デフォルトのキャッシュプロファイル {#default-cache-profiles}

Next.jsはいくつかのタイムスケールに基づいてモデル化された一連の名前付きキャッシュプロファイルを提供します。`use cache`ディレクティブと一緒に`cacheLife`関数でキャッシュプロファイルを指定しない場合、Next.jsは自動的に「default」キャッシュプロファイルを適用します。

| **プロファイル** | **古さ** | **再検証** | **期限切れ**   | **説明**                                                   |
| ---------------- | -------- | ---------- | -------------- | ---------------------------------------------------------- |
| `default`        | 未定義   | 15分       | INFINITE_CACHE | 頻繁な更新が不要なコンテンツに適したデフォルトプロファイル |
| `seconds`        | 未定義   | 1秒        | 1分            | ほぼリアルタイムの更新を必要とする急速に変化するコンテンツ |
| `minutes`        | 5分      | 1分        | 1時間          | 1時間以内に頻繁に更新されるコンテンツ                      |
| `hours`          | 5分      | 1時間      | 1日            | 毎日更新されるが少し古くなることが許容されるコンテンツ     |
| `days`           | 5分      | 1日        | 1週間          | 毎週更新されるが1日前のものが許容されるコンテンツ          |
| `weeks`          | 5分      | 1週間      | 1ヶ月          | 毎月更新されるが1週間前のものが許容されるコンテンツ        |
| `max`            | 5分      | 1ヶ月      | INFINITE_CACHE | 非常に安定しており、ほとんど更新が必要ないコンテンツ       |

**基本的な例**：

```tsx title="app/page.tsx" highlight={4}
'use cache'
import { unstable_cacheLife as cacheLife } from 'next/cache'

cacheLife('minutes')
```

キャッシュプロファイルを参照するために使用される文字列値自体に意味があるわけではなく、セマンティックなラベルとして機能します。これにより、コードベース内のキャッシュされたコンテンツをよりよく理解し管理できます。

### 再利用可能なキャッシュプロファイルを定義する {#defining-reusable-cache-profiles}

再利用可能なキャッシュプロファイルを作成するには、使用するケースに適した名前を選びます。必要に応じて、好きなだけカスタムキャッシュプロファイルを作成できます。各プロファイルは`cacheLife`関数に渡される文字列として名前で参照できます。

```ts title="next.config.ts"
const nextConfig = {
  experimental: {
    dynamicIO: true,
    cacheLife: {
      biweekly: {
        stale: 60 * 60 * 24 * 14, // 14日
        revalidate: 60 * 60 * 24, // 1日
        expire: 60 * 60 * 24 * 14, // 14日
      },
    },
  },
}

module.exports = nextConfig
```

上記の例では14日間キャッシュし、毎日更新をチェックし、14日後にキャッシュを期限切れにします。このプロファイルを、アプリケーション全体で名前を基に参照できます：

```tsx title="app/page.tsx" highlight={4}
'use cache'
import { unstable_cacheLife as cacheLife } from 'next/cache'

cacheLife('biweekly')

// rest of code
```

### デフォルトのキャッシュプロファイルをオーバーライドする {#overriding-the-default-cache-profiles}

デフォルトのキャッシュプロファイルは、キャッシュ可能な出力の各部分が新鮮か古いかを考えるのに役立ちますが、アプリケーションのキャッシュ戦略によりうまく合う異なる名前のプロファイルを好むかもしれません。

デフォルトの名前付きキャッシュプロファイルをオーバーライドするには、デフォルトと同じ名前で新しい構成を作成します。

以下の例は、デフォルトの「days」キャッシュプロファイルをオーバーライドする方法を示しています：

```ts title="next.config.ts"
const nextConfig = {
  experimental: {
    dynamicIO: true,
    cacheLife: {
      days: {
        stale: 3600, // 1時間
        revalidate: 900, // 15分
        expire: 86400, // 1日
      },
    },
  },
}

module.exports = nextConfig
```

### 行内キャッシュプロファイルを定義する {#defining-inlining-cache-profiles}

特定のユースケースに応じて、オブジェクトを`cacheLife`関数に渡してカスタムキャッシュプロファイルを設定できます：

```tsx title="app/page.tsx" highlight={5,6,7}
'use cache'
import { unstable_cacheLife as cacheLife } from 'next/cache'

cacheLife({
  stale: 3600, // 1時間
  revalidate: 900, // 15分
  expire: 86400, // 1日
})

// rest of code
```

このインラインキャッシュプロファイルは、それが作成されたファイルや関数にのみ適用されます。アプリケーション全体でこのプロファイルを再利用したい場合は、その構成を`next.config.ts`ファイルの`cacheLife`プロパティに追加できます。

### `use cache`と`cacheLife`のネスト使用 {#nested-usage-of-use-cache-and-cachelife}

同じルートまたはコンポーネントツリーの中で複数のキャッシング動作を定義する場合、内部キャッシュが独自の`cacheLife`プロファイルを指定している場合、外部キャッシュは最も短いキャッシュ期間を尊重します。**これは、外部キャッシュが独自の明示的な`cacheLife`プロファイルを持たない場合にのみ適用されます。**

**キャッシュ境界に関する決定階層：**

1. Next.jsは全体の`use cache`境界内で最も短いキャッシュプロファイルを使用しますが、内部の`use cache`ディレクティブを除外します。
2. キャッシュプロファイルが存在しない場合、すべての内部`use cache`呼び出しからの最も短いプロファイル時間がこの`use cache`に適用されます。内部`use cache`がない場合はデフォルトが使用されます。
3. 2つ深いレベルの内部キャッシュは、親にその期間を既に提供しているため、外部キャッシュには影響しません。

例えば、ページに`use cache`ディレクティブを追加し、キャッシュプロファイルを指定しない場合、デフォルトのキャッシュプロファイルが暗黙的に適用されます（`cacheLife(“default”)`）。ページにインポートされたコンポーネントも`use cache`ディレクティブを使用して独自のキャッシュプロファイルを持っている場合、外部と内部のキャッシュプロファイルが比較され、プロファイルで設定されている最も短い期間が適用されます。

```tsx title="app/components/parent.tsx" highlight={5,6,19,20}
// 親コンポーネント
import { unstable_cacheLife as cacheLife } from 'next/cache'

export async function ParentComponent() {
  'use cache'
  cacheLife('days')

  return (
    <div>
      <ChildComponent />
    </div>
  )
}

// 子コンポーネント
import { unstable_cacheLife as cacheLife } from 'next/cache'

export async function ChildComponent() {
  'use cache'
  cacheLife('hours')

  // このコンポーネントのキャッシュは、より短い「hours」プロファイルを尊重します
}
```

## `cacheTag`を使用したオンデマンドでの再検証 {#revalidate-on-demand-with-cachetag}

`cacheTag`は、[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)と組み合わせて、オンデマンドでキャッシュデータを消去するために使用されます。`cacheTag`関数は単一の文字列値または文字列配列を取ります。

以下の例では`getData`関数が「weeks」キャッシュプロファイルを使用し、キャッシュされた出力に`cacheTag`を定義しています：

```tsx title="app/actions.ts" highlight={8,9}
import {
  unstable_cacheTag as cacheTag,
  unstable_cacheLife as cacheLife,
} from 'next/cache'

export async function getData() {
  'use cache'
  cacheLife('weeks')
  cacheTag('my-data')

  const data = await fetch('/api/data')
  return data
}
```

その後、他の関数（例えば、[route handler](/docs/app/building-your-application/routing/route-handlers)や[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)）でrevalidateTagを使用してオンデマンドでキャッシュを消去できます：

```tsx title="app/submit.ts" highlight={6,7}
'use server'

import { revalidateTag } from 'next/cache'

export default async function submit() {
  await addPost()
  revalidateTag('my-data')
}
```

オンデマンドでのキャッシュデータの消去に関する詳細については、[revalidateTag](/docs/app/api-reference/functions/revalidateTag)ドキュメントをご覧ください。

## 例 {#examples}

### `use cache`を使用したルート全体のキャッシング {#caching-entire-routes-with-use-cache}

アプリケーション内の`Suspense`境界の配置は、コンポーネントの動的さを決定します。`Suspense`境界内のコンポーネントは動的となることができますが、自動的になるわけではありません。すべてをキャッシュするか、コンテンツが静的である場合、Next.jsは静的なアプリケーションを生成します。`Suspense`を使用して境界内の動的振る舞いを許可します。

ルートを静的に保つためには、`Suspense`境界の使用を避けます。もし使用する必要がある場合でも、アプリケーション内で別々のエントリーポイントとして扱われるため、レイアウトおよびページコンポーネントの両方に`use cache`ディレクティブを追加することで、静的ページを維持できます。

これは以前[`export const dynamic = "force-cache"`](/docs/app/building-your-application/caching#opting-out-1)オプションを使用したアプリケーションに推奨され、ルート全体が事前に生成されることを保証します。

```tsx title="app/layout.tsx"
"use cache"
import { unstable_cacheLife as cacheLife } from 'next/cache'
cacheLife('minutes')

export default Layout({children}: {children: ReactNode}) {
  return <div>{children}</div>
}
```

そして、`page.tsx`ファイルにて、ファイルの冒頭に`use cache`ディレクティブを追加し、キャッシュプロファイルを定義します：

```tsx title="app/page.tsx"
"use cache"
import { unstable_cacheLife as cacheLife } from 'next/cache'
cacheLife('minutes')

async function Users() {
  const users = await fetch('/api/users');
  // ユーザーをループする
}

export default Page() {
  return (
    <main>
      <Users/>
    </main>
  )
}
```

### `use cache`を使用したコンポーネントの出力のキャッシング {#caching-component-output-with-use-cache}

コンポーネントレベルで`use cache`を使用して、そのコンポーネント内で行われるフェッチや計算をキャッシュします。アプリケーション内でコンポーネントを再利用すると、propsが同じ構造を維持する限り、同じキャッシュエントリを共有できます。

propsはシリアライズされ、キャッシュキーの一部を形成します。アプリケーションの複数の場所で同じコンポーネントを使用する場合、シリアライズされたpropsがどのインスタンスにおいても同じ値を生成する限り、そのキャッシュエントリは再利用されます。

```tsx title="app/components/bookings.tsx" highlight={8,9}
import { unstable_cacheLife as cacheLife } from 'next/cache'

interface BookingsProps {
  type: string
}

export async function Bookings({ type = 'massage' }: BookingsProps) {
  'use cache'
  cacheLife('minutes')

  async function getBookingsData() {
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    return data
  }
  return //...
}
```

### `use cache`を使用した関数の出力のキャッシング {#caching-function-output-with-use-cache}

`use cache`を任意の非同期関数に追加できるため、コンポーネントやルートだけに限らずキャッシングできます。ネットワークリクエストやデータベースクエリをキャッシュしたり、非常に遅い計算を行うことを考えるかもしれません。このタイプの作業を含む関数に`use cache`を追加することで、それがキャッシュ可能になり、再利用時に同じキャッシュエントリを共有することができます。

```tsx title="app/actions.ts" highlight={4,5}
import { unstable_cacheLife as cacheLife } from 'next/cache'

export async function getData() {
  'use cache'
  cacheLife('minutes')

  const data = await fetch('/api/data')
  return data
}
```
