---
title: 'use cache'
description: 'Next.jsアプリケーションでuse cacheディレクティブを使用してデータをキャッシュする方法を学びましょう。'
version: 'canary'
related:
  title: 'Related'
  description: '関連するAPIリファレンスを表示します。'
  links:
    - 'app/api-reference/next-config-js/dynamicIO'
    - 'app/api-reference/next-config-js/cacheLife'
    - 'app/api-reference/functions/cacheTag'
    - 'app/api-reference/functions/cacheLife'
    - 'app/api-reference/functions/revalidateTag'
---

`use cache`ディレクティブはコンポーネントおよび/または関数をキャッシュすることを指定します。ファイルのトップで使用すると、ファイル内のすべてのエクスポートがキャッシュ可能であることを示します。関数またはコンポーネントのトップでインラインで使用すると、Next.jsに返り値がキャッシュされ、後続のリクエストで再利用されるべきであることを知らせます。これは実験的なNext.jsの機能であり、`use client`や`use server`のようなネイティブなReactの機能ではありません。

## 使用法 {#usage}

`next.config.ts`ファイルで`dynamicIO`フラグを設定し、`use cache`ディレクティブのサポートを有効にします：

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    dynamicIO: true,
  },
}

export default nextConfig
```

次に、ファイル、コンポーネント、または関数レベルで`use cache`ディレクティブを使用できます：

```tsx
// ファイルレベル
'use cache'

export default async function Page() {
  // ...
}

// コンポーネントレベル
export async function MyComponent() {
  'use cache'
  return <></>
}

// 関数レベル
export async function getData() {
  'use cache'
  const data = await fetch('/api/data')
  return data
}
```

## 知っておくべきこと {#good-to-know}

- `use cache`は実験的なNext.js機能であり、[`use client`](/docs/app/api-reference/directives/use-client)や[`use server`](/docs/app/api-reference/directives/use-server)のようなネイティブなReact機能ではありません。
- キャッシュされた関数に渡される引数（あるいはprops）は、Reactによって[シリアライズ可能](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values)である必要があります。これは、これらがJSONのような形式に変換できることを意味します。関数やReact要素のようなシリアライズできないpropsは引数として使用できません。
- キャッシュ可能な関数の返り値もシリアライズ可能である必要があります。これは、キャッシュされたデータが正しく保存され、取得できることを保証します。
- `use cache`ディレクティブを使用する関数は、状態を変更したり、直接DOMを操作したり、インターバルでコードを実行するタイマーを設定するなどの副作用を持ってはいけません。
- [Partial Prerendering](/docs/app/building-your-application/rendering/partial-prerendering)と一緒に使用する場合、`use cache`を持つセグメントは静的HTMLシェルの一部としてプリレンダーされます。
- `use cache`ディレクティブは、将来的に`dynamicIO`フラグとは別に提供される予定です。
- [`unstable_cache`](/docs/app/api-reference/legacy-apis/unstable_cache)がJSONデータのみをサポートするのに対して、`use cache`はReactがレンダーできるシリアライズ可能なデータ、コンポーネントのレンダー出力を含むすべてをキャッシュできます。

## 例 {#examples}

### `use cache`で全ルートのキャッシュ {#caching-entire-routes-with-use-cache}

ルート全体をプリレンダーするためには、`layout`ファイルと`page`ファイルの**両方**に`use cache`を追加します。これらのセグメントはアプリケーションの独立したエントリーポイントとして扱われ、それぞれ個別にキャッシュされます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
"use cache"
import { unstable_cacheLife as cacheLife } from 'next/cache'

export default Layout({children}: {children: ReactNode}) {
  return <div>{children}</div>
}
```

</TabItem>
</Tabs>
<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.tsx" switcher
"use cache"
import { unstable_cacheLife as cacheLife } from 'next/cache'

export default Layout({ children }) {
  return <div>{children}</div>
}
```

</TabItem>
</Tabs>

`page`ファイル内でインポートおよびネストされたコンポーネントは、`page`のキャッシュの振る舞いを継承します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
"use cache"
import { unstable_cacheLife as cacheLife } from 'next/cache'

async function Users() {
  const users = await fetch('/api/users');
  // ユーザーをループ
}

export default Page() {
  return (
    <main>
      <Users/>
    </main>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
"use cache"
import { unstable_cacheLife as cacheLife } from 'next/cache'

async function Users() {
  const users = await fetch('/api/users');
  // ユーザーをループ
}

export default Page() {
  return (
    <main>
      <Users/>
    </main>
  )
}
```

</TabItem>
</Tabs>

> これは、以前[`export const dynamic = "force-static"`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)オプションを使用していたアプリケーションに推奨され、ルート全体をプリレンダーすることを保証します。

### `use cache`でコンポーネントの出力をキャッシュ {#caching-component-output-with-use-cache}

コンポーネントレベルで`use cache`を使用すると、そのコンポーネント内で行われたフェッチや計算をキャッシュできます。アプリケーション全体でコンポーネントを再利用する際、propsが同じ構造を維持する限り同じキャッシュエントリを共有できます。

propsはシリアライズされ、キャッシュキーの一部となり、シリアライズされたpropsが各インスタンスで同じ値を生成する限り、キャッシュエントリは再利用されます。

```tsx title="app/components/bookings.tsx" highlight={2}
export async function Bookings({ type = 'haircut' }: BookingsProps) {
  'use cache'
  async function getBookingsData() {
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    return data
  }
  return //...
}

interface BookingsProps {
  type: string
}
```

```jsx title="app/components/bookings.js" highlight={2}
export async function Bookings({ type = 'haircut' }) {
  'use cache'
  async function getBookingsData() {
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    return data
  }
  return //...
}
```

### `use cache`で関数の出力をキャッシュ {#caching-function-output-with-use-cache}

非同期関数のどれにでも`use cache`を追加できるため、コンポーネントやルートだけでなく、ネットワークリクエスト、データベースクエリのキャッシュや非常に遅い計算をキャッシュすることもできます。この種の作業を含む関数に`use cache`を追加すると、それがキャッシュ可能になり、再利用されるときに同じキャッシュエントリを共有します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" highlight={2} switcher
export async function getData() {
  'use cache'

  const data = await fetch('/api/data')
  return data
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions.js" highlight={2} switcher
export async function getData() {
  'use cache'

  const data = await fetch('/api/data')
  return data
}
```

</TabItem>
</Tabs>

### 再検証 {#revalidating}

デフォルトでは、Next.jsは`use cache`ディレクティブを使用した際に、**[15分間の再検証期間](/docs/app/building-your-application/data-fetching/fetching#revalidating-cached-data)**を設定します。Next.jsはほぼ無限の期限を設定するため、頻繁な更新が不要なコンテンツに適しています。

この再検証期間があまり変化することを予期しないコンテンツには便利かもしれませんが、`cacheLife`および`cacheTag`APIを使用してキャッシュ動作を設定することもできます：

- [`cacheLife`](/docs/app/api-reference/functions/cacheLife)：時間ベースの再検証期間のためのもの。
- [`cacheTag`](/docs/app/api-reference/functions/cacheTag)：オンデマンドの再検証のためのもの。

これらのAPIは、クライアントとサーバーのキャッシングレイヤーを横断して統合されており、一カ所でキャッシングの意味を設定し、それをどこにでも適用することができます。

詳細については、[`cacheLife`](/docs/app/api-reference/functions/cacheLife)と[`cacheTag`](/docs/app/api-reference/functions/cacheTag)のドキュメントを参照してください。

### インタリービング {#interleaving}

キャッシュ可能な関数にシリアライズできない引数を渡す必要がある場合、これらを`children`として渡すことができます。これにより、`children`の参照が変わってもキャッシュエントリに影響を与えません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
async function Page() {
  const uncachedData = await getData()
  return (
    <CacheComponent>
      <DynamicComponent data={uncachedData} />
    </CacheComponent>
  )
}

async function CacheComponent({ children }) {
  'use cache'
  const cachedData = await fetch('/api/cached-data')
  return (
    <div>
      <PrerenderedComponent data={cachedData} />
      {children}
    </div>
  )
}
```

</TabItem>
</Tabs>

キャッシュされたコンポーネントを通じて、サーバーアクションを呼び出さずに、Client Componentsに渡すこともできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import ClientComponent from './ClientComponent';

async function Page() {
  const performUpdate = async () => {
    "use server"
    // サーバー側での更新を実施する
    await db.update(...);
  };

  return <CacheComponent performUpdate={performUpdate} />;
}

async function CachedComponent({ performUpdate }) {
  "use cache"
  // ここでperformUpdateを呼び出さない
  return <ClientComponent action={performUpdate} />;
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import ClientComponent from './ClientComponent';

async function Page() {
  const performUpdate = async () => {
    "use server"
    // サーバー側での更新を実施する
    await db.update(...);
  };

  return <CacheComponent performUpdate={performUpdate} />;
}

async function CachedComponent({ performUpdate }) {
  "use cache"
  // ここでperformUpdateを呼び出さない
  return <ClientComponent action={performUpdate} />;
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ClientComponent.tsx" switcher
'use client'

export default function ClientComponent({ action }) {
  return <button onClick={action}>Update</button>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ClientComponent.js" switcher
'use client'

export default function ClientComponent({ action }) {
  return <button onClick={action}>Update</button>
}
```

</TabItem>
</Tabs>
