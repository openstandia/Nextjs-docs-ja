---
title: '<Form>'
description: '<Form> コンポーネントを使って、フォーム送信とクライアントサイドのナビゲーションでの検索パラメータの更新方法を学びます'
---

`<Form>` コンポーネントはHTMLの `<form>` 要素を拡張し、<AppOnly>[**prefetching**](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) と[ローディングUI](/docs/app/building-your-application/routing/loading-ui-and-streaming)を提供し、</AppOnly> フォーム送信時の**クライアントサイドのナビゲーション**や**プログレッシブエンハンスメント**を可能にします。

これは、URLの検索パラメータを更新するフォームに役立ち、上記を達成するためのボイラープレートコードを削減します。

基本的な使い方:

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/ui/search.tsx" switcher
import Form from 'next/form'

export default function Page() {
  return (
    <Form action="/search">
      {/* 送信時、入力値がURLに追加されます 
          例: /search?query=abc  */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/ui/search.js" switcher
import Form from 'next/form'

export default function Search() {
  return (
    <Form action="/search">
      {/* 送信時、入力値がURLに追加されます 
          例: /search?query=abc  */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/ui/search.js" switcher
import Form from 'next/form'

export default function Page() {
  return (
    <Form action="/search">
      {/* 送信時、入力値がURLに追加されます 
          例: /search?query=abc  */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/ui/search.js" switcher
import Form from 'next/form'

export default function Search() {
  return (
    <Form action="/search">
      {/* 送信時、入力値がURLに追加されます 
          例: /search?query=abc  */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

## 参照 {#reference}

`<Form>` コンポーネントの動作は、`action` prop に渡される値が `string` または `function` かによって異なります。

<AppOnly>

- `action` が **string** の場合、`<Form>` は **`GET`** メソッドを使うネイティブHTMLフォームのように動作します；フォームデータはURLに検索パラメータとしてエンコードされ、フォームが送信されると指定されたURLに移動します。さらに、Next.jsは以下を行います：
  - フォームが表示される際にパスを[プレフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)し、共有UI（例：`layout.js`および`loading.js`）を事前にロードし、ナビゲーションを高速化します
  - フォームが送信されると、完全なページリロードの代わりに[クライアントサイドのナビゲーション](/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation)を実行します。これにより、共有UIとクライアントサイドの状態を保持します。
- `action` が **function** （Server Action）の場合、`<Form>` は[Reactのform](https://react.dev/reference/react-dom/components/form)のように動作し、フォームが送信されるとアクションを実行します。

</AppOnly>

<PagesOnly>

- `action` が **string** の場合、`<Form>` は **`GET`** メソッドを使うネイティブHTMLフォームのように動作します；フォームデータはURLに検索パラメータとしてエンコードされ、フォームが送信されると指定されたURLに移動します。さらに、Next.jsは以下を行います：
  - フォームが送信されると、完全なページリロードの代わりに[クライアントサイドのナビゲーション](/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation)を実行します。これにより、共有UIとクライアントサイドの状態を保持します；

</PagesOnly>

### `action`（string）Props {#action-string-props}

<PagesOnly>

`action` が string の場合、`<Form>` コンポーネントは次のpropsをサポートします：

| Prop      | Example            | Type                            | Required |
| --------- | ------------------ | ------------------------------- | -------- |
| `action`  | `action="/search"` | `string` (URL or relative path) | Yes      |
| `replace` | `replace={false}`  | `boolean`                       | -        |
| `scroll`  | `scroll={true}`    | `boolean`                       | -        |

- **`action`**: フォームが送信されたときに移動するURLまたはパスです
  - 空文字列 `""` の場合、検索パラメータが更新された同じルートに移動します
- **`replace`**: 新しい履歴を[ブラウザの履歴](https://developer.mozilla.org/ja/docs/Web/API/History_API)スタックに追加するのではなく現在の履歴状態を置き換えます；デフォルトは`false`です；
- **`scroll`**: ナビゲーション中のスクロール動作を制御します；デフォルトは`true`であり、これは新しいルートのトップにスクロールし、後退および前進ナビゲーションでもスクロール位置を維持します；

</PagesOnly>

<AppOnly>

`action` が string の場合、`<Form>` コンポーネントは次のpropsをサポートします：

| Prop       | Example            | Type                            | Required |
| ---------- | ------------------ | ------------------------------- | -------- |
| `action`   | `action="/search"` | `string` (URL or relative path) | Yes      |
| `replace`  | `replace={false}`  | `boolean`                       | -        |
| `scroll`   | `scroll={true}`    | `boolean`                       | -        |
| `prefetch` | `prefetch={true}`  | `boolean`                       | -        |

- **`action`**: フォームが送信されたときに移動するURLまたはパスです
  - 空文字列 `""` の場合、検索パラメータが更新された同じルートに移動します
- **`replace`**: 新しい履歴を[ブラウザの履歴](https://developer.mozilla.org/ja/docs/Web/API/History_API)スタックに追加するのではなく現在の履歴状態を置き換えます；デフォルトは`false`です；
- **`scroll`**: ナビゲーション中のスクロール動作を制御します；デフォルトは`true`であり、これは新しいルートのトップにスクロールし、後退および前進ナビゲーションでもスクロール位置を維持します；
- **`prefetch`**: フォームがユーザーの表示領域に入ったときにパスをプレフェッチするかどうかを制御します；デフォルトは`true`です；

### `action`（function）Props {#action-function-props}

`action` が function の場合、`<Form>` コンポーネントは次のpropをサポートします：

| Prop     | Example             | Type                       | Required |
| -------- | ------------------- | -------------------------- | -------- |
| `action` | `action={myAction}` | `function` (Server Action) | Yes      |

- **`action`**: フォームが送信されたときに呼び出されるServer Actionです；詳細については[Reactのドキュメント](https://react.dev/reference/react-dom/components/form#props)をご覧ください；

> **ここを知っておくとよいです**: `action` が function の場合、`replace` と `scroll` プロップは無視されます；

</AppOnly>

### 留意事項 {#caveats}

<AppOnly>

- **`formAction`**: `<button>` または `<input type="submit">` フィールドで `action` プロップをオーバーライドするために使用できます；Next.js はクライアントサイドのナビゲーションを行いますが、この方法ではプレフェッチをサポートしません。
  - [`basePath`](/docs/app/api-reference/next-config-js/basePath)を使用する場合、`formAction` パスにも含める必要があります；例：`formAction="/base-path/search"`。
- **`key`**: 文字列 `action`への `key` プロップの渡しはサポートされていません；再レンダリングをトリガーしたり、ミューテーションを実行したりする場合は、関数 `action` を使用することを検討してください。

</AppOnly>

- **`onSubmit`**: フォーム送信ロジックを処理するために使用できます；ただし、`event.preventDefault()` を呼び出すと、指定されたURLへのナビゲーションなど `<Form>` の動作を上書きします；
- **[`method`](https://developer.mozilla.org/ja/docs/Web/HTML/Element/form#method)、[`encType`](https://developer.mozilla.org/ja/docs/Web/HTML/Element/form#enctype)、[`target`](https://developer.mozilla.org/ja/docs/Web/HTML/Element/form#target)**: `<Form>` の動作を上書きするため、サポートされていません；
  - 同様に、`formMethod`、`formEncType`、`formTarget` はそれぞれ `method`、`encType`、`target` プロップをオーバーライドするために使用でき、それらを使用するとネイティブブラウザの動作にフォールバックします；
  - これらの props を使用する必要がある場合は、HTMLの `<form>` 要素を使用してください；
- **`<input type="file">`**: `action` が文字列の場合、この入力タイプを使用すると、ブラウザの動作と一致し、ファイルオブジェクトではなくファイル名を送信します；

<AppOnly>

## 例 {#examples}

### 検索結果ページに移動する検索フォーム {#search-form-that-leads-to-a-search-result-page}

パスを `action` として渡すことで、検索結果ページに移動する検索フォームを作成できます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/page.tsx" switcher
import Form from 'next/form'

export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/page.js" switcher
import Form from 'next/form'

export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
</Tabs>

ユーザーがクエリの入力フィールドを更新してフォームを送信すると、フォームデータがURLに検索パラメータとしてエンコードされます；例：`/search?query=abc`；

> **ここを知っておくとよいです**: `action` に空文字列 `""` を渡すと、フォームは検索パラメータが更新された同じルートに移動します；

検索結果ページでは、[`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) `page.js` prop を使用してクエリにアクセスし、外部ソースからデータを取得するために使用できます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/search/page.tsx" switcher
import { getSearchResults } from '@/lib/search'

export default async function SearchPage({
  searchParams,
}: {
  searchParams: { [key: string]: string | string[] | undefined }
}) {
  const results = await getSearchResults(searchParams.query)

  return <div>...</div>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/search/page.js" switcher
import { getSearchResults } from '@/lib/search'

export default async function SearchPage({ searchParams }) {
  const results = await getSearchResults(searchParams.query)

  return <div>...</div>
}
```

</TabItem>
</Tabs>

ユーザーのビューポートに `<Form>` が表示されると、`/search` ページの共有UI（`layout.js`や`loading.js`など）がプレフェッチされます；送信すると、フォームは即座に新しいルートにナビゲートし、結果がフェッチされる間ローディングUIを表示します；`[`loading.js`](/docs/app/api-reference/file-conventions/loading)`を使用してフォールバックUIをデザインできます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/search/loading.tsx" switcher
export default function Loading() {
  return <div>Loading...</div>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/search/loading.js" switcher
export default function Loading() {
  return <div>Loading...</div>
}
```

</TabItem>
</Tabs>

共有UIがまだ読み込まれていない場合をカバーするために、[`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)を使用してユーザーに即時のフィードバックを表示できます。

まず、フォームが保留中のときにローディング状態を表示するコンポーネントを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/ui/search-button.tsx" switcher
'use client'
import { useFormStatus } from 'react-dom'

export default function SearchButton() {
  const status = useFormStatus()
  return (
    <button type="submit">{status.pending ? 'Searching...' : 'Search'}</button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/ui/search-button.js" switcher
'use client'
import { useFormStatus } from 'react-dom'

export default function SearchButton() {
  const status = useFormStatus()
  return (
    <button type="submit">{status.pending ? 'Searching...' : 'Search'}</button>
  )
}
```

</TabItem>
</Tabs>

次に、`SearchButton` コンポーネントを使用するように検索フォームページを更新します；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/page.tsx" switcher
import Form from 'next/form'
import { SearchButton } from '@/ui/search-button'

export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <SearchButton />
    </Form>
  )
}
```

</TabItem>
</Tabs>
<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/ui/search-button.js" switcher
import Form from 'next/form'
import { SearchButton } from '@/ui/search-button'

export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <SearchButton />
    </Form>
  )
}
```

</TabItem>
</Tabs>

### Server Actionsを使ったミューテーション {#mutations-with-server-actions}

`action` prop に関数を渡すことでミューテーションを実行できます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/posts/create/page.tsx" switcher
import Form from 'next/form'
import { createPost } from '@/posts/actions'

export default function Page() {
  return (
    <Form action={createPost}>
      <input name="title" />
      {/* ... */}
      <button type="submit">Create Post</button>
    </Form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/posts/create/page.js" switcher
import Form from 'next/form'
import { createPost } from '@/posts/actions'

export default function Page() {
  return (
    <Form action={createPost}>
      <input name="title" />
      {/* ... */}
      <button type="submit">Create Post</button>
    </Form>
  )
}
```

</TabItem>
</Tabs>

ミューテーションの後、新しいリソースにリダイレクトすることが一般的です；`next/navigation` から[`redirect`](/docs/app/building-your-application/routing/redirecting)関数を使用して、新しい投稿ページにナビゲートできます；

> **ここを知っておくとよいです**: フォーム送信の「宛先」はアクションが実行されるまで不明なため、`<Form>`は共有UIを自動的にプレフェッチできません；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/posts/actions.ts" switcher
'use server'
import { redirect } from 'next/navigation'

export async function createPost(formData: FormData) {
  // 新しい投稿を作成
  // ...

  // 新しい投稿にリダイレクト
  redirect(`/posts/${data.id}`)
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/posts/actions.js" switcher
'use server'
import { redirect } from 'next/navigation'

export async function createPost(formData) {
  // 新しい投稿を作成
  // ...

  // 新しい投稿にリダイレクト
  redirect(`/posts/${data.id}`)
}
```

</TabItem>
</Tabs>

次に、新しいページで`params` プロップを使用してデータを取得できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/posts/[id]/page.tsx" switcher
import { getPost } from '@/posts/data'

export default async function PostPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const data = await getPost((await params).id)

  return (
    <div>
      <h1>{data.title}</h1>
      {/* ... */}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/posts/[id]/page.js" switcher
import { getPost } from '@/posts/data'

export default async function PostPage({ params }) {
  const data = await getPost((await params).id)

  return (
    <div>
      <h1>{data.title}</h1>
      {/* ... */}
    </div>
  )
}
```

</TabItem>
</Tabs>

詳細な例については、[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) ドキュメントを参照してください；

</AppOnly>
