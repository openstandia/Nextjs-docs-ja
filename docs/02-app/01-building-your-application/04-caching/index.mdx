---
title: 'Next.jsにおけるキャッシュ'
nav_title: 'キャッシュ'
description: 'Next.jsのキャッシュメカニズムの概要。'
---

Next.jsは、レンダリング作業とデータリクエストをキャッシュすることにより、アプリケーションのパフォーマンスを改善し、コストを削減します。このページでは、Next.jsのキャッシュメカニズム、設定に使用できるAPI、およびそれらがどのように相互作用するかについて詳しく説明します。

> **Good to know**: このページは、Next.jsの内部動作を理解するのに役立ちますが、Next.jsで生産性を上げるために必須の知識ではありません。ほとんどのNext.jsのキャッシュヒューリスティクスは、APIの使用に基づいて決定され、ゼロまたは最小の設定で最高の性能を発揮するデフォルトがあります。代わりに例に飛びたい場合は、[こちらから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

こちらは、異なるキャッシュメカニズムとその目的の概要です：

| Mechanism                                   | What                      | Where        | Purpose                                      | Duration                           |
| ------------------------------------------- | ------------------------- | ------------ | -------------------------------------------- | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の戻り値              | サーバー     | React Component treeでデータを再利用         | リクエストライフサイクルごと       |
| [Data Cache](#data-cache)                   | データ                    | サーバー     | ユーザーリクエストとデプロイ間でデータを保存 | 永続的（再検証可能）               |
| [Full Route Cache](#full-route-cache)       | HTMLおよびRSCのペイロード | サーバー     | レンダリングコストの削減と性能の向上         | 永続的（再検証可能）               |
| [Router Cache](#client-side-router-cache)   | RSCペイロード             | クライアント | ナビゲーション時のサーバーリクエストの削減   | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsは性能を向上させ、コストを削減するために可能な限りキャッシュします。これは、ルートが**静的にレンダリング**され、データリクエストが**キャッシュ**されることを意味します。ただし、オプトアウトすることもできます。下記の図は、ビルド時に静的にレンダリングされたルートと静的ルートが初めてアクセスされたときのデフォルトのキャッシュ動作を示しています。

<Image
  alt="Next.jsでの4メカニズムにおけるデフォルトのキャッシュ動作を示す図、ビルド時とルート初訪問時におけるHIT、MISS、SET。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

ルートが静的にまたは動的にレンダリングされるか、データがキャッシュされるかされないか、リクエストが初回訪問の一部であるか、次のナビゲーションの一部であるかによってキャッシュ動作は変わります。ユースケースに応じて、個々のルートとデータリクエストのキャッシュ動作を設定できます。

## リクエストメモ化 {#request-memoization}

Reactは[`fetch` API](#fetch)を拡張し、同じURLとオプションを持つリクエストを自動的に**メモ化**します。これは、React component tree内の複数の場所で同じデータのfetch関数を呼び出しながら、実行は一度だけ行うことを意味します。

<Image
  alt="重複排除されたFetchリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

たとえば、ルート全体（例：Layout、Page、および複数のコンポーネント）で同じデータを使用する必要がある場合、ツリーの上部でデータを取得して、コンポーネント間でpropsを渡す必要はありません。代わりに、同じデータのネットワーク経由の複数リクエストのパフォーマンスへの影響を心配することなく、必要なコンポーネントでデータを取得できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果は
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、実行されるのは最初の1回のみです
const item = await getItem() // cache MISS

// 2回目の呼び出しはルート内のどこでも行われる可能性があります
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果は
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、実行されるのは最初の1回のみです
const item = await getItem() // cache MISS

// 2回目の呼び出しはルート内のどこでも行われる可能性があります
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**リクエストメモ化のしくみ**

<Image
  alt="Reactレンダリング中にfetchメモ化がどのように機能するかを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングしている間、特定のリクエストが最初に呼び出されたとき、その結果はメモリに存在せず、キャッシュ`MISS`となります；
- したがって、関数は実行され、データは外部ソースから取得され、その結果はメモリに保存されます；
- 同じレンダーパス中にリクエストの後続の関数呼び出しはキャッシュ`HIT`となり、関数を実行せずにメモリからデータが返されます；
- ルートのレンダリングが完了し、レンダリングパスが完了すると、メモリは "リセット" され、すべてのリクエストメモ化エントリがクリアされます；

> **Good to know**:
>
> - リクエストメモ化はReactの機能であり、Next.jsの機能ではありません。ここでは、他のキャッシュメカニズムとの相互作用を示すために含まれています；
> - memo化は `fetch` リクエスト内の `GET` メソッドのみに適用されます；
> - memo化はReact Component treeにのみ適用されます。つまり：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、その他のServer Componentsでの `fetch` リクエストに適用されます；
>   - Route Handlersでの `fetch` リクエストには適用されません。これらはReact component treeの一部ではないためです；
> - `fetch` が適切でない場合（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）、関数をメモ化するために [React `cache` 関数](#react-cache-function) を使用できます；

### 期間 {#duration}

キャッシュは、サーバーリクエストの存続期間中、React component treeがレンダリングを完了するまで持続します；

### 再検証 {#revalidating}

メモ化はサーバーリクエストごとに共有されず、レンダリング中にのみ適用されるため、これを再検証する必要はありません；

### オプトアウト {#opting-out}

メモ化は `fetch` リクエスト内の `GET` メソッドのみに適用され、`POST` や `DELETE` などの他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、これをオプトアウトすることは推奨されません；

個々のリクエストを管理するために、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)の[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これにより、リクエストがメモ化からオプトアウトするのではなく、進行中のリクエストが中止されます；

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## データキャッシュ {#data-cache}

Next.jsには組み込みのデータキャッシュがあり、データフェッチの結果を**サーバーリクエスト**と**デプロイ**間で**永続化**します。これは、Next.jsがネイティブの `fetch` APIを拡張し、サーバーの各リクエストが独自の永続的なキャッシュセマンティクスを設定できるようにすることで可能になります；

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示します。Next.jsでは、`cache`オプションはサーバーサイドリクエストがサーバーのデータキャッシュとどのように相互作用するかを示します；

`fetch`のキャッシュ動作を設定するために、[`cache`](#fetch-optionscache)と[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用できます；

**データキャッシュのしくみ**

<Image
  alt="キャッシュされたおよびキャッシュされていないfetchリクエストがデータキャッシュとどう相互作用するかを示す図。キャッシュされたリクエストはデータキャッシュに保存され、メモ化される。キャッシュされていないリクエストはデータソースからフェッチされ、データキャッシュには保存されず、メモ化される。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- `'force-cache'`オプションを使用した`fetch`リクエストがレンダリング中に初めて呼び出されると、Next.jsはデータキャッシュにキャッシュされているレスポンスがあるかを確認します；
- キャッシュされたレスポンスが見つかれば、それがただちに返され、[メモ化](#request-memoization)されます；
- キャッシュされたレスポンスが見つからない場合は、データソースにリクエストされ、結果がデータキャッシュに保存され、メモ化されます；
- キャッシュされていないデータ（例：キャッシュオプションが定義されていない、または{ cache: 'no-store' }を使用している場合）については、結果はデータソースから常にフェッチされ、メモ化されます；
- データがキャッシュされているかキャッシュされていないかにかかわらず、リクエストは常にメモ化されて、Reactレンダーパス内で同じデータに対する重複リクエストが行われるのを防ぎます；

> **データキャッシュとリクエストメモ化の違い**
>
> 両方のキャッシュメカニズムがキャッシュされたデータを再利用することによりパフォーマンス向上に寄与しますが、データキャッシュはリクエストやデプロイ間で永続化され、一方メモ化はリクエストの存続期間にのみ持続します；

### 期間 {#duration}

デフォルトでは、データキャッシュは永続型です；再検証またはオプトアウトしない限りリクエストやデプロイ間で保持されます；

### 再検証 {#revalidating}

キャッシュされたデータは、次の2つの方法で再検証できます；

- **時間ベースの再検証**：一定時間が経過し、新しいリクエストが行われるとデータを再検証します；これはあまり頻繁に変更されないデータで、フレッシュネスがそれほど重要でない場合に役立ちます；
- **オンデマンドの再検証**：イベントに基づいてデータを再検証します（例：フォームの送信）；オンデマンドの再検証はタグベースまたはパスベースのアプローチを使用して、データのグループを一度に再検証できます；これはヘッドレスCMSからのコンテンツが更新されたときにできるだけ早く最新データを表示したい場合に役立ちます；

#### 時間ベースの再検証 {#time-based-revalidation}

一定間隔でデータを再検証するには、`fetch`の`next.revalidate`オプションを使用してリソースのキャッシュ存続期間を設定できます（秒単位）；

```js
// 最長1時間ごとに再検証
fetch('https://...', { next: { revalidate: 3600 } })
```

あるいは、[Route Segment Configオプション](#segment-config-options)を使用してセグメント内のすべての`fetch`リクエストを設定することも、または`fetch`を使用できない場合にも使用できます；

**時間ベースの再検証のしくみ**

<Image
  alt="時間ベースの再検証のしくみを示す図。再検証期間後、最初のリクエストで古いデータが返され、その後データが再検証される。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- 再検証を使用した`fetch`リクエストが初めて呼ばれたとき、データは外部データソースからフェッチされ、データキャッシュに保存されます；
- 指定された期間（例：60秒）内に呼ばれる任意のリクエストはキャッシュされたデータを返します；
- 期間が経過すると、次のリクエストでもキャッシュされた（今では古い）データが返されます；
  - Next.jsはデータのバックグラウンド再検証をトリガーします；
  - データが正常にフェッチされると、Next.jsはデータキャッシュを新しいデータで更新します；
  - バックグラウンド再検証が失敗すると、前のデータはそのまま保持されます；

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)動作に類似しています；

#### オンデマンドの再検証 {#on-demand-revalidation}

データはオンデマンドでパスベース（[`revalidatePath`](#revalidatepath)）またはキャッシュタグベース（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）で再検証できます；

**オンデマンドの再検証のしくみ**

<Image
  alt="オンデマンドの再検証のしくみを示す図。再検証リクエスト後、データキャッシュが新しいデータで更新される。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが最初に呼ばれたとき、データは外部データソースからフェッチされ、データキャッシュに保存されます；
- オンデマンド再検証がトリガされた場合、該当するキャッシュエントリはキャッシュから削除されます；
  - これは時間ベースの再検証とは異なり、新しいデータがフェッチされるまで、古いデータをキャッシュ内に保持します；
- 次にリクエストが行われたとき、再びキャッシュ`MISS`となり、データは外部データソースからフェッチされ、データキャッシュに保存されます；

### オプトアウト {#opting-out}

`fetch`からのレスポンスをキャッシュしたくない場合、以下を実行できます；

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**：
>
> **自動静的最適化**、**静的サイト生成**、または**静的レンダリング**という用語が、ビルド時にアプリケーションのルートをレンダリングおよびキャッシュするプロセスを指して使われることがあります；

Next.jsはビルド時にルートを自動的にレンダリングおよびキャッシュします。これは、ルートをサーバー上でレンダリングする代わりにキャッシュされたルートを提供できるようにする最適化で、ページの読み込みを早くします；

Full Route Cacheのしくみを理解するには、Reactがレンダリングをどのように処理し、Next.jsがどのように結果をキャッシュするかを理解するのが役立ちます；

### 1. サーバーでのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業はチャンクに分割されます：個別のルートセグメントとサスペンス境界によって。

各チャンクは2ステップでレンダリングされます；

1. ReactはServer Componentsをストリーミング用に最適化された特殊なデータ形式（**React Server Component Payload**）にレンダリングします；
2. Next.jsはReact Server Component PayloadとClient ComponentのJavaScript指示を使用して、サーバー上で**HTML**をレンダリングします；

これにより、レンダリングがすべて完了する前に作業をキャッシュしたりレスポンスを送信したりする必要がなくなります；代わりに、作業が完了するたびにレスポンスをストリームできます；

> **React Server Component Payloadとは？**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。クライアント側のReactでブラウザのDOMを更新するために使用されます。React Server Component Payloadには以下が含まれます：
>
> - Server Componentsのレンダリング結果
> - Client Componentsをレンダリングするべき場所のプレースホルダーと、それらのJavaScriptファイルに対する参照
> - Server ComponentからClient Componentに渡されるprops
>
> 詳しくは、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください；

### 2. サーバーでのNext.jsのキャッシュ（Full Route Cache） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="Full Route Cacheのデフォルトの動作を示す。静的にレンダリングされたルートのReact Server Component PayloadとHTMLがサーバーでキャッシュされる。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルト動作は、サーバー上でルートのレンダリング結果（React Server Component PayloadとHTML）をキャッシュすることです；これはビルド時または再検証時の静的にレンダリングされたルートに適用されます；

### 3. クライアントでのReactのハイドレーションと調和 {#3-react-hydration-and-reconciliation-on-the-client}

リクエストタイムに、クライアント側で：

1. HTMLはClient ComponentとServer Componentの非インタラクティブな初期プレビューをすばやく表示するために使用されます；
2. React Server Components Payloadは、Client ComponentsとレンダリングされたServer Component treeを調和させ、DOMを更新するために使用されます；
3. JavaScriptの指示が使用され、Client Componentsを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)してアプリケーションをインタラクティブにします；

### 4. クライアントでのNext.jsのキャッシュ（Router Cache） {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadは、レイアウトや読み込み状態、ページごとに分割されたクライアント側の[Router Cache](#client-side-router-cache)に保存されます；このRouter Cacheは、以前に訪れたルートを記憶し、将来のルートを事前読み込みすることでナビゲーション体験を向上させるために使用されます；

### 5. その後のナビゲーション {#5-subsequent-navigations}

その後のナビゲーションまたは事前読み込み時には、Next.jsはReact Server Component PayloadがRouter Cacheに保存されているかどうかを確認します；もしそうなら、新しいリクエストをサーバーに送るのはスキップします；

もしルートセグメントがキャッシュにない場合、Next.jsはサーバーからReact Server Components Payloadを取得し、クライアントのRouter Cacheを充実させます；

### 静的レンダリングと動的レンダリング {#static-and-dynamic-rendering}

ルートがビルド時にキャッシュされるかどうかは、それが静的にレンダリングされるか、動的にレンダリングされるかによります；デフォルトで静的ルートはキャッシュされ、動的ルートはリクエストタイムにレンダリングされ、キャッシュされません；

この図は、静的にレンダリングされたルートと動的にレンダリングされたルートの違いを、キャッシュされたデータとキャッシュされていないデータで示しています；

<Image
  alt="データの再検証後に静的ルートがキャッシュされるか、動的ルートが決してキャッシュされないかによるFull Route Cacheへの静的レンダリングと動的レンダリングの影響。"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的レンダリングと動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)についてもっと学びましょう；

### 期間 {#duration}

デフォルトで、Full Route Cacheは永続的です；これは、レンダー出力がユーザーリクエスト間でキャッシュされていることを意味します；

### 無効化 {#invalidation}

Full Route Cacheを無効にする方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**：データキャッシュを再検証することで、サーバーでコンポーネントを再レンダリングし、新しいレンダー出力をキャッシュすることにより、Router Cacheも無効にします；
- **リデプロイ**：デプロイ間でデータキャッシュが保持されるのとは異なり、Full Route Cacheは新しいデプロイでクリアされます；

### オプトアウト {#opting-out}

Full Route Cacheをオプトアウトする、つまり各着信リクエストごとに動的にコンポーネントをレンダリングすることを希望する場合は、次のことができます：

- **[動的APIを使用](#dynamic-apis)**：これにより、Full Route Cacheからルートがオプトアウトされ、リクエストタイムに動的にレンダリングされます。データキャッシュは引き続き使用できます；
- **`dynamic = 'force-dynamic'`や`revalidate = 0`のルートセグメント設定オプションを使用する**：これにより、Full Route Cacheとデータキャッシュをスキップします。つまり、コンポーネントは着信リクエストごとにサーバーでレンダリングされ、データは取得されます。Router Cacheの方は、クライアント側のキャッシュです；
- **[データキャッシュ](#data-cache)のオプトアウト**：あるルートにキャッシュされていない`fetch`リクエストがある場合、それによりそのルートはFull Route Cacheからオプトアウトされます；特定の`fetch`リクエストのデータは、各着信リクエストのためにフェッチされます。キャッシュからオプトアウトしない他の`fetch`リクエストのデータはデータキャッシュに保たれます；これにより、キャッシュされたデータとキャッシュされていないデータのハイブリッドを実現できます；

## クライアント側Router Cache {#client-side-router-cache}

Next.jsには、レイアウト、読み込み状態、およびページごとに分割されたルートセグメントのRSCペイロードを保存するクライアント側のメモリー内Router Cacheがあります。

ユーザーがルート間を移動するとき、Next.jsは訪れたルートセグメントをキャッシュし、ユーザーが移動しそうなルートを[事前読み込み](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、後戻り/前進ナビゲーションが瞬時に行われ、ナビゲーション間でのフルページのリロードはなく、Reactステートやブラウザステートが維持されます。

Router Cacheがあることで：

- **レイアウト**はナビゲーション中にキャッシュされ、再利用されます（[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）；
- **読み込み状態**は[瞬時のナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のためにナビゲーション中にキャッシュされ、再利用されます；
- **ページ**はデフォルトでキャッシュされませんが、ブラウザの後退・前進ナビゲーション中に再利用されます。実験的な[`staleTimes`](/docs/app/api-reference/next-config-js/staleTimes)設定オプションを使用してページセグメントのキャッシュを有効にできます；

{/* TODO: Update diagram to match v15 behavior */}

> **Good to know:** このキャッシュは特にNext.jsとServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、結果は似ています；

### 期間 {#duration}

キャッシュはブラウザの一時的なメモリに保存されます；2つの要因がrouter cacheの持続時間を決定します：

- **セッション**：キャッシュはナビゲーションをまたいで持続します；ただし、ページをリフレッシュすると消去されます；
- **自動無効期間**：レイアウトと読み込み状態のキャッシュは特定の時間後に自動で無効化されます；期間は、リソースがどのように[事前読み込みされ](/docs/app/api-reference/components/link#prefetch)たか、リソースが[静的に生成され](/docs/app/building-your-application/rendering/server-components#static-rendering-default)たかに依存します：
  - **デフォルト事前読み込み**（`prefetch={null}`または未指定）：動的ページの場合はキャッシュされません。静的ページの場合は5分持続します；
  - **フル事前読み込み**（`prefetch={true}`または`router.prefetch`）：静的ページおよび動的ページの両方で5分持続します；

ページリフレッシュは**すべての**キャッシュされたセグメントをクリアしますが、自動無効期間は事前読み込みされた個々のセグメントにのみ影響を与えます；

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/next-config-js/staleTimes)設定オプションを使用して上記の自動無効期間を調整できます；

### 無効化 {#invalidation}

Router Cacheを無効にする方法は2つあります：

- **Server Action**内で：
  - パスでオンデマンドでデータを再検証します（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)） またはキャッシュタグで（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用すると、Router Cacheが無効化され、クッキーを使用するルートが古くならないようにします（例：認証の場合）；
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すことで、Router Cacheを無効化し、現在のルートに対してサーバーへの新しいリクエストを送信します；

### オプトアウト {#opting-out}

Next.js 15以降、ページセグメントはデフォルトでオプトアウトされています；

> **Good to know:** `<Link>`コンポーネントの`prefetch` propを`false`に設定することで[事前読み込み](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)をオプトアウトすることもできます；

## キャッシュ相互作用 {#cache-interactions}

異なるキャッシュメカニズムを設定する際に、それらがどのように相互作用するかを理解することが重要です；

### データキャッシュと Full Route Cache {#data-cache-and-full-route-cache}

- データキャッシュの再検証またはオプトアウトすることは、レンダー出力がデータに依存しているため、Full Route Cacheを無効にします；
- Full Route Cacheを無効にしたりオプトアウトしたりしてもデータキャッシュに影響を与えません；キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングすることができます；これは、ページのほとんどがキャッシュされたデータを使用し、いくつかのコンポーネントがリクエスト時のデータに依存している場合に便利です；すべてのデータを再フェッチしなければならないパフォーマンスの影響を心配することなく動的にレンダリングができます；

### データキャッシュとクライアント側Router Cache {#data-cache-and-client-side-router-cache}

- データキャッシュとRouter Cacheを即座に無効にするには、[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます；
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でデータキャッシュを再検証しても、Router Cacheは即座に無効になりません。Route Handlerは特定のルートに紐づいていないためです；つまり、Router Cacheはハードリフレッシュまたは自動無効期間が経過するまでは以前のペイロードを提供し続けます；

## API {#apis}

次の表は、さまざまなNext.js APIがキャッシュにどのように影響するかを示す概要を提供します；

| API                                                                        | Router Cache               | Full Route Cache        | Data Cache              | React Cache |
| -------------------------------------------------------------------------- | -------------------------- | ----------------------- | ----------------------- | ----------- |
| [`<Link prefetch>`](#link)                                                 | Cache                      |                         |                         |             |
| [`router.prefetch`](#router-prefetch)                                      | Cache                      |                         |                         |             |
| [`router.refresh`](#router-refresh)                                        | Revalidate                 |                         |                         |             |
| [`fetch`](#fetch)                                                          |                            |                         | Cache                   | Cache       |
| [`fetch` `options.cache`](#fetch-options-cache)                            |                            |                         | CacheまたはOpt out      |             |
| [`fetch` `options.next.revalidate`](#fetch-options-next-revalidate)        |                            | Revalidate              | Revalidate              |             |
| [`fetch` `options.next.tags`](#fetch-options-next-tags-and-revalidate-tag) |                            | Cache                   | Cache                   |             |
| [`revalidateTag`](#fetch-options-next-tags-and-revalidate-tag)             | Revalidate (Server Action) | Revalidate              | Revalidate              |             |
| [`revalidatePath`](#revalidatepath)                                        | Revalidate (Server Action) | Revalidate              | Revalidate              |             |
| [`const revalidate`](#segment-config-options)                              |                            | RevalidateまたはOpt out | RevalidateまたはOpt out |             |
| [`const dynamic`](#segment-config-options)                                 |                            | CacheまたはOpt out      | CacheまたはOpt out      |             |
| [`cookies`](#cookies)                                                      | Revalidate (Server Action) | Opt out                 |                         |             |
| [`headers`, `searchParams`](#dynamic-apis)                                 |                            | Opt out                 |                         |             |
| [`generateStaticParams`](#generatestaticparams)                            |                            | Cache                   |                         |             |
| [`React.cache`](#react-cache-function)                                     |                            |                         |                         | Cache       |
| [`unstable_cache`](/docs/app/api-reference/legacy-apis/unstable_cache)     |                            |                         | Cache                   |             |

### `<Link>` {#link}

デフォルトでは、`<Link>`コンポーネントはFull Route Cacheからルートを自動的に事前読み込みし、そのReact Server Component PayloadをRouter Cacheに追加します；

事前読み込みを無効にするには、`prefetch` propを`false`に設定します；ただし、これはキャッシュを恒久的にスキップするわけではありません。ルートセグメントは、ユーザーがルートを訪れるとクライアント側でキャッシュされます；

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しくは調べてください；

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使用して、ルートを手動で事前読み込みすることができます；これにより、React Server Component PayloadがRouter Cacheに追加されます；

[`useRouter`フック](/docs/app/api-reference/functions/use-router) APIリファレンスをご覧ください；

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使用して、ルートを手動でリフレッシュできます；これによりRouter Cacheが完全にクリアされ、現在のルートに対してサーバーへの新しいリクエストが送信されます；`refresh`は、データキャッシュやFull Route Cacheには影響を与えません；

レンダーされた結果は、Reactステートとブラウザステートを保持しながらクライアントで調和されます；

[`useRouter`フック](/docs/app/api-reference/functions/use-router) APIリファレンスをご覧ください；

### `fetch` {#fetch}

`fetch`から返されたデータは自動的にデータキャッシュにキャッシュされます；

もし`fetch`からのレスポンスをキャッシュしたくない場合、以下を実行できます；

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)でより多くのオプションを確認してください；

### `fetch options.cache` {#fetch-options-cache}

個別の`fetch`をキャッシュにオプトインするには、`cache`オプションを`force-cache`に設定します；

```jsx
// キャッシュにオプトイン
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)でより多くのオプションを確認してください；

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

個別の`fetch`リクエストの再検証期間（秒単位）を設定するために、`fetch`の`next.revalidate`オプションを使用できます。これにより、データキャッシュが再検証され、Full Route Cacheも再検証されます；新しいデータがフェッチされ、コンポーネントがサーバーで再レンダリングされます；

```jsx
// 最長1時間ごとに再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)でより多くのオプションを確認してください；

### `fetch options.next.tags`と`revalidateTag` {#fetch-options-next-tags-and-revalidate-tag}

Next.jsには、詳細なデータキャッシュおよび再検証のためのキャッシュタグシステムがあります；

1. `fetch`か[`unstable_cache`](/docs/app/api-reference/legacy-apis/unstable_cache)を使用する場合、キャッシュエントリに1つ以上のタグを設定できます；
2. 次に、`revalidateTag`を呼び出してそのタグに関連付けられたキャッシュエントリを削除できます；

例えば、データをフェッチする際にタグを設定することができます；

```jsx
// キャッシュデータにタグを設定
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

次に、タグを指定して`revalidateTag`を呼び出してキャッシュエントリを削除します；

```jsx
// 特定のタグを持つエントリを再検証
revalidateTag('a')
```

何を達成しようとしているかに応じて、`revalidateTag`を使用する2つの場所があります；

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：ウェブフック）の応答でデータを再検証します；これによりVendor Cacheは即座に無効にはなりません。Router Handlerは特定のルートに結び付けられていないためです；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) -ユーザーアクション（例：フォームの送信）後にデータを再検証します。これにより、Router Cacheは関連するルートに対して無効になります；

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用して、特定のパス以下のルートセグメントを再レンダリングすることによりデータを手動で再検証できます；`revalidatePath`メソッドを呼び出すことでデータキャッシュが再検証され、Full Route Cacheも無効になります；

```jsx
revalidatePath('/')
```

何を達成しようとしているかに応じて、`revalidatePath`を使用する2つの場所があります；

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：ウェブフック）の応答でデータを再検証します；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション後にデータを再検証します（例：フォーム送信、ボタンのクリック）；

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)で詳しくは確認してください；

> **`revalidatePath`**と**`router.refresh`**：
>
> `router.refresh`を呼び出すことでRouter Cacheはクリアされ、データキャッシュまたはFull Route Cacheを無効にせずにサーバーでルートセグメントが再レンダリングされます；
>
> 違いは、`revalidatePath`がデータキャッシュとFull Route Cacheを削除することに対し、`router.refresh()`はクライアントサイドのAPIであり、データキャッシュやFull Route Cacheに変更しないことです；

### 動的API {#dynamic-apis}

`cookies`や`headers`のような動的API、およびPagesの`searchParams` propは、実行時の受信リクエスト情報に依存します；これらを使用すると、ルートはFull Route Cacheからオプトアウトされます。つまり、ルートは動的にレンダリングされることになります；

#### `cookies` {#cookies}

Server Actionで`cookies.set`または`cookies.delete`を使用することで、クッキーを使用するルート（例：認証の反映）が古くならないようにRouter Cacheを無効にします；

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスで詳しく確認してください；

### Segment Configオプション {#segment-config-options}

Route Segment Configオプションは、`fetch` APIを使用できない場合（例：データベースクライアントやサードパーティライブラリ）またはデフォルト自体を上書きするために使用することができます；

次のRoute Segment ConfigオプションはFull Route Cacheからオプトアウトします：

- `const dynamic = 'force-dynamic'`

この設定オプションは、すべての`fetch`を`no-store`なデータキャッシュからオプトアウトします：

- `const fetchCache = 'default-no-store'`

もっと詳細なオプションを見るには[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)を参照してください；

[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントでさらに多くのオプションを確認してください；

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)に対して（例：`app/blog/[slug]/page.js`）、`generateStaticParams`によって提供されるパスは、ビルド時にFull Route Cacheにキャッシュされます；リクエスト時には、最初に訪れるときにビルド時に知らなかったパスもキャッシュされます；

ビルド時にすべてのパスを静的にレンダリングするには、`generateStaticParams`にパスの完全なリストを提供します；

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスのサブセットを静的にレンダリングし、実行時に最初に訪れる際に残りをレンダリングするには、パスの部分的なリストを返します；

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // ビルド時に最初の10個の投稿をレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

初めて訪れるときにすべてのパスを静的にレンダリングするには、空の配列を返します（ビルド時にパスは何もレンダリングされません）または[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します；

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** 例え空であっても`generateStaticParams`から配列を返す必要があります。それ以外の場合、ルートは動的にレンダリングされます；

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時にキャッシュを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。この設定オプションを使用すると、`generateStaticParams`で提供されるパスのみが提供され、それ以外のルートは404または一致します（[catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）；

### React `cache`関数 {#react-cache-function}

Reactの`cache`関数を使用して、関数の戻り値をメモ化することができます。これにより、同じ関数を複数回呼び出しても1回だけ実行されます；

`fetch`リクエストは自動的にメモ化されるため、React `cache`にラップする必要はありません；ただし、`fetch` APIが適さないユースケースに対して手動でデータリクエストをメモ化するために`cache`を使用できます。例えば、一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアントのように；

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
