---
title: 'Next.jsのキャッシュ'
nav_title: 'キャッシュ'
description: 'Next.jsのキャッシュメカニズムの概要'
---

Next.jsは、レンダリング作業とデータリクエストをキャッシュすることで、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシュメカニズム、設定に使用できるAPI、および相互の関係について詳しく説明します。

> **知っておくと良い情報**: このページでは、Next.jsが内部でどのように機能するかを理解するのに役立ちますが、Next.jsで生産的になるために必要な知識では**ありません**。Next.jsのキャッシュヒューリスティックのほとんどは、APIの使用方法によって決定され、ゼロまたは最小限の設定で最高のパフォーマンスを発揮するためのデフォルトが用意されています。例に直接進みたい場合は、[ここから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

次に、さまざまなキャッシュメカニズムとその目的の概要を示します：

| メカニズム                                      | 内容                | 場所         | 目的                                             | 期間                               |
| ----------------------------------------------- | ------------------- | ------------ | ------------------------------------------------ | ---------------------------------- |
| [リクエストのメモ化](#request-memoization)      | 関数の戻り値        | サーバー     | React コンポーネントツリーでデータを再利用       | リクエストライフサイクル単位       |
| [データキャッシュ](#data-cache)                 | データ              | サーバー     | ユーザーリクエストやデプロイ間でデータを保存     | 永続的（再検証可能）               |
| [フルルートキャッシュ](#full-route-cache)       | HTMLとRSCペイロード | サーバー     | レンダリングコストを削減し、パフォーマンスを向上 | 永続的（再検証可能）               |
| [ルーターキャッシュ](#client-side-router-cache) | RSCペイロード       | クライアント | ナビゲーションでのサーバーリクエストを削減       | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsは性能向上とコスト削減のため、可能な限りキャッシュします。つまり、ルートは**静的にレンダリング**され、データリクエストは**キャッシュ**されます（オプトアウトしない限り）。以下の図は、ビルド時と静的ルートが初めて訪問された際のデフォルトのキャッシュ動作を示しています。

<Image
  alt="Next.jsの既定のキャッシュ動作を示す図で、ビルド時およびルートが最初に訪問された際のHIT、MISS、SETを表示している。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシュ動作は、ルートが静的または動的にレンダリングされるか、データがキャッシュされるかされないか、およびリクエストが初回の訪問の一部か、後続のナビゲーションの一部かによって変化します。使用ケースに応じて、個々のルートとデータリクエストのキャッシュ動作を設定できます。

## リクエストのメモ化 {#request-memoization}

Reactは、同じURLとオプションを持つリクエストを自動的に**メモ化**するために[`fetch` API](#fetch)を拡張します。これにより、Reactコンポーネントツリー内の複数の場所で同じデータのフェッチ関数を呼び出しながら、1回だけ実行することができます。

<Image
  alt="デデュプリケートされたフェッチリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

たとえば、ルート全体で同じデータを使用する必要がある場合（例：Layout、Page、複数のコンポーネント内）、ツリーの最上位でデータをフェッチし、コンポーネント間でpropsを転送する必要はありません。代わりに、必要なコンポーネントでデータをフェッチして、そのデータに対してネットワーク全体で複数のリクエストを行うことによるパフォーマンスへの影響を心配することなく、利用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されるが、最初の1回だけ実行されます
const item = await getItem() // キャッシュMISS

// 2回目の呼び出しはルートのどこででも行われる可能性があります
const item = await getItem() // キャッシュHIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されるが、最初の1回だけ実行されます
const item = await getItem() // キャッシュMISS

// 2回目の呼び出しはルートのどこででも行われる可能性があります
const item = await getItem() // キャッシュHIT
```

</TabItem>
</Tabs>

**リクエストのメモ化の仕組み**

<Image
  alt="Reactレンダリング中のフェッチメモ化の仕組みを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングする際、特定のリクエストが最初に呼び出されたとき、その結果はメモリに存在せず、キャッシュ`MISS`となります；
- したがって、関数が実行され、データが外部ソースからフェッチされ、結果がメモリに保存されます；
- 同じレンダーパス内でのリクエストの後続の関数呼び出しはキャッシュ`HIT`となり、データは関数を実行せずにメモリから返されます；
- ルートがレンダリングされ、レンダリングパスが完了すると、メモリは「リセット」され、すべてのリクエストメモ化エントリがクリアされます。

> **知っておくと良い情報**:
>
> - リクエストメモ化はReactの機能であり、Next.jsの機能ではありません。ここでは、他のキャッシュメカニズムとの相互作用を示すために含まれています。
> - メモ化は、`fetch`リクエストの`GET`メソッドにのみ適用されます；
> - メモ化はReactコンポーネントツリーにのみ適用され、つまり：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、および他のServer Componentsでの`fetch`リクエストに適用されます；
>   - Reactコンポーネントツリーの一部ではないRoute Handlersでの`fetch`リクエストには適用されません；
> - `fetch`が適していない場合（例：一部のデータベースクライアント、CMSクライアント、グラフQLクライアント）、[Reactの`cache`関数](#react-cache-function)を使用して関数をメモ化できます。

### 期間 {#duration}

このキャッシュは、サーバーリクエストのライフタイムとReactコンポーネントツリーのレンダリングが完了するまで持続します。

### 再検証 {#revalidating}

メモ化はサーバーリクエスト間で共有されず、レンダリング中にのみ適用されるため、それを再検証する必要はありません。

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、他のメソッド（例：`POST`や`DELETE`）にはメモ化されません。このデフォルトの動作はReactの最適化であり、それをオプトアウトすることは推奨されません。

個々のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/ja/docs/Web/API/AbortController)から[`signal`](https://developer.mozilla.org/ja/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これによりメモ化からリクエストをオプトアウトするのではなく、進行中のリクエストを中止します。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## データキャッシュ {#data-cache}

Next.jsには、到着する**サーバーリクエスト**や**デプロイメント**間でデータフェッチの結果を永続的に**維持**する組み込みのデータキャッシュがあります。これは、Next.jsがネイティブの`fetch` APIを拡張して、サーバー上の各リクエストが独自の永続的なキャッシングセマンティクスを設定できるようにするため、可能です。

> **知っておくと良い情報**: ブラウザでは、`fetch`の`cache`オプションは、リクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは`cache`オプションは、サーバー側のリクエストがサーバーのデータキャッシュとどのように相互作用するかを示します。

`fetch`の[`cache`](#fetch-optionscache)および[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用してキャッシュ動作を設定できます。

**データキャッシュの仕組み**

<Image
  alt="キャッシュされたおよびキャッシュされていないフェッチリクエストがデータキャッシュとどのように相互作用するかを示す図。キャッシュされたリクエストはデータキャッシュに保存され、メモ化され、キャッシュされていないリクエストはデータソースからフェッチされ、データキャッシュには保存されず、メモ化されます。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- レンダリング中に`'force-cache'`オプションを指定した初回の`fetch`リクエストが呼び出されると、Next.jsはデータキャッシュ内にキャッシュされたレスポンスがあるか確認します；
- キャッシュされたレスポンスが見つかった場合、それは即座に返され、[メモ化](#request-memoization)されます；
- キャッシュされたレスポンスが見つからない場合、リクエストはデータソースに送信され、その結果がデータキャッシュに格納され、メモ化されます；
- キャッシュされないデータの場合（例：`cache`オプションが定義されていないか、`{ cache: 'no-store' }`を使用）、その結果は常にデータソースからフェッチされ、メモ化されます；
- データがキャッシュされているかされていないかにかかわらず、リクエストは常にメモ化され、Reactのレンダーパス中に同じデータに対する重複リクエストを避けます；

> **データキャッシュとリクエストメモ化の違い**
>
> 両方のキャッシュメカニズムは、キャッシュされたデータを再利用することでパフォーマンスを向上させるのに役立ちますが、データキャッシュは到着するリクエストやデプロイメント間で永続的であるのに対し、メモ化はリクエストのライフタイムのみ持続します。

### 期間 {#duration}

データキャッシュは到着するリクエストやデプロイメント間で永続的です。ただし、再検証やオプトアウトを行わない限り。

### 再検証 {#revalidating}

キャッシュされたデータは、次の2つの方法で再検証可能です：

- **時間ベースの再検証**: 一定の時間が経過した後に新しいリクエストがあった際にデータを再検証します。これは、データが頻繁に変更されず、鮮度がそれほど重要でない場合に有用です。
- **オンデマンドの再検証:** イベントに基づいてデータを再検証します（例：フォーム送信）。オンデマンド再検証は、タグベースまたはパスベースのアプローチを使用して、一度にデータのグループを再検証することができます。これはヘッドレスCMSのコンテンツが更新された際に最新のデータをできるだけ早く表示したい時に有用です。

#### 時間ベースの再検証 {#time-based-revalidation}

特定の間隔でデータを再検証するには、`fetch`の`next.revalidate`オプションを使用して、リソースのキャッシュの寿命を（秒単位で）設定できます。

```js
// 最長で毎時間再検証します
fetch('https://...', { next: { revalidate: 3600 } })
```

または、[ルートセグメントの設定オプション](#segment-config-options)を使用して、セグメント内のすべての`fetch`リクエストを設定したり、`fetch`を使用できないケースで利用できます。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証の動作を示す図で、再検証期間の後、最初のリクエストで古いデータが返され、新しいデータがバックグラウンドで再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`を指定した`fetch`リクエストが最初に呼び出されたとき、データは外部データソースからフェッチされ、データキャッシュに格納されます；
- 指定された時間枠（例：60秒）内に呼び出されたリクエストはキャッシュされたデータを返します；
- 時間枠の後、次のリクエストはまだキャッシュされた（現在は古くなった）データを返します；
  - Next.jsはデータのバックグラウンド再検証をトリガーします；
  - データが正常にフェッチされると、Next.jsは新鮮なデータでデータキャッシュを更新します；
  - バックグラウンド再検証が失敗した場合、以前のデータはそのまま保持されます；

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)動作と似ています。

#### オンデマンドの再検証 {#on-demand-revalidation}

データは[パス](#revalidatepath)またはキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）によってオンデマンドで再検証できます。

**オンデマンドの再検証の仕組み**

<Image
  alt="オンデマンド再検証の動作を示す図で、再検証リクエストの後に新鮮なデータと共にデータキャッシュが更新されます。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが最初に呼び出されたとき、データは外部データソースからフェッチされ、データキャッシュに格納されます；
- オンデマンドの再検証がトリガーされると、適切なキャッシュエントリはキャッシュから削除されます；
  - これは時間ベースの再検証と異なり、新鮮なデータがフェッチされるまで古いデータをキャッシュに保持します；
- 次にリクエストが行われると、再びキャッシュ`MISS`となり、データは外部データソースからフェッチされ、データキャッシュに格納されます；

### オプトアウト {#opting-out}

`fetch`からのレスポンスをキャッシュしたくない場合は、以下のようにします：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## フルルートキャッシュ {#full-route-cache}

> **関連用語**:
>
> 自動静的最適化、静的サイト生成、または静的レンダリングを、アプリケーションのルートをビルド時にレンダリングおよびキャッシュするプロセスを指す用語として使うことがあります。

Next.jsはビルド時にルートを自動的にレンダリングし、キャッシュします。これは、リクエストごとにサーバー上でレンダリングする代わりにキャッシュされたルートを提供できる最適化であり、より速いページ読み込みをもたらします。

フルルートキャッシュの仕組みを理解するには、Reactがレンダリングをどのように処理し、Next.jsが結果をどのようにキャッシュするかを見ることが役立ちます：

### 1. サーバー上でのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は個々のルートセグメントやSuspenseバウンダリごとに分割されます。

各チャンクは2つのステップでレンダリングされます：

1. ReactはServer Componentsをストリーミング最適化された特殊なデータ形式にレンダリングします、これは**React Server Component Payload**と呼ばれます；
2. Next.jsはReact Server Component PayloadとClient Component JavaScript命令を使用してサーバー上で**HTML**をレンダリングします；

これにより、すべてがレンダリングされるまでキャッシュ作業を待つ必要がなくなり、作業が完了するにつれてレスポンスをストリーミングすることができます。

> **React Server Component Payloadとは？**
>
> React Server Component Payloadは、ブラウザのDOMを更新するためにクライアント側でReactが使用する、レンダリングされたReact Server Componentsツリーのコンパクトなバイナリ表現です。React Server Component Payloadには：
>
> - Server Componentsのレンダリング結果；
> - Client ComponentsがレンダリングされるべきプレースホルダーとそれらのJavaScriptファイルへの参照；
> - Server ComponentからClient Componentに渡されたprops；
>
> 詳細については、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください。

### 2. サーバー上のNext.jsのキャッシュ（フルルートキャッシュ） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="静的にレンダリングされたルートに対し、React Server Component PayloadとHTMLがサーバー上でキャッシュされるフルルートキャッシュのデフォルト動作を示す図。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルト動作は、サーバー上でのルートのレンダリング結果（React Server Component PayloadとHTML）をキャッシュすることです。これはビルド時や再検証中に静的にレンダリングされたルートに適用されます。

### 3. クライアントでのReactのハイドレーションと和解 {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時、クライアントでは：

1. HTMLは、ClientおよびServer Componentsの高速な非対話的な初期プレビューを即座に表示するために使用されます；
2. React Server Components Payloadは、クライアントとレンダリングされたServer Componentツリーを和解し、DOMを更新するために使用されます；
3. JavaScriptの命令は、クライアントコンポーネントを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションを対話的にします；

### 4. クライアント側のNext.jsのキャッシュ（ルーターキャッシュ） {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadは、ルートセグメントごとに分割されたクライアント側の[ルーターキャッシュ](#client-side-router-cache)に保存されます - これは、訪れたルートを保存し、将来のルートをプリフェッチすることによって、ナビゲーション体験を改善するために使用される別のインメモリキャッシュです。

### 5. その後のナビゲーション {#5-subsequent-navigations}

その後のナビゲーションやプリフェッチ中に、Next.jsはReact Server Components Payloadがルーターキャッシュに保存されているかどうかを確認します。 もし保存されていれば、新たなサーバーへのリクエストをスキップします。

ルートセグメントがキャッシュされていない場合、Next.jsはサーバーからReact Server Components Payloadをフェッチし、クライアント側のルーターキャッシュに追加します。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ビルド時にルートがキャッシュされるかどうかは、それが静的にレンダリングされるか動的にレンダリングされるかによります。静的ルートはデフォルトでキャッシュされ、動的ルートはリクエスト時にレンダリングされ、キャッシュされません。

この図は、静的レンダリングと動的レンダリングの違いを、キャッシュされたデータおよびキャッシュされていないデータで示しています：

<Image
  alt="フルルートキャッシュに対して静的レンダリングおよび動的レンダリングがどのように影響するか。静的ルートはビルド時またはデータ再検証後にキャッシュされ、動的ルートは決してキャッシュされません"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)についてもっと学ぶ

### 期間 {#duration}

デフォルトでは、フルルートキャッシュは永続的です。これは、レンダリング出力がユーザーリクエスト間でキャッシュされることを意味します。

### 無効化 {#invalidation}

フルルートキャッシュを無効にするには、以下の2つの方法があります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: データキャッシュの再検証は、サーバー上でコンポーネントを再レンダリングし、新しいレンダリング出力をキャッシュすることでルーターキャッシュも無効にします。
- **再デプロイ**: データキャッシュはデプロイメントをまたいで永続しますが、フルルートキャッシュは新しいデプロイメントでクリアされます。

### オプトアウト {#opting-out}

フルルートキャッシュをオプトアウトする、つまり、到着するリクエストごとに動的にコンポーネントをレンダリングするには：

- **[Dynamic API](#dynamic-apis)の使用**: これにより、ルートはフルルートキャッシュからオプトアウトされ、リクエスト時に動的にレンダリングされます。データキャッシュは使用可能です。
- **`dynamic = 'force-dynamic'` または `revalidate = 0` のルートセグメント設定を使用**: これにより、フルルートキャッシュもデータキャッシュもスキップされます。つまり、到着するリクエストごとにコンポーネントがレンダリングされ、データがフェッチされます。ルーターキャッシュはクライアント側のキャッシュであるため、適用されます。
- **[データキャッシュ](#data-cache)のオプトアウト**: もしルートにキャッシュされていない`fetch`リクエストがある場合、これによりルートはフルルートキャッシュからオプトアウトされます。特定の`fetch`リクエストのデータは、到着するリクエストごとにフェッチされます。キャッシュオプトアウトしていない他の`fetch`リクエストは、データキャッシュでキャッシュされます。これはキャッシュされたデータとキャッシュされていないデータのハイブリッドを可能にします。

## クライアント側のルーターキャッシュ {#client-side-router-cache}

Next.jsにはインメモリのクライアント側ルーターキャッシュがあり、レイアウト、ローディング状態、およびページごとに分割されたルートセグメントのRSCペイロードを保存します。

ユーザーがルート間をナビゲートするとき、Next.jsは訪れたルートセグメントをキャッシュし、ユーザーがナビゲートしそうなルートを[事前取得](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これは、インスタントな前後のナビゲーション、ナビゲーション間のフルページリロードなし、React状態とブラウザ状態の保持をもたらします。

ルーターキャッシュを使用すると：

- **レイアウト**はキャッシュされ、ナビゲーションで再利用されます（[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）
- **ローディング状態**は、[インスタントナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のために、ナビゲーションでキャッシュされ、再利用されます；
- **ページ**はデフォルトではキャッシュされませんが、ブラウザの後方および前方ナビゲーション中に再利用されます。ページセグメントのキャッシングを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/next-config-js/staleTimes)設定オプションを使用できます。

{/* TODO: v15の動作に合わせて図を更新 */}

> **知っておくと良い情報:** このキャッシュは特にNext.jsとServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、結果は似ています。

### 期間 {#duration}

このキャッシュはブラウザの一時メモリに保存されます。ルーターキャッシュが持続する期間は次の2つの要因によって決まります：

- **セッション**: キャッシュはナビゲーションをまたいで持続します。ただし、ページリフレッシュでクリアされます；
- **自動無効化期間**: レイアウトとローディング状態のキャッシュは、特定時間後に自動的に無効化されます。期間は、リソースがどのように[事前取得](/docs/app/api-reference/components/link#prefetch)されたか、またはリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかによります：
  - **デフォルトの事前取得** (`prefetch={null}` または指定なし): 動的ページにはキャッシュされませんが、静的ページには5分間；
  - **フル事前取得** (`prefetch={true}` または `router.prefetch`): 静的および動的ページの両方で5分間；

ページリフレッシュは**すべての**キャッシュされたセグメントをクリアしますが、自動無効化期間は、事前取得された時点から個々のセグメントに対してのみ影響します；

> **知っておくと良い情報**: 実験的な[`staleTimes`](/docs/app/api-reference/next-config-js/staleTimes)設定オプションを使用して、上記の自動無効化時間を調整できます。

### 無効化 {#invalidation}

ルーターキャッシュを無効化するには、次の2つの方法があります：

- **Server Action**内で：
  - パスでのデータをオンデマンドで再検証する（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)）またはキャッシュタグで（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）；
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用して、cookiesを使用するルートが古くならないようにルーターキャッシュを無効にする（例：認証）；
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すと、ルーターキャッシュが無効になり、現在のルートに対してサーバーへの新しいリクエストが行われます。

### オプトアウト {#opting-out}

Next.js 15以降、ページセグメントはデフォルトでオプトアウトされています。

> **知っておくと良い情報:** `<Link>`コンポーネントの`prefetch`プロップを`false`に設定することによって、[事前取得](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)をオプトアウトすることもできます。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシュメカニズムを設定する際には、互いの相互作用を理解することが重要です：

### データキャッシュとフルルートキャッシュ {#data-cache-and-full-route-cache}

- データキャッシュを再検証またはオプトアウトすることは、レンダリング出力がデータに依存しているため、フルルートキャッシュを無効に**します**；
- フルルートキャッシュを無効化またはオプトアウトすることは、データキャッシュに影響を与えません。キャッシュされたデータとキャッシュされていないデータのハイブリッドが可能で、レンダリング出力が動的に行われるが、ページのほとんどがキャッシュされたデータを使用していて、いくつかのコンポーネントだけがリクエスト時にフェッチされる必要がある場合に有用です。

### データキャッシュとクライアント側ルーターキャッシュ {#data-cache-and-client-side-router-cache}

- データキャッシュとルーターキャッシュを即座に無効化するには、Server Action内で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます。
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でデータキャッシュを再検証することは、Route Handlerが特定のルートに関連付けられていないため、ルーターキャッシュを即座に無効にはしません。これにより、ハードリフレッシュまたは自動無効化期間が経過するまで、ルーターキャッシュは以前のペイロードを提供し続けます。

## APIs {#apis}

以下の表は、異なるNext.jsのAPIがキャッシュにどのように影響するかの概要を示しています：

| API                                                                     | ルーターキャッシュ         | フルルートキャッシュ    | データキャッシュ        | Reactキャッシュ |
| ----------------------------------------------------------------------- | -------------------------- | ----------------------- | ----------------------- | --------------- |
| [`<Link prefetch>`](#link)                                              | Cache                      |                         |                         |                 |
| [`router.prefetch`](#routerprefetch)                                    | Cache                      |                         |                         |                 |
| [`router.refresh`](#routerrefresh)                                      | Revalidate                 |                         |                         |                 |
| [`fetch`](#fetch)                                                       |                            |                         | Cache                   | Cache           |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                         | CacheまたはOpt out      |                 |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Revalidate              | Revalidate              |                 |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Cache                   | Cache                   |                 |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate              | Revalidate              |                 |
| [`revalidatePath`](#revalidatepath)                                     | Revalidate (Server Action) | Revalidate              | Revalidate              |                 |
| [`const revalidate`](#segment-config-options)                           |                            | RevalidateまたはOpt out | RevalidateまたはOpt out |                 |
| [`const dynamic`](#segment-config-options)                              |                            | CacheまたはOpt out      | CacheまたはOpt out      |                 |
| [`cookies`](#cookies)                                                   | Revalidate (Server Action) | Opt out                 |                         |                 |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Opt out                 |                         |                 |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Cache                   |                         |                 |
| [`React.cache`](#react-cache-function)                                  |                            |                         |                         | Cache           |
| [`unstable_cache`](/docs/app/api-reference/legacy-apis/unstable_cache)  |                            |                         | Cache                   |                 |

### `<Link>` {#link}

デフォルトでは、`<Link>`コンポーネントはフルルートキャッシュからルートを自動でプリフェッチし、Router CacheにReact Server Component Payloadを追加します。

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定します。ただし、これにより、ルートセグメントが完全にキャッシュをスキップすることはなく、ユーザーがルートを訪れるときにクライアント側でキャッシュされます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しく学ぶ

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使用して、ルートを手動でプリフェッチできます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを参照。

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使用してルートを手動で更新できます。これにより、Router Cacheが完全にクリアされ、現在のルートに対してサーバーへの新しいリクエストが行われます。`refresh`はデータキャッシュやフルルートキャッシュには影響を与えません。

レンダリングされた結果は、React状態とブラウザ状態を保持しつつクライアント側で和解されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを参照。

### `fetch` {#fetch}

`fetch`から返されるデータは、自動的にデータキャッシュにキャッシュされます。

`fetch`からのレスポンスをキャッシュしたくない場合は：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)のその他のオプションを参照。

### `fetch options.cache` {#fetch-options-cache}

`cache`オプションを`force-cache`に設定することで、個々の`fetch`をキャッシュにオプトすることができます：

```jsx
// キャッシュにオプトインします
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)のその他のオプションを参照。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

`fetch`の`next.revalidate`オプションを使用して、個々の`fetch`リクエストの再検証期間（秒単位）を設定できます。これによりデータキャッシュが再検証され、フルルートキャッシュも再検証されます。新鮮なデータがフェッチされ、コンポーネントがサーバーで再レンダリングされます。

```jsx
// 最大1時間ごとに再検証します
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)のその他のオプションを参照。

### `fetch options.next.tags` と `revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、詳細なデータキャッシュと再検証のためのキャッシュタグシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/legacy-apis/unstable_cache)を使用する場合、一つ以上のタグでキャッシュエントリをタグ付けするオプションがあります；
2. その後、そのタグに関連付けられたキャッシュエントリをパージするために`revalidateTag`を呼び出せます；

たとえば、データをフェッチするときにタグを設定します：

```jsx
// タグでデータをキャッシュ
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

その後、タグを使用してキャッシュエントリをパージするために`revalidateTag`を呼び出します：

```jsx
// 特定のタグでエントリを再検証
revalidateTag('a')
```

達成しようとしていることによって、使用する場所は2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：webhook）に応じてデータを再検証します。ルーターハンドラーが特定のルートに関連付けられていないため、これによりルーターキャッシュが即座に無効になるわけではありません；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション（例：フォーム送信）の後にデータを再検証します。関連するルートに対してルーターキャッシュを無効にします；

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、単一の操作で特定のパス以下のデータを再検証し、ルートセグメントを再レンダリングできます。`revalidatePath`メソッドを呼び出すと、データキャッシュが再検証され、フルルートキャッシュが無効になります。

```jsx
revalidatePath('/')
```

達成しようとしていることによって、使用する場所は2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：webhook）に応じてデータを再検証するため；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーのインタラクション後 （例：フォーム送信、ボタンのクリック）にデータを再検証するため；

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)を参照。

> **`revalidatePath`** vs. **`router.refresh`**:
>
> `router.refresh`を呼び出すと、ルーターキャッシュがクリアされ、サーバーでのデータキャッシュやフルルートキャッシュを無効にすることなくルートセグメントが再レンダリングされます；
>
> 違いは、`revalidatePath`はデータキャッシュとフルルートキャッシュをパージしますが、`router.refresh()`はクライアント側APIとしてデータキャッシュとフルルートキャッシュを変更しません。

### 動的API {#dynamic-apis}

`cookies`や`headers`のような動的API、およびPagesの`searchParams`プロップは、ランタイムの到着リクエスト情報に依存しています。それらを使用することで、ルートはフルルートキャッシュからオプトアウトされ、つまりルートが動的にレンダリングされます。

#### `cookies` {#cookies}

Server Action内で`cookies.set`や`cookies.delete`を使用すると、cookiesを使用するルートが古くならないように（例：認証の変更を反映するために）ルーターキャッシュが無効化されます。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照。

### セグメントの設定オプション {#segment-config-options}

ルートセグメントの設定オプションは、ルートセグメントのデフォルトをオーバーライドしたり、`fetch` APIを使用できない場合に（例：データベースクライアントやサードパーティライブラリ）使用します。

次のルートセグメントの設定オプションはフルルートキャッシュをオプトアウトします：

- `const dynamic = 'force-dynamic'`

この設定オプションは、すべてのフェッチをデータキャッシュからオプトアウト（つまり、`no-store`）します：

- `const fetchCache = 'default-no-store'`

高度なオプションについては、[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)を参照してください。

詳細なオプションについては、[ルートセグメントの設定](/docs/app/api-reference/file-conventions/route-segment-config)のドキュメントを参照してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）では、`generateStaticParams`によって提供されるパスはビルド時にフルルートキャッシュにキャッシュされます。リクエスト時にビルド時に知られていなかったパスも、最初に訪問されたときにキャッシュされます。

ビルド時にすべてのパスを静的にレンダリングするには、`generateStaticParams`にパスの完全なリストを提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスのサブセットを静的にレンダリングし、残りをランタイムで初めて訪問されたときに最初にレンダリングするには、部分的なパスリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10件の投稿をビルド時にレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

すべてのパスを初めて訪問されたときに静的にレンダリングするには、空配列を返します（ビルド時にはパスはレンダリングされません）または[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **知っておくと良い情報:** `generateStaticParams`からは、空の配列であっても配列を返す必要があります。そうでない場合、ルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時のキャッシュを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。この設定オプションを使用すると、`generateStaticParams`によって提供されたパスのみが提供され、他のルートは404を返します（[catch-allルート](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）。

### React `cache` 関数 {#react-cache-function}

Reactの`cache`関数は、関数の戻り値をメモ化することを可能にし、同じ関数を複数回呼び出しても1回だけ実行されます。

`fetch`リクエストは自動的にメモ化されるため、Reactの`cache`でラップする必要はありません。ただし、`fetch` APIが適していない場合（例：一部のデータベースクライアント、CMSクライアント、GraphQLクライアント）、手動でデータリクエストをメモ化するために`cache`を使用できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
