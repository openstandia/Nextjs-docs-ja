---
title: 'Next.jsにおけるキャッシング'
nav_title: 'キャッシング'
description: 'Next.jsにおけるキャッシングメカニズムの概要。'
---

Next.jsはレンダリング作業やデータ要求をキャッシュすることで、アプリケーションのパフォーマンスを向上し、コストを削減します。このページでは、Next.jsのキャッシングメカニズム、それを設定するためのAPI、それらの相互作用について詳細に説明します。

> **知っておくと良いこと**: このページは、Next.jsが内部でどのように動作するかを理解するのに役立ちますが、Next.jsを生産的に利用するために必ずしも必要な知識ではありません。Next.jsのキャッシングヒューリスティクスは、ほとんどがAPIの使用により決定され、ゼロまたは最小限の設定で最高のパフォーマンスが得られるようにデフォルト設定されています。例に飛びたい場合は、[こちらから](/docs/app/building-your-application/data-fetching/fetching)始めてください。

## 概要

以下は、さまざまなキャッシングメカニズムとその目的の概要です：

| メカニズム                                           | 内容                      | 場所  | 目的                                            | 期間                          |
| ---------------------------------------------------- | ------------------------- | ------ | ------------------------------------------------ | ------------------------------- |
| [Request Memoization](#request-memoization)          | 関数の戻り値              | サーバー | Reactコンポーネントtreeでのデータ再利用           | リクエストのライフサイクル中  |
| [Data Cache](#data-cache)                            | データ                    | サーバー | ユーザーリクエストとデプロイメント間でデータの保存 | 永続的（再検証可能）          |
| [Full Route Cache](#full-route-cache)                | HTMLとRSCペイロード       | サーバー | レンダリングコストの削減とパフォーマンスの向上     | 永続的（再検証可能）          |
| [Router Cache](#client-side-router-cache)            | RSCペイロード             | クライアント | ナビゲーション時のサーバーリクエストの削減        | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsはパフォーマンスを向上し、コストを削減するために可能な限りキャッシュを行います。これは、ルートが**静的にレンダリング**され、データ要求が**キャッシュ**されることを意味しますが、これを選択解除することも可能です。以下の図は、ビルド時や静的ルートが最初に訪問されたときに、ルートが静的にレンダリングされたときのデフォルトのキャッシング挙動を示しています。

<Image
  alt="Next.jsにおけるデフォルトのキャッシング挙動を示す図。ビルド時とルートが最初に訪れた時にHIT、MISS、SETが発生する。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシングの挙動は、ルートが静的あるいは動的にレンダリングされたか、データがキャッシュされたか未キャッシュであるか、初回訪問かその後のナビゲーションかにより変わります。使用ケースに応じて、個別のルートやデータリクエストのキャッシング挙動を設定できます。

## Request Memoization

Reactは[`fetch` API](#fetch)を拡張して、同じURLとオプションを持つリクエストを自動的に**メモ化**します。これにより、Reactコンポーネントtree内の異なる場所で同じデータのフェッチ関数を呼び出すことが可能です。そしてそれは一度だけ実行されます。

<Image
  alt="重複排除されたフェッチリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

たとえば、ルート全体で同じデータを使用する必要がある場合（例：Layout、Page、および複数のコンポーネントで）、treeの最上部でデータを取得し、propsをコンポーネント間で転送する必要はありません。代わりに、必要なコンポーネント内でデータを取得し、同じデータの複数のリクエストがネットワークを介して行われる際のパフォーマンスへの影響を心配する必要がありません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch` 関数は自動的にメモ化され、結果が
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初の実行のみです
const item = await getItem() // cache MISS

// 2回目の呼び出しはルート内のどこでも可能です
const item = await getItem() // cache HIT
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch` 関数は自動的にメモ化され、結果が
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初の実行のみです
const item = await getItem() // cache MISS

// 2回目の呼び出しはルート内のどこでも可能です
const item = await getItem() // cache HIT
```
</TabItem>
</Tabs>


**Request Memoizationの仕組み**

<Image
  alt="Reactレンダリング中にfetchのメモ化がどのように機能するかを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリング中に、特定のリクエストが初めて呼び出されたとき、その結果はメモリにありませんので、キャッシュ `MISS` になります。
- これにより、関数は実行され、データは外部ソースから取得され、結果はメモリに保存されます。
- 同じレンダーパスでのリクエストの次の関数呼び出しはキャッシュ `HIT` になり、関数を実行することなくメモリからデータが返されます。
- レンダリングパスが完了した後、メモリは「リセット」され、すべてのリクエストメモ化エントリがクリアされます。

> **知っておくと良いこと**:
>
> - リクエストメモ化はReactの機能であり、Next.jsの機能ではありません。他のキャッシングメカニズムとの相互作用を示すためにここに含まれています。
> - メモ化は`fetch`リクエストの`GET`メソッドにのみ適用されます。
> - メモ化はReactコンポーネントtreeにのみ適用されます。これにより、以下が適用されます：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、およびその他のServer Components内の`fetch`リクエストに適用されます。
>   - Route Handlers内の`fetch`リクエストには適用されません。なぜなら、それらはReactコンポーネントtreeの一部ではないからです。
> - `fetch`が適していないケース（例：特定のデータベースクライアント、CMSクライアント、GraphQLクライアント）の場合、[React `cache` 関数](#react-cache-function)を使用して関数をメモ化できます。

### 期間

キャッシュはサーバーリクエストのライフタイムの間持続しますが、Reactコンポーネントtreeのレンダリングが完了するまでです。

### 再検証

メモ化はサーバーリクエスト間で共有されず、レンダリング中にのみ適用されるため、再検証する必要はありません。

### 選択しない

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、他のメソッド、たとえば`POST`や`DELETE`はメモ化されません。このデフォルトの挙動はReactの最適化であり、これを選択しないことをお勧めします。

個々のリクエストを管理するために、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)から[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。これにより、メモ化からリクエストを選択しないのではなく、進行中のリクエストを中止します。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache

Next.jsは、**サーバーリクエスト**と**デプロイメント**をまたいでデータフェッチの結果を**永続化**する組み込みのData Cacheを持っています。これは、Next.jsがネイティブ`fetch` APIを拡張し、サーバー上での各リクエストに独自の永続キャッシングセマンティクスを設定できるようにしているため可能です。

> **知っておくと良いこと**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示します。Next.jsでは、`cache`オプションはサーバー側リクエストがサーバーのData Cacheとどのように相互作用するかを示します。

`fetch`の[`cache`](#fetch-optionscache)および[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシングの挙動を設定できます。

**Data Cacheの仕組み**

<Image
  alt="キャッシュされたフェッチリクエストと未キャッシュのフェッチリクエストがData Cacheとどのように相互作用するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化され、未キャッシュのリクエストはデータソースから取得され、Data Cacheに保存されず、メモ化される。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- `force-cache`オプションを持つ`fetch`リクエストがレンダリング中に初めて呼ばれる際、Next.jsはData Cache内のキャッシュされたレスポンスを確認します。
- キャッシュされたレスポンスが見つかれば、それが即座に返され、[メモ化](#request-memoization)されます。
- キャッシュされたレスポンスが見つからなければ、リクエストはデータソースに送信され、結果はData Cacheに保存され、メモ化されます。
- 未キャッシュのデータ（例：`cache`オプションが定義されていない、または`{ cache: 'no-store' }`を使用）は常にデータソースから取得され、メモ化されます。
- データがキャッシュされているか否かに関係なく、リクエストは常にメモ化され、Reactレンダーパス中に同じデータに対して重複したリクエストを行うのを避けます。

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシングメカニズムは、キャッシュされたデータを再利用することでパフォーマンスを向上させますが、Data Cacheはリクエストおよびデプロイメントをまたぐ永続的なものであるのに対し、メモ化はリクエストのライフタイムのみ持続します。

### 期間

Data Cacheは、再検証するか選択しない限り、リクエストおよびデプロイメントをまたいで永続的です。

### 再検証

キャッシュされたデータは2つの方法で再検証できます：

- **時間ベースの再検証**: 一定の時間が経過し、新しいリクエストが行われた場合にデータを再検証します。これは、データがめったに変更されず、鮮度がそれほど重要でない場合に役立ちます。
- **オンデマンド再検証:** イベントに基づいてデータを再検証します（例：フォーム送信）。オンデマンド再検証では、タグベースまたはパスベースのアプローチを使用してデータのグループを一度に再検証します。これは、ヘッドレスCMSからのコンテンツが更新された場合など、できるだけ早く最新のデータを表示したい場合に役立ちます。

#### 時間ベースの再検証

データを一定間隔で再検証するには、`fetch`の`next.revalidate`オプションを使用してリソースのキャッシュ寿命を設定します（秒単位）。

```js
// 最大で1時間ごとに再検証します
fetch('https://...', { next: { revalidate: 3600 } })
```

また、すべてのセグメント内の`fetch`リクエストを設定するか、`fetch`を使用できない場合に、[Route Segment Configオプション](#segment-config-options)を使用できます。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証がどのように機能するかを示す図。再検証期間後、最初のリクエストでは古いデータが返され、その後データが再検証される。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`を持つフェッチリクエストが最初に呼び出されたとき、データは外部データソースから取得され、Data Cacheに保存されます。
- 指定された時間枠（例：60秒）内に呼び出されたリクエストは、キャッシュされたデータを返します。
- 設定した時間枠が過ぎた場合、次のリクエストは依然としてキャッシュされた（現在の状態では古い）データを返します。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データが正常に取得されると、Next.jsは新鮮なデータでData Cacheを更新します。
  - バックグラウンド再検証が失敗した場合、前のデータが変更されずに保たれます。

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)の挙動に似ています。

#### オンデマンド再検証

データはパス([`revalidatePath`](#revalidatepath))またはキャッシュタグ([`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag))でオンデマンドに再検証できます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証がどのように機能するかを示す図。再検証要求後、Data Cacheは新鮮なデータで更新されます。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼び出されたとき、データは外部データソースから取得され、Data Cacheに保存されます。
- オンデマンド再検証がトリガーされると、適切なキャッシュエントリがキャッシュから削除されます。
  - これは時間ベースの再検証とは異なり、新鮮なデータが取得されるまで古いデータをキャッシュに保持します。
- 次にリクエストが行われたとき、それは再びキャッシュ`MISS`となり、データは外部データソースから取得され、Data Cacheに保存されます。

### 選択しない

`fetch`の応答をキャッシュしたくない場合は、以下の方法を取ります：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache

> **関連用語**:
>
> 自動静的最適化、静的サイト生成、または静的レンダリングという用語が、アプリケーションのルートをビルド時にレンダリングおよびキャッシングするプロセスを指して用いられることがあります。

Next.jsはルートを自動的にビルド時にレンダリングし、キャッシングします。これは、ルートをサーバーでレンダリングする代わりにキャッシュされたルートを提供することを可能にし、結果としてページの読み込み速度を速くします。

Full Route Cacheがどのように機能するかを理解するには、Reactがレンダリングをどのように処理し、Next.jsがその結果をどのようにキャッシュするかを見ていくとわかりやすいです：

### 1. サーバーでのReactレンダリング

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを制御します。レンダリング作業は、個々のルートセグメントとサスペンス境界によってチャンクに分割されます。

各チャンクは2つのステップでレンダリングされます：

1. ReactはServer Componentsをストリーミングに最適化された特別なデータ形式でレンダリングします。これを**React Server Component Payload**と呼びます。
2. Next.jsはReact Server Component PayloadとClient Component JavaScriptの指示を使用して、**HTML**をサーバー上でレンダリングします。

これにより、すべてをレンダリングするまで待つことなく、作業をキャッシュや応答を送信することができます。代わりに、作業が完了するたびに応答をストリーミングできます。

> **React Server Component Payloadとは何ですか？**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。クライアント上のReactがブラウザのDOMを更新するために使用されます。React Server Component Payloadには以下が含まれます：
>
> - Server Componentsのレンダリング結果
> - Client ComponentsをどこにレンダリングすべきかのプレースホルダーとそれらのJavaScriptファイルの参照
> - Server ComponentからClient Componentへのprops
>
> 詳しくは、[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください。

### 2. サーバーでのNext.jsキャッシング (Full Route Cache)

<Image
  alt="Full Route Cacheのデフォルトの挙動を示す画像。静的にレンダリングされたルートのためにサーバーでReact Server Component PayloadとHTMLがキャッシュされる。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの挙動は、ルートのレンダリング結果（React Server Component PayloadとHTML）をサーバーでキャッシュすることです。これは、ビルド時や再検証時に静的にレンダリングされるルートに適用されます。

### 3. クライアントでのReactハイドレーションと調整

リクエスト時にクライアントで：

1. HTMLは、クライアントとサーバーコンポーネントのインタラクティブでない初期プレビューを即座に表示するために使用されます。
2. React Server Components PayloadはクライアントとレンダリングされたServer Component treeを調整し、DOMを更新するために使用されます。
3. JavaScriptの指示は[hydrate](https://react.dev/reference/react-dom/client/hydrateRoot)され、Client Componentsをインタラクティブにします。

### 4. クライアントでのNext.jsキャッシング (Router Cache)

React Server Component Payloadはクライアント側の[Router Cache](#client-side-router-cache)に保存されます - 個々のルートセグメントで分割された別々のメモリ内キャッシュです。このRouter Cacheは、以前に訪問したルートを保存し、将来のルートをプレフェッチすることでナビゲーション体験を向上させるために使用されます。

### 5. 次回のナビゲーション

次回以降のナビゲーションやプレフェッチ中に、Next.jsは、React Server Components PayloadがRouter Cacheに格納されているかどうかを確認します。そうであれば、新しいリクエストをサーバーに送信することをスキップします。

ルートセグメントがキャッシュにない場合、Next.jsはサーバーからReact Server Components Payloadを取得し、クライアントにRouter Cacheをポピュレートします。

### 静的および動的レンダリング

ビルド時にルートがキャッシュされるかどうかは、それが静的にレンダリングされたか動的にレンダリングされたかによります。静的ルートはデフォルトでキャッシュされますが、動的ルートはリクエスト時にレンダリングされ、キャッシュされません。

以下の図は、静的および動的にレンダリングされたルートと、キャッシュされたデータおよびキャッシュされていないデータの違いを示しています：

<Image
  alt="静的および動的レンダリングがFull Route Cacheにどのように影響するか。静的ルートはビルド時またはデータ再検証後にキャッシュされ、動的ルートは決してキャッシュされません。"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学びましょう。

### 期間

デフォルトでは、Full Route Cacheは持続的です。つまり、レンダリング結果はユーザーリクエスト間でキャッシュされます。

### 無効化

Full Route Cacheを無効化する方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)を再検証すると、Router Cacheも無効にし、サーバー上のコンポーネントの再レンダリングと新しいレンダリング結果のキャッシュを行います。
- **再デプロイする**: Data Cacheとは異なり、デプロイメントをまたぐとFull Route Cacheはクリアされます。

### 選択しない

Full Route Cacheを選択しない、つまり、すべての受信リクエストに対して動的にコンポーネントをレンダリングすることで：

- **[Dynamic API](#dynamic-apis)を使用する**: これにより、そのルートはFull Route Cacheから選択しないされ、リクエスト時に動的にレンダリングされます。Data Cacheはまだ使用可能です。
- **`dynamic = 'force-dynamic'` または `revalidate = 0` のroute segment config optionsを使用する**: これにより、Full Route CacheとData Cacheをスキップします。つまり、サーバーへの受信リクエストごとにコンポーネントがレンダリングされ、データがフェッチされます。Router Cacheはクライアントサイドのキャッシュであるため、まだ適用されます。
- **[Data Cache](#data-cache)を選択しない**: `fetch` リクエストをキャッシュしないルートがある場合、そのルートはFull Route Cacheから選択しないされます。特定の`fetch` リクエストのデータは、受信リクエストごとにフェッチされます。他のキャッシュを選択しない`fetch` リクエストは、まだData Cacheにキャッシュされます。これにより、キャッシュされたデータとキャッシュされていないデータのハイブリッドが可能です。

## クライアントサイド Router Cache

Next.jsは、ルートセグメントのRSCペイロードをLayouts、ローディング状態、およびページごとに分割してストアするインメモリのクライアントサイドRouter Cacheを持っています。

ユーザーがルート間をナビゲートするとき、Next.jsは訪れたルートセグメントをキャッシュし、[プレフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)によってユーザーがナビゲートする可能性のあるルートを予測します。これにより、瞬時の戻る/進むナビゲーション、ナビゲーション間でのフルページリロードの不要化、およびReactステートとブラウザステートの保持が可能になります。

Router Cacheを使用すると：

- **Layouts**はキャッシュされ、ナビゲーション時に再利用されます（[partial rendering](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）。
- **ローディング状態**は、[瞬時のナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のためにキャッシュされ、ナビゲーション時に再利用されます。
- **ページ**はデフォルトでキャッシュされませんが、ブラウザのバックワードおよびフォワードナビゲーション時に再利用されます。`staleTimes`の実験的な[設定オプション](/docs/app/api-reference/next-config-js/staleTimes)を使用して、ページセグメントのキャッシングを有効にできます。

{/* TODO: Update diagram to match v15 behavior */}

> **知っておくと良いこと:** このキャッシュは特にNext.jsおよびServer Componentsに適用され、ブラウザの [bfcache](https://web.dev/bfcache/)とは異なりますが、類似の結果をもたらします。

### 期間

キャッシュはブラウザの一時的なメモリに保存されます。2つの要因によってRouter Cacheの持続時間が決まります：

- **セッション**: キャッシュはナビゲーションを通じて持続します。ただし、ページのリフレッシュ時にクリアされます。
- **自動無効化期間**: レイアウトとローディング状態のキャッシュは特定の時間後に自動的に無効化されます。期間は、そのリソースがどのように[プレフェッチ](/docs/app/api-reference/components/link#prefetch)され、[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかによって異なります：
  - **デフォルトのプレフェッチ** (`prefetch={null}` または指定なし): 動的ページではキャッシュされず、静的ページでは5分間。
  - **完全なプレフェッチ** (`prefetch={true}` または `router.prefetch`): 静的および動的ページの両方で5分。

ページリフレッシュは**すべての**キャッシュされたセグメントをクリアしますが、自動無効化期間は、そのセグメントがプレフェッチされた時点からの個々のセグメントのみに影響します。

> **知っておくと良いこと**: `staleTimes` の実験的な[設定オプション](/docs/app/api-reference/next-config-js/staleTimes)を使用して、上記の自動無効化時間を調整できます。

### 無効化

Router Cacheを無効化するための方法は2つあります：

- **Server Action**内で：
  - パスで([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath))またはキャッシュタグで([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag))オンデマンドでデータを再検証します。
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#methods)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#methods)を使用すると、クッキーを使用するルートの不整合を防ぐためにRouter Cacheが無効になります（例: 認証）。
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すとRouter Cacheが無効化され、現在のルートに対してサーバーへの新しいリクエストが行われます。

### 選択しない

Next.js 15以降では、ページセグメントがデフォルトで選択しないされるようになっています。

> **知っておくと良いこと:** `<Link>` コンポーネントの`prefetch`プロップを`false`に設定して、[プレフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)を選択しないこともできます。

## キャッシュの相互作用

異なるキャッシングメカニズムを設定するとき、それらがどのように相互作用するかを理解することは重要です：

### Data Cache と Full Route Cache

- Data Cacheを再検証、または選択しないすると、レンダリング結果がデータに依存しているため、Full Route Cacheも無効化されます。
- Full Route Cacheを無効化、または選択しないしても、Data Cacheには影響しません。キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングできます。ページのほとんどがキャッシュされたデータを使用していますが、一部のコンポーネントはリクエスト時に取得する必要があるデータに依存している場合に便利です。データを再フェッチする際のパフォーマンスに対する影響を心配することなく、動的にレンダリングできます。

### Data Cache と クライアントサイド Router Cache

- Data Cache と Router Cacheをすぐに無効化するには、[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます。
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証しても、Route Handlerが特定のルートに結びつけられていないため、Router Cacheはすぐに無効化されません。Router Cacheはハードリフレッシュまたは自動無効化期間が経過するまで、以前のペイロードを提供し続けます。

## APIs

以下の表は、さまざまなNext.js APIがキャッシングにどのように影響するかの概要を示しています：

| API                                                                     | Router Cache               | Full Route Cache      | Data Cache            | React Cache |
| ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | Cache                      |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                    | Cache                      |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                      | Revalidate                 |                       |                       |             |
| [`fetch`](#fetch)                                                       |                            |                       | Cache                 | Cache       |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                       | Cache または Opt out  |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Revalidate            | Revalidate            |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Cache                 | Cache                 |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`revalidatePath`](#revalidatepath)                                     | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`const revalidate`](#segment-config-options)                           |                            | Revalidate または Opt out | Revalidate または Opt out |             |
| [`const dynamic`](#segment-config-options)                              |                            | Cache または Opt out  | Cache または Opt out  |             |
| [`cookies`](#cookies)                                                   | Revalidate (Server Action) | Opt out               |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Opt out               |                       |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Cache                 |                       |             |
| [`React.cache`](#react-cache-function)                                  |                            |                       |                       | Cache       |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                       | Cache                 |             |

### `<Link>`

デフォルトで、`<Link>` コンポーネントは、Full Route Cacheからルートを自動的にプレフェッチし、Router CacheにReact Server Component Payloadを追加します。

プレフェッチを無効にするには、`prefetch`プロップを`false`に設定します。しかし、これによりキャッシュが恒久的にスキップされることはなく、ユーザーが訪問したときにルートセグメントはまだクライアント側にキャッシュされます。

[`<Link>` コンポーネント](/docs/app/api-reference/components/link)の詳細を学びましょう。

### `router.prefetch`

`useRouter`フックの`prefetch`オプションを使用して手動でルートをプレフェッチできます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)APIリファレンスを参照してください。

### `router.refresh`

`useRouter`フックの`refresh`オプションを使用してルートを手動で更新できます。これによりRouter Cacheが完全にクリアされ、現在のルートに対してサーバーへの新しいリクエストが行われます。`refresh`はDataまたはFull Route Cacheに影響しません。

レンダリングされた結果はReactステートとブラウザステートを保持しながらクライアント側で調整されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)APIリファレンスを参照してください。

### `fetch`

`fetch`から返されるデータは、自動的にData Cacheにキャッシュされます。

`fetch`の応答をキャッシュしたくない場合は、以下のようにします：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)にて、その他のオプションを確認してください。

### `fetch options.cache`

個々の`fetch`をキャッシングするように選択するには、`cache`オプションを`force-cache`に設定します：

```jsx
// キャッシュを有効にします
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で詳細なオプションをご確認ください。

### `fetch options.next.revalidate`

`fetch`の`next.revalidate`オプションを使用して、個々の`fetch` リクエストの再検証期間（秒単位）を設定できます。これによりData Cacheが再検証され、結果としてFull Route Cacheも再検証されます。新鮮なデータが取得され、コンポーネントがサーバーで再レンダリングされます。

```jsx
// 最大で１時間ごとに再検証します
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.next.tags` と `revalidateTag`

Next.jsには、詳細なデータキャッシングおよび再検証のためのキャッシュタグシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用するとき、キャッシュエントリを1つ以上のタグでタグ付けするオプションがあります。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリをパージできます。

例えば、データをフェッチした際にタグを設定できます：

```jsx
// タグ付きでデータをキャッシュします
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

次に、特定のタグを使用して`revalidateTag`を呼び出してキャッシュエントリをパージします：

```jsx
// 特定のタグでエントリを再検証します
revalidateTag('a')
```

`revalidateTag`を使用する場所は2つあります。目的に応じて選択してください：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティのイベント（例: Webhook）に対応してデータを再検証します。Router Cacheが特定のルートに結びついていないため、Router Cacheをすぐには無効化しません。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション後（例: フォーム送信）にデータを再検証します。関連するルートのRouter Cacheを無効化します。

### `revalidatePath`

`revalidatePath`を使用すると、データを手動で再検証し、特定のパス以下のルートセグメントを再レンダリングすることができます。`revalidatePath`メソッドを呼び出すことでData Cacheが再検証され、これによってFull Route Cacheが無効化されます。

```jsx
revalidatePath('/')
```

`revalidatePath`を使用する場所は2つあります。目的に応じて選択してください：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティのイベント（例: Webhook）に対応してデータを再検証します。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション後（例: フォーム送信、ボタンをクリック）にデータを再検証します。

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)を参照してください。

> **`revalidatePath`** vs. **`router.refresh`**:
>
> `router.refresh`を呼び出すと、Router Cacheがクリアされ、Data CacheまたはFull Route Cacheを無効にすることなく、サーバー上でルートセグメントが再レンダリングされます。
>
> 違いは、`revalidatePath`がData CacheとFull Route Cacheをパージするのに対し、`router.refresh()`はData CacheとFull Route Cacheを変更しません。これはクライアントサイドのAPIです。

### ダイナミックAPI

クッキーやヘッダのようなダイナミックAPI、およびPagesの`searchParams`プロップは、実行時の受信リクエスト情報に依存します。これらを使用すると、ルートはFull Route Cacheから選択しないされ、ルートが動的にレンダリングされます。

#### `cookies`

Server Actionで`cookies.set`または`cookies.delete`を使用すると、クッキーを使用するルートの不整合を防ぐためにRouter Cacheを無効にする（例：認証の反映）ことができます。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照してください。

### Segment Config Options

Route Segment Configオプションを使用して、ルートセグメントのデフォルトを上書きするか、`fetch` APIを使用できない場合に設定します（例：データベースクライアントやサードパーティライブラリ）。

以下のRoute Segment Configオプションは、Full Route Cacheから選択しないにします：

- `const dynamic = 'force-dynamic'`

この設定オプションは、すべてのフェッチをData Cacheから選択しないにします（例：`no-store`）：

- `const fetchCache = 'default-no-store'`

[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)で詳細なオプションを参照してください。

[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)のドキュメントでより多くのオプションを確認してください。

### `generateStaticParams`

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）には、`generateStaticParams` で提供されるパスがビルド時にFull Route Cacheにキャッシュされます。リクエスト時には、ビルド時に知られていなかったパスも、初めて訪れたときにキャッシュされます。

すべてのパスをビルド時に静的にレンダリングするには、`generateStaticParams`に全パスのリストを提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時に一部のパスを静的にレンダリングし、その他はランタイムで初めて訪れたときにレンダリングするには、パスの部分リストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の 10 件の投稿をビルド時にレンダリングします
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

すべてのパスを静的にレンダリングするには、最初に訪れたときに空の配列（ビルド時にはパスがレンダリングされません）を返すか、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **知っておくと良いこと**: `generateStaticParams`からは必ず配列を返す必要があります。たとえそれが空であっても。そうしないと、ルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時にキャッシュを無効にするには、ルートセグメントに`export const dynamicParams = false` オプションを追加します。この設定オプションが使用されると、`generateStaticParams` で提供されたパスのみが提供され、他のルートは404または一致します（[catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）。

### React `cache` 関数

React `cache` 関数を使用すると、関数の戻り値をメモ化でき、同じ関数を複数回呼び出しても一度だけ実行されます。

`fetch` リクエストは自動的にメモ化されるため、React `cache` でラップする必要はありません。ただし、`fetch` APIが適していないスユースケースにデータリクエストを手動でメモ化する場合に`cache`を使用できます。例えば、データベースクライアント、CMSクライアント、GraphQLクライアントなどです。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```
</TabItem>
</Tabs>

