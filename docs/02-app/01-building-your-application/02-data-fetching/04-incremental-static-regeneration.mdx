---
title: インクリメンタル静的再生成 (ISR)
description: インクリメンタル静的再生成を使用して、実行時に静的ページを作成または更新する方法を学びます。
---

<details>
  <summary>Examples</summary>

- [Next.js Commerce](https://vercel.com/templates/next.js/nextjs-commerce)
- [On-Demand ISR](https://on-demand-isr.vercel.app)
- [Next.js Forms](https://github.com/vercel/next.js/tree/canary/examples/next-forms)

</details>

インクリメンタル静的再生成 (ISR) を使用すると、次のことが可能になります:

- サイト全体を再構築することなく静的コンテンツを更新する
- ほとんどのリクエストに対して事前にレンダリングされた静的ページを提供し、サーバー負荷を軽減する
- 適切な `cache-control` ヘッダーが自動的に追加されることを保証する
- 長時間の `next build` 時間をかけずに大量のコンテンツページを処理する

以下は最低限の例です:

<AppOnly>

```tsx filename="app/blog/[id]/page.tsx" switcher
interface Post {
  id: string
  title: string
  content: string
}

// リクエストが入ったときにNext.jsはキャッシュを無効にしますが、最大60秒に1回のみです。
export const revalidate = 60

// ビルド時に `generateStaticParams` からのみパラメータを事前レンダリングします。
// 生成されていないパスがリクエストされた場合、Next.jsはページをオンデマンドでサーバーレンダリングします。
export const dynamicParams = true // またはfalseに設定して、未知のパスで404を返す

export async function generateStaticParams() {
  const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  return posts.map((post) => ({
    id: String(post.id),
  }))
}

export default async function Page({ params }: { params: { id: string } }) {
  const post = await fetch(`https://api.vercel.app/blog/${params.id}`).then(
    (res) => res.json()
  )
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

```jsx filename="app/blog/[id]/page.jsx" switcher
// リクエストが入ったときにNext.jsはキャッシュを無効にしますが、最大60秒に1回のみです。
export const revalidate = 60;

// ビルド時に `generateStaticParams` からのみパラメータを事前レンダリングします。
// 生成されていないパスがリクエストされた場合、Next.jsはページをオンデマンドでサーバーレンダリングします。
export const dynamicParams = true // またはfalseに設定して、未知のパスで404を返す

export async function generateStaticParams() {
  const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) => res.json());
  return posts.map((post) => ({
    id: String(post.id),
  }));
}

export default async function Page({ params }) {
  const post = await fetch(`https://api.vercel.app/blog/${params.id}`).then((res) => res.json());
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  );
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/blog/[id].tsx" switcher
import { GetStaticPaths, GetStaticProps } from 'next'

interface Post {
  id: string
  title: string
  content: string
}

interface Props {
  post: Post
}

export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  const paths = posts.map((post: Post) => ({
    params: { id: String(post.id) },
  }))

  // ビルド時にこれらのパスのみを事前レンダリングします。
  // { fallback: 'blocking' }は、パスが存在しない場合にページをオンデマンドでサーバーレンダリングします。
  return { paths, fallback: false }
}

export const getStaticProps: GetStaticProps<Props> = async ({
  params,
}: {
  params: { id: string }
}) => {
  let post = await fetch(`https://api.vercel.app/blog/${params.id}`).then(
    (res) => res.json()
  )

  return {
    props: { post },
    // リクエストが入ったときにNext.jsはキャッシュを無効にしますが、最大60秒に1回のみです。
    revalidate: 60,
  }
}

export default function Page({ post }: Props) {
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

```jsx filename="pages/blog/[id].jsx" switcher
export async function getStaticPaths() {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  const paths = posts.map((post) => ({
    params: { id: post.id },
  }))

  // ビルド時にこれらのパスのみを事前レンダリングします。
  // { fallback: false } は他のルートが404であるべきことを意味します。
  return { paths, fallback: false }
}

export async function getStaticProps({ params }) {
  const post = await fetch(`https://api.vercel.app/blog/${params.id}`).then(
    (res) => res.json()
  )

  return {
    props: { post },
    // リクエストが入ったときにNext.jsはキャッシュを無効にしますが、最大60秒に1回のみです。
    revalidate: 60,
  }
}

export default function Page({ post }) {
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

</PagesOnly>

この例がどのように動作するかは次のとおりです;

1. `next build` の間に、すべての既知のブログ投稿が生成されます（この例では25件あります）
2. これらのページに対して行われたすべてのリクエスト（例：`/blog/1`）はキャッシュされ、即座に応答されます
3. 60秒が経過した後も、次のリクエストではキャッシュされた（古い）ページが表示されます
4. キャッシュが無効になり、ページの新しいバージョンがバックグラウンドで生成され始めます
5. 正常に生成されると、Next.jsは更新されたページを表示しキャッシュします
6. `/blog/26` がリクエストされた場合、Next.jsはこのページをオンデマンドで生成してキャッシュします

## Reference

<AppOnly>

### ルートセグメント設定

- [`revalidate`](/docs/app/api-reference/file-conventions/route-segment-config#revalidate)
- [`dynamicParams`](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)

### 関数

- [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)
- [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)

</AppOnly>

<PagesOnly>

### 関数

- [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props)
- [`res.revalidate`](/docs/pages/building-your-application/routing/api-routes#response-helpers)

</PagesOnly>

## Examples

<AppOnly>

### 時間ベースの再検証

これは、`/blog` にブログ投稿のリストをフェッチして表示します。1時間後、このページに対する次回の訪問時にキャッシュが無効になります。その後、バックグラウンドで最新のブログ投稿を使用してページの新しいバージョンが生成されます。

```jsx
export const revalidate = 3600 // 毎時間キャッシュを無効化する

export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <main>
      <h1>Blog Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  )
}
```

再検証時間を高く設定することをお勧めします。例えば、1秒ではなく1時間です。より高精度が必要な場合は、オンデマンド再検証を検討してください。リアルタイムデータが必要な場合は、[動的レンダリング](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)への切り替えを検討してください。

### `revalidatePath`によるオンデマンド再検証

より精密な再検証手法として、`revalidatePath`関数を使用してページをオンデマンドで無効化します。

例えば、新しい投稿を追加した後にこのサーバーアクションが呼び出されます。サーバーコンポーネントでデータをフェッチしているか、データベースに接続しているかに関係なく、これはルート全体のキャッシュをクリアし、サーバーコンポーネントが新しいデータをフェッチできるようにします。

```jsx
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  // キャッシュ内の /posts ルートを無効にする
  revalidatePath('/posts')
}
```

[デモを見てください](https://on-demand-isr.vercel.app) と [ソースコードを調べます](https://github.com/vercel/on-demand-isr).

### `revalidateTag`によるオンデマンド再検証

ほとんどのユースケースでは、完全なパスの再検証を優先します。より詳細な制御が必要な場合は、`revalidateTag`関数を使用できます。たとえば、個別の`fetch`呼び出しにタグを付けることができます。

```jsx
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog', {
    next: { tags: ['posts'] },
  })
  const posts = await data.json()
  // ...
}
```

ORMを使用している場合やデータベースに接続している場合は、`unstable_cache`を使用できます。

```jsx
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getCachedPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const posts = getCachedPosts()
  // ...
}
```

その後、[サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)や[ルートハンドラー](/docs/app/building-your-application/routing/route-handlers)で`revalidateTag`を使用できます：

```jsx
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  // キャッシュ内の 'posts' タグ付けされたすべてのデータを無効にする
  revalidateTag('posts')
}
```

</AppOnly>

<PagesOnly>

### オンデマンド再検証の`res.revalidate()`


より精密な再検証方法として、`res.revalidate`を使用してAPIルーターからオンデマンドで新しいページを生成します。

例えば、このAPIルートは、与えられたブログ投稿を再検証するために`/api/revalidate?secret=<token>`で呼び出すことができます。Next.jsアプリだけが知っている秘密のトークンを作成します。この秘密は、再検証APIルートへの不正アクセスを防ぐために使用されます。

```ts filename="pages/api/revalidate.ts"
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // 正当なリクエストであることを確認するための秘密をチェックします
  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' })
  }

  try {
    // これは実際のパスであるべきで、書き換えられたパスではない
    // 例えば "/posts/[id]" の場合は "/posts/1" であるべき
    await res.revalidate('/posts/1')
    return res.json({ revalidated: true })
  } catch (err) {
    // エラーが発生した場合、Next.jsは最後に正常に生成されたページを
    // 引き続き表示します
    return res.status(500).send('Error revalidating')
  }
}
```

オンデマンド再検証を使用している場合、`getStaticProps`内部で`revalidate`時間を指定する必要はありません。Next.jsはデフォルト値の`false`（再検証しない）を使用し、`res.revalidate()`が呼び出された時にのみページをオンデマンドで再検証します。

</PagesOnly>

### 捕捉されていない例外の処理

<AppOnly>

データの再検証を試みる際にエラーが発生した場合、最後に正常に生成されたデータが引き続きキャッシュから提供されます。次のリクエストでは、Next.jsはデータの再検証を試みます。[エラー処理について詳しく学ぶ](/docs/app/building-your-application/routing/error-handling).

</AppOnly>

<PagesOnly>

バックグラウンド再生成を処理する際に`getStaticProps`内でエラーが発生する場合、または手動でエラーをスローする場合、最後に正常に生成されたページが引き続き表示されます。次のリクエスト時に、Next.jsは`getStaticProps`を再度呼び出そうとします。

```jsx filename="pages/blog/[id].jsx" switcher
export async function getStaticProps({ params }) {
  // このリクエストがキャッチされないエラーをスローした場合、Next.jsはキャッシュを無効にせず、
  // 現在表示されているページを無効にせずに、次のリクエストでgetStaticPropsを再試行します。
  const res = await fetch(`https://api.vercel.app/blog/${params.id}`)
  const posts = await res.json()

  if (!res.ok) {
    // サーバーエラーが発生した場合、キャッシュが次回の成功するリクエストまで
    // 更新されないようにエラーをスローしたいかもしれません。
    throw new Error(`Failed to fetch posts, received status ${res.status}`)
  }

  return {
    props: { post },
    // リクエストが入ったときにNext.jsはキャッシュを無効にしますが、
    // 最大60秒に1回のみです。
    revalidate: 60,
  }
}
```

</PagesOnly>

### キャッシュ場所のカスタマイズ

キャッシュとページの再検証（インクリメンタル静的再生成を使用）には同じ共有キャッシュを使用します。[Vercelにデプロイする際](https://vercel.com/docs/incremental-static-regeneration?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)、ISRキャッシュは自動的に耐久性のあるストレージに保存されます。

セルフホスティングする場合、ISRキャッシュはNext.jsサーバーのファイルシステム（ディスク）にストアされます。セルフホスティングにpagesルーターとappルーターの両方を使用する場合、この動作は自動的に行われます。

キャッシュされたページとデータを耐久性のあるストレージに保存したり、Next.jsアプリケーションの複数のコンテナまたはインスタンス間でキャッシュを共有したりする場合は、Next.jsのキャッシュ位置を設定できます。[詳細を学ぶ](/docs/app/building-your-application/deploying#caching-and-isr).

## トラブルシューティング

### ローカル開発でのキャッシュデータのデバッグ

`fetch` APIを使用している場合、追加のログを追加してキャッシュされたリクエストとキャッシュされていないリクエストを把握できます。[`logging`オプションについて詳しく学ぶ](/docs/app/api-reference/next-config-js/logging).

```jsx filename="next.config.js"
module.exports = {
  logging: {
    fetches: {
      fullUrl: true,
    },
  },
}
```

### 正しいプロダクション動作の確認

プロダクションでページが正しくキャッシュされ再検証されているか確認するために、`next build`を実行し、その後に`next start`を実行してプロダクションのNext.jsサーバーをローカルでテストできます。

これにより、本番環境でのISRの動作をテストすることが可能になります。さらにデバッグするために、次の環境変数を`.env`ファイルに追加します：

```bash filename=".env"
NEXT_PRIVATE_DEBUG_CACHE=1
```

これにより、Next.jsサーバーはISRキャッシュのヒットとミスをコンソールログに出力します。`next build`中に生成されたページや、アクセスに応じてどのようにページが更新されるかを出力を確認できます。

## 注意事項

<AppOnly>

- インクリメンタル静的再生成はNode.jsランタイム（デフォルト）を使用している場合のみサポートされています
- インクリメンタル静的再生成は、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)を作成する際にはサポートされていません
- 静的にレンダリングされたルートに複数の`fetch`リクエストが存在し、各リクエストが異なる`revalidate`頻度を持つ場合、最も低い時間がインクリメンタル静的再生成で使用されます。ただし、これらの再検証頻度は[データキャッシュ](/docs/app/building-your-application/caching#data-cache)によって引き続き尊重されます
- ルートで使用されている`fetch`リクエストのいずれかに`revalidate`時間が`0`である場合、または明示的に`no-store`が指定されている場合、そのルートは[動的にレンダリング](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)されます
- オンデマンドISRリクエストに対してミドルウェアは実行されず、ミドルウェア内のパスの書き換えやロジックは適用されません。正確なパスを再検証していることを確認してください。たとえば、書き換えられた`/post-1`ではなく`/post/1`などです。

</AppOnly>

<PagesOnly>

- インクリメンタル静的再生成はNode.jsランタイム（デフォルト）を使用している場合のみサポートされています
- インクリメンタル静的再生成は、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)を作成する際にはサポートされていません
- オンデマンドISRリクエストに対してミドルウェアは実行されず、ミドルウェア内のパスの書き換えやロジックは適用されません。正確なパスを再検証していることを確認してください。たとえば、書き換えられた`/post-1`ではなく`/post/1`などです。

</PagesOnly>

## バージョン履歴

| Version   | Changes                                                                             |
| --------- | ----------------------------------------------------------------------------------- |
| `v14.1.0` | Custom `cacheHandler` is stable                                                     |
| `v13.0.0` | App Router is introduced                                                            |
| `v12.2.0` | Pages Router: On-Demand ISR is stable                                               |
| `v12.0.0` | Pages Router: [Bot-aware ISR fallback](/blog/next-12#bot-aware-isr-fallback) added  |
| `v9.5.0`  | Pages Router: [Stable ISR introduced](/blog/next-9-5)                               |