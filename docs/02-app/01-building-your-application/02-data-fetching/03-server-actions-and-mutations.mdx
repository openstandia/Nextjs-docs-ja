---
title: 'Server Actionsとミューテーション'
nav_title: 'Server Actionsとミューテーション'
description: 'Next.jsでフォームの送信とデータのミューテーションを行う方法を学びましょう。'
related:
  description: 'Next.jsでServer Actionsを設定する方法を学びましょう。'
  links:
    - app/api-reference/next-config-js/serverActions
---

[Server Actions](https://react.dev/reference/rsc/server-actions)は、サーバで実行される**非同期関数**です。Next.jsアプリケーションでフォーム送信やデータのミューテーションを処理するために、Server ComponentやClient Componentで呼び出すことができます。

> **🎥 視聴:** Server Actionsでのミューテーションについてもっと学ぶ → [YouTube (10分)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg)。

## 規約

Server ActionはReactの[`"use server"`](https://react.dev/reference/react/use-server)ディレクティブで定義できます。このディレクティブを`async`関数の先頭に配置してその関数をServer Actionとしてマークするか、別のファイルの先頭に配置してそのファイルのすべてのエクスポートをServer Actionとしてマークすることができます。

### Server Components

Server Componentsは、インライン関数レベルまたはモジュールレベルで`"use server"`ディレクティブを使用できます。Server Actionをインラインにするには、関数本体の先頭に`"use server"`を追加します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default function Page() {
  // Server Action
  async function create() {
    'use server'
    // データをミューテート
  }

  return '...'
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default function Page() {
  // Server Action
  async function create() {
    'use server'
    // データをミューテート
  }

  return '...'
}
```
</TabItem>
</Tabs>


### Client Components

Client ComponentでServer Actionを呼び出すには、新しいファイルを作成し、その先頭に`"use server"`ディレクティブを追加します。ファイル内でエクスポートされたすべての関数はClient ComponentとServer Componentの両方で再利用できるServer Actionとしてマークされます。


<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

export async function create() {}
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

export async function create() {}
```
</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/button.tsx" switcher
'use client'

import { create } from '@/app/actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/button.js" switcher
'use client'

import { create } from '@/app/actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```
</TabItem>
</Tabs>


### アクションをpropsとして渡す

Server ActionをClient Componentにpropとして渡すこともできます。

```jsx
<ClientComponent updateItemAction={updateItem} />
```

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
'use client'

export default function ClientComponent({
  updateItemAction,
}: {
  updateItemAction: (formData: FormData) => void
}) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
'use client'

export default function ClientComponent({ updateItemAction }) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```
</TabItem>
</Tabs>


通常、Next.js TypeScriptプラグインは`client-component.tsx`内の`updateItemAction`をフラグ付けします。これは、通常クライアント-サーバー間の境界をシリアライズできない関数だからです。しかし、`action`という名前や`Action`で終わるpropはServer Actionsを受け取ると仮定されます。TypeScriptプラグインは実際にServer Actionか普通の関数を受け取っているかを知らないので、これはあくまでヒューリスティックです。しかし、ランタイムでの型チェックは誤ってClient Componentに関数を渡さないように保証します。

## 挙動

- Server actionsは[`<form>`要素](#forms)内の`action`属性を使用して呼び出すことができます。
  - Server Componentsはデフォルトでプログレッシブエンハンスメントをサポートし、JavaScriptがまだロードされていないか無効でもフォームが送信されます。
  - Client Componentsでは、JavaScriptがまだロードされていない場合、Server Actionsを呼び出すフォームは送信をキューに入れ、クライアントのハイドレーションを優先します。
  - ハイドレーション後、ブラウザはフォーム送信時にリフレッシュしません。
- Server Actionsは`<form>`に限定されず、イベントハンドラ、`useEffect`、サードパーティライブラリ、`<button>`など他のフォーム要素からも呼び出すことができます。
- Server ActionsはNext.jsの[キャッシュおよび再検証](/docs/app/building-your-application/caching)アーキテクチャと統合されます。アクションが呼び出されると、Next.jsは更新されたUIと新しいデータの両方を一度のサーバー往復で返すことができます。
- アクションは`POST`メソッドを使用し、このHTTPメソッドだけがアクションを呼び出すことができます。
- Server Actionsの引数と戻り値はReactによってシリアライズ可能でなければなりません。シリアライズ可能な引数と値のリストについてはReactのドキュメントを参照してください[シリアライズ可能な引数と値](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)。
- Server Actionsは関数です。つまり、アプリケーション内のどこでも再利用できます。
- Server Actionsは、その使用されるページまたはレイアウトから[ランタイム](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を継承します。
- Server Actionsは、その使用されるページまたはレイアウトから[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)を継承し、`maxDuration`のようなフィールドが含まれます。

## 例

### Forms

ReactはHTMLの[`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form)要素を拡張することで、`action` propでServer Actionsを呼び出せるようにしています。

フォーム内で呼び出されたとき、アクションは自動的に[`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData)オブジェクトを受け取ります。Reactの`useState`を使用してフィールドを管理する必要はなく、代わりにネイティブの[`FormData`メソッド](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods)を使用してデータを抽出できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/invoices/page.tsx" switcher
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // データをミューテート
    // キャッシュを再検証
  }

  return <form action={createInvoice}>...</form>
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/invoices/page.js" switcher
export default function Page() {
  async function createInvoice(formData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // データをミューテート
    // キャッシュを再検証
  }

  return <form action={createInvoice}>...</form>
}
```
</TabItem>
</Tabs>


> **Good to know:**
>
> - 例: [ロード中とエラーステートを持つフォーム](https://github.com/vercel/next.js/tree/canary/examples/next-forms)
> - 多くのフィールドを持つフォームを扱う場合は、JavaScriptの[`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用して、 [`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries)メソッドを検討することがあります。例えば、`const rawFormData = Object.fromEntries(formData)`です。ただし、`formData`には追加の`$ACTION_`プロパティが含まれることに注意してください。
> - 詳細は[Reactの`<form>`ドキュメント](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-action)を参照してください。

### 追加の引数を渡す

JavaScriptの`bind`メソッドを使用して、Server Actionに追加の引数を渡せます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Update User Name</button>
    </form>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Update User Name</button>
    </form>
  )
}
```
</TabItem>
</Tabs>


Server Actionは、フォームデータに加えて`userId`引数を受け取ります。

```js title="app/actions.js"
'use server'

export async function updateUser(userId, formData) {}
```

> **Good to know**:
>
> - 代替案としては、フォーム内の隠し入力フィールドとして引数を渡す方法もあります（例: `<input type="hidden" name="userId" value={userId} />`）。しかし、この値はレンダリングされたHTMLの一部として保存され、エンコードされません。
> - `.bind`は、ServerおよびClient Componentsの両方で動作します。また、プログレッシブエンハンスメントをサポートします。

### ネストされたフォーム要素

`<form>`内にネストされた`<button>`、`<input type="submit">`、`<input type="image">`などの要素でServer Actionを呼び出すことができます。これらの要素は`formAction` propまたは[イベントハンドラ](#event-handlers)を受け入れます。

これは、フォーム内で複数のサーバーアクションを呼び出したい場合に便利です。たとえば、投稿の下書きを保存する特定の`<button>`要素を作成し、公開することに加えることができます。詳細は[Reactの`<form>`ドキュメント](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types)を参照してください。

### プログラムによるフォームの送信

[`requestSubmit()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit)メソッドを使用して、プログラムによってフォームの送信をトリガーできます。たとえば、ユーザーが`⌘` + `Enter`キーボードショートカットを使用してフォームを送信したときに、`onKeyDown`イベントをリッスンできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/entry.tsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/entry.js" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```
</TabItem>
</Tabs>


これにより、最も近い`<form>`祖先の送信がトリガーされ、Server Actionが呼び出されます。

### サーバー側フォーム検証

ブラウザ側の基本的な検証には、`required`や`type="email"`などのHTML属性を使用することができます。

より高度なサーバー側の検証には、フォームのフィールドをミューテートする前に[zod](https://zod.dev/)のようなライブラリを使用してフォームフィールドを検証できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: '無効なメールアドレスです',
  }),
})

export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // フォームデータが無効な場合には早期に終了する
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // データをミューテート
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions.js" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: '無効なメールアドレスです',
  }),
})

export default async function createsUser(formData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // フォームデータが無効な場合には早期に終了する
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // データをミューテート
}
```
</TabItem>
</Tabs>


サーバー上でフィールドが検証されたら、アクションでシリアライズ可能なオブジェクトを返し、Reactの`useFormState`フックを使用してユーザーにメッセージを表示できます。

- アクションを`useFormState`に渡すことにより、アクションの関数シグネチャが変更され、新しい`prevState`または`initialState`パラメータを最初の引数として受け取るようになります。
- `useFormState`はReactのフックであるため、Client Component内で使用する必要があります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState: any, formData: FormData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '有効なメールを入力してください' }
  }

  redirect('/dashboard')
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState, formData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '有効なメールを入力してください' }
  }

  redirect('/dashboard')
}
```
</TabItem>
</Tabs>


次に、`useFormState`フックにアクションを渡し、戻された`state`を使用してエラーメッセージを表示できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup.tsx" highlight={11,18-20} switcher
'use client'

import { useFormState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction] = useFormState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button>Sign up</button>
    </form>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup.js" highlight={11,18-20} switcher
'use client'

import { useFormState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction] = useFormState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button>Sign up</button>
    </form>
  )
}
```
</TabItem>
</Tabs>


> **Good to know:**
>
> - これらの例では、Reactの`useFormState`フックを使用しています。Next.js App Routerにバンドルされています。React 19を使用している場合は、代わりに`useActionState`を使用してください。詳細は[React docs](https://react.dev/reference/react/useActionState)を参照してください。

### 処理中のステート

> - データをミューテーションする前に、ユーザーがアクションを実行することを許可されていることを確認する必要があります。[認証と認可](#authentication-and-authorization)を参照してください。

[`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)フックは、アクションが実行されている間にローディングインジケーターを表示するために使用できる`pending`ブール値を公開します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/submit-button.tsx" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      Sign Up
    </button>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/submit-button.js" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      Sign Up
    </button>
  )
}
```
</TabItem>
</Tabs>


> **Good to know:**
>
> - React 19では、`useFormStatus`は返されるオブジェクトにデータ、メソッド、アクションなどの追加のキーが含まれています。React 19を使用していない場合、利用可能なキーは`pending`のみです。
> - React 19では、`useActionState`も返されたステートに`pending`のキーが含まれています。

### 楽観的なアップデート

Server Actionが実行を終了するのを待つのではなく、UIを楽観的に更新するためにReactの[`useOptimistic`](https://react.dev/reference/react/useOptimistic)フックを使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

type Message = {
  message: string
}

export function Thread({ messages }: { messages: Message[] }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic<
    Message[],
    string
  >(messages, (state, newMessage) => [...state, { message: newMessage }])

  const formAction = async (formData) => {
    const message = formData.get('message') as string
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m, i) => (
        <div key={i}>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">Send</button>
      </form>
    </div>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )

  const formAction = async (formData) => {
    const message = formData.get('message')
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">Send</button>
      </form>
    </div>
  )
}
```
</TabItem>
</Tabs>


### イベントハンドラ

Server Actionsは通常`<form>`要素内で使用されますが、`onClick`のようなイベントハンドラでも呼び出すことができます。例えば、Likeカウントを増やすには次のようにします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```
</TabItem>
</Tabs>


フォーム要素にイベントハンドラを追加することもできます。例えば、`onChange`でフォームフィールドを保存するには次のようにします。

```tsx title="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">Publish</button>
    </form>
  )
}
```

このような場合、すばやく連続して複数のイベントが発生するかもしれないので、余分なServer Actionの呼び出しを避けるために**デバウンス**を推奨します。

### `useEffect`

Reactの[`useEffect`](https://react.dev/reference/react/useEffect)フックを使って、コンポーネントがマウントされたときや依存関係が変わったときにServer Actionを呼び出すことができます。これは、グローバルイベントに依存する変化や自動的にトリガーされる必要のある変化に役立ちます。例えば、アプリのショートカットのための`onKeyDown`、無限スクロール用のインターセクションオブザーバーフック、またはビュー数を更新するためにコンポーネントがマウントされたときなどです。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>Total Views: {views}</p>
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>Total Views: {views}</p>
}
```
</TabItem>
</Tabs>


`useEffect`の[振る舞いと注意点](https://react.dev/reference/react/useEffect#caveats)を考慮することを忘れないでください。

### エラーハンドリング

エラーがスローされると、クライアント上で最も近い[`error.js`](/docs/app/building-your-application/routing/error-handling)または`<Suspense>` boundaryがキャッチします。UIで処理されるエラーを返すために`try/catch`を使用することをお勧めします。

例えば、新しいアイテムの作成でエラーを処理し、メッセージを返すようにServer Actionを実装することができます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

export async function createTodo(prevState: any, formData: FormData) {
  try {
    // データをミューテート
  } catch (e) {
    throw new Error('タスクの作成に失敗しました')
  }
}
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

export async function createTodo(prevState, formData) {
  try {
    //  データをミューテート
  } catch (e) {
    throw new Error('タスクの作成に失敗しました')
  }
}
```
</TabItem>
</Tabs>


> **Good to know:**
>
> - エラーをスローするだけでなく、`useFormState`で処理されるオブジェクトを返すこともできます。[サーバー側の検証とエラーハンドリング](#server-side-form-validation)を参照してください。

### データの再検証

Next.js Cache内のServer Actionsを使ってデータを次のように再検証することができます。次のAPIを使用します:[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```
</TabItem>
</Tabs>


また、`revalidateTag`を使用して特定のデータフェッチをキャッシュタグで無効にすることもできます。[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```
</TabItem>
</Tabs>


### リダイレクト

Server Actionの完了後にユーザーを別のルートにリダイレクトしたい場合は、[`redirect`](/docs/app/api-reference/functions/redirect) APIを使うことができます。`redirect`は`try/catch`ブロックの外で呼び出す必要があります。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // キャッシュされた投稿を更新
  redirect(`/post/${id}`) // 新しい投稿ページに移動
}
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // キャッシュされた投稿を更新
  redirect(`/post/${id}`) // 新しい投稿ページに移動
}
```
</TabItem>
</Tabs>


### Cookies

Server Action内で[`cookies`](/docs/app/api-reference/functions/cookies) APIを使用して、cookieを`取得`、`設定`、および`削除`することができます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  const cookieStore = await cookies()

  // クッキーを取得
  cookieStore.get('name')?.value

  // クッキーを設定
  cookieStore.set('name', 'Delba')

  // クッキーを削除
  cookieStore.delete('name')
}
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // クッキーを取得
  const cookieStore = await cookies()

  // クッキーを取得
  cookieStore.get('name')?.value

  // クッキーを設定
  cookieStore.set('name', 'Delba')

  // クッキーを削除
  cookieStore.delete('name')
}
```
</TabItem>
</Tabs>


Server Actionsからクッキーを削除するための[追加の例](/docs/app/api-reference/functions/cookies#deleting-cookies)を参照してください。

## セキュリティ

デフォルトでは、Server Actionが作成およびエクスポートされると、それは公開HTTPエンドポイントを作成し、同じセキュリティの仮定と認可チェックと共に扱われるべきです。つまり、Server Actionやユーティリティ関数がコード内の他の場所でインポートされていない場合でも、それは公開にアクセス可能です。

セキュリティを向上させるために、Next.jsには以下の組み込み機能があります。

- **デッドコード削除:** 未使用のServer ActionsのIDはクライアントサイドのJavaScriptバンドルに公開されず、バンドルサイズを削減しパフォーマンスを向上させます。
- **安全なアクションID:** Next.jsは、クライアントがServer Actionを参照して呼び出すのを許可するための推測できない非決定論的IDを作成します。これらのIDは、セキュリティを強化するために定期的に再計算されます。

```jsx
// app/actions.js
'use server'

// このアクションはアプリケーションで使用されているため、Next.js
// はクライアントがServer Actionを参照して呼び出すことができるように
// 安全なIDを作成します。
export async function updateUserAction(formData) {}

// このアクションはアプリケーションで使用されていないため、Next.jsは
// 次の`next build`時にこのコードを自動的に削除し、
// 公開エンドポイントを作成しません。
export async function deleteUserAction(formData) {}
```

### 認証と認可

ユーザーがアクションを実行することが許可されていることを確認する必要があります。例えば：

```tsx title="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('このアクションを実行するにはサインインが必要です')
  }

  // ...
}
```

### クロージャと暗号化

コンポーネント内にServer Actionを定義すると[クロージャ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)が作成され、アクションは外部関数スコープへのアクセスを持ちます。例えば、`publish`アクションは`publishVersion`変数にアクセスできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('公開を押してからバージョンが変わりました');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>Publish</button>
    </form>
  );
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('公開を押してからバージョンが変わりました');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>Publish</button>
    </form>
  );
}
```
</TabItem>
</Tabs>


クロージャは、アクションが呼び出されるときに使用するためにデータ（例：`publishVersion`）のスナップショットをレンダリングの時点で取得する必要がある場合に便利です。

ただし、これを実現するために、取得された変数はアクションが呼び出されたときにクライアントに送信され、サーバーに戻ります。顧客に公開されるのを防ぐために、Next.jsはクローズオーバーされた変数を自動的に暗号化します。新しいプライベートキーは毎回Next.jsアプリケーションがビルドされるたびに生成されます。これは、アクションは特定のビルドにのみ呼び出すことができることを意味します。

> **Good to know:** クライアントに公開されるセンシティブな値を防ぐために、暗号化のみに頼ることはお勧めしません。代わりに、[React taint APIs](/docs/app/building-your-application/data-fetching/fetching#preventing-sensitive-data-from-being-exposed-to-the-client)を使用してプロアクティブに特定のデータがクライアントに送信されないようにすることをお勧めします。

### 暗号化キーの上書き（高度な）

複数のサーバーにわたってNext.jsアプリケーションをセルフホスティングする場合、各サーバーインスタンスが異なる暗号化キーで終了する可能性があり、一貫性の問題が発生します。

これを緩和するために、`process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY`環境変数を使用して暗号化キーを上書きすることができます。この変数を指定することで、暗号化キーがビルド間で持続され、すべてのサーバーインスタンスが同じキーを使用することを保証します。

これは、複数のデプロイメント間で一貫した暗号化の動作が重要である高度なユースケースです。キーのローテーションや署名などの標準的なセキュリティプラクティスを考慮する必要があります。

> **Good to know:** VercelにデプロイされたNext.jsアプリケーションは自動的にこれを処理します。

### 許可されたオリジン（高度な）

Server Actionsは`<form>`要素で呼び出されることができるため、[CSRF攻撃](https://developer.mozilla.org/en-US/docs/Glossary/CSRF)に対してオープンされています。

内部的には、Server Actionsは`POST`メソッドを使用し、このHTTPメソッドだけがそれらを呼び出すことができます。これは、特に[SameSite cookie](https://web.dev/articles/samesite-cookies-explained)がデフォルトである現代のブラウザでほとんどのCSRFの脆弱性を防ぎます。

追加の保護として、Next.jsのServer Actionsも[Originヘッダ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin)を[Hostヘッダ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host)（または`X-Forwarded-Host`）と比較します。これらが一致しない場合、要求は中止されます。言い換えれば、Server Actionsは、ページがホストされているのと同じホストでのみ呼び出されることができます。

逆プロキシや多層バックエンドアーキテクチャ（サーバーAPIがプロダクションドメインと異なる場所）を使用する大規模なアプリケーションの場合、[`serverActions.allowedOrigins`](/docs/app/api-reference/next-config-js/serverActions)オプションを使用して安全なオリジンのリストを指定することをお勧めします。このオプションは文字列の配列を受け入れます。

```js title="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

[Security and Server Actions](https://nextjs.org/blog/security-nextjs-server-components-actions)についてもっと学びましょう。

## 追加のリソース

詳細については、以下のReactドキュメントを参照してください。

- [Server Actions](https://react.dev/reference/rsc/server-actions)
- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useActionState`](https://react.dev/reference/react/useActionState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)