---
title: 'Server Actions とミューテーション'
nav_title: 'Server Actions とミューテーション'
description: 'Next.js でフォームの送信とデータのミューテーションを処理する方法を学びます。'
related:
  description: 'Next.jsでServer Actionsを構成する方法を学びます'
  links:
    - app/api-reference/next-config-js/serverActions
---

[Server Actions](https://react.dev/reference/rsc/server-actions) は、サーバーで実行される**非同期関数**です。これらは、Server ComponentとClient Componentで呼び出して、Next.jsアプリケーションでフォームの送信やデータのミューテーションを処理できます。

> **🎥 視聴:** Server Actionsを使用したミューテーションの詳細を学ぶ→ [YouTube (10 minutes)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg).

## 規約 {#convention}

Server ActionはReactの[`"use server"`](https://react.dev/reference/react/use-server)ディレクティブで定義できます。 `async`関数の先頭にこのディレクティブを配置して関数をServer Actionとしてマークしたり、別のファイルの先頭に配置してそのファイルのすべてのエクスポートをServer Actionsとしてマークできます。

### Server Components {#server-components}

Server Componentsはインライン関数レベルまたはモジュールレベルの`"use server"`ディレクティブを利用できます。Server Actionをインライン化するには、関数の冒頭に`"use server"`を追加します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default function Page() {
  // Server Action
  async function create() {
    'use server'
    // データをミューテートする
  }

  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default function Page() {
  // Server Action
  async function create() {
    'use server'
    // データをミューテートする
  }

  return '...'
}
```

</TabItem>
</Tabs>

### Client Components {#client-components}

Client Component内でServer Actionを呼び出すには、新しいファイルを作成し、その上部に`"use server"`ディレクティブを追加します。そのファイル内のすべてのエクスポートされた関数は、Client ComponentとServer Componentの両方で再利用できるServer Actionsとしてマークされます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

export async function create() {}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

export async function create() {}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/button.tsx" switcher
'use client'

import { create } from '@/app/actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/button.js" switcher
'use client'

import { create } from '@/app/actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```

</TabItem>
</Tabs>

### Server Action を prop として渡す {#passing-actions-as-props}

Server ActionはClient Componentにpropとして渡すこともできます：

```jsx
<ClientComponent updateItemAction={updateItem} />
```

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
'use client'

export default function ClientComponent({
  updateItemAction,
}: {
  updateItemAction: (formData: FormData) => void
}) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
'use client'

export default function ClientComponent({ updateItemAction }) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

</TabItem>
</Tabs>

通常、Next.jsのTypeScriptプラグインは、`client-component.tsx`の`updateItemAction`をシリアル化できないために警告を出します。しかし、`action`または`Action`で終わる名前のpropsは、Server Actionを受け取ると仮定されます。TypeScriptプラグインは実際にはServer Actionを受け取るか普通の関数を受け取るかを判断できないため、これはあくまでヒューリスティックに基づきます。ランタイムの型チェックにより、誤ってClient Componentに関数を渡さないようにすることが保証されます。

## 挙動 {#behavior}

- Server actionは[`<form>` エレメント](#forms)内の `action` 属性を使用して呼び出すことができます：
  - Server ComponentsはBy defaultでプログレッシブ エンハンスメントをサポートしており、JavaScriptが読み込まれて いなくても、または無効になっていても、フォームは送信されます。
  - Client Componentsでは、JavaScriptがまだ読み込まれていない場合、Server Actionを呼び出すフォームは送信をキューに入れ、client hydrationを優先します。
  - hydration後、ブラウザはフォームの送信時に更新しません；
- Server Actionsは `<form>` に限定されず、イベントハンドラー、 `useEffect` 、サードパーティライブラリ、および `<button>` などの他のフォーム要素からも呼び出すことができます；
- Server ActionsはNext.jsの[キャッシングと再検証](/docs/app/building-your-application/caching)アーキテクチャと統合されています。アクションが呼び出されると、Next.jsは更新されたUIと新しいデータの両方を1回のサーバーラウンドトリップで返すことができます；
- 内部では、アクションは`POST`メソッドを使用しており、このHTTPメソッドのみがアクションを呼び出すことができます；
- Server Actionsの引数と戻り値は、Reactによってシリアル化可能でなければなりません。シリアル化可能な引数と値のリストについては、Reactのドキュメントを参照してください：[serializable arguments and values](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)；
- Server Actionsは関数です；つまり、アプリケーションのどこでも再利用できます；
- Server Actionsは使用されるページまたはレイアウトの[ランタイム](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を継承します；
- Server Actionsは、使用されるページまたはレイアウトから[ルートセグメント構成](/docs/app/api-reference/file-conventions/route-segment-config)を継承し、 `maxDuration` などのフィールドを含みます。

## 例 {#examples}

### フォーム {#forms}

ReactはHTMLの[`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form)要素を拡張して、 `action` propでServer Actionsを呼び出せるようにしています。

フォームで呼び出された場合、アクションは自動的に[`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData)オブジェクトを受け取ります。React `useState`を使用してフィールドを管理する必要はなく、代わりにネイティブの[`FormData`メソッド](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods)を使用してデータを抽出できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/invoices/page.tsx" switcher
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // データをミューテートする
    // キャッシュを再検証する
  }

  return <form action={createInvoice}>...</form>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/invoices/page.js" switcher
export default function Page() {
  async function createInvoice(formData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // データをミューテートする
    // キャッシュを再検証する
  }

  return <form action={createInvoice}>...</form>
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - 例: [Form with Loading & Error States](https://github.com/vercel/next.js/tree/canary/examples/next-forms)
> - 多くのフィールドを持つフォームを使用する場合は、JavaScriptの[`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)メソッドと共に[`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries)メソッドを検討することをお勧めします。たとえば `const rawFormData = Object.fromEntries(formData)` です。一つ注意点は、`formData`は追加の `$ACTION_` プロパティを含むことです。
> - 詳細は[React `<form>`のドキュメント](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-action)を参照してください。

### 追加の引数を渡す {#passing-additional-arguments}

JavaScriptの`bind`メソッドを使用してServer Actionに追加の引数を渡すことができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Update User Name</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Update User Name</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

Server Actionは`formData`に加えて、`userId`引数を受け取ります：

```js title="app/actions.js"
'use server'

export async function updateUser(userId, formData) {}
```

> **Good to know**:
>
> - 代替として、フォーム内の隠し入力フィールドとして引数を渡すこともできます（例：`<input type="hidden" name="userId" value={userId} />`）。ただし、この値はレンダリングされたHTMLの一部になりますが、エンコードされません。
> - `.bind` はServer ComponentsとClient Componentsの両方で動作します。また、プログレッシブエンハンスメントをサポートしています。

### ネストされたフォーム要素 {#nested-form-elements}

`<form>`内にネストされた要素（例：`<button>`, `<input type="submit">`, `<input type="image">`）でもServer Actionを呼び出すことができます。これらの要素は `formAction` プロパティまたは[イベントハンドラー](#event-handlers)を受け入れます。

特定のサーバーアクションをフォーム内で複数回呼び出したい場合に便利です。例えば、投稿の下書きを保存するための特定の`<button>`要素を作成することができます[React `<form>` ドキュメント](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types)で詳細を参照してください。

### プログラムによるフォーム送信 {#programmatic-form-submission}

[`requestSubmit()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit) メソッドを使用してプログラム的にフォーム送信をトリガーできます。たとえば、 `⌘` + `Enter` キーボードショートカットを使用してユーザーがフォームを送信する場合、`onKeyDown`イベントをリッスンします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/entry.tsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/entry.js" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

</TabItem>
</Tabs>

これにより、最も近い`<form>`祖先が送信され、Server Actionが呼び出されます。

### サーバーサイドのフォームバリデーション {#server-side-form-validation}

基本的なクライアントサイドのフォームバリデーションには `required` 、`type="email"` などのHTML属性を使用できます。

より高度なサーバーサイドのバリデーションには、 [zod](https://zod.dev/)などのライブラリを使用してデータをミューテートする前にフォームフィールドを検証できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: 'Invalid Email',
  }),
})

export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // フォームデータが無効な場合、早期に返す
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // データをミューテートする
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions.js" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: 'Invalid Email',
  }),
})

export default async function createsUser(formData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // フォームデータが無効な場合、早期に返す
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // データをミューテートする
}
```

</TabItem>
</Tabs>

フィールドがサーバー側で検証された後、アクション内でシリアル化可能なオブジェクトを返し、Reactの`useFormState`フックを使用してユーザーにメッセージを表示できます。

- アクションを `useFormState` に渡すことで、アクションの関数シグネチャは、1番目の引数として新しい `prevState` または `initialState` パラメーターを受け取るようになります；
- `useFormState` はReactフックであるため、Client Component内で使用する必要があります；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState: any, formData: FormData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: 'Please enter a valid email' }
  }

  redirect('/dashboard')
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState, formData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: 'Please enter a valid email' }
  }

  redirect('/dashboard')
}
```

</TabItem>
</Tabs>

次に、あなたのアクションを `useFormState` フックに渡し、返された`state`を使用してエラーメッセージを表示します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup.tsx" highlight={11,18-20} switcher
'use client'

import { useFormState } from 'react-dom'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction] = useFormState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button>Sign up</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup.js" highlight={11,18-20} switcher
'use client'

import { useFormState } from 'react-dom'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction] = useFormState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button>Sign up</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - これらの例は、Next.js App RouterにバンドルされているReactの`useFormState`フックを使用しています。React 19を使用している場合は代わりに`useActionState`を使用してください。詳細は[Reactの文書](https://react.dev/reference/react/useActionState)を参照してください。

### ペンディングステート {#pending-states}

> - データをミューテートする前に、ユーザーがそのアクションを実行する権限を持っているかを常に確認してください。詳細は[認証と認可](#authentication-and-authorization)を参照してください。

[`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) フックは `pending` ブール値を公開しており、アクションが実行されている間、ローディングインジケータを表示するのに使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/submit-button.tsx" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      Sign Up
    </button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/submit-button.js" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      Sign Up
    </button>
  )
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - React 19では、`useFormStatus` による返されたオブジェクトには data、method、および action などの追加キーが含まれています。React 19を使用していない場合、利用可能なのは`pending`キーのみです。
> - React 19では、`useActionState` にも返されたステートに `pending` キーが含まれます。

### 楽観的更新 {#optimistic-updates}

Reactの[`useOptimistic`](https://react.dev/reference/react/useOptimistic) フックを使用して、Server Actionが実行される前に楽観的にUIを更新することができます。応答を待つよりも前に更新します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

type Message = {
  message: string
}

export function Thread({ messages }: { messages: Message[] }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic<
    Message[],
    string
  >(messages, (state, newMessage) => [...state, { message: newMessage }])

  const formAction = async (formData) => {
    const message = formData.get('message') as string
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m, i) => (
        <div key={i}>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">Send</button>
      </form>
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )

  const formAction = async (formData) => {
    const message = formData.get('message')
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">Send</button>
      </form>
    </div>
  )
}
```

</TabItem>
</Tabs>

### イベントハンドラー {#event-handlers}

通常、`<form>`要素内でServer Actionsを使用しますが、 `onClick`のようなイベントハンドラーで呼び出すこともできます。たとえば、いいね数をインクリメントするには：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

</TabItem>
</Tabs>

フォーム要素にもイベントハンドラーを追加できます。たとえば、 `onChange`でフォームフィールドを保存するには：

```tsx title="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">Publish</button>
    </form>
  )
}
```

このような場合、複数のイベントが迅速に連続して発生する可能性があるため、不要なServer Actionの呼び出しを防ぐために**デバウンス**をお勧めします。

### `useEffect` {#useeffect}

《React》の[`useEffect`](https://react.dev/reference/react/useEffect)フックを使用して、コンポーネントがマウントされるときや依存関係が変化したときにServer Actionを呼び出すことができます。これは、グローバルイベントに依存したり、自動的にトリガーする必要があるミューテーションに役立ちます。たとえば、アプリのショートカットを実装するための `onKeyDown` 、または簡易スクロールのための交差オブザーバーフック、およびコンポーネントがマウントする際にビューカウントを更新する場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>Total Views: {views}</p>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>Total Views: {views}</p>
}
```

</TabItem>
</Tabs>

`useEffect` の [挙動と注意点](https://react.dev/reference/react/useEffect#caveats) を考慮することを忘れないでください。

### エラーハンドリング {#error-handling}

エラーが投げられると、最も近い[`error.js`](/docs/app/building-your-application/routing/error-handling)またはクライアント側で `<Suspense>` boundary によってキャッチされます。 `try/catch` を使用して、UIで処理するためのエラーを返すことをお勧めします。

たとえば、新しいアイテムの作成におけるエラーを処理するには、メッセージを返すか次のようにします：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

export async function createTodo(prevState: any, formData: FormData) {
  try {
    // データをミューテートする
  } catch (e) {
    throw new Error('Failed to create task')
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

export async function createTodo(prevState, formData) {
  try {
    // データをミューテートする
  } catch (e) {
    throw new Error('Failed to create task')
  }
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - エラーをスローすることとは別に、 `useFormState` によって処理されるオブジェクトを返すこともできます。 [サーバーサイドのバリデーションとエラーハンドリング](#server-side-form-validation)を参照してください。

### データの再検証 {#revalidating-data}

[Next.jsキャッシュ](/docs/app/building-your-application/caching) をServer Actions内で再検証することができます。[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) APIを使用します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

</TabItem>
</Tabs>

または、[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) を使用してキャッシュタグと共に特定のデータフェッチを無効にすることができます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

</TabItem>
</Tabs>

### リダイレクト {#redirecting}

Server Actionの完了後にユーザーを別のルートにリダイレクトしたい場合は、 [`redirect`](/docs/app/api-reference/functions/redirect) APIを使用します。`redirect`は `try/catch` ブロックの外で呼び出す必要があります：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // キャッシュされた投稿を更新する
  redirect(`/post/${id}`) // 新しい投稿ページに移動する
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // キャッシュされた投稿を更新する
  redirect(`/post/${id}`) // 新しい投稿ページに移動する
}
```

</TabItem>
</Tabs>

### Cookie {#cookies}

Server Action内で [`cookies`](/docs/app/api-reference/functions/cookies) APIを使用して `get`、`set`、および `delete` cookiesできます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  const cookieStore = await cookies()

  // Cookieを取得する
  cookieStore.get('name')?.value

  // Cookieを設定する
  cookieStore.set('name', 'Delba')

  // Cookieを削除する
  cookieStore.delete('name')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // Cookieを取得する
  const cookieStore = await cookies()

  // Cookieを取得する
  cookieStore.get('name')?.value

  // Cookieを設定する
  cookieStore.set('name', 'Delba')

  // Cookieを削除する
  cookieStore.delete('name')
}
```

</TabItem>
</Tabs>

See [Server Action からの Cookie の削除に関する追加の例](/docs/app/api-reference/functions/cookies#deleting-cookies) を参照してください。

## セキュリティ {#security}

デフォルトでは、サーバーアクションが作成されエクスポートされると、公開HTTPエンドポイントが作成され、同じセキュリティの仮定と許可チェックが適用されるべきです。つまり、Server Actionやユーティリティ関数がコード内で他の場所にインポートされなくても、公にアクセス可能な状態です。

セキュリティを改善するために、Next.jsには以下の組み込み機能があります：

- **セキュリティアクションID:** Next.jsは暗号化された非決定的なIDを作成し、クライアントがServer Actionを参照し呼び出すことができます。これらのIDは、セキュリティを向上させるためにビルドごとに定期的に再計算されます；
- **デッドコード削除:** 未使用の Server Actions (IDで参照される) は、サードパーティによる公開アクセスを避けるためにクライアントバンドルから削除されます；

> **Good to know**:
>
> IDはコンパイル時に作成され、最大14日間キャッシュされます。新しいビルドが開始されたり、ビルドキャッシュが無効になったときに再生成されます；
> このセキュリティ改善は、認証レイヤが不足している場合のリスクを軽減します；しかし、それでもServer Actionsは公開HTTPエンドポイントとして扱うべきです。

```jsx
// app/actions.js
'use server'

// このアクションは私たちのアプリケーションで使用されているため、Next.js
// はクライアントがServer Actionを参照し呼び出すためのセキュリティIDを作成します。
export async function updateUserAction(formData) {}

// このアクションはアプリケーションで使用されていないため、Next.js
// は自動的にこのコードを `next build` 中に削除し、
// 公共のエンドポイントを作成しません。
export async function deleteUserAction(formData) {}
```

### 認証と認可 {#authentication-and-authorization}

ユーザーがそのアクションを実行する許可があることを確認するべきです。たとえば：

```tsx title="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('You must be signed in to perform this action')
  }

  // ...
}
```

### クロージャと暗号化 {#closures-and-encryption}

コンポーネント内でServer Actionを定義すると、アクションが外部関数のスコープにアクセスできる[クロージャ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)が作成されます。たとえば、`publish` アクションは `publishVersion` 変数にアクセスできます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('The version has changed since pressing publish');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>Publish</button>
    </form>
  );
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('The version has changed since pressing publish');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>Publish</button>
    </form>
  );
}
```

</TabItem>
</Tabs>

クロージャは、アクションが呼び出されたとき後で使用できるように、レンダリング時のデータ（例：`publishVersion`）の**スナップショット**をキャプチャする必要がある場合に役立ちます。

ただし、これを実現するために、キャプチャされた変数はアクションが呼び出されたときにクライアントに送信され、サーバーに戻されます。機密データがクライアントに公開されないようにするには、Next.jsは閉じ込め変数を自動的に暗号化します。 Next.jsアプリケーションがビルドされるたびに非公開キーが新たに生成されます。これは、特定のビルドに対してのみアクションを呼び出すことができることを意味します。

> **Good to know:** 機密情報がクライアントに公開されるのを防ぐために、暗号化だけに頼ることはおすすめしません。代わりに、 [Reactの汚染API](/docs/app/building-your-application/data-fetching/fetching#preventing-sensitive-data-from-being-exposed-to-the-client) を使用して、特定のデータがクライアントに送信されないように積極的に防止するのが良いです。

### 暗号化キーを上書きする (高度なオプション) {#overwriting-encryption-keys-advanced}

Next.jsアプリケーションを複数のサーバー間で自己ホスティングする場合、各サーバーインスタンスが異なる暗号化キーで終わる可能性があり、潜在的な不整合が生じる可能性があります。

これを軽減するために、`process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY` 環境変数を使用して暗号化キーを上書きできます。指定されたこの変数は、暗号化キーがビルド間で永続的であり、すべてのサーバーインスタンスが同じキーを使用することを保証します。

これは、高度なユースケースであり、複数のデプロイメントで一貫性のある暗号化動作がアプリケーションにとって重要です。キーのローテーションや署名などの標準的なセキュリティ慣行を考慮すべきです。

> **Good to know:** VercelにデプロイされたNext.jsアプリケーションはこの点を自動的に処理します。

### 許可されたオリジン (高度なオプション) {#allowed-origins-advanced}

Server Actionsは `<form>` 要素内で呼び出されるため、[CSRF攻撃](https://developer.mozilla.org/en-US/docs/Glossary/CSRF)の影響を受ける可能性があります。

Server Actionsは内部で`POST` メソッドを使用し、このHTTPメソッドのみがそれらを呼び出せるため、ほとんどのCSRFの脆弱性を防ぎます。特に、[SameSite Cookie](https://web.dev/articles/samesite-cookies-explained) がデフォルトで設定されている場合はさらに効果的です。

追加の保護として、Next.jsのServer Actionsは[Originヘッダ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin)を[Hostヘッダ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host)（または `X-Forwarded-Host`）と比較し、一致しない場合、リクエストを中止します。言い換えれば、Server Actionsはそれをホストしているページと同じホスト上でしか呼び出せません。

プロキシを使用する大規模なアプリケーションまたはマルチレイヤバックエンドアーキテクチャ（サーバーAPIがプロダクションドメインと異なる）がある場合は、安全なオリジンのリストを指定するために [`serverActions.allowedOrigins`](/docs/app/api-reference/next-config-js/serverActions) 構成オプションを使用することをお勧めします。このオプションは文字列の配列を受け入れます。

```js title="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

[セキュリティと Server Actions](https://nextjs.org/blog/security-nextjs-server-components-actions)の詳細を学びます。

## 追加のリソース {#additional-resources}

詳細については、次のReactの文書を確認してください：

- [Server Actions](https://react.dev/reference/rsc/server-actions)
- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useActionState`](https://react.dev/reference/react/useActionState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)
