---
title: 'Server Components'
description: 'React Server Componentsを使用して、アプリケーションの一部をサーバーでレンダリングする方法を学びましょう。'
related:
  description: 'Next.jsがデータと静的レンダリングの結果をどのようにキャッシュするかを学びましょう。'
  links:
    - app/building-your-application/caching
---

React Server Componentsを使用すると、サーバーでレンダリングされ、オプションでキャッシュすることができるUIを書くことができます。Next.jsでは、ストリーミングと部分レンダリングを可能にするために、レンダリング作業がルートセグメントによってさらに分割され、サーバーレンダリングの戦略は三つあります：

- [Static Rendering](#static-rendering-default)
- [Dynamic Rendering](#dynamic-rendering)
- [Streaming](#streaming)

このページでは、Server Componentsの動作方法、それらを使用する場合、そして異なるサーバーレンダリングの戦略について説明します。

## サーバーレンダリングの利点 {#benefits-of-server-rendering}

サーバーでレンダリング作業を行うことにはいくつかの利点があります：

- **データフェッチング**: Server Componentsを使用すると、データフェッチングをデータソースに近いサーバーに移動できます。これにより、レンダリングに必要なデータを取得する時間が短縮され、クライアントが行う必要のあるリクエストの数が減少することで、パフォーマンスが向上します。
- **セキュリティ**: Server Componentsを使用すると、トークンやAPIキーなどの機密データやロジックをクライアントに露出することなくサーバーに保持できます。
- **キャッシング**: サーバーでレンダリングすることで、その結果をキャッシュし、後続のリクエストやユーザー間で再利用できます。これにより、リクエストごとに行われるレンダリングやデータフェッチの量が削減されるため、パフォーマンスが向上し、コストが削減されます。
- **パフォーマンス**: Server Componentsは、基礎からパフォーマンスを最適化するための追加ツールを提供します。たとえば、完全にclient component で構成されたアプリがある場合、UIの非対話的部分をServer Componentsに移動することで、クライアントサイドのJavaScriptの量を削減できます。これは、インターネット接続が遅いユーザーや性能が低いデバイスにとって有益です。ブラウザがダウンロード、解析、実行するクライアントサイドのJavaScriptの量が少なくなるからです。
- **初回ページロードと[First Contentful Paint (FCP)](https://web.dev/fcp/)**: サーバー上で、HTMLを生成し、ユーザーがクライアントがページをレンダリングするために必要なJavaScriptをダウンロード、解析、実行するのを待たずにページをすぐに表示できるようにします。
- **検索エンジン最適化とソーシャルネットワークでの共有可能性**: レンダリングされたHTMLは、検索エンジンボットがページをインデックスするためや、ソーシャルネットワークボットがページのソーシャルカードプレビューを生成するために使用されます。
- **ストリーミング**: Server Componentsを使用すると、レンダリング作業をチャンクに分割し、準備ができ次第クライアントにストリーム送信できます。これにより、ユーザーはサーバーでページ全体がレンダリングされるのを待たずにページの一部を早く見ることができます。

## Next.jsでのServer Componentsの使用 {#using-server-components-in-next-js}

デフォルトで、Next.jsはServer Componentsを使用します。これにより、追加の設定なしで自動的にサーバーレンダリングを実行でき、必要に応じてClient Componentsを使用することができます。詳細は[Client Components](/docs/app/building-your-application/rendering/client-components)を参照してください。

## Server Componentsはどのようにレンダリングされるのですか？ {#how-are-server-components-rendered}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個別のルートセグメントと[Suspense Boundaries](https://react.dev/reference/react/Suspense)によってチャンクに分割されます。

各チャンクは二段階でレンダリングされます：

1. ReactはServer Componentsを**React Server Component Payload (RSC Payload)**という特別なデータ形式にレンダリングします。
2. Next.jsはRSC PayloadとClient ComponentのJavaScript命令を使用して、サーバー上で**HTML**をレンダリングします。

{/* Rendering Diagram */}

その後、クライアント側では：

1. HTMLが使用されて、ルートの迅速な非インタラクティブなプレビューが即座に表示されます - これは初回ページロード時のみです。
2. React Server Components Payloadは、ClientとServer Componentのツリーを和解させ、DOMを更新するために使用されます。
3. JavaScript命令はClient Componentsを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにします。

> #### React Server Component Payload (RSC)とは？
>
> RSC Payloadは、レンダリングされたReact Server Componentsツリーのコンパクトなバイナリ表現です。クライアント側でReactがブラウザのDOMを更新するために使用されます。RSC Payloadには次のものが含まれます：
>
> - Server Componentsのレンダリングされた結果
> - Client Componentsがレンダリングされる場所とそのJavaScriptファイルへの参照
> - Server ComponentからClient Componentに渡されたprops

## サーバーレンダリング戦略 {#server-rendering-strategies}

サーバーレンダリングには、Static、Dynamic、Streamingの三つのサブセットがあります。

### Static Rendering (デフォルト) {#static-rendering-default}

Static Renderingでは、ルートが**ビルド時間**にレンダリングされるか、[データの再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)後にバックグラウンドでレンダリングされます。その結果はキャッシュされ、[コンテンツ配信ネットワーク（CDN）](https://developer.mozilla.org/docs/Glossary/CDN)にプッシュすることができます。この最適化により、レンダリング作業の結果をユーザーやサーバーリクエスト間で共有することができます。

Static Renderingは、ルートのデータがユーザーに対してパーソナライズされておらずビルド時に既知である場合に有用です。たとえば、静的なブログ投稿や製品ページなどです。

### Dynamic Rendering {#dynamic-rendering}

Dynamic Renderingでは、ルートが**リクエスト時間**に各ユーザーに対してレンダリングされます。

Dynamic Renderingは、ルートのデータがユーザーに対してパーソナライズされている場合や、クッキーやURLの検索パラメータなど、リクエスト時にのみ既知の情報がある場合に有用です。

> **キャッシュされたデータを持つDynamic Routes**
>
> ほとんどのWebサイトでは、ルートは完全に静的または完全に動的ではなく、スペクトラムのようなものです。たとえば、定期的に再検証されるキャッシュされた製品データを使用するeコマースページがあり、同時にキャッシュされていないパーソナライズされた顧客データもあります。
>
> Next.jsでは、キャッシュされたデータとキャッシュされていないデータの両方を持つ動的にレンダリングされたルートを持つことができます。これは、RSC Payloadとデータが別々にキャッシュされるためです。これにより、すべてのデータをリクエスト時間にフェッチするパフォーマンスへの影響を心配することなく、動的レンダリングを選択できます。
>
> [full-route cache](/docs/app/building-your-application/caching#full-route-cache)および [Data Cache](/docs/app/building-your-application/caching#data-cache) について詳しく学びましょう。

#### Dynamic Renderingへの切り替え {#switching-to-dynamic-rendering}

レンダリング中に、[Dynamic API](#dynamic-apis)やキャッシュされていないデータリクエストが発見された場合、Next.jsはルート全体を動的にレンダリングするように切り替えます。この表は、Dynamic APIとデータキャッシュがルートが静的または動的にレンダリングされるかどうかにどのように影響するかをまとめたものです：

| Dynamic APIs | データ       | ルート                   |
| ------------ | ------------ | ------------------------ |
| No           | キャッシュ   | 静的にレンダリングされる |
| Yes          | キャッシュ   | 動的にレンダリングされる |
| No           | 非キャッシュ | 動的にレンダリングされる |
| Yes          | 非キャッシュ | 動的にレンダリングされる |

上記の表では、ルートが完全に静的であるためには、すべてのデータがキャッシュされている必要があります。ただし、キャッシュされたデータフェッチとキャッシュされていないデータフェッチの両方を利用する動的にレンダリングされたルートを持つことができます。

開発者として、静的レンダリングと動的レンダリングのどちらを選ぶ必要はありません。Next.jsは、使用されている機能やAPIに基づいて各ルートに最適なレンダリング戦略を自動的に選択します。代わりに、[キャッシュする](https://your_url/docs/app/building-your-application/data-fetching/fetching)かどうかや、特定のデータを[再検証する](https://your_url/docs/app/building-your-application/data-fetching/incremental-static-regeneration)タイミングを選びます。または、UIの一部を[ストリーミング](#streaming)することを選ぶことができます。

### Dynamic APIs {#dynamic-apis}

Dynamic APIsは、事前レンダリング中ではなく、リクエスト時にのみ既知の情報に依存します。これらのAPIを使用することは、開発者の意図を示し、リクエスト時にルート全体を動的レンダリングに切り替えることを意味します。これらのAPIには次のものが含まれます：

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/legacy-apis/unstable_noStore)
- [`unstable_after`](/docs/app/api-reference/functions/unstable_after)

### ストリーミング {#streaming}

<Image
  alt="ストリーミング中のルートセグメントの並列化を示すダイアグラム。データフェッチ、個々のチャンクのレンダリング、およびハイドレーションを示す。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

ストリーミングを使用すると、サーバーからUIを段階的にレンダリングすることができます。作業はチャンクに分割され、準備が整うとクライアントにストリーミングされます。これにより、ユーザーは全体のコンテンツのレンダリングが完了する前に、ページの一部をすぐに見ることができます。

<Image
  alt="クライアント側で部分的にレンダリングされたページを示すダイアグラム。ストリーミング中のチャンクに対して読み込みUIが表示されている。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

ストリーミングは、デフォルトでNext.jsのApp Routerに組み込まれています。これにより、初期ページロードのパフォーマンスが向上し、ルート全体のレンダリングを妨げるような遅いデータフェッチに依存するUIも改善されます。たとえば、製品ページ上のレビューなどです。

ルートセグメントを`loading.js`とUIコンポーネントでストリーミングし始めることができます。詳細は[Loading UI and Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming)セクションを参照してください。
