---
title: 'Server Components'
description: 'React Server Componentsを使用して、アプリケーションの一部をサーバーでレンダリングする方法を学びます。'
related:
  description: 'Next.jsがデータと静的レンダリングの結果をどのようにキャッシュするかについて学びます。'
  links:
    - app/building-your-application/caching
---

React Server Componentsを使用すると、UIをサーバーでレンダリングし、オプションでキャッシュすることができます。Next.jsでは、レンダリング作業がルートセグメントによってさらに分割され、ストリーミングと部分的なレンダリングを可能にし、3つの異なるサーバーレンダリング戦略があります；

- [Static Rendering](#static-rendering-default)
- [Dynamic Rendering](#dynamic-rendering)
- [Streaming](#streaming)

このページでは、Server Componentsがどのように機能するか、どのような場合にそれらを使用するか、そして異なるサーバーレンダリング戦略について説明します。

## サーバーレンダリングの利点

サーバーでレンダリング作業を行うことにはいくつかの利点があります；

- **データフェッチング**: Server Componentsを使用すると、データソースに近いサーバーでデータフェッチングを行うことができます。これにより、レンダリングに必要なデータを取得する時間が短縮され、クライアントが行うリクエストの数が減少し、パフォーマンスが向上します。
- **セキュリティ**: Server Componentsを使用すると、クライアントに公開せずに、トークンやAPIキーなどの機密データやロジックをサーバーに保持することができます。
- **キャッシュ**: サーバーでレンダリングすることで、結果をキャッシュして後続のリクエストや他のユーザーに再利用できます。これにより、各リクエストで行われるレンダリングやデータフェッチの量を削減し、パフォーマンスを向上させ、コストを削減します。
- **パフォーマンス**: Server Componentsは、基本からパフォーマンスを最適化するための追加のツールを提供します。例えば、完全にクライアントコンポーネントで構成されたアプリを開始し、UIの非対話部分をServer Componentsに移すことで、必要なクライアントサイドのJavaScriptの量を減らすことができます。これは、より遅いインターネット環境や性能の低いデバイスを持つユーザーにとって有益です。ブラウザがダウンロード、解析、および実行するクライアントサイドのJavaScriptが少なくなるためです。
- **初期ページロードと[First Contentful Paint（FCP）](https://web.dev/fcp/)**: サーバー側でHTMLを生成することで、ユーザーはクライアントがページをレンダリングするために必要なJavaScriptをダウンロード、解析、実行するのを待たずにページをすぐに表示できます。
- **検索エンジンの最適化とソーシャルネットワークの共有性**: レンダリングされたHTMLは、検索エンジンのボットによってページをインデックス化し、ソーシャルネットワークのボットによってページのソーシャルカードプレビューを生成するために利用できます。
- **ストリーミング**: Server Componentsを使用すると、レンダリング作業をチャンクに分割し、それらが準備でき次第クライアントにストリーム送信できます。これにより、ユーザーはページ全体がサーバーでレンダリングされるのを待たずして、ページの一部を早く確認できます。

## Next.jsでのServer Componentsの使用

デフォルトで、Next.jsはServer Componentsを使用します。これにより、追加の設定なしにサーバーレンダリングを自動的に実装でき、必要に応じてClient Componentsを採用できます。詳細は[Client Components](/docs/app/building-your-application/rendering/client-components)を参照してください。

## Server Componentsはどのようにレンダリングされるのか？

サーバー上で、Next.jsはReactのAPIを利用してレンダリングをオーケストレーションします。レンダリング作業は個々のルートセグメントおよび[Suspense Boundaries](https://react.dev/reference/react/Suspense)によってチャンクに分割されます。

各チャンクは2つのステップでレンダリングされます；

1. ReactはServer Componentsを特別なデータ形式である**React Server Component Payload（RSC Payload）**にレンダリングします。
2. Next.jsはRSC PayloadとクライアントコンポーネントのJavaScript命令を使用して、サーバーで**HTML**をレンダリングします。

{/* レンダリング図 */}

次に、クライアント側で；

1. HTMLを使用して、ルートの迅速な非対話プレビューを即座に表示します - これは初回ページロード時のみです。
2. React Server Components Payloadを使用してクライアントとサーバーコンポーネントのtreeを調整し、DOMを更新します。
3. JavaScriptの命令を用いて、クライアントコンポーネントを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)してアプリケーションをインタラクティブにします。

> #### React Server Component Payload（RSC）とは何ですか？
>
> RSC Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。クライアントのReactはRSC Payloadを使ってブラウザのDOMを更新します。RSC Payloadが含むもの：
>
> - Server Componentsのレンダリング結果
> - クライアントコンポーネントがレンダリングされるべき場所のプレースホルダーと、それらのJavaScriptファイルへの参照
> - サーバーコンポーネントからクライアントコンポーネントへ渡されるprops

## サーバーレンダリング戦略

サーバーレンダリングには、静的、動的、ストリーミングの3つのサブセットがあります。

### Static Rendering（デフォルト）

Static Renderingでは、ルートは**ビルド時**または[データの再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)後にバックグラウンドでレンダリングされます。その結果はキャッシュされ、[Content Delivery Network（CDN）](https://developer.mozilla.org/docs/Glossary/CDN)にプッシュすることができます。この最適化により、レンダリング作業の結果をユーザーとサーバーリクエスト間で共有することができます。

静的レンダリングは、ユーザーにパーソナライズされておらず、ビルド時に特定できるデータがあるルートに便利です。例えば、静的なブログ投稿や商品ページなどです。

### Dynamic Rendering

Dynamic Renderingでは、ルートは**リクエスト時**にユーザーごとにレンダリングされます。

動的レンダリングは、ルートがユーザーにパーソナライズされたデータを持つ場合や、リクエスト時にしか知り得ない情報がある場合に便利です。例えば、クッキーやURLの検索パラメータです。

> **キャッシュされたデータを含む動的ルート**
>
> 多くのウェブサイトでは、ルートは完全に静的でもなく、完全に動的でもない - スペクトラムです。例えば、キャッシュされた商品データを使用し、一定の間隔で再検証されるeコマースページがあり、また、キャッシュされていない個別の顧客データを持つ場合があります。
>
> Next.jsでは、キャッシュされたデータとキャッシュされていないデータの両方を持つ動的にレンダリングされたルートを作成することができます。これは、RSC Payloadとデータが別々にキャッシュされるためです。これにより、リクエスト時にすべてのデータを取得するというパフォーマンスへの影響を気にすることなく、動的レンダリングを選択できます。
>
> 詳しくは[full route cache](/docs/app/building-your-application/caching#full-route-cache)および[Data Cache](/docs/app/building-your-application/caching#data-cache)について学んでください。

#### 動的レンダリングへの切り替え

レンダリング中に[Dynamic API](#dynamic-apis)またはキャッシュされていないデータリクエストが発見された場合、Next.jsはルート全体を動的にレンダリングするように切り替えます。このテーブルは、Dynamic APIsとデータキャッシュがルートを静的にまたは動的にレンダリングするかどうかに与える影響をまとめたものです；

| Dynamic APIs | Data       | Route                |
| ------------ | ---------- | -------------------- |
| No           | Cached     | Statically Rendered  |
| Yes          | Cached     | Dynamically Rendered |
| No           | Not Cached | Dynamically Rendered |
| Yes          | Not Cached | Dynamically Rendered |

上記のテーブルでは、ルートが完全に静的であるためには、すべてのデータがキャッシュされている必要があります。ただし、キャッシュされたデータとキャッシュされていないデータのフェッチの両方を使用する動的にレンダリングされたルートを持つこともできます。

開発者としては、静的レンダリングと動的レンダリングを選択する必要はありません。Next.jsが使用される機能やAPIに基づいて各ルートに最適なレンダリング戦略を自動的に選択します。代わりに、特定のデータをいつ[キャッシュする](/docs/app/building-your-application/data-fetching/fetching)か、または[再検証する](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)か選択し、UIの部分をいつ[ストリーミングする](#streaming)か選択します。

### Dynamic APIs

Dynamic APIは、リクエスト時にしか知り得ない情報（プレンダーリング時には知っていることができない情報）に依存します。これらのAPIのいずれかを使用することで、開発者の意図が示され、リクエスト時にルート全体が動的レンダリングに移行します。これらのAPIには以下が含まれます；

- [`cookies`](https://www.notion.so/docs/app/api-reference/functions/cookies)
- [`headers`](https://www.notion.so/docs/app/api-reference/functions/headers)
- [`unstable_noStore`](https://www.notion.so/docs/app/api-reference/functions/unstable_noStore)
- [`unstable_after`](https://www.notion.so/docs/app/api-reference/functions/unstable_after)
- [`connection`](https://www.notion.so/docs/app/api-reference/functions/connection)
- [`draftMode`](https://www.notion.so/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](https://www.notion.so/docs/app/api-reference/file-conventions/page#searchparams-optional)

### Streaming

<Image
  alt="ストリーミング中のルートセグメントの並列化を示す図。データフェッチ、レンダリング、個々のチャンクのハイドレーションが示されている。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

ストリーミングを使用すると、サーバーから進行的にUIをレンダリングできます。作業はチャンクに分割され、準備ができたときにクライアントにストリームされます。これにより、全体のコンテンツがレンダリングされるのを待たずして、ページの一部をすぐに確認できます。

<Image
  alt="クライアント側で部分的にレンダリングされたページを示す図。ストリーミングされているチャンクのための読み込みUIが表示されている。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

ストリーミングはNext.js App Routerにデフォルトで組み込まれています。これにより、初期ページの読み込みパフォーマンスが向上し、遅いデータフェッチに依存するUIがルート全体のレンダリングをブロックするのを防ぎます。例えば、商品ページのレビューです。

`loading.js`を使用してルートセグメントをストリーミングし、UIコンポーネントを[React Suspense](/docs/app/building-your-application/routing/loading-ui-and-streaming)で開始できます。詳細は[Loading UI and Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming)セクションを参照してください。