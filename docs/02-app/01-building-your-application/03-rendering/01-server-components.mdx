---
title: 'Server Components'
description: 'アプリケーションの一部をサーバーでレンダリングするためにReact Server Componentsを使用する方法を学びます。'
related:
  description: 'Next.jsがデータと静的レンダリングの結果をどのようにキャッシュするかを学びます。'
  links:
    - app/building-your-application/caching
---

React Server Componentsを使用すると、UIをサーバーでレンダリングし、オプションでキャッシュすることができます。Next.jsでは、ルートセグメントごとにレンダリング作業がさらに分割され、ストリーミングと部分レンダリングが可能になっています。サーバーレンダリングには3つの異なる戦略があります。

- [Static Rendering](#static-rendering-default)
- [Dynamic Rendering](#dynamic-rendering)
- [Streaming](#streaming)

このページでは、Server Componentsがどのように機能するか、いつ使用するか、異なるサーバーレンダリングの戦略について説明します。

## サーバーレンダリングの利点 {#benefits-of-server-rendering}

サーバーでレンダリング作業を行うことには、いくつかの利点があります。

- **データフェッチング**: Server Componentsを使用すると、データソースに近いサーバーでデータフェッチングを行うことができます。これにより、レンダリングに必要なデータのフェッチ時間を短縮し、クライアントが行うリクエストの数を減らすことで、パフォーマンスを向上させることができます。
- **セキュリティ**: Server Componentsを使用すると、トークンやAPIキーなどの機密データやロジックをクライアントに公開するリスクなしにサーバーに保持することができます。
- **キャッシュ**: サーバーでレンダリングすることで、結果をキャッシュし、次回のリクエストや複数のユーザーで再利用できます。これにより、各リクエストで行われるレンダリングやデータフェッチの量を減らすことで、パフォーマンスが向上し、コストも削減できます。
- **パフォーマンス**: Server Componentsを使用すると、基礎からパフォーマンスを最適化するための追加ツールを使用できます。たとえば、完全にClient Componentsで構成されたアプリから始めて、UIのインタラクティブでない部分をServer Componentsに移動することで、必要なクライアント側のJavaScriptの量を減らすことができます。これにより、インターネットが遅延しているユーザーや性能が低いデバイスを使用しているユーザーにとっては、ブラウザでダウンロード、解析、実行されるクライアント側のJavaScriptが減少することで有益です。
- **初回ページロードと[ファースト・コンテンツフル・ペイント（FCP）](https://web.dev/fcp/)**: サーバーでは、HTMLを生成して、クライアントがJavaScriptをダウンロード、解析、実行してページをレンダリングする前に、すぐにページを表示できるようにします。
- **検索エンジン最適化（SEO）およびソーシャルネットワークの共有性**: レンダリングされたHTMLは、検索エンジンのボットがページをインデックスするのに使用でき、また、ソーシャルネットワークのボットがソーシャルカードプレビューを生成するのに使用できます。
- **ストリーミング**: Server Componentsを使用すると、レンダリング作業をチャンクに分割し、それらが準備でき次第クライアントにストリーミングできます。これにより、ユーザーはページのすべてがサーバーでレンダリングされるのを待たずに、ページの一部を早く見ることができます。

## Next.jsでのServer Componentsの使用 {#using-server-components-in-next-js}

デフォルトでNext.jsはServer Componentsを使用します。これにより、追加の設定なしで自動的にサーバーレンダリングを実装できます。そして、必要に応じてClient Componentsを使用することもできます。詳しくは、[Client Components](/docs/app/building-your-application/rendering/client-components)をご覧ください。

## Server Componentsはどのようにレンダリングされるか？ {#how-are-server-components-rendered}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントと[Suspense Boundaries](https://react.dev/reference/react/Suspense)ごとにチャンクに分割されます。

各チャンクは、以下の2つのステップでレンダリングされます。

1. ReactはServer Componentsを、 **React Server Component Payload（RSC Payload）** という特別なデータ形式にレンダリングします。
2. Next.jsは、RSC PayloadとClient Component JavaScript命令を使用して、サーバー上で**HTML**をレンダリングします。

{/* Rendering Diagram */}

その後、クライアント側で：

1. HTMLが使用され、ルートの高速で非インタラクティブなプレビューを即座に表示します - これは初回ページロード用です。
2. React Server Components Payloadが、Client ComponentとServer Componentのツリーを調整し、DOMを更新するのに使用されます。
3. JavaScript命令は、[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)を使用してClient Componentsをインタラクティブにします。

> #### React Server Component Payload（RSC）とは？
>
> RSC Payloadは、レンダリングされたReact Server Componentsツリーのコンパクトなバイナリ表現です。これは、クライアント側のReactがブラウザのDOMを更新するのに使用します。RSC Payloadには以下が含まれます。
>
> - Server Componentsのレンダリング結果
> - Client Componentsがレンダリングされるべき場所のプレースホルダーと、それらのJavaScriptファイルへの参照
> - Server ComponentからClient Componentに渡された任意のprops

## サーバーレンダリングの戦略 {#server-rendering-strategies}

サーバーレンダリングには、静的レンダリング、動的レンダリング、ストリーミングの3つのサブセットがあります。

### 静的レンダリング（デフォルト） {#static-rendering-default}

静的レンダリングでは、ルートは**ビルド時**にレンダリングされるか、または[データ再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)後にバックグラウンドでレンダリングされます。その結果はキャッシュされ、[コンテンツ・デリバリ・ネットワーク（CDN）](https://developer.mozilla.org/docs/Glossary/CDN)にプッシュすることができます。この最適化により、レンダリング作業の結果をユーザー間およびサーバーリクエスト間で共有することができます。

静的レンダリングは、ユーザーにパーソナライズされていないデータを持ち、ビルド時に把握することができるルートに有用です。たとえば、静的なブログ投稿や製品ページなどです。

### 動的レンダリング {#dynamic-rendering}

動的レンダリングでは、ルートは各ユーザーの**リクエスト時**にレンダリングされます。

動的レンダリングは、ユーザーにパーソナライズされたデータや、クッキーやURLの検索パラメータのようにリクエスト時にしか把握できない情報を持つルートに有用です。

> **キャッシュされたデータを持つ動的ルート**
>
> 多くのウェブサイトでは、ルートは完全に静的でも完全に動的でもありません - それはスペクトラムです。例えば、一定の間隔で再検証されるキャッシュされた製品データを使用するeコマースページがありつつ、キャッシュされていないパーソナライズされた顧客データを持つこともできます。
>
> Next.jsでは、キャッシュされたデータとキャッシュされていないデータの両方を持つ動的にレンダリングされたルートを持つことができます。これは、RSC Payloadとデータが別々にキャッシュされるためです。これにより、リクエスト時にすべてのデータをフェッチすることによるパフォーマンスへの影響を心配せずに動的レンダリングを選択することができます。
>
> [フルルートキャッシュ](/docs/app/building-your-application/caching#full-route-cache)および[データキャッシュ](/docs/app/building-your-application/caching#data-cache)について詳しく学んでください。

#### 動的レンダリングへの切り替え {#switching-to-dynamic-rendering}

レンダリングの間に、[動的API](#dynamic-apis)やキャッシュされていないデータリクエストが検出された場合、Next.jsはそのルート全体を動的にレンダリングするように切り替えます。このテーブルは、動的APIとデータキャッシングがルートが静的または動的にレンダリングされるかどうかにどう影響するかをまとめたものです：

| 動的API | データ       | ルート             |
| ------- | ------------ | ------------------ |
| いいえ  | キャッシュ   | 静的にレンダリング |
| はい    | キャッシュ   | 動的にレンダリング |
| いいえ  | 非キャッシュ | 動的にレンダリング |
| はい    | 非キャッシュ | 動的にレンダリング |

上記のテーブルにおいて、ルートが完全に静的であるためには、すべてのデータがキャッシュされている必要があります。ただし、キャッシュされたデータ取得とキャッシュされていないデータ取得の両方を使用する動的にレンダリングされたルートを持つことができます。

開発者として、Next.jsは使用される機能とAPIに基づいて各ルートの最適なレンダリング戦略を自動的に選択するため、静的レンダリングと動的レンダリングのどちらかを選ぶ必要はありません。かわりに、特定のデータを[キャッシュする](/docs/app/building-your-application/data-fetching/fetching)か、[再検証する](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)タイミングを選択し、UIの一部を[ストリーミングする](#streaming)ことができます。

### 動的API {#dynamic-apis}

動的APIは、事前レンダリング中ではなくリクエスト時にしか知られない情報に依存します。これらのAPIの使用は、開発者の意図を示し、リクエスト時にルート全体を動的レンダリングに適応させます。これらのAPIには以下が含まれます。

- [`cookies`](https://www.notion.so/docs/app/api-reference/functions/cookies)
- [`headers`](https://www.notion.so/docs/app/api-reference/functions/headers)
- [`unstable_noStore`](https://www.notion.so/docs/app/api-reference/functions/unstable_noStore)
- [`unstable_after`](https://www.notion.so/docs/app/api-reference/functions/unstable_after)
- [`connection`](https://www.notion.so/docs/app/api-reference/functions/connection)
- [`draftMode`](https://www.notion.so/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](https://www.notion.so/docs/app/api-reference/file-conventions/page#searchparams-optional)

### ストリーミング {#streaming}

<Image
  alt="ストリーミング中のルートセグメントの並列化を示す図、個々のチャンクのデータフェッチ、レンダリング、ハイドレーションを示す。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

ストリーミングを使用すると、サーバーからUIを段階的にレンダリングできます。作業はチャンクに分割され、それが準備でき次第クライアントにストリームされます。これにより、ユーザーはコンテンツ全体がレンダリング完了する前に、ページの一部を見ることができます。

<Image
  alt="クライアントで部分的にレンダリングされたページを示す図、ストリーミング中のチャンクの読み込みUIを示す。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

ストリーミングはデフォルトでNext.js App Routerに組み込まれています。これにより、初回ページ読み込みのパフォーマンスを向上させるだけでなく、ルート全体のレンダリングをブロックするデータフェッチが遅いUIのパフォーマンスも向上します。たとえば、製品ページのレビューなどです。

UIコンポーネントとともに`loading.js`を使用してルートセグメントのストリーミングを開始できます。詳しくは、[Loading UI and Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming)セクションを参照してください。
