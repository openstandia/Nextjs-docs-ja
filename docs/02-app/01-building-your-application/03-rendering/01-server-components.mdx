---
title: サーバーコンポーネント
description: アプリケーションの一部をサーバー側でレンダリングするために、Reactサーバーコンポーネントを使用する方法を学びます。
related:
  description: Next.jsがデータと静的レンダリングの結果をどのようにキャッシュするかを学びます。
  links:
    - app/building-your-application/caching
---

Reactサーバーコンポーネントを使用すると、UIをサーバー上でレンダリングし、必要に応じてキャッシュすることができます。Next.jsでは、レンダリングの作業がルートセグメントごとにさらに分割され、ストリーミングと部分的なレンダリングを可能にし、次の3つの異なるサーバーレンダリング戦略があります:

- [静的レンダリング](#static-rendering-default)
- [動的レンダリング](#dynamic-rendering)
- [ストリーミング](#streaming)

このページでは、サーバーコンポーネントがどのように機能するか、いつ使用するか、そして異なるサーバーレンダリング戦略について説明します。

## サーバーレンダリングのメリット

レンダリングの作業をサーバーで行うことには、いくつかの利点があります、それには以下が含まれます:

- **データフェッチング**: サーバーコンポーネントを使用すると、データフェッチングをサーバー、すなわちデータソースに近づけることができます。これにより、レンダリングに必要なデータを取得する時間を短縮し、クライアントが行う必要のあるリクエストの数を減らすことができ、パフォーマンスが向上します。
- **セキュリティ**: サーバーコンポーネントを使用することで、トークンやAPIキーなどの機密データやロジックをクライアントに公開するリスクなしに、サーバーに保持することができます。
- **キャッシュ**: サーバーでレンダリングすることで、その結果はキャッシュされ、その後のリクエストやユーザー間で再利用できます。これにより、各リクエストで行われるレンダリングとデータフェッチの量を減らし、パフォーマンスを向上させ、コストを削減できます。
- **パフォーマンス**: サーバーコンポーネントは、基礎からパフォーマンスを最適化するための追加のツールを提供します。たとえば、完全にクライアントコンポーネントで構成されたアプリから始めて、UIの非インタラクティブ部分をサーバーコンポーネントに移行すると、必要なクライアントサイドのJavaScriptの量を減らすことができます。これは、より低速なインターネットまたはあまり強力でないデバイスを使用しているユーザーにとって有益であり、ブラウザがダウンロード、解析、および実行しなければならないクライアントサイドのJavaScriptが少なくなります。
- **初回ページロードと[First Contentful Paint (FCP)](https://web.dev/fcp/)**: サーバー上でHTMLを生成し、ユーザーがページをすぐに表示できるようにします。これは、クライアントがページをレンダリングするために必要なJavaScriptをダウンロード、解析、および実行するのを待たずに行います。
- **検索エンジン最適化とソーシャルネットワークでの共有可能性**: レンダリングされたHTMLは、検索エンジンのボットがページをインデックス化し、ソーシャルネットワークのボットがページのソーシャルカードプレビューを生成するのに使用できます。
- **ストリーミング**: サーバーコンポーネントを使用すると、レンダリング作業をチャンクに分割し、それらが準備ができたらクライアントにストリーミングできます。これにより、ユーザーはページの一部をサーバー全体がレンダリングされるのを待たずに早期に確認できます。

## Next.jsでのサーバーコンポーネントの使用

Next.jsでは、デフォルトでサーバーコンポーネントを使用します。これにより、追加の設定なしにサーバーレンダリングを自動的に実装することができ、必要に応じてクライアントコンポーネントを使用することを選択できます。[クライアントコンポーネント](/docs/app/building-your-application/rendering/client-components)を参照してください。

## サーバーコンポーネントはどのようにレンダリングされるのか？

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業はルートセグメントごとや[Suspense Boundaries](https://react.dev/reference/react/Suspense)ごとにチャンクに分割されます。

各チャンクは2つのステップでレンダリングされます:

1. Reactはサーバーコンポーネントを特別なデータ形式、**Reactサーバーコンポーネントペイロード（RSCペイロード）** にレンダリングします。
2. Next.jsはRSCペイロードとクライアントコンポーネントのJavaScript命令を使用してサーバー上で**HTML**をレンダリングします。

{/* レンダリング図 */}

そして、クライアント側で:

1. HTMLはルートの非インタラクティブな高速プレビューをすぐに表示するために使用されます - これは初回ページロードのみのためです。
2. Reactサーバーコンポーネントペイロードはクライアントとサーバーコンポーネントツリーを調整し、DOMを更新するために使用されます。
3. JavaScript命令はクライアントコンポーネントを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)してアプリケーションをインタラクティブにするために使用されます。

> #### Reactサーバーコンポーネントペイロード（RSC）とは？
>
> RSCペイロードはレンダリングされたReactサーバーコンポーネントツリーのコンパクトなバイナリ表現です。Reactはクライアント側で使用し、ブラウザのDOMを更新します。RSCペイロードには以下が含まれます:
>
> - サーバーコンポーネントのレンダリング結果
> - クライアントコンポーネントがレンダリングされ、そのJavaScriptファイルへの参照となるプレースホルダー
> - サーバーコンポーネントからクライアントコンポーネントに渡されたすべてのprops

## サーバーレンダリング戦略

サーバーレンダリングには、静的、動的、ストリーミングの3つのサブセットがあります。

### 静的レンダリング（デフォルト）

{/* 静的レンダリング図 */}

静的レンダリングは、**ビルド時**または[データ再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)後のバックグラウンドでルートがレンダリングされます。結果はキャッシュされ、[コンテンツ配信ネットワーク (CDN)](https://developer.mozilla.org/docs/Glossary/CDN)にプッシュされます。この最適化により、ユーザーとサーバーリクエスト間でレンダリング作業の結果を共有することが可能になります。

静的レンダリングは、静的ブログ投稿や製品ページのように、ビルド時に知ることができ、ユーザー向けにパーソナライズされていないデータを持つルートに役立ちます。

### 動的レンダリング

{/* 動的レンダリング図 */}

動的レンダリングでは、ルートは**リクエスト時**に各ユーザー向けにレンダリングされます。

動的レンダリングは、特定のユーザーにパーソナライズされたデータや、リクエスト時にしか知ることができない情報を持つルートに役立ちます。例えば、クッキーやURLの検索パラメータなどです。

> **キャッシュされたデータを使用した動的ルート**
>
> ほとんどのウェブサイトでは、ルートは完全に静的でも完全に動的でもなく、これはスペクトルです。例えば、一定間隔で再検証されるキャッシュされた製品データを使用するeコマースページがあり、またキャッシュされていないパーソナライズされた顧客データを持つことができます。
>
> Next.jsでは、キャッシュされたデータとキャッシュされていないデータの両方を持つ動的にレンダリングされたルートを持つことができます。これは、RSCペイロードとデータが個別にキャッシュされるからです。これにより、パフォーマンスの影響を心配せずに、動的レンダリングに移行することができます。
>
> 詳細は、[フルルートキャッシュ](/docs/app/building-your-application/caching#full-route-cache)と[データキャッシュ](/docs/app/building-your-application/caching#data-cache)を参照してください。

#### 動的レンダリングへの切り替え

レンダリング中に[動的関数](#dynamic-functions)またはキャッシュされていないデータリクエストが見つかった場合、Next.jsはルート全体を動的にレンダリングするように切り替えます。この表は、動的関数とデータキャッシュが、ルートが静的または動的にレンダリングされるかどうかにどのように影響するかをまとめたものです:

| 動的関数  | データ      | ルート                |
| -------- | ---------- | -------------------- |
| No       | Cached     | 静的にレンダリングされた |
| Yes      | Cached     | 動的にレンダリングされた |
| No       | Not Cached | 動的にレンダリングされた |
| Yes      | Not Cached | 動的にレンダリングされた |

上記の表では、路盤が完全に静的であるためには、すべてのデータがキャッシュされる必要があります。ただし、キャッシュされたデータフェッチとキャッシュされていないデータフェッチの両方を使用する動的にレンダリングされたルートを持つこともできます。

開発者としては、Next.jsが使用する機能やAPIに基づいて各ルートに最適なレンダリング戦略を自動的に選択するため、静的レンダリングと動的レンダリングを選択する必要はありません。代わりに、特定のデータを[キャッシュ](https://docs/app/building-your-application/data-fetching/fetching)または[再検証](https://docs/app/building-your-application/data-fetching/incremental-static-regeneration)するタイミングを選択し、UIの一部を[ストリーム](#streaming)することを選択できます。

#### 動的関数

動的関数は、ユーザーのクッキー、現在のリクエストヘッダー、またはURLの検索パラメータなど、リクエスト時にしか知ることができない情報に依存しています。Next.jsでのこれらの動的APIは次のとおりです:

- [`cookies()`](/docs/app/api-reference/functions/cookies)
- [`headers()`](/docs/app/api-reference/functions/headers)
- [`unstable_noStore()`](/docs/app/api-reference/functions/unstable_noStore)
- [`unstable_after()`](/docs/app/api-reference/functions/unstable_after)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)

これらの関数のいずれかを使用すると、リクエスト時にルート全体が動的レンダリングに切り替わります。

### ストリーミング

<Image
  alt="ストリーミング中にルートセグメントが並列化されていることを示すダイアグラム、個々のチャンクのデータフェッチ、レンダリング、およびハイドレーションを示しています。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

ストリーミングにより、サーバーからUIを逐次レンダリングできます。作業はチャンクに分割され、それが準備が整うとクライアントにストリーミングされます。これにより、すべてのコンテンツがレンダリングを完了する前に、ページの一部をすぐに確認できます。

<Image
  alt="クライアント側で部分的にレンダリングされたページを示す図、ストリーミングされているチャンクの読み込みUI。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

ストリーミングはデフォルトでNext.jsのApp Routerに組み込まれています。これにより、初回ページロードパフォーマンスの向上と、ルート全体のレンダリングをブロックするスローデータフェッチに依存するUIが向上します。たとえば、製品ページのレビューなどです。

`loading.js`と[React Suspense](/docs/app/building-your-application/routing/loading-ui-and-streaming)を使用してルートセグメントとUIコンポーネントをストリーミングし始めることができます。[ローディングUIとストリーミング](/docs/app/building-your-application/routing/loading-ui-and-streaming)セクションをご覧ください。