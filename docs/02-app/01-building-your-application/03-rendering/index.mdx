---
title: 'レンダリング'
description: 'Next.js のレンダリング環境、戦略、およびランタイムの違いを学びましょう。'
---

レンダリングは、あなたが書いたコードをユーザーインターフェースに変換します。ReactとNext.jsを使うことで、一部のコードをサーバーまたはクライアントでレンダリングするハイブリッドWebアプリケーションを作成できます。このセクションでは、これらのレンダリング環境、戦略、およびランタイムの違いを理解するのに役立ちます。

## 基礎

まず、3つの基本的なWeb概念に慣れておくとよいでしょう：

- アプリケーションコードが実行されることができる[レンダリング環境](#rendering-environments)：サーバーとクライアント
- ユーザーがアプリケーションを訪問または操作する際に開始する[リクエスト-レスポンスライフサイクル](#request-response-lifecycle)
- サーバーとクライアントのコードを分離する[ネットワーク境界](#network-boundary)

### レンダリング環境

Webアプリケーションがレンダリングできる環境は、クライアントとサーバーの2つです。

<Image
  alt="クライアントとサーバーの環境"
  srcLight="/docs/light/client-and-server-environments.png"
  srcDark="/docs/dark/client-and-server-environments.png"
  width="1600"
  height="672"
/>

- **クライアント**は、ユーザーのデバイス上のブラウザーを指し、サーバーにアプリケーションコードをリクエストします。その後、サーバーからのレスポンスをユーザーインターフェースに変換します。
- **サーバー**は、データセンター内のコンピュータを指し、アプリケーションコードを保存し、クライアントからのリクエストを受け取り、適切なレスポンスを返します。

歴史的に、開発者はサーバーとクライアントのコードを書くときに異なる言語（JavaScriptやPHPなど）とフレームワークを使用する必要がありました。Reactでは、開発者は**同じ言語**（JavaScript）と**同じフレームワーク**（Next.jsや選択したフレームワーク）を使用できます。この柔軟性により、環境を切り替えることなく、両方の環境でコードを書くことができます。

ただし、各環境には独自の機能や制約があります。したがって、サーバーとクライアント向けに書いたコードは常に同じではありません。特定の操作（例えばデータ取得やユーザーの状態管理）には、どちらかの環境がより適しています。

これらの違いを理解することは、ReactとNext.jsを効果的に使用する鍵です。この違いとユースケースについては、[Server](/docs/app/building-your-application/rendering/server-components)と[Client](/docs/app/building-your-application/rendering/client-components)のコンポーネントページで詳しく説明しますが、ここでは基礎を深め続けましょう。

### リクエスト-レスポンスライフサイクル

一般的にすべてのWebサイトは同じ**リクエスト-レスポンスライフサイクル**に従います：

1. **ユーザーアクション：** ユーザーがWebアプリケーションと対話します。これはリンクをクリックすること、フォームを送信すること、またはブラウザのアドレスバーにURLを直接入力することが含まれます。
2. **HTTPリクエスト：** クライアントは、リクエストされたリソースに関する必要な情報、使用されるメソッド（例：`GET`、`POST`）、および追加データを含む[HTTP](https://developer.mozilla.org/docs/Web/HTTP)リクエストをサーバーに送信します。
3. **サーバー：** サーバーはリクエストを処理し、適切なリソースを持って応答します。このプロセスにはルーティング、データ取得などいくつかのステップが含まれる場合があります。
4. **HTTPレスポンス：** リクエストを処理した後、サーバーはクライアントにHTTPレスポンスを返送します。このレスポンスにはステータスコード（リクエストが成功したかどうかをクライアントに示します）および要求されたリソース（例：HTML、CSS、JavaScript、静的アセットなど）が含まれます。
5. **クライアント：** クライアントはリソースを解析してユーザーインターフェースをレンダリングします。
6. **ユーザーアクション：** ユーザーインターフェースがレンダリングされると、ユーザーはそれと対話でき、プロセスは再び始まります。

ハイブリッドWebアプリケーションを構築する主要な部分は、ライフサイクル内でどのように作業を分割し、ネットワーク境界をどこに置くかを決定することです。

### ネットワーク境界

Web開発において、**ネットワーク境界**は異なる環境を分離する概念上の線です。たとえば、クライアントとサーバー、およびサーバーとデータストアです。

{/* 図：ネットワーク境界 */}

Reactでは、クライアントとサーバーのネットワーク境界を最も合理的な場所に設定します。

内部的には、作業は2つの部分に分かれています：**クライアントモジュールグラフ**と**サーバーモジュールグラフ**です。サーバーモジュールグラフには、サーバーでレンダリングされるすべてのコンポーネントが含まれ、クライアントモジュールグラフには、クライアントでレンダリングされるすべてのコンポーネントが含まれます。

{/* 図：クライアントとサーバーモジュールグラフ */}

モジュールグラフを、アプリケーション内のファイルがどのように依存しているかを視覚的に表現したものと考えると役に立ちます。

{/* たとえば、サーバー上で `Page.jsx` というファイルが `Button.jsx` というファイルをインポートしている場合、モジュールグラフは次のようになります： - 図 - */}

Reactの`"use client"`規約を使用して境界を定義できます。また、`"use server"`規約は、サーバーで計算作業を行うように指示します。

## ハイブリッドアプリケーションの構築

これらの環境で作業する際、アプリケーションのコードフローを**単方向**と考えると役立ちます。言い換えれば、レスポンス中にアプリケーションコードは1方向に流れます：サーバーからクライアントへ。

{/* 図：レスポンスのフロー */}

クライアントからサーバーにアクセスする必要がある場合は、新しいリクエストをサーバーに送信し、同じリクエストを再利用しません。これにより、コンポーネントをどこにレンダリングするか、ネットワーク境界をどこに配置するかを理解しやすくなります。

実際には、このモデルは、まずサーバーで実行したい内容を考慮した上で、その結果をクライアントに送り、アプリケーションをインタラクティブにするよう開発者に促します。

この概念は、同じコンポーネントツリー内で[client componentとserver componentをインターリーブする](/docs/app/building-your-application/rendering/composition-patterns)方法を見るとより明確になります。