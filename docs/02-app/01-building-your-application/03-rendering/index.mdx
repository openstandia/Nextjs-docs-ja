---
title: レンダリング
description: Next.jsのレンダリング環境、戦略、およびランタイムの違いを学びましょう。
---

レンダリングは、あなたが書いたコードをユーザーインターフェースに変換します。ReactとNext.jsを使うと、コードの一部をサーバーまたはクライアントでレンダリングするハイブリッドWebアプリケーションを作成できます。このセクションでは、これらのレンダリング環境、戦略、およびランタイムの違いを理解するのに役立ちます。

## 基本

始めるにあたり、次の3つの基本的なWeb概念に慣れておくと便利です：

- アプリケーションコードが実行できる[環境](#rendering-environments)：サーバーとクライアント
- ユーザーがアプリケーションを訪れたり、操作したりするときに開始される[リクエスト-レスポンスライフサイクル](#request-response-lifecycle)
- サーバーとクライアントのコードを分ける[ネットワーク境界](#network-boundary)

### レンダリング環境

Webアプリケーションがレンダリングされる環境は2つあります：クライアントとサーバーです。

<Image
  alt="クライアントとサーバーの環境"
  srcLight="/docs/light/client-and-server-environments.png"
  srcDark="/docs/dark/client-and-server-environments.png"
  width="1600"
  height="672"
/>

- **クライアント**は、ユーザーのデバイス上のブラウザを指し、サーバーにアプリケーションコードのリクエストを送信します。それからサーバーからのレスポンスをユーザーインターフェースに変換します
- **サーバー**は、データセンター内のコンピュータを指し、アプリケーションコードを保存し、クライアントからのリクエストを受け取り、適切なレスポンスを返します

歴史的には、開発者はサーバーとクライアントのコードを書くときに異なる言語（例：JavaScript、PHP）やフレームワークを使わなければなりませんでした。Reactを使うと、開発者は**同じ言語**（JavaScript）および**同じフレームワーク**（例：Next.jsまたは選択したフレームワーク）を使用できます。この柔軟性により、コンテキストを切り替えずに両方の環境のコードをシームレスに書くことができます。

ただし、各環境には独自の機能と制約があります。そのため、サーバーとクライアント用に書いたコードが常に同じとは限りません。特定の操作（例：データフェッチやユーザーステートの管理）には、いずれかの環境がより適しています。

これらの違いを理解することは、ReactとNext.jsを効果的に使うための鍵です。これらの違いとユースケースは、[サーバー](/docs/app/building-your-application/rendering/server-components)および[クライアント](/docs/app/building-your-application/rendering/client-components)コンポーネントのページで詳しく説明しますが、まずは基礎を構築し続けましょう。

### リクエスト-レスポンスライフサイクル

広く言えば、すべてのWebサイトは同じ**リクエスト-レスポンスライフサイクル**を辿ります：

1. **ユーザーアクション：** ユーザーがWebアプリケーションを操作する。これはリンクをクリックしたり、フォームを送信したり、ブラウザのアドレスバーにURLを直接入力したりすることです
2. **HTTPリクエスト:** クライアントがサーバーに[HTTP](https://developer.mozilla.org/docs/Web/HTTP)リクエストを送信し、どのリソースが要求されているか、どのメソッドが使用されているか（例：`GET`、`POST`）、および必要に応じて追加データを含む必要があります
3. **サーバー：** サーバーがリクエストを処理し、適切なリソースで応答します。このプロセスはルーティング、データフェッチなどいくつかのステップを含む可能性があります
4. **HTTPレスポンス:** リクエストを処理した後、サーバーはクライアントにHTTPレスポンスを送信します。このレスポンスにはステータスコード（リクエストが成功したかどうかをクライアントに知らせるもの）と要求されたリソース（例：HTML、CSS、JavaScript、静的アセットなど）が含まれます
5. **クライアント：** クライアントがリソースを解析してユーザーインターフェースをレンダリングします
6. **ユーザーアクション：** ユーザーインターフェースがレンダリングされると、ユーザーはそれを操作でき、プロセスは再び始まります

ハイブリッドWebアプリケーションを構築する際の大部分は、ライフサイクルでの作業の分割を決め、ネットワーク境界をどこに置くかを決定することです。

### ネットワーク境界

Web開発では、**ネットワーク境界**は異なる環境を分ける概念的なラインです。例えば、クライアントとサーバー、サーバーとデータストアの間などです。

{/* Diagram: ネットワーク境界 */}

Reactでは、クライアントとサーバーのネットワーク境界を最も意味のある場所に配置することができます。

裏側では、作業が2つの部分に分割されます：**クライアントモジュールグラフ**と**サーバーモジュールグラフ**です。サーバーモジュールグラフにはサーバーでレンダリングされるすべてのコンポーネントが含まれ、クライアントモジュールグラフにはクライアントでレンダリングされるすべてのコンポーネントが含まれます。

{/* Diagram: クライアントとサーバーのモジュールグラフ */}

モジュールグラフをあなたのアプリケーション内のファイルが互いにどのように依存しているかを視覚的に表現するものとして考えると役立ちます。

{/* 例として、サーバー上の`Page.jsx`というファイルが`Button.jsx`というファイルをインポートしている場合、モジュールグラフは次のようになります： - ダイアグラム - */}

Reactの`"use client"`という慣習を使って境界を定義することができます。また、`"use server"`という慣習もあり、リアクトにサーバーでいくつかの計算処理を行わせます。

## ハイブリッドアプリケーションの構築

これらの環境で作業する際、アプリケーションにおけるコードの流れを**一方向**と考えると便利です。つまり、レスポンス中にあなたのアプリケーションコードは一方向に流れます：サーバーからクライアントへと。

{/* Diagram: レスポンスフロー */}

クライアントからサーバーにアクセスする必要がある場合、新しいリクエストをサーバーに送信し、同じリクエストを再利用しません。これにより、コンポーネントをどこにレンダリングするか、ネットワーク境界をどこに置くかを理解しやすくなります。

実際には、このモデルは開発者に対して、最初にサーバーで実行したいことを考え、その結果をクライアントに送ってアプリケーションをインタラクティブにすることを奨励します。

この概念は、同じコンポーネントツリー内で[クライアントとサーバーコンポーネントを重ねる](/docs/app/building-your-application/rendering/composition-patterns)方法を見たときにより明確になるでしょう。

{/* NOTE: この <DocCardList /> は手動で追加しています。自動翻訳等で更新され消えてしまった場合、必要に応じて再度追加しなおしてください */}

<DocCardList />
