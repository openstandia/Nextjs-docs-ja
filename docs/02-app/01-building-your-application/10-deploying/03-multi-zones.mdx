---
title: 'Multi-Zones'
description: '複数のNext.jsアプリケーションを単一のドメインにデプロイするためのNext.js Multi-Zonesを使用して、マイクロフロントエンドを構築する方法を学びましょう'
---

{/* このドキュメントの内容は、app routerとpages routerの間で共有されます。 `<PagesOnly>Content</PagesOnly>` コンポーネントを使用して、Pages Routerに特化したコンテンツを追加できます。共有コンテンツはコンポーネントでラップしないでください */}

<details open>
  <summary>例</summary>

- [With Zones](https://github.com/vercel/next.js/tree/canary/examples/with-zones)

</details>

Multi-Zonesは、ドメイン内の大規模なアプリケーションをいくつかのパスを提供する小さなNext.jsアプリケーションに分離することで、マイクロフロントエンドを実現するためのアプローチです。これは、アプリケーション内の他のページに関係のないページのコレクションがある場合に役立ちます。これらのページを別のzone（つまり、別のアプリケーション）に移動することで、各アプリケーションのサイズを縮小し、ビルド時間を短縮し、特定のzoneにのみ必要なコードを削除できます。アプリケーションがデカップルされるため、Multi-Zonesを使用すると、ドメイン上の他のアプリケーションが独自のフレームワークを選択して使用できます。

たとえば、次のようなページセットを分割したい場合を考えてみましょう：

- `/blog/*` すべてのブログ投稿
- `/dashboard/*` ユーザーがダッシュボードにログインしているときのすべてのページ
- `/*` 他のzonesにカバーされていないWebサイトの残りの部分

Multi-Zonesサポートにより、同じドメイン上で提供され、ユーザーには同じように見える3つのアプリケーションを作成できますが、それぞれのアプリケーションを独自に開発し、デプロイすることができます。

<Image
  alt="3つのゾーン: A, B, C。異なるゾーン間のルート間のハードナビゲーションと、同じゾーン内のルート間のソフトナビゲーションを示している。"
  srcLight="/docs/light/multi-zones.png"
  srcDark="/docs/dark/multi-zones.png"
  width="1600"
  height="750"
/>

同じzone内のページ間を移動する場合は、ページの再読み込みを必要としないソフトナビゲーションが実行されます。たとえば、この図では、`/` から `/products` へ移動することは、ソフトナビゲーションになります。

あるzone内のページから別のzone内のページに移動する場合（例：`/` から `/dashboard` に移動する場合）、ハードナビゲーションが実行され、現在のページのリソースがアンロードされ、新しいページのリソースがロードされます。頻繁に一緒に訪問されるページは、ハードナビゲーションを避けるために同じzone内に配置する必要があります。

## zoneを定義する方法 {#how-to-define-a-zone}

zoneは通常のNext.jsアプリケーションであり、他のzone内のページおよび静的ファイルとの競合を回避するために、[assetPrefix](/docs/app/api-reference/next-config-js/assetPrefix)を設定する必要があります。

```js title="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  assetPrefix: '/blog-static',
}
```

JavaScriptやCSSなどのNext.jsの資産は、他のzoneの資産と競合しないようにするために`assetPrefix`でプレフィックスが付けられます。これらの資産は、各zoneに対して`/assetPrefix/_next/...`で提供されます。

別のより具体的なzoneにルーティングされていないすべてのパスを処理するデフォルトのアプリケーションには、`assetPrefix`は必要ありません。

Next.js 15より前のバージョンでは、静的資産を処理するための追加のリライトが必要になる場合があります。これは次の構文を利用して実現できますが、Next.js 15ではこれが必要なくなっています。

```js title="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  assetPrefix: '/blog-static',
  async rewrites() {
    return {
      beforeFiles: [
        {
          source: '/blog-static/_next/:path+',
          destination: '/_next/:path+',
        },
      ],
    }
  },
}
```

## リクエストを適切なzoneにルーティングする方法 {#how-to-route-requests-to-the-right-zone}

Multi-Zonesの設定では、パスを正しいzoneにルーティングする必要があります。なぜなら、それらは異なるアプリケーションによって提供されるからです。これを達成するためには、HTTPプロキシを使用することができますが、Next.jsアプリケーションの1つを利用して、ドメイン全体のリクエストをルーティングすることもできます。

Next.jsアプリケーションを使用して正しいzoneにルーティングするには、[`rewrites`](/docs/app/api-reference/next-config-js/rewrites)を使用します。異なるzoneに提供される各パスについて、そのパスを他のzoneのドメインに送信するリライトルールを追加します。たとえば：

```js title="next.config.js"
async rewrites() {
    return [
        {
            source: '/blog',
            destination: `${process.env.BLOG_DOMAIN}/blog`,
        },
        {
            source: '/blog/:path+',
            destination: `${process.env.BLOG_DOMAIN}/blog/:path+`,
        }
    ];
}
```

`destination`はschemeとドメインを含む、zoneで提供されるURLである必要があります。これはzoneの本番ドメインを指すべきですが、ローカル開発では`localhost`にリクエストをルーティングするためにも使用できます。

> **知っておくと便利です**: URLパスはzoneに対して一意であるべきです。たとえば、2つのzoneが`/blog`を提供しようとすると、ルーティングの競合が発生します。

### ミドルウェアを使用してリクエストをルーティングする {#routing-requests-using-middleware}

リクエストのレイテンシーオーバーヘッドを最小限に抑えるため、[`rewrites`](/docs/app/api-reference/next-config-js/rewrites)を通じてリクエストをルーティングすることが推奨されますが、ルーティング時に動的な判断が必要な場合にはミドルウェアを使用することもできます。たとえば、パスをルーティングする場所を決定するためにフィーチャーフラグを使用している場合、例えば移行中に、ミドルウェアを使用できます。

```js title="middleware.js"
export async function middleware(request) {
  const { pathname, search } = req.nextUrl;
  if (pathname === '/your-path' && myFeatureFlag.isEnabled()) {
    return NextResponse.rewrite(`${rewriteDomain}${pathname}${search}）;
  }
}
```

## zone間のリンク {#linking-between-zones}

異なるzoneのパスへのリンクは、Next.jsの[`<Link>`](https://nextjs.org/docs/canary/pages/api-reference/components/link)コンポーネントではなく、`a`タグを使用する必要があります。これは、Next.jsが`<Link>`コンポーネント内の相対パスをプリフェッチしてソフトナビゲーションしようとするためであり、zoneを超えた場合には機能しません。

## コードの共有 {#sharing-code}

異なるzonesを構成するNext.jsアプリケーションは、任意のリポジトリで管理できます。しかし、これらのzonesを[monorepo](https://en.wikipedia.org/wiki/Monorepo)に置くと、コードをより簡単に共有できるため、便利なことが多いです。異なるリポジトリに存在するzonesに対して、コードは公開または非公開のNPMパッケージを使用して共有することもできます。

異なるzonesのページが異なるタイミングでリリースされる可能性があるため、フィーチャーフラグは、異なるzones全体で一斉に機能を有効または無効にするために役立ちます。

[Next.js on Vercel](https://vercel.com?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)アプリケーションでは、[monorepo](https://vercel.com/blog/monorepos-are-changing-how-teams-build-software?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)を使用して、影響を受けるすべてのzoneを単一の`git push`でデプロイできます。

<AppOnly>

## Server Actions {#server-actions}

[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)をMulti-Zonesで使用する場合、ユーザーが向いているドメインが複数のアプリケーションを提供している可能性があるため、明示的にユーザーが向いているオリジンを許可する必要があります。`next.config.js`ファイルに次の行を追加してください：

```js title="next.config.js"
const nextConfig = {
  experimental: {
    serverActions: {
      allowedOrigins: ['your-production-domain.com'],
    },
  },
}
```

詳しくは[`serverActions.allowedOrigins`](/docs/app/api-reference/next-config-js/serverActions#allowedorigins)を参照してください。

</AppOnly>
