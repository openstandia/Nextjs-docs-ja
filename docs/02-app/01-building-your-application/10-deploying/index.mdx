---
title: 'デプロイ'
description: 'Next.jsアプリを本番環境にデプロイする方法を、マネージドおよびセルフホストの両方で学びます。'
---

{/* このドキュメントの内容は、app と pages router の間で共有されています。Pages Router 独自のコンテンツを追加するには、 `<PagesOnly>Content</PagesOnly>` コンポーネントを使用してください。共有コンテンツはコンポーネントにラップしないでください。 */}

おめでとうございます、いよいよ本番環境に出荷する時が来ました。

[マネージドのNext.jsをVercelで](#managed-nextjs-with-vercel)デプロイするか、Node.jsサーバー、Dockerイメージ、または静的HTMLファイルでセルフホストすることができます。`next start`を使用してデプロイする場合、すべてのNext.jsの機能がサポートされます。

## 本番ビルド

`next build`を実行することで、本番環境向けに最適化されたアプリケーションバージョンが生成されます。ページに基づいてHTML、CSS、JavaScriptファイルが作成されます。JavaScriptは[Next.js Compiler](/docs/architecture/nextjs-compiler)を使用して**コンパイル**され、ブラウザバンドルは**圧縮**され、最高のパフォーマンスとすべての[モダンブラウザのサポート](/docs/architecture/supported-browsers)を達成します。

Next.jsは、マネージドおよびセルフホストのNext.jsで使用される標準的なデプロイ出力を生成します。これにより、すべてのデプロイ方法で機能がサポートされることが保証されます。次のメジャーバージョンでは、この出力を[Build Output APIの仕様](https://vercel.com/docs/build-output-api/v3?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)に変換する予定です。

## マネージドNext.jsをVercelで

Next.jsの作成者およびメンテナである[Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)は、Next.jsアプリケーションのためのマネージドインフラストラクチャと開発者体験プラットフォームを提供しています。

Vercelへデプロイするのは設定不要で、グローバルにスケーラビリティ、可用性、パフォーマンスを強化します。とはいえ、セルフホストする場合でも、すべてのNext.jsの機能はサポートされています。

[Next.js on Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)や[無料のテンプレートをデプロイ](https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)してお試しください。

## セルフホスティング

Next.jsをセルフホストする方法は3つあります：

- [Node.jsサーバー](#nodejs-server)
- [Dockerコンテナ](#docker-image)
- [静的エクスポート](#static-html-export)

> **🎥 視聴:** セルフホスティングNext.jsについてもっと詳しく知る → [YouTube (45分)](https://www.youtube.com/watch?v=sIVL4JMqRfc)。

### Node.jsサーバー

Next.jsは、Node.jsをサポートする任意のホスティングプロバイダにデプロイできます。`package.json`に `"build"` と `"start"` スクリプトを追加することを確認してください：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

次に、`npm run build`を実行してアプリケーションをビルドします。最後に、`npm run start`を実行してNode.jsサーバーを起動します。このサーバーはNext.jsのすべての機能をサポートします。

### Dockerイメージ

Next.jsは、[Docker](https://www.docker.com/)コンテナをサポートする任意のホスティングプロバイダにデプロイできます。この方法を使用して、[Kubernetes](https://kubernetes.io/)などのコンテナオーケストレーターにデプロイしたり、クラウドプロバイダ内のコンテナで実行したりできます。

1. マシンに[Dockerをインストール](https://docs.docker.com/get-docker/)
2. 私たちの[例をクローン](https://github.com/vercel/next.js/tree/canary/examples/with-docker)します（または[複数環境の例](https://github.com/vercel/next.js/tree/canary/examples/with-docker-multi-env)）
3. コンテナをビルド：`docker build -t nextjs-docker .`
4. コンテナを実行：`docker run -p 3000:3000 nextjs-docker`

Dockerを通じてのNext.jsは、すべてのNext.jsの機能をサポートします。

### 静的HTMLエクスポート

Next.jsは静的サイトまたはシングルページアプリケーション（SPA）として開始し、後でオプションでサーバーを必要とする機能を使用するようアップグレードできます。

Next.jsはこの[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)をサポートしているため、HTML/CSS/JSの静的資産を提供できる任意のウェブサーバーにデプロイおよびホストできます。AWS S3、Nginx、またはApacheなどのツールが含まれます。

[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)として実行すると、サーバーを必要とするNext.jsの機能はサポートされません。[詳細はこちら](/docs/app/building-your-application/deploying/static-exports#unsupported-features)を参照してください。

> **知っておくと良い情報:**
>
> - [Server Components](/docs/app/building-your-application/rendering/server-components)は静的エクスポートでサポートされています。

## 機能

### 画像最適化

`next/image`を通じた[画像最適化](/docs/app/building-your-application/optimizing/images)は、`next start`を使用してデプロイする際、セルフホストでゼロ設定で動作します。画像を最適化するために別のサービスが必要な場合は、[画像ローダーを設定](/docs/app/building-your-application/optimizing/images#loaders)できます。

画像最適化は、`next.config.js`にカスタム画像ローダーを定義することで、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports#image-optimization)と共に使用できます。なお、画像はビルド時ではなく、実行時に最適化されます。

> **知っておくと良い情報:**
>
> - glibcベースのLinuxシステムでは、画像最適化には過度のメモリ消費を防ぐための[追加の設定](https://sharp.pixelplumbing.com/install#linux-memory-allocator)が必要になる場合があります。
> - 最適化された画像の[キャッシュ動作](https://sharp.pixelplumbing.com/install#linux-memory-allocator)とTTLの設定についてもっと詳しく知る。
> - 画像が別途最適化されている場合、画像最適化を[無効にする](/docs/app/api-reference/components/image#unoptimized)こともでき、`next/image`を使用する他の利点を保持できます。

### ミドルウェア

[ミドルウェア](/docs/app/building-your-application/routing/middleware)は、`next start`を使用してデプロイする際、セルフホストでゼロ設定で動作します。受信リクエストへのアクセスが必要なため、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)ではサポートされません。

ミドルウェアは、アプリケーション内のすべてのルートまたは資産の前で実行される可能性があるため、低レイテンシーを保証するために使用される、すべての利用可能なNode.js APIのサブセットである[ランタイム](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を使用します。このランタイムは「エッジで」実行する必要はなく、単一リージョンのサーバーで動作します。ミドルウェアを複数の地域で実行するには、追加の設定とインフラストラクチャが必要です。

すべてのNode.js APIを必要とするロジックを追加（または外部パッケージを使用）したい場合は、このロジックを[レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#layouts)の[Server Component](/docs/app/building-your-application/rendering/server-components)に移動できるかもしれません。たとえば、[ヘッダー](/docs/app/api-reference/functions/headers)をチェックし、[リダイレクト](/docs/app/api-reference/functions/redirect)を行います。`next.config.js`を通して、ヘッダー、クッキー、クエリパラメータを使用して[リダイレクト](/docs/app/api-reference/next-config-js/redirects#header-cookie-and-query-matching)や[リライト](/docs/app/api-reference/next-config-js/rewrites#header-cookie-and-query-matching)することもできます。それが機能しない場合は、[カスタムサーバー](/docs/pages/building-your-application/configuring/custom-server)を使用することもできます。

### 環境変数

Next.jsはビルド時と実行時の環境変数をサポートできます。

**デフォルトでは、環境変数はサーバー上でのみ利用可能です**。環境変数をブラウザに公開するには、`NEXT_PUBLIC_`プレフィックスを付ける必要があります。ただし、これらの公開環境変数は`next build`中にJavaScriptバンドルにインライン化されます。

<PagesOnly>

実行時の環境変数を読み取るには、`getServerSideProps`を利用するか、[アプリケーションルーターを段階的に導入することをお勧めします](/docs/app/building-your-application/upgrading/app-router-migration)。

</PagesOnly>

<AppOnly>

サーバー上で動的レンダリング中に安全に環境変数を読み取ります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.ts" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies, headers, and other Dynamic APIs
  // will also opt into dynamic rendering, meaning
  // this env variable is evaluated at runtime
  const value = process.env.MY_VALUE
  // ...
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies, headers, and other Dynamic APIs
  // will also opt into dynamic rendering, meaning
  // this env variable is evaluated at runtime
  const value = process.env.MY_VALUE
  // ...
}
```
</TabItem>
</Tabs>


</AppOnly>

これにより、異なる値を持つ複数の環境にプロモートできる単一のDockerイメージを使用することができます。

> **知っておくと良い情報:**
>
> - [`register`関数](/docs/app/building-your-application/optimizing/instrumentation)を使用してサーバー起動時にコードを実行できます。
> - [runtimeConfig](/docs/pages/api-reference/next-config-js/runtime-configuration)オプションは、スタンドアロン出力モードと互換性がないため、使用を推奨しません。代わりに、アプリケーションルーターを[段階的に導入します](/docs/app/building-your-application/upgrading/app-router-migration)ことをお勧めします。

### キャッシングとISR

Next.jsは、レスポンス、生成された静的ページ、ビルド出力、画像、フォント、スクリプトなどの他の静的資産をキャッシュすることができます。

ページのキャッシングと再検証は、[増分静的再生成（Incremental Static Regeneration）](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)で行われます。このキャッシュはファイルシステム（ディスク）にデフォルトで保存されます。この機能は、PagesとApp Routerでセルフホスト時に自動的に機能します。

キャッシュされたページやデータを耐久性のあるストレージに永続化したい場合やNext.jsアプリケーションの複数のコンテナやインスタンスでキャッシュを共有したい場合、Next.jsキャッシュの場所を設定することができます。

#### 自動キャッシング

- Next.jsは`public, max-age=31536000, immutable`の`Cache-Control`ヘッダーを本当に不変な資産に設定します。これはオーバーライドできません。これらの不変ファイルには、ファイル名にSHAハッシュが含まれているため、安全に無期限でキャッシュできます。たとえば、[静的画像インポート](/docs/app/building-your-application/optimizing/images#local-images)が含まれます。画像の[TTLを設定](/docs/app/api-reference/components/image#caching-behavior)できます。
- 増分静的再生成（ISR）は、`s-maxage: <revalidate in getStaticProps>, stale-while-revalidate`の`Cache-Control`ヘッダーを設定します。この再検証時間は、[`getStaticProps`関数](/docs/pages/building-your-application/data-fetching/get-static-props)で秒単位で定義されます。`revalidate: false`を設定すると、デフォルトで1年のキャッシュ期間になります。
- 動的にレンダリングされたページは、ユーザー固有のデータがキャッシュされないようにするために、`private, no-cache, no-store, max-age=0, must-revalidate`の`Cache-Control`ヘッダーを設定します。これはApp RouterとPages Routerの両方に適用されます。[ドラフトモード](/docs/app/building-your-application/configuring/draft-mode)も含まれます。

#### 静的資産

静的資産を異なるドメインやCDNでホストしたい場合は、`next.config.js`の`assetPrefix` [設定](/docs/app/api-reference/next-config-js/assetPrefix)を使用できます。Next.jsはJavaScriptやCSSファイルを取得する際にこの資産プレフィックスを使用します。資産を別のドメインに分けることで、DNSとTLSの解決に余分な時間がかかるというデメリットがあります。

[`assetPrefix`についてもっと知る](/docs/app/api-reference/next-config-js/assetPrefix)。

#### キャッシュの設定

デフォルトでは、生成されたキャッシュ資産はメモリ（デフォルトで50MB）とディスクに保存されます。Kubernetesのようなコンテナオーケストレーションプラットフォームを使用してNext.jsをホストしている場合、各ポッドはキャッシュのコピーを持ちます。キャッシュがデフォルトでポッド間で共有されていないため、古いデータが表示されないようにするには、Next.jsキャッシュを設定してキャッシュハンドラーを提供し、メモリ内キャッシュを無効にします。

セルフホスト時にISR/データキャッシュの場所を設定するには、`next.config.js`ファイルにカスタムハンドラーを設定できます：

```jsx title="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // デフォルトのメモリ内キャッシュを無効にします
}
```

次に、プロジェクトのルートに`cache-handler.js`を作成します。たとえば：

```jsx title="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // これはどこにでも保存できます。耐久性のあるストレージのように
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // これはどこにでも保存できます。耐久性のあるストレージのように
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // tags は文字列または文字列の配列です
    tags = [tags].flat()
    // キャッシュ内のすべてのエントリを繰り返す
    for (let [key, value] of cache) {
      // 値のタグに指定されたタグが含まれている場合、このエントリを削除する
      if (value.tags.some((tag) => tags.include(tag))) {
        cache.delete(key)
      }
    }
  }
}
```

カスタムキャッシュハンドラーを使用することで、Next.jsアプリケーションをホストしているすべてのポッド間での一貫性を確保できます。たとえば、[Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis)やAWS S3のように、キャッシュされた値をどこにでも保存できます。

> **知っておくと良い情報:**
>
> - `revalidatePath`はキャッシュタグの上位レイヤーです。`revalidatePath`の呼び出しは、提供されたページの特別なデフォルトタグを持つ`revalidateTag`関数を呼び出します。

### ビルドキャッシュ

Next.jsは、`next build`中にあなたのアプリケーションのどのバージョンが提供されているかを識別するためにIDを生成します。同じビルドを使用して複数のコンテナを起動する必要があります。

環境の各ステージに対して再ビルドしている場合は、コンテナ間で使用する一貫したビルドIDを生成する必要があります。`next.config.js`の`generateBuildId`コマンドを使用してください：

```jsx title="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // これは最新のgitハッシュを使用することです
    return process.env.GIT_HASH
  },
}
```

### バージョンのスキュー

Next.jsは、ほとんどの[バージョンスキュー](https://www.industrialempathy.com/posts/version-skew/)のインスタンスを自動的に緩和し、検出されたときに新しい資産を取得するためにアプリケーションを自動的にリロードします。たとえば、`deploymentId`の不一致がある場合、ページ間の移行は、prefetched値を使用する代わりに、強制的なナビゲーションを行います。

アプリケーションがリロードされると、ページナビゲーション間で持続するように設計されていないアプリケーションステートが失われる可能性があります。たとえば、URLステートやローカルストレージを使用すれば、ページリフレッシュ後にステートを保持できます。ただし、`useState`のようなコンポーネントステートは、そのようなナビゲーションでは失われます。

Vercelは、新しいバージョンがデプロイされた後でも、古いクライアントに以前のバージョンからの資産と機能がまだ利用可能であることを保証するために、Next.jsアプリケーションに[スキュー保護](https://vercel.com/docs/deployments/skew-protection?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)を追加で提供します。

各リクエストが`?dpl`クエリ文字列または`x-deployment-id`ヘッダーを使用するようにするには、手動で`next.config.js`ファイルの`deploymentId`プロパティを構成できます。

<AppOnly>

### ストリーミングとサスペンス

Next.js App Routerは、セルフホスト時に[ストリーミングレスポンス](/docs/app/building-your-application/routing/loading-ui-and-streaming)をサポートします。Nginxや類似のプロキシを使用している場合は、バッファリングを無効にしてストリーミングを有効にするように設定する必要があります。

たとえば、`X-Accel-Buffering`を`no`に設定してNginxでバッファリングを無効にできます：

```js title="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

### 部分的プリレンダリング

[部分的プリレンダリング（実験的）](/docs/app/building-your-application/rendering/partial-prerendering)は、デフォルトでNext.jsと共に機能します。これはCDN機能ではありません。これは、Node.jsサーバーとしてのデプロイ（`next start`を通じて）や、Dockerコンテナでの使用を含みます。

### CDNの使用

Next.jsアプリケーションの前にCDNを使用する場合、ページには動的なAPIがアクセスされたときに`Cache-Control: private`レスポンスヘッダーが含まれます。これにより、結果として得られるHTMLページがキャッシュ可能でないことが保証されます。ページが完全に静的にプリレンダリングされた場合、CDN上でページがキャッシュされることを許可するために`Cache-Control: public`が含まれます。

静的および動的なコンポーネントの両方のミックスが必要ない場合は、ルート全体を静的にし、出力HTMLをCDNでキャッシュできます。この自動静的最適化は、動的なAPIが使用されていない場合、`next build`を実行したときのデフォルトの動作です。

</AppOnly>

<PagesOnly>

## 手動のグレースフルシャットダウン

セルフホスティング時には、`SIGTERM`や`SIGINT`シグナルでサーバーがシャットダウンする際にコードを実行したいかもしれません。

環境変数`NEXT_MANUAL_SIG_HANDLE`を`true`に設定し、そのシグナル用のハンドラーを`_document.js`ファイル内に登録できます。環境変数は`.env`ファイル内ではなく、`package.json`スクリプトに直接登録する必要があります。

> **知っておくと良い情報**：手動のシグナル処理は、`next dev`では利用できません。

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js title="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('Received SIGTERM: cleaning up')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('Received SIGINT: cleaning up')
    process.exit(0)
  })
}
```

</PagesOnly>

{/* NOTE: この <DocCardList /> は手動で追加しています。自動翻訳等で更新され消えてしまった場合、必要に応じて再度追加しなおしてください */}

<DocCardList />