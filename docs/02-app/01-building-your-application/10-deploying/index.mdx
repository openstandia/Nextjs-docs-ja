---
title: デプロイ
description: Next.js アプリを本番環境にデプロイする方法を学びましょう。マネージドまたはセルフホストのいずれでも可能です。
---

{/* このドキュメントの内容は、アプリとページルーターの間で共有されています。`<PagesOnly>Content</PagesOnly>`コンポーネントを使用して、ページルーター固有のコンテンツを追加することができます。共有コンテンツはコンポーネントでラップしないでください。 */}

おめでとうございます。いよいよ本番環境に出荷する時が来ました。

[マネージドNext.jsをVercelでデプロイ](#vercelを用いたマネージドnextjs)するか、Node.jsサーバー、Dockerイメージ、あるいは静的HTMLファイルとしてセルフホストすることができます。`next start`を使用してデプロイする場合は、すべてのNext.js機能がサポートされます。

## プロダクションビルド

`next build`を実行すると、アプリケーションの最適化されたバージョンが本番用に生成されます。ページに基づいてHTML、CSS、およびJavaScriptファイルが作成されます。JavaScriptは**コンパイル**され、ブラウザーバンドルは[Next.js Compiler](/docs/architecture/nextjs-compiler)を使用して**圧縮**され、最高のパフォーマンスを達成し、[すべての最新ブラウザー](/docs/architecture/supported-browsers)をサポートします。

Next.jsは、マネージドおよびセルフホストのNext.jsで使用される標準的なデプロイメント出力を生成します。これにより、すべてのデプロイメント方法で全機能がサポートされることが保証されます。次のメジャーバージョンでは、この出力を[Build Output API仕様](https://vercel.com/docs/build-output-api/v3?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)に変換する予定です。

## Vercelを用いたマネージドNext.js

Next.jsのクリエイターおよびメンテナーである[Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)は、Next.jsアプリケーションのためのマネージドインフラストラクチャと開発者エクスペリエンスプラットフォームを提供しています。

Vercelへのデプロイはゼロコンフィギュレーションで行え、スケーラビリティ、可用性、およびグローバルなパフォーマンスのための追加の強化が提供されます。とはいえ、セルフホストでもすべてのNext.js機能がサポートされます。

[Next.js on Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)についての詳細や、[テンプレートを無料でデプロイ](https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)して試してみることができます。

## セルフホスティング

Next.jsをセルフホスティングする手段は3つあります：

- [Node.jsサーバー](#nodejs-server)
- [Dockerコンテナ](#docker-image)
- [静的エクスポート](#static-html-export)

### Node.jsサーバー

Next.jsは、Node.jsをサポートしている任意のホスティングプロバイダにデプロイできます。`package.json`に`"build"`および`"start"`スクリプトがあることを確認してください：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

その後、`npm run build`を実行してアプリケーションをビルドします。最後に、`npm run start`を実行してNode.jsサーバーを開始します。このサーバーはNext.jsのすべての機能をサポートします。

### Dockerイメージ

Next.jsは、[Docker](https://www.docker.com/)コンテナをサポートしている任意のホスティングプロバイダにデプロイ可能です。この方法は、[Kubernetes](https://kubernetes.io/)のようなコンテナオーケストレーターへのデプロイや、任意のクラウドプロバイダーでコンテナ内で実行するときにも使用できます。

1. マシンに[Dockerをインストール](https://docs.docker.com/get-docker/)
2. [例をクローン](https://github.com/vercel/next.js/tree/canary/examples/with-docker)（または[マルチ環境の例](https://github.com/vercel/next.js/tree/canary/examples/with-docker-multi-env)）
3. コンテナをビルド：`docker build -t nextjs-docker .`
4. コンテナを実行：`docker run -p 3000:3000 nextjs-docker`

Docker経由のNext.jsは、Next.jsのすべての機能をサポートします。

### 静的HTMLエクスポート

Next.jsは、静的サイトまたはシングルページアプリケーション（SPA）として開始し、後でサーバーを必要とする機能を使用するようにオプションでアップグレードすることを可能にします。

Next.jsは、この[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)をサポートしているため、HTML/CSS/JS静的アセットを提供できる任意のWebサーバーでデプロイおよびホスティング可能です。これには、AWS S3、Nginx、Apacheなどのツールが含まれます。

[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)として実行する場合、サーバーを必要とするNext.js機能はサポートされません。[詳細はこちら](/docs/app/building-your-application/deploying/static-exports#unsupported-features).

> **Good to know:**
>
> - [サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)は、静的エクスポートでサポートされています。

## 機能

### 画像の最適化

`next/image`を利用した[画像の最適化](/docs/app/building-your-application/optimizing/images)は、`next start`を用いたデプロイ時に、ゼロコンフィギュレーションでセルフホスティングでも機能します。別のサービスで画像を最適化したい場合は、[画像ローダーを設定](/docs/app/building-your-application/optimizing/images#loaders)することができます。

`next.config.js`でカスタム画像ローダーを定義することで、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports#image-optimization)と共に画像の最適化を使用できます。画像はビルド時ではなく、ランタイムで最適化されることに注意してください。

> **Good to know:**
>
> - glibcベースのLinuxシステムでは、過度なメモリ使用を防ぐために画像の最適化に[追加の設定](https://sharp.pixelplumbing.com/install#linux-memory-allocator)が必要な場合があります。
> - 最適化された画像のキャッシング動作についての[詳細情報](/docs/app/api-reference/components/image#caching-behavior)とTTLの設定方法。
> - もしあなたが別途画像を最適化している場合でも、`next/image`の他の利点を維持しつつ[画像の最適化を無効化](/docs/app/api-reference/components/image#unoptimized)できます。

### ミドルウェア

ミドルウェア](/docs/app/building-your-application/routing/middleware)は、`next start`を用いたデプロイ時にセルフホスティングでもゼロコンフィギュレーションで機能します。これには受信要求へのアクセスが必要なため、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)に使用する場合にはサポートされません。

ミドルウェアは、すべての利用可能なNode.js APIのサブセットである[ランタイム](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を使用して、低遅延を確保します。これは、アプリケーションのすべてのルートやアセットの前に実行される可能性があるためです。このランタイムは「エッジ」上で実行する必要はなく、単一のリージョンサーバーでも機能します。ただし、ミドルウェアを複数のリージョンで実行するためには追加の設定とインフラストラクチャが必要です。

すべてのNode.js APIが必要なロジック（または外部パッケージの使用）を追加したい場合は、ロジックを[レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#layouts)として[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)に移動することができるかもしれません。たとえば、[ヘッダー](/docs/app/api-reference/functions/headers)の確認や[リダイレクト](/docs/app/api-reference/functions/redirect)などを行う場合です。`next.config.js`を通じて、ヘッダー、クッキー、またはクエリパラメータを使用して[リダイレクト](/docs/app/api-reference/next-config-js/redirects#header-cookie-and-query-matching)や[書き換え](/docs/app/api-reference/next-config-js/rewrites#header-cookie-and-query-matching)を行うこともできます。それがうまくいかない場合は、[カスタムサーバ](/docs/pages/building-your-application/configuring/custom-server)を使用することも可能です。

### 環境変数

Next.jsはビルド時およびランタイムの環境変数の両方をサポートできます。

**デフォルトでは、環境変数はサーバーでのみ利用可能です**。環境変数をブラウザに公開するには、`NEXT_PUBLIC_`で接頭辞を付ける必要があります。ただし、これらの公開環境変数は`next build`中にJavaScriptバンドルにインライン化されます。

ランタイム環境変数を読み込むには、`getServerSideProps`を使用するか[Appルーターへの漸進的な採用](/docs/app/building-your-application/upgrading/app-router-migration)をお勧めします。Appルーターを使用すると、動的レンダリング中にサーバー上で安全に環境変数を読み取ることができます。これにより、異なる値を持つ複数の環境を通じて昇格できる単一のDockerイメージを使用できます。

```jsx
import { unstable_noStore as noStore } from 'next/cache';

export default function Component() {
  noStore();
  // cookies(), headers(), and other dynamic functions
  // will also opt into dynamic rendering, making
  // this env variable is evaluated at runtime
  const value = process.env.MY_VALUE
  ...
}
```

> **Good to know:**
>
> - サーバースタートアップ時にコードを実行するためには、[`register`関数](/docs/app/building-your-application/optimizing/instrumentation)を使用することができます。
> - [runtimeConfig](/docs/pages/api-reference/next-config-js/runtime-configuration)オプションの使用はお勧めしません。これはスタンドアロン出力モードで機能しないためです。代わりに、Appルーターへの[漸進的な採用](/docs/app/building-your-application/upgrading/app-router-migration)をお勧めします。

### キャッシングとISR

Next.jsは、レスポンス、生成された静的ページ、ビルドアウトプット、および画像、フォント、スクリプトといったその他の静的アセットをキャッシュできます。

ページのキャッシングと再検証は、（[漸進的な静的再生成](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)を使用して）**同じ共有キャッシュ**を使用します。デフォルトでは、このキャッシュはNext.jsサーバー上のファイルシステム（ディスク上）に保存されます。**セルフホスティングの場合、これは自動的に機能します**。Pagesルーターとアプリルーターの両方で。

キャッシュされたページやデータを永続的なストレージに保存したり、Next.jsアプリケーションの複数コンテナやインスタンス間でキャッシュを共有したい場合は、Next.jsキャッシュの保存場所を設定できます。

#### 自動キャッシング

- Next.jsは、本当に不変なアセットに対して`public, max-age=31536000, immutable`の`Cache-Control`ヘッダーを設定します。これはオーバーライドできません。これらの不変ファイルはファイル名にSHAハッシュを含み、そのため無限にキャッシュできます。たとえば、[静的画像インポート](/docs/app/building-your-application/optimizing/images#local-images)などです。画像の[TTLを設定](/docs/app/api-reference/components/image#caching-behavior)することができます。
- 漸進的静的再生成（ISR）は、`getStaticProps`の`revalidate`で指定された`Cache-Control`ヘッダーを`s-maxage: <revalidate in getStaticProps>, stale-while-revalidate`に設定します。この再検証時間は、[`getStaticProps`関数](/docs/pages/building-your-application/data-fetching/get-static-props)で秒単位で定義されています。`revalidate: false`が設定されている場合、デフォルトで1年間のキャッシュ期間が適用されます。
- 動的にレンダリングされたページは、ユーザー固有のデータがキャッシュされないようにするために、`Cache-Control`ヘッダーを`private, no-cache, no-store, max-age=0, must-revalidate`に設定します。これはアプリルーターとページルーターの両方に適用されます。これには[ドラフトモード](/docs/app/building-your-application/configuring/draft-mode)も含まれます。

#### 静的アセット

他のドメインまたはCDN上で静的アセットをホストしたい場合は、`next.config.js`で`assetPrefix` [設定](/docs/app/api-reference/next-config-js/assetPrefix)を使用できます。Next.jsはJavaScriptやCSSファイルの取得時にこのアセットプレフィックスを使用します。アセットを別のドメインに分離することは、DNSとTLSの解決にかかる時間が増えるという欠点を伴います。

[`assetPrefix`についての詳細](/docs/app/api-reference/next-config-js/assetPrefix).

#### キャッシングの設定

デフォルトで、生成されたキャッシュアセットはメモリに保存されます（デフォルトは50mb）とディスクに保存されます。Kubernetesのようなコンテナオーケストレーションプラットフォームを使用してNext.jsをホスティングする場合、各ポッドはキャッシュのコピーを持つことになります。デフォルトではポッド間でキャッシュが共有されないため、古いデータが表示されないようにするには、Next.jsキャッシュを設定してキャッシュハンドラーを提供し、メモリ内キャッシュを無効にすることができます。

セルフホスティング時にISR/データキャッシュの場所を設定するには、`next.config.js`ファイルにカスタムハンドラーを設定することができます：

```jsx title="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // デフォルトのメモリキャッシングを無効化します
}
```

その後、プロジェクトのルートに`cache-handler.js`を作成します。例えば：

```jsx title="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // ここには、耐久性のあるストレージのような場所に保存されるかもしれません
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // ここには、耐久性のあるストレージのような場所に保存されるかもしれません
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // tagsは文字列または文字列の配列です
    tags = [tags].flat()
    // キャッシュ内のすべてのエントリを反復処理します
    for (let [key, value] of cache) {
      // 指定されたタグが値のタグに含まれている場合、このエントリを削除します
      if (value.tags.some((tag) => tags.include(tag))) {
        cache.delete(key)
      }
    }
  }
}
```

カスタムキャッシュハンドラーを使用すると、Next.jsアプリケーションをホスティングしているすべてのポッド間で一貫性を確保することができます。たとえば、キャッシュされた値を[Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis)やAWS S3のどこにでも保存できます。

> **Good to know:**
>
> - `revalidatePath`はキャッシュタグの上層の便利なレイヤーです。`revalidatePath`を呼び出すと、指定されたページに対する特別なデフォルトのタグで`revalidateTag`関数が呼び出されます。

### ビルドキャッシュ

Next.jsは、どのバージョンのアプリケーションが提供されているかを特定するために、`next build`の際にIDを生成します。同じビルドを使用して、複数のコンテナを起動する必要があります。

もし、環境の各ステージごとに再ビルドしている場合、コンテナ間で使用するための一貫したビルドIDを生成する必要があります。`next.config.js`の`generateBuildId`コマンドを使用してください：

```jsx title="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // これは最新のgitハッシュを使用するなど、何でもできます
    return process.env.GIT_HASH
  },
}
```

### バージョンスキュー

Next.jsは、ほとんどの[バージョンスキュー](https://www.industrialempathy.com/posts/version-skew/)のインスタンスを自動的に緩和し、検出されたときに新しいアセットを取得するためにアプリケーションを自動的にリロードします。たとえば、`deploymentId`に不一致がある場合、ページ間の移行は事前取得された値の使用を避けてハードナビゲーションを行います。

アプリケーションがリロードされると、ページナビゲーション間での永続化が設計されていない限り、アプリケーションステートが失われる場合があります。たとえば、URLステートやローカルストレージを使用すると、ページリフレッシュ後もステートを保持できます。ただし、`useState`のようなコンポーネントステートは、このようなナビゲーションで失われます。

Vercelは、Next.jsアプリケーションに対して追加の[スキュー保護](https://vercel.com/docs/deployments/skew-protection?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)を提供し、新しいバージョンがデプロイされた後でも、古いクライアントに以前のバージョンのアセットおよび関数が引き続き利用可能であることを保証します。

`next.config.js`ファイルの`deploymentId`プロパティを手動で設定し、各リクエストで`?dpl`クエリ文字列または`x-deployment-id`ヘッダーを使用して使用するように設定できます。

<AppOnly>

### ストリーミングとサスペンス

Next.jsのアプリルーターは、セルフホスティング時に[ストリーミングレスポンス](/docs/app/building-your-application/routing/loading-ui-and-streaming)をサポートしています。Nginxなどのプロキシを使用している場合は、ストリーミングを有効にするためにバッファリングを無効にするように設定する必要があります。

たとえば、Nginxでバッファリングを無効にするには、`X-Accel-Buffering`を`no`に設定します：

```js title="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

### 部分的プリレンダリング

[部分的プリレンダリング（実験的）](/docs/app/building-your-application/rendering/partial-prerendering)は、Next.jsでデフォルトで機能し、CDN機能ではありません。これには、Node.jsサーバーとしてのデプロイ（`next start`経由）とDockerコンテナでの使用が含まれます。

### CDNでの使用

Next.jsアプリケーションの前にCDNを使用する場合、動的APIにアクセスするとページには`Cache-Control: private`レスポンスヘッダーが含まれます。これにより、生成されたHTMLページがキャッシュ不可能としてマークされます。ページが完全に静的にプリレンダリングされている場合、CDNでページがキャッシュできるように、`Cache-Control: public`が含まれます。

静的コンポーネントと動的コンポーネントの両方が混在する必要がない場合、ルート全体を静的にして出力HTMLをCDNでキャッシュ化することができます。この自動静的最適化は、動的APIが使用されていない場合に`next build`の実行時にデフォルトの動作です。

</AppOnly>

<PagesOnly>

## 手動のグレースフルシャットダウン

セルフホスティング時に、サーバーが`SIGTERM`または`SIGINT`信号でシャットダウンするときにコードを実行したい場合があります。

環境変数`NEXT_MANUAL_SIG_HANDLE`を`true`に設定し、`\_document.js`ファイル内にそのシグナル用のハンドラーを登録できます。環境変数を`.env`ファイル内ではなく、`package.json`スクリプトに直接登録する必要があります。

> **Good to know**: マニュアルシグナル処理は`next dev`では利用できません。

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js title="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('Received SIGTERM: cleaning up')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('Received SIGINT: cleaning up')
    process.exit(0)
  })
}
```

</PagesOnly>