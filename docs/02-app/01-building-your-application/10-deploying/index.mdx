---
title: 'デプロイ'
description: '管理またはセルフホスト型のいずれかで、Next.jsアプリケーションを本番環境にデプロイする方法を学びます。'
---

{/* このドキュメントの内容は、app routerとpages routerの間で共有されています。`<PagesOnly>Content</PagesOnly>`コンポーネントを使用して、Pages Routerに固有のコンテンツを追加できます。共有コンテンツはコンポーネントでラップしないでください。 */}

おめでとうございます。いよいよ本番環境に出荷する時が来ました。

[管理されたNext.jsをVercelでデプロイ](#managed-next-js-with-vercel)するか、Node.jsサーバー、Dockerイメージ、または静的HTMLファイルとしてセルフホストすることができます。`next start`を使用してデプロイする際には、すべてのNext.js機能がサポートされます。

## 本番ビルド {#production-builds}

`next build`を実行すると、アプリケーションの最適化されたバージョンが生成されます。ページに基づいてHTML、CSS、JavaScriptファイルが作成されます。JavaScriptは**コンパイル**され、ブラウザバンドルはNext.js Compilerを使用して**最小化**され、最適なパフォーマンスを達成し、[すべての最新ブラウザ](/docs/architecture/supported-browsers)をサポートします。

Next.jsは、管理されたNext.jsとセルフホスト型Next.jsで使用される標準的なデプロイメント出力を生成します。これにより、両方のデプロイメント方法で機能がサポートされることが保証されます。次のメジャーバージョンでは、この出力を私たちの[ビルド出力API仕様](https://vercel.com/docs/build-output-api/v3?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)に変換する予定です。

## 管理されたNext.jsをVercelで {#managed-next-js-with-vercel}

[Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)は、Next.jsの作成者であり、Next.jsアプリケーションのための管理されたインフラストラクチャと開発者体験プラットフォームを提供します。

Vercelへのデプロイはゼロ設定で行え、スケーラビリティ、可用性、およびパフォーマンスの強化をグローバルに提供します。ただし、セルフホストしてもすべてのNext.js機能がサポートされます。

[Next.js on Vercelについてさらに学ぶ](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)か、[無料でテンプレートをデプロイ](https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)して試してみてください。

## セルフホスティング {#self-hosting}

Next.jsをセルフホストする方法は3つあります：

- [Node.jsサーバー](#node-js-server)
- [Dockerコンテナ](#docker-image)
- [静的エクスポート](#static-html-export)

> **🎥 視聴:** Next.jsをセルフホストする方法を学ぶ→ [YouTube（45分）](https://www.youtube.com/watch?v=sIVL4JMqRfc).

次のプロバイダーでのコミュニティが維持するデプロイ例もあります：

- [Deno](https://github.com/nextjs/deploy-deno)
- [DigitalOcean](https://github.com/nextjs/deploy-digitalocean)
- [Flightcontrol](https://github.com/nextjs/deploy-flightcontrol)
- [Fly.io](https://github.com/nextjs/deploy-fly)
- [GitHub Pages](https://github.com/nextjs/deploy-github-pages)
- [Google Cloud Run](https://github.com/nextjs/deploy-google-cloud-run)
- [Railway](https://github.com/nextjs/deploy-railway)
- [Render](https://github.com/nextjs/deploy-render)
- [SST](https://github.com/nextjs/deploy-sst)

### Node.jsサーバー {#node-js-server}

Next.jsは、Node.jsをサポートする任意のホスティングプロバイダーにデプロイできます。`package.json`に`"build"`と`"start"`スクリプトが含まれていることを確認してください：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

その後、`npm run build`を実行してアプリケーションをビルドします。最後に、`npm run start`を実行してNode.jsサーバーを開始します。このサーバーはすべてのNext.js機能をサポートします。

### Dockerイメージ {#docker-image}

Next.jsは、[Docker](https://www.docker.com/)コンテナをサポートする任意のホスティングプロバイダーにデプロイできます。このアプローチは、[Kubernetes](https://kubernetes.io/)のようなコンテナオーケストレーションを行う場合や、任意のクラウドプロバイダーでコンテナ内で実行する場合に使用できます。

1. あなたのマシンに[Dockerをインストール](https://docs.docker.com/get-docker/)してください
2. 私たちの[例をクローン](https://github.com/vercel/next.js/tree/canary/examples/with-docker)（または[マルチ環境の例](https://github.com/vercel/next.js/tree/canary/examples/with-docker-multi-env)）
3. コンテナをビルドします：`docker build -t nextjs-docker .`
4. コンテナを実行します：`docker run -p 3000:3000 nextjs-docker`

Dockerを介したNext.jsはすべてのNext.js機能をサポートします。

### 静的HTMLエクスポート {#static-html-export}

Next.jsは、静的サイトまたはシングルページアプリケーション（SPA）として始め、後でサーバーを必要とする機能を使用するようにオプションでアップグレードすることが可能です。

Next.jsがこの[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)をサポートしているため、HTML/CSS/JS静的アセットを提供できる任意のWebサーバーでデプロイし、ホストすることができます。これには、AWS S3、Nginx、またはApacheのようなツールが含まれます。

[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)として実行すると、サーバーを必要とするNext.js機能はサポートされません。[詳細はこちら](/docs/app/building-your-application/deploying/static-exports#unsupported-features).

> **Good to know:**
>
> - [Server Components](/docs/app/building-your-application/rendering/server-components)は静的エクスポートでサポートされます。

## 機能 {#features}

### 画像最適化 {#image-optimization}

`next/image`による[画像最適化](/docs/app/building-your-application/optimizing/images)は、`next start`を使用してデプロイする際にゼロ設定で自己ホスト型で動作します。画像を別のサービスで最適化したい場合は、[画像ローダーを設定](/docs/app/building-your-application/optimizing/images#loaders)することができます。

カスタム画像ローダーを`next.config.js`で定義することで、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports#image-optimization)と一緒に画像最適化を使用できます。画像はビルド時ではなく実行時に最適化されることに注意してください。

> **Good to know:**
>
> - glibcベースのLinuxシステムでは、画像最適化に過剰なメモリ使用を防ぐために[追加の設定](https://sharp.pixelplumbing.com/install#linux-memory-allocator)が必要な場合があります。
> - 最適化された画像の[キャッシング動作](/docs/app/api-reference/components/image#caching-behavior)およびTTLの設定方法について詳しく学べます。
> - 画像最適化を[無効にする](/docs/app/api-reference/components/image#unoptimized)こともできるが、その場合でも`next/image`を使用する他の利点を保持することができます。例えば、あなた自身で画像を別々に最適化している場合です。

### ミドルウェア {#middleware}

[ミドルウェア](/docs/app/building-your-application/routing/middleware)は、`next start`を使用してデプロイする際にゼロ設定で自己ホスト型で動作します。受信リクエストへのアクセスを必要とするため、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)を使用する場合はサポートされていません。

ミドルウェアは、アプリケーション内のすべてのルートまたはアセットの前で実行される可能性があるため、低レイテンシーを確保するために、使用可能なすべてのNode.js APIのサブセットである[ランタイム](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を使用します。このランタイムでは、「エッジで」の実行は必要なく、単一の地域サーバーで動作します。ミドルウェアを複数の地域で実行するためには、追加の設定とインフラが必要です。

すべてのNode.js APIを必要とするロジックを追加したい場合（または外部パッケージを使用したい場合）、それを[レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#layouts)の[Server Component](/docs/app/building-your-application/rendering/server-components)に移動することで実現できるかもしれません。例えば、[ヘッダーチェック](/docs/app/api-reference/functions/headers)と[リダイレクト](/docs/app/api-reference/functions/redirect)です。`next.config.js`を介してヘッダー、cookie、またはクエリパラメーターを使用して、[リダイレクト](/docs/app/api-reference/next-config-js/redirects#header-cookie-and-query-matching)または[書き換え](/docs/app/api-reference/next-config-js/rewrites#header-cookie-and-query-matching)することもできます。それがうまくいかない場合は、[カスタムサーバー](https://nextjs.org/docs/canary/pages/building-your-application/configuring/custom-server)を使用することもできます。

### 環境変数 {#environment-variables}

Next.jsは、ビルド時と実行時の両方の環境変数をサポートできます。

**デフォルトでは、環境変数はサーバーでのみ利用可能です**。ブラウザに環境変数を公開するには、それが`NEXT_PUBLIC_`というプレフィックスで始まっている必要があります。ただし、これらの公開された環境変数は、`next build`の間にJavaScriptバンドルにインラインされます。

<PagesOnly>

実行時環境変数を読み取るには、`getServerSideProps`または[App Routerを漸進的に採用する](/docs/app/building-your-application/upgrading/app-router-migration)の使用をお勧めします。

</PagesOnly>

<AppOnly>

ダイナミックレンダリング中のサーバーで安全に環境変数を読み取ることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.ts" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookie、ヘッダー、その他のダイナミックAPIもダイナミックレンダリングを選択し、
  // このenv変数は実行時に評価されることを意味します
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookie、ヘッダー、その他のダイナミックAPIもダイナミックレンダリングを選択し、
  // このenv変数は実行時に評価されることを意味します
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
</Tabs>

</AppOnly>

これにより、異なる値を持つ複数の環境を通して昇進する単一のDockerイメージを使用することが可能になります。

> **Good to know:**
>
> - ['register'関数](/docs/app/building-your-application/optimizing/instrumentation)を使用してサーバースタートアップ時にコードを実行できます。
> - [runtimeConfig](https://nextjs.org/docs/canary/pages/api-reference/next-config-js/runtime-configuration)オプションの使用はお勧めしません。これはスタンドアロン出力モードで機能しないためです。代わりに、App Routerの[漸進的な採用](/docs/app/building-your-application/upgrading/app-router-migration)をお勧めします。

### キャッシングとISR {#caching-and-isr}

Next.jsは応答、生成された静的ページ、ビルド出力、および画像、フォント、スクリプトなどの他の静的アセットをキャッシュできます。

ページキャッシングと再検証（[Incremental Static Regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)による）では、**同じ共有キャッシュ**が使用されます。デフォルトでは、このキャッシュは（ディスク上の）ファイルシステムに保存されます。**これはセルフホスト時に自動的に動作します**。これはPages RouterとApp Routerの両方で使用可能です。

キャッシュされたページとデータを永続的なストレージに保持したり、Next.jsアプリケーションの複数のコンテナやインスタンスでキャッシュを共有したりするために、Next.jsキャッシュの場所を設定できます。

#### 自動キャッシング {#automatic-caching}

- Next.jsは、`public, max-age=31536000, immutable`の`Cache-Control`ヘッダーを真に不変なアセットに設定します。これは上書きできません。これらの不変のファイルはファイル名にSHAハッシュを含んでいるため、安全に無期限にキャッシュできます。例えば、[静的画像インポート](/docs/app/building-your-application/optimizing/images#local-images)です。画像のTTLを[設定できます](/docs/app/api-reference/components/image#caching-behavior)。
- Incremental Static Regeneration（ISR）は、`s-maxage: <revalidate in getStaticProps>, stale-while-revalidate`の`Cache-Control`ヘッダーを設定します。この再検証時間は[`getStaticProps`関数](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)で秒単位で定義されます。`revalidate: false`を設定すると、デフォルトで1年間のキャッシュ期間になります。
- 動的にレンダリングされたページは、ユーザー固有のデータがキャッシュされないようにするために、`private, no-cache, no-store, max-age=0, must-revalidate`の`Cache-Control`ヘッダーを設定します。これは、App RouterとPages Routerの両方に適用されます。[Draft Mode](/docs/app/building-your-application/configuring/draft-mode)も含まれます。

#### 静的アセット {#static-assets}

静的アセットを異なるドメインやCDNでホストしたい場合は、`next.config.js`の`assetPrefix`[設定](/docs/app/api-reference/next-config-js/assetPrefix)を使用できます。Next.jsはJavaScriptまたはCSSファイルを取得するときにこのアセットプレフィックスを使用します。アセットを異なるドメインに分離することで、DNSとTLSの解決に余分な時間がかかるという欠点があります。

[`assetPrefix`についてもっと学ぶ](/docs/app/api-reference/next-config-js/assetPrefix).

#### キャッシングの設定 {#configuring-caching}

デフォルトでは、生成されたキャッシュアセットはメモリ（最大50mb）およびディスクに保存されます。Next.jsをKubernetesのようなコンテナオーケストレーションプラットフォームを使用してホスティングしている場合、各ポッドにはキャッシュのコピーがあります。キャッシュがポッド間で共有されないために表示されない古いデータを防ぐには、Next.jsキャッシュを構成してキャッシュハンドラを提供し、メモリ内キャッシングを無効化することができます。

セルフホスティング時にISR/データキャッシュの位置を設定するには、`next.config.js`ファイルでカスタムハンドラを設定できます：

```jsx title="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // デフォルトのメモリ内キャッシュを無効化
}
```

次に、プロジェクトのrootに`cache-handler.js`を作成してください。例えば：

```jsx title="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // これは耐久性あるストレージなどに保存できます
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // これは耐久性あるストレージなどに保存できます
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // tagsは文字列または文字列の配列です
    tags = [tags].flat()
    // キャッシュ内のすべてのエントリを反復処理します
    for (let [key, value] of cache) {
      // 値のタグが指定されたタグを含む場合、このエントリを削除します
      if (value.tags.some((tag) => tags.include(tag))) {
        cache.delete(key)
      }
    }
  }
}
```

カスタムキャッシュハンドラを使用すると、Next.jsアプリケーションをホストするすべてのポッド間で一貫性を確保できます。たとえば、キャッシュされた値を[Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis)やAWS S3のような場所に保存できます。

> **Good to know:**
>
> - `revalidatePath`はキャッシュタグの上にある便利なレイヤーです。`revalidatePath`の呼び出しは、提供されたページに対する特別なデフォルトタグで`revalidateTag`関数を呼び出します。

### ビルドキャッシュ {#build-cache}

Next.jsは、`next build`中にアプリケーションが提供されるバージョンを識別するためのIDを生成します。1つのビルドは、複数のコンテナを使用して起動する必要があります。

環境の各ステージごとに再ビルドする場合、コンテナ間で使用する一貫したビルドIDを生成する必要があります。`next.config.js`で`generateBuildId`コマンドを使用します：

```jsx title="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // これは、最新のgitハッシュを使用して何でもよい可能性があります
    return process.env.GIT_HASH
  },
}
```

### バージョンの不一致 {#version-skew}

Next.jsは[バージョンスキュー](https://www.industrialempathy.com/posts/version-skew/)のほとんどのインスタンスを自動的に軽減し、検出時に新しいアセットを取得するためにアプリケーションを自動的にリロードします。たとえば、`deploymentId`に不一致がある場合、ページ間の遷移はプリフェッチ値を使用する代わりにハードナビゲーションを実行します。

アプリケーションがリロードされると、ページナビゲーション間で永続しないように設計されていない場合、アプリケーションの状態が失われる可能性があります。たとえば、URLの状態やローカルストレージを使用すると、ページのリフレッシュ後も状態が永続します。ただし、`useState`のようなコンポーネントの状態は、そのようなナビゲーションで失われます。

Vercelは、Next.jsアプリケーションのための追加の[不均等保護](https://vercel.com/docs/deployments/skew-protection?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)を提供し、新しいバージョンがデプロイされた後でも以前のバージョンの資産と機能が古いクライアントに利用可能であることを保証します。

各リクエストが`?dpl`クエリ文字列または`x-deployment-id`ヘッダーのいずれかを使用するようにするには、`next.config.js`ファイルの`deploymentId`プロパティを手動で設定できます。

<AppOnly>

### ストリーミングとSuspense {#streaming-and-suspense}

Next.js App Routerは、セルフホスティング時に[ストリーミング応答](/docs/app/building-your-application/routing/loading-ui-and-streaming)をサポートします。Nginxのようなプロキシを使用している場合は、バッファリングを無効にしてストリーミングを有効にする必要があります。

たとえば、Nginxで`X-Accel-Buffering`を`no`に設定してバッファリングを無効にできます：

```js title="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

### 部分的プレンダリング {#partial-prerendering}

[Partial Prerendering (experimental)](/docs/app/building-your-application/rendering/partial-prerendering)は、デフォルトでNext.jsで動作し、CDN機能ではありません。これにはNode.jsサーバー（`next start`を通じて）としてのデプロイおよびDockerコンテナで使用される場合が含まれます。

### CDNとの使用 {#usage-with-cdns}

Next.jsアプリケーションの前でCDNを使用する場合、動的APIがアクセスされると、ページには`Cache-Control: private`応答ヘッダーが含まれます。これにより、結果のHTMLページがキャッシュ可能としてマークされないことが保証されます。ページが完全に静的にプリレンダリングされている場合、CDN上でページをキャッシュできるように`Cache-Control: public`が含まれます。

静的と動的なコンポーネントのどちらかが必要ない場合、ルート全体を静的にして、CDN上で出力HTMLをキャッシュできます。動的APIが使用されない場合、`next build`を実行すると、Automatic Static Optimizationはデフォルトの動作です。

</AppOnly>

<PagesOnly>

## 手動のグレースフルシャットダウン {#manual-graceful-shutdowns}

自己ホスティング時に、サーバーが`SIGTERM`または`SIGINT`シグナルでシャットダウンする際にコードを実行したい場合があります。

環境変数`NEXT_MANUAL_SIG_HANDLE`を`true`に設定し、その信号を`_document.js`ファイル内で処理するハンドラを登録できます。この環境変数をパッケージのスクリプトに直接登録する必要があり、`.env`ファイルには登録しないでください。

> **Good to know**: 手動信号処理は`next dev`で利用できません。

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js title="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('Received SIGTERM: cleaning up')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('Received SIGINT: cleaning up')
    process.exit(0)
  })
}
```

</PagesOnly>

{/* NOTE: この <DocCardList /> は手動で追加しています。自動翻訳等で更新され消えてしまった場合、必要に応じて再度追加しなおしてください */}

<DocCardList />
