---
title: 'Parallel Routes'
description: '同一ビュー内で1つ以上のページを同時にレンダリングし、それらを独立してナビゲートできる、非常に動的なアプリケーションのためのパターンです。'
related:
  links:
    - app/api-reference/file-conventions/default
---

Parallel Routes は、同じレイアウト内で1つ以上のページを同時または条件付きでレンダリングできる機能です。これは、ダッシュボードやソーシャルサイトのフィードなど、アプリの非常に動的なセクションに役立ちます。

たとえば、ダッシュボードを考えると、`team` ページと `analytics` ページを同時にレンダリングするために Parallel Routes を使用することができます：

<Image
  alt="Parallel Routes Diagram"
  srcLight="/docs/light/parallel-routes.png"
  srcDark="/docs/dark/parallel-routes.png"
  width="1600"
  height="942"
/>

## スロット {#slots}

Parallel Routes は、名前付き**スロット**を使用して作成されます。スロットは `@folder` 規約で定義されます。たとえば、次のファイル構造では、2つのスロット `@analytics` と `@team` を定義しています：

<Image
  alt="Parallel Routes File-system Structure"
  srcLight="/docs/light/parallel-routes-file-system.png"
  srcDark="/docs/dark/parallel-routes-file-system.png"
  width="1600"
  height="687"
/>

スロットは共有の親レイアウトに props として渡されます。上記の例では、`app/layout.js` にあるコンポーネントが `@analytics` と `@team` スロット props を受け入れ、`children` prop と並行してそれらをレンダリングできます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode
  analytics: React.ReactNode
  team: React.ReactNode
}) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function Layout({ children, team, analytics }) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

</TabItem>
</Tabs>

しかし、スロットは [route segments](/docs/app/building-your-application/routing#route-segments) ではないため、URL 構造には影響を与えません。たとえば、`/@analytics/views` の場合、URL は `/views` になります。なぜなら `@analytics` はスロットだからです。スロットは通常の [Page](/docs/app/api-reference/file-conventions/page) コンポーネントと結合されて、ルートセグメントに関連付けられた最終的なページを形成します。したがって、同じルートセグメントレベルで別個の[静的](/docs/app/building-your-application/rendering/server-components#static-rendering-default)および[動的](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)スロットを持つことはできません。1つのスロットが動的である場合、そのレベルのすべてのスロットが動的である必要があります。

> **Good to know**:
>
> - `children` prop はフォルダにマッピングする必要のない暗黙のスロットです。つまり、`app/page.js` は `app/@children/page.js` と同等です。

## アクティブな状態とナビゲーション {#active-state-and-navigation}

デフォルトでは、Next.js は各スロットのアクティブな _状態_（またはサブページ）を追跡します。しかし、スロット内でレンダリングされるコンテンツは、ナビゲーションの種類に依存します：

- [**Soft Navigation**](/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation): クライアントサイドのナビゲーション中、Next.js は[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)を行い、スロット内でサブページを変更しますが、他のスロットのアクティブなサブページを保持します。たとえそれらが現在の URL と一致しなくてもです。
- **Hard Navigation**: ページ全体の読み込み後（ブラウザリフレッシュ）、Next.js は現在の URL と一致しないスロットのアクティブステートを判断できません。代わりに、現在の URL と一致しないスロットのために [`default.js`](#defaultjs) ファイルをレンダリングするか、それが存在しない場合は `404` をレンダリングします。

> **Good to know**:
>
> - 一致しないルートの `404` は、意図しないページで parallel route をレンダリングしないようにするのに役立ちます。

### `default.js` {#default-js}

最初の読み込みまたはページ全体のリロード時に一致しないスロットのフォールバックとして、`default.js` ファイルを定義することができます。

次のフォルダ構造を考えてみましょう。`@team` スロットには `/settings` ページがありますが、`@analytics` にはありません。

<Image
  alt="Parallel Routes unmatched routes"
  srcLight="/docs/light/parallel-routes-unmatched-routes.png"
  srcDark="/docs/dark/parallel-routes-unmatched-routes.png"
  width="1600"
  height="930"
/>

`/settings` にナビゲートすると、`@team` スロットは `/settings` ページをレンダリングし、`@analytics` スロットの現在アクティブなページを維持します。

リフレッシュ時には、Next.js は `@analytics` のために `default.js` をレンダリングします。`default.js` が存在しない場合は `404` が代わりにレンダリングされます。

さらに、`children` は暗黙のスロットであるため、Next.js が親ページのアクティブな状態を復元できない場合にフォールバックをレンダリングする `default.js` ファイルも作成する必要があります。

### `useSelectedLayoutSegment(s)` {#useselectedlayoutsegment-s}

[`useSelectedLayoutSegment`](/docs/app/api-reference/functions/use-selected-layout-segment) および [`useSelectedLayoutSegments`](/docs/app/api-reference/functions/use-selected-layout-segments) の両方は、`parallelRoutesKey` パラメータを受け入れ、スロット内のアクティブなルートセグメントを読み取ることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export default function Layout({ auth }: { auth: React.ReactNode }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export default function Layout({ auth }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}
```

</TabItem>
</Tabs>

ユーザーが `app/@auth/login`（または URL バーで `/login`）にナビゲートすると、`loginSegment` は文字列 `"login"` と等しくなります。

## 例 {#examples}

### 条件付きルート {#conditional-routes}

Parallel Routes を使用して、特定の条件（たとえばユーザーロール）に基づいてルートを条件付きでレンダリングすることができます。たとえば、`/admin` または `/user` ロールのために異なるダッシュボードページをレンダリングする場合：

<Image
  alt="Conditional routes diagram"
  srcLight="/docs/light/conditional-routes-ui.png"
  srcDark="/docs/dark/conditional-routes-ui.png"
  width="1600"
  height="898"
/>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/layout.tsx" switcher
import { checkUserRole } from '@/lib/auth'

export default function Layout({
  user,
  admin,
}: {
  user: React.ReactNode
  admin: React.ReactNode
}) {
  const role = checkUserRole()
  return <>{role === 'admin' ? admin : user}</>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/layout.js" switcher
import { checkUserRole } from '@/lib/auth'

export default function Layout({ user, admin }) {
  const role = checkUserRole()
  return <>{role === 'admin' ? admin : user}</>
}
```

</TabItem>
</Tabs>

### タブグループ {#tab-groups}

スロット内に `layout` を追加して、スロットを独立して移動できるようにできます。これは、タブを作成するのに便利です。

たとえば、`@analytics` スロットには 2 つのサブページ `/page-views` と `/visitors` があります。

<Image
  alt="Analytics slot with two subpages and a layout"
  srcLight="/docs/light/parallel-routes-tab-groups.png"
  srcDark="/docs/dark/parallel-routes-tab-groups.png"
  width="1600"
  height="768"
/>

`@analytics` 内に [`layout`](/docs/app/building-your-application/routing/layouts-and-templates) ファイルを作成し、2 つのページ間でタブを共有します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@analytics/layout.tsx" switcher
import Link from 'next/link'

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Link href="/page-views">Page Views</Link>
        <Link href="/visitors">Visitors</Link>
      </nav>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@analytics/layout.js" switcher
import Link from 'next/link'

export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Link href="/page-views">Page Views</Link>
        <Link href="/visitors">Visitors</Link>
      </nav>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
</Tabs>

### モーダル {#modals}

Parallel Routes は、[Intercepting Routes](/docs/app/building-your-application/routing/intercepting-routes) と組み合わせて利用することで、ディープリンクをサポートするモーダルを作成できます。これにより、モーダルを構築する際の一般的な課題を解決できます。たとえば：

- **URL で共有可能な** モーダルコンテンツを作成します。
- ページの更新時にモーダルを閉じるのではなく、**コンテキストを保持**します。
- モーダルが閉じられたときに前のルートに移動するのではなく、**戻るナビゲーションでモーダルを閉じます**。
- **進むナビゲーションでモーダルを再度開く**ことができます。

次の UI パターンを考えてみましょう。ユーザーがクライアントサイドのナビゲーションを使用してレイアウトからログインモーダルを開いたり、別の `/login` ページにアクセスしたりできます：

<Image
  alt="Parallel Routes Diagram"
  srcLight="/docs/light/parallel-routes-auth-modal.png"
  srcDark="/docs/dark/parallel-routes-auth-modal.png"
  width="1600"
  height="687"
/>

このパターンを実装するには、まず `/login` ルートを作成して、メインのログインページをレンダリングします。

<Image
  alt="Parallel Routes Diagram"
  srcLight="/docs/light/parallel-routes-modal-login-page.png"
  srcDark="/docs/dark/parallel-routes-modal-login-page.png"
  width="1600"
  height="768"
/>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/login/page.tsx" switcher
import { Login } from '@/app/ui/login'

export default function Page() {
  return <Login />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/login/page.js" switcher
import { Login } from '@/app/ui/login'

export default function Page() {
  return <Login />
}
```

</TabItem>
</Tabs>

次に、`@auth` スロット内に [`default.js`](/docs/app/api-reference/file-conventions/default) ファイルを追加し、`null` を返します。これにより、モーダルがアクティブでないときにレンダリングされないようにします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@auth/default.tsx" switcher
export default function Default() {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@auth/default.js" switcher
export default function Default() {
  return '...'
}
```

</TabItem>
</Tabs>

`@auth` スロット内で、`/(.)login` フォルダを更新して `/login` ルートをインターセプトします。`/(.)login/page.tsx` ファイルに `<Modal>` コンポーネントとその子コンポーネントをインポートします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@auth/(.)login/page.tsx" switcher
import { Modal } from '@/app/ui/modal'
import { Login } from '@/app/ui/login'

export default function Page() {
  return (
    <Modal>
      <Login />
    </Modal>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@auth/(.)login/page.js" switcher
import { Modal } from '@/app/ui/modal'
import { Login } from '@/app/ui/login'

export default function Page() {
  return (
    <Modal>
      <Login />
    </Modal>
  )
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - ルートをインターセプトするための規約（例：`(.)`）は、ファイルシステムの構造に依存します。詳細は [Intercepting Routes 規約](/docs/app/building-your-application/routing/intercepting-routes#convention) を参照してください。
> - `<Modal>` の機能をモーダルコンテンツ（`<Login>`）から分離することで、モーダル内のあらゆるコンテンツ（例：[フォーム](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#forms)）がサーバーコンポーネントであることを保証できます。詳細は [クライアントコンポーネントとサーバーコンポーネントのインターリーブ](/docs/app/building-your-application/rendering/composition-patterns#supported-pattern-passing-server-components-to-client-components-as-props) を参照してください。

#### モーダルを開く {#opening-the-modal}

ここで、Next.js ルーターを利用してモーダルを開閉できます。これにより、モーダルが開いているときに URL が正しく更新されることが保証され、前後のナビゲーションでも同じです。

モーダルを開くには、`@auth` スロットを親レイアウトに prop として渡し、`children` prop と並行してレンダリングします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import Link from 'next/link'

export default function Layout({
  auth,
  children,
}: {
  auth: React.ReactNode
  children: React.ReactNode
}) {
  return (
    <>
      <nav>
        <Link href="/login">Open modal</Link>
      </nav>
      <div>{auth}</div>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import Link from 'next/link'

export default function Layout({ auth, children }) {
  return (
    <>
      <nav>
        <Link href="/login">Open modal</Link>
      </nav>
      <div>{auth}</div>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
</Tabs>

ユーザーが `<Link>` をクリックすると、モーダルが開き、`/login` ページには移動しません。ただし、ブラウザのリフレッシュや最初の読み込み時には、`/login` に移動するとメインのログインページが表示されます。

#### モーダルを閉じる {#closing-the-modal}

`router.back()` を呼び出すか、`Link` コンポーネントを使用してモーダルを閉じることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/modal.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export function Modal({ children }: { children: React.ReactNode }) {
  const router = useRouter()

  return (
    <>
      <button
        onClick={() => {
          router.back()
        }}
      >
        Close modal
      </button>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/modal.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export function Modal({ children }) {
  const router = useRouter()

  return (
    <>
      <button
        onClick={() => {
          router.back()
        }}
      >
        Close modal
      </button>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
</Tabs>

`Link` コンポーネントを使用して、もはや `@auth` スロットをレンダリングすべきでないページから移動する場合は、並行ルートが `null` を返すコンポーネントに一致するようにする必要があります。たとえば、ルートページに戻るときには、`@auth/page.tsx` コンポーネントを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/modal.tsx" switcher
import Link from 'next/link'

export function Modal({ children }: { children: React.ReactNode }) {
  return (
    <>
      <Link href="/">Close modal</Link>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/modal.js" switcher
import Link from 'next/link'

export function Modal({ children }) {
  return (
    <>
      <Link href="/">Close modal</Link>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@auth/page.tsx" switcher
export default function Page() {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@auth/page.js" switcher
export default function Page() {
  return '...'
}
```

</TabItem>
</Tabs>

または、他のページ（`/foo`、`/foo/bar` など）に移動する場合、catch-all スロットを使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@auth/[...catchAll]/page.tsx" switcher
export default function CatchAll() {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@auth/[...catchAll]/page.js" switcher
export default function CatchAll() {
  return '...'
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - 前述の [アクティブな状態とナビゲーション](#active-state-and-navigation) に記載されている動作のため、`@auth` スロットでモーダルを閉じるために catch-all ルートを使用しています。スロットと一致しなくなったルートへのクライアントサイドのナビゲーションは可視のままになるため、スロットを `null` を返すルートに一致させてモーダルを閉じる必要があります。
> - 他の例としては、ギャラリー内の写真モーダルを開く一方で `/photo/[id]` ページを専用に持ったり、ショッピングカートをサイドモーダルで開くことが含まれます。
> - [Intecepted and Parallel Routes を使用したモーダルの例を見る](https://github.com/vercel-labs/nextgram)

### ローディングとエラー UI {#loading-and-error-ui}

Parallel Routes は独立してストリーミングできるため、各ルートに独立したエラーとローディング状態を定義できます：

<Image
  alt="Parallel routes enable custom error and loading states"
  srcLight="/docs/light/parallel-routes-cinematic-universe.png"
  srcDark="/docs/dark/parallel-routes-cinematic-universe.png"
  width="1600"
  height="1218"
/>

[Loading UI](/docs/app/building-your-application/routing/loading-ui-and-streaming) および [エラー処理](/docs/app/building-your-application/routing/error-handling) のドキュメントで詳細を確認してください。
