---
title: 'Parallel Routes'
description: '独立してナビゲート可能な同一ビューに1つ以上のページを同時にレンダリングします。高度に動的なアプリケーションに対するパターンです。'
related:
  links:
    - 'app/api-reference/file-conventions/default'
---

Parallel Routesは、同一のレイアウト内で1つ以上のページを同時または条件付きでレンダリングすることができます。これは、ダッシュボードやソーシャルサイトのフィードなど、アプリの高度に動的なセクションに役立ちます。

たとえば、ダッシュボードを考えてみると、Parallel Routesを使用して`team`と`analytics`ページを同時にレンダリングすることができます:

<Image
  alt="Parallel Routes Diagram"
  srcLight="/docs/light/parallel-routes.png"
  srcDark="/docs/dark/parallel-routes.png"
  width="1600"
  height="942"
/>

## スロット {#slots}

Parallel Routesは、名前付きの**スロット**を使用して作成されます。スロットは`@folder`規約で定義されます。たとえば、次のファイル構造では、`@analytics`と`@team`の2つのスロットが定義されています:

<Image
  alt="Parallel Routes File-system Structure"
  srcLight="/docs/light/parallel-routes-file-system.png"
  srcDark="/docs/dark/parallel-routes-file-system.png"
  width="1600"
  height="687"
/>

スロットは共有親レイアウトへのpropsとして渡されます。上記の例では、`app/layout.js`のコンポーネントが`@analytics`と`@team`スロットのpropsを受け取り、それらを`children`のpropと一緒に平行にレンダリングできます:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode
  analytics: React.ReactNode
  team: React.ReactNode
}) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function Layout({ children, team, analytics }) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

</TabItem>
</Tabs>

ただし、スロットは[route segments](/docs/app/building-your-application/routing#route-segments)ではなく、URLの構造には影響しません。たとえば、`/@analytics/views`の場合、`@analytics`はスロットであるため、URLは`/views`になります。スロットは通常の[Page](/docs/app/api-reference/file-conventions/page)コンポーネントと組み合わされて、route segmentに関連付けられた最終ページを形成します。このため、同じroute segmentレベルで、別々の[静的](/docs/app/building-your-application/rendering/server-components#static-rendering-default)および[動的](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)スロットを持つことはできません。1つのスロットが動的である場合、そのレベルのすべてのスロットも動的でなければなりません。

> **知っておくと良いこと**:
>
> - `children` propは暗黙のスロットであるため、フォルダーにマッピングする必要はありません。つまり、`app/page.js`は`app/@children/page.js`に相当します。

## アクティブ状態とナビゲーション {#active-state-and-navigation}

デフォルトで、Next.jsは各スロットのアクティブな*状態*（またはサブページ）を追跡します。ただし、スロット内にレンダリングされるコンテンツは、ナビゲーションの種類に依存します:

- [**ソフトナビゲーション**](/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation): クライアントサイドのナビゲーション中、Next.jsは[部分的レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)を実行し、スロット内のサブページを変更しますが、他のスロットのアクティブなサブページを保持します。それらが現在のURLと一致しない場合でもです。
- **ハードナビゲーション**: ページ全体を読み込んだ後（ブラウザのリフレッシュ時）、Next.jsは現在のURLと一致しないスロットのアクティブな状態を特定できません。代わりに、一致しないスロットのために`default.js`ファイルをレンダリングするか、`default.js`が存在しない場合は`404`をレンダリングします。

> **知っておくと良いこと**:
>
> - 一致しないルートの`404`は、意図しないページで並行ルートをレンダリングするのを防ぐのに役立ちます。

### `default.js` {#default-js}

最初のロードやページのフルリロード時に一致しないスロットのフォールバックとしてレンダリングする`default.js`ファイルを定義できます。

次のフォルダー構造を考えてみてください。`@team`スロットには`/settings`ページがありますが、`@analytics`にはありません。

<Image
  alt="Parallel Routes unmatched routes"
  srcLight="/docs/light/parallel-routes-unmatched-routes.png"
  srcDark="/docs/dark/parallel-routes-unmatched-routes.png"
  width="1600"
  height="930"
/>

`/settings`に移動すると、`@team`スロットは`/settings`ページをレンダリングしながら、`@analytics`スロットの現在アクティブなページを維持します。

リフレッシュ時、Next.jsは`@analytics`用に`default.js`をレンダリングします。`default.js`が存在しない場合は、代わりに`404`がレンダリングされます。

さらに、`children`は暗黙のスロットであるため、Next.jsが親ページのアクティブな状態を取り戻せない場合に備えて、`children`のフォールバックをレンダリングする`default.js`ファイルも作成する必要があります。

### `useSelectedLayoutSegment(s)` {#useselectedlayoutsegment-s}

[`useSelectedLayoutSegment`](/docs/app/api-reference/functions/use-selected-layout-segment)と[`useSelectedLayoutSegments`](/docs/app/api-reference/functions/use-selected-layout-segments)は`parallelRoutesKey`パラメーターを受け入れ、スロット内のアクティブなルートセグメントを読み取ることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export default function Layout({ auth }: { auth: React.ReactNode }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export default function Layout({ auth }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}
```

</TabItem>
</Tabs>

ユーザーが`app/@auth/login`（またはURLバーで`/login`）に移動すると、`loginSegment`は文字列`"login"`と等しくなります。

## 例 {#examples}

### 条件付きルート {#conditional-routes}

Parallel Routesを使用して、ユーザーの役割など、特定の条件に基づいてルートを条件付きでレンダリングすることができます。たとえば、`/admin`または`/user`の役割ごとに異なるダッシュボードページをレンダリングするには:

<Image
  alt="Conditional routes diagram"
  srcLight="/docs/light/conditional-routes-ui.png"
  srcDark="/docs/dark/conditional-routes-ui.png"
  width="1600"
  height="898"
/>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/layout.tsx" switcher
import { checkUserRole } from '@/lib/auth'

export default function Layout({
  user,
  admin,
}: {
  user: React.ReactNode
  admin: React.ReactNode
}) {
  const role = checkUserRole()
  return <>{role === 'admin' ? admin : user}</>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/layout.js" switcher
import { checkUserRole } from '@/lib/auth'

export default function Layout({ user, admin }) {
  const role = checkUserRole()
  return <>{role === 'admin' ? admin : user}</>
}
```

</TabItem>
</Tabs>

### タブグループ {#tab-groups}

スロット内に`layout`を追加して、スロットを独立してナビゲートできるようにすることができます。これはタブを作成する際に便利です。

たとえば、`@analytics`スロットには2つのサブページがあります: `/page-views`と`/visitors`。

<Image
  alt="Analytics slot with two subpages and a layout"
  srcLight="/docs/light/parallel-routes-tab-groups.png"
  srcDark="/docs/dark/parallel-routes-tab-groups.png"
  width="1600"
  height="768"
/>

`@analytics`内で、タブを2つのページ間で共有するために[`layout`](/docs/app/building-your-application/routing/layouts-and-templates)ファイルを作成します:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@analytics/layout.tsx" switcher
import Link from 'next/link'

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Link href="/page-views">ページビュー</Link>
        <Link href="/visitors">ビジター</Link>
      </nav>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@analytics/layout.js" switcher
import Link from 'next/link'

export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Link href="/page-views">ページビュー</Link>
        <Link href="/visitors">ビジター</Link>
      </nav>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
</Tabs>

### モーダル {#modals}

Parallel Routesを[Intercepting Routes](/docs/app/building-your-application/routing/intercepting-routes)と組み合わせて、ディープリンクをサポートするモーダルを作成できます。これにより、モーダルの作成時に一般的な課題を解決できます。

- モーダルのコンテンツをURLを介して**シェア可能**にする
- ページがリフレッシュされたときにモーダルを閉じずに**コンテキストを保持**する
- 前のルートに戻るのではなく、後方ナビゲーションでモーダルを**閉じる**
- 前方ナビゲーションでモーダルを**再び開く**

次のUIパターンを考えてみてください。ユーザーはクライアントサイドナビゲーションを使用してレイアウトからログインモーダルを開くか、別の`/login`ページにアクセスできます:

<Image
  alt="Parallel Routes Diagram"
  srcLight="/docs/light/parallel-routes-auth-modal.png"
  srcDark="/docs/dark/parallel-routes-auth-modal.png"
  width="1600"
  height="687"
/>

このパターンを実装するには、まず**メイン**のログインページをレンダリングする`/login`ルートを作成します。

<Image
  alt="Parallel Routes Diagram"
  srcLight="/docs/light/parallel-routes-modal-login-page.png"
  srcDark="/docs/dark/parallel-routes-modal-login-page.png"
  width="1600"
  height="768"
/>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/login/page.tsx" switcher
import { Login } from '@/app/ui/login'

export default function Page() {
  return <Login />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/login/page.js" switcher
import { Login } from '@/app/ui/login'

export default function Page() {
  return <Login />
}
```

</TabItem>
</Tabs>

その後、`@auth`スロット内に、アクティブでない場合にモーダルがレンダリングされないように`null`を返す[`default.js`](/docs/app/api-reference/file-conventions/default)ファイルを追加します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@auth/default.tsx" switcher
export default function Default() {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@auth/default.js" switcher
export default function Default() {
  return '...'
}
```

</TabItem>
</Tabs>

次に、`@auth`スロット内で、`/(.)login`フォルダを更新して`/login`ルートをインターセプトします。`/(.)login/page.tsx`ファイルに`<Modal>`コンポーネントとその子をインポートします:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@auth/(.)login/page.tsx" switcher
import { Modal } from '@/app/ui/modal'
import { Login } from '@/app/ui/login'

export default function Page() {
  return (
    <Modal>
      <Login />
    </Modal>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@auth/(.)login/page.js" switcher
import { Modal } from '@/app/ui/modal'
import { Login } from '@/app/ui/login'

export default function Page() {
  return (
    <Modal>
      <Login />
    </Modal>
  )
}
```

</TabItem>
</Tabs>

> **知っておくと良いこと**:
>
> - ルートをインターセプトするために使用される規約（例: `(.)`）は、ファイルシステムの構造に依存します。詳しくは[Intercepting Routes規約](/docs/app/building-your-application/routing/intercepting-routes#convention)を参照してください。
> - `<Modal>`機能をモーダルコンテンツ（`<Login>`）から分離することで、モーダル内の任意のコンテンツ（例: [フォーム](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#forms)）がServer Componentsであることを確認できます。詳しくは[Interleaving Client and Server Components](/docs/app/building-your-application/rendering/composition-patterns#supported-pattern-passing-server-components-to-client-components-as-props)を参照してください。

#### モーダルを開く {#opening-the-modal}

これで、Next.js routerを利用してモーダルを開閉できます。これにより、モーダルが開いているときにURLが正しく更新され、前後のナビゲーションが可能になります。

モーダルを開くには、`@auth`スロットを親レイアウトのpropとして渡し、`children` propと一緒にレンダリングします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import Link from 'next/link'

export default function Layout({
  auth,
  children,
}: {
  auth: React.ReactNode
  children: React.ReactNode
}) {
  return (
    <>
      <nav>
        <Link href="/login">モーダルを開く</Link>
      </nav>
      <div>{auth}</div>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import Link from 'next/link'

export default function Layout({ auth, children }) {
  return (
    <>
      <nav>
        <Link href="/login">モーダルを開く</Link>
      </nav>
      <div>{auth}</div>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
</Tabs>

ユーザーが`<Link>`をクリックすると、`/login`ページに移動する代わりにモーダルが開きます。ただし、リフレッシュや初期ロード時に`/login`に移動すると、メインのログインページにユーザーが連れて行かれます。

#### モーダルを閉じる {#closing-the-modal}

モーダルを閉じるには、`router.back()`を呼び出すか、`Link`コンポーネントを使用します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/modal.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export function Modal({ children }: { children: React.ReactNode }) {
  const router = useRouter()

  return (
    <>
      <button
        onClick={() => {
          router.back()
        }}
      >
        モーダルを閉じる
      </button>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/modal.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export function Modal({ children }) {
  const router = useRouter()

  return (
    <>
      <button
        onClick={() => {
          router.back()
        }}
      >
        モーダルを閉じる
      </button>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
</Tabs>

`Link`コンポーネントを使用してページから離れる場合、そのページがもう`@auth`スロットをレンダリングしないときは、parallel routeが`null`を返すコンポーネントに一致していることを確認する必要があります。たとえば、rootページに戻る場合、`@auth/page.tsx`コンポーネントを作成します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/modal.tsx" switcher
import Link from 'next/link'

export function Modal({ children }: { children: React.ReactNode }) {
  return (
    <>
      <Link href="/">モーダルを閉じる</Link>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/modal.js" switcher
import Link from 'next/link'

export function Modal({ children }) {
  return (
    <>
      <Link href="/">モーダルを閉じる</Link>
      <div>{children}</div>
    </>
  )
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@auth/page.tsx" switcher
export default function Page() {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@auth/page.js" switcher
export default function Page() {
  return '...'
}
```

</TabItem>
</Tabs>

または、他のページ（`/foo`や`/foo/bar`など）に移動する場合は、catch-allスロットを使用できます:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/@auth/[...catchAll]/page.tsx" switcher
export default function CatchAll() {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/@auth/[...catchAll]/page.js" switcher
export default function CatchAll() {
  return '...'
}
```

</TabItem>
</Tabs>

> **知っておくと良いこと**:
>
> - [アクティブ状態とナビゲーション](#active-state-and-navigation)で説明した動作のため、モーダルを閉じるには、`@auth`スロットでcatch-allルートを使用しています。スロットに一致しなくなったルートへのクライアントサイドナビゲーションが表示されたままになるため、モーダルを閉じるために`null`を返すルートにスロットを一致させる必要があります。
> - 他の例としては、ギャラリー内で写真モーダルを開く一方で、専用の`/photo/[id]`ページを持たせる、またはサイドモーダルでショッピングカートを開くことが含まれます。
> - InterceptedおよびParallel Routesを使用したモーダルの[例を参照する](https://github.com/vercel-labs/nextgram)こともできます。

### ローディングとエラーUI {#loading-and-error-ui}

Parallel Routesは独立してストリームできるため、各ルートの独立したエラーステートとローディングステートを定義できます:

<Image
  alt="Parallel routes enable custom error and loading states"
  srcLight="/docs/light/parallel-routes-cinematic-universe.png"
  srcDark="/docs/dark/parallel-routes-cinematic-universe.png"
  width="1600"
  height="1218"
/>

詳細については、[ローディングUI](/docs/app/building-your-application/routing/loading-ui-and-streaming)および[エラーハンドリング](/docs/app/building-your-application/routing/error-handling)のドキュメントを参照してください。
