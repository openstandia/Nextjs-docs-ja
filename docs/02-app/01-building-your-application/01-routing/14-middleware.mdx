---
title: 'ミドルウェア'
description: 'リクエストが完了する前にコードを実行するためにミドルウェアを使用する方法を学びます。'
---

{/* このドキュメントの内容はapp routerとpages routerで共有されています。Pages Routerに特化した内容を追加するためには、`<PagesOnly>Content</PagesOnly>`コンポーネントを使用できます。共有されている内容はコンポーネントにラップしないでください。 */}

ミドルウェアを使用すると、リクエストが完了する前にコードを実行できます。そして、受信したリクエストに基づいて、レスポンスをリライト、リダイレクト、リクエストやレスポンスのヘッダーを変更するか、直接応答することで修正できます。

ミドルウェアはキャッシュされたコンテンツやルートが一致する前に実行されます。「[パスの一致](#matching-paths)」を参照してください。

## ユースケース

アプリケーションにミドルウェアを統合することで、パフォーマンス、セキュリティ、およびユーザーエクスペリエンスの大幅な改善が可能になります。ミドルウェアが特に効果的な一般的なシナリオには、次のようなものがあります：

- 認証と認可：特定のページやAPIルートにアクセスを許可する前に、ユーザーの身元を確認し、セッションCookieをチェックします
- サーバーサイドリダイレクト：条件に基づいて（例：言語、ユーザーの役割）、ユーザーをサーバーレベルでリダイレクトします
- パスのリライト：A/Bテスト、機能のロールアウト、またはレガシーパスのサポートを、リクエストプロパティに基づいて動的にAPIルートやページへのパスをリライトすることによって実現します
- ボットの検出：リソースを保護するために、ボットトラフィックを検出してブロックします
- ロギングと分析：ページまたはAPIによって処理される前に、インサイトのためにリクエストデータをキャプチャして分析します
- フィーチャーフラッギング：シームレスな機能のロールアウトやテストのために、動的に機能を有効または無効にします

ミドルウェアが最適なアプローチではない可能性のある状況を認識することも同様に重要です。注意すべきいくつかのシナリオを以下に示します：

- 複雑なデータの取得と操作：ミドルウェアはデータの直接取得や操作用に設計されていません。これはRoute Handlersやサーバーサイドのユーティリティ内で行うべきです。
- 重い計算タスク：ミドルウェアは軽量で即座に応答するべきです。重い計算タスクや長時間実行されるプロセスは専用のRoute Handlersで行うべきです。
- 大量のセッション管理：ミドルウェアは基本的なセッション管理タスクを管理できますが、大量のセッション管理は専用の認証サービスやRoute Handlers内で管理するべきです。
- データベースの直接操作：ミドルウェアでのデータベースの直接操作は推奨されません。データベースとのやり取りはRoute Handlersやサーバーサイドのユーティリティ内で行うべきです。

## 規約

ミドルウェアを定義するには、プロジェクトのrootにある`middleware.ts`（または`.js`）ファイルを使用します。たとえば、`pages`や`app`と同じレベル、または該当する場合は`src`内に配置します。

> **ノート**：プロジェクトごとにサポートされる`middleware.ts`ファイルは1つだけですが、それでもモジュール式にミドルウェアロジックを整理できます。ミドルウェアの機能を個別の`.ts`や`.js`ファイルに分けて、メインの`middleware.ts`ファイルにインポートすることができます。これにより、特定のルートに特化したミドルウェアを管理しやすくなり、`middleware.ts`に集約して集中管理することができます。単一のミドルウェアファイルを設定することで、設定が簡素化され、潜在的な衝突が防止され、複数のミドルウェアレイヤーを避けることでパフォーマンスが最適化されます。

## 例

```ts filename="middleware.ts" switcher
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// この関数は、内部で`await`を使用する場合`async`としてマークすることができます
export function middleware(request: NextRequest) {
  return NextResponse.redirect(new URL('/home', request.url))
}

// 詳細については、以下の「パスの一致」を参照してください
export const config = {
  matcher: '/about/:path*',
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'

// この関数は、内部で`await`を使用する場合`async`としてマークすることができます
export function middleware(request) {
  return NextResponse.redirect(new URL('/home', request.url))
}

// 詳細については、以下の「パスの一致」を参照してください
export const config = {
  matcher: '/about/:path*',
}
```

## パスの一致

ミドルウェアは、**プロジェクト内のすべてのルート**に対して呼び出されます。このため、特定のルートを正確にターゲットにするか除外するために、マッチャを使用することが重要です。以下は実行順序です：

1. `next.config.js`の`headers`
2. `next.config.js`の`redirects`
3. ミドルウェア（`rewrites`、`redirects`など）
4. `next.config.js`の`beforeFiles`（`rewrites`）
5. ファイルシステムルート (`public/`, `_next/static/`, `pages/`, `app/`など）
6. `next.config.js`の`afterFiles`（`rewrites`）
7. 動的ルート（`/blog/[slug]`）
8. `next.config.js`の`fallback`（`rewrites`）

ミドルウェアが実行されるパスを定義する方法は2つあります：

1. [カスタムマッチャ設定](#matcher)
2. [条件文](#conditional-statements)

### マッチャ

`matcher`を使用すると、特定のパスでミドルウェアを実行するようにフィルタリングできます。

```js filename="middleware.js"
export const config = {
  matcher: '/about/:path*',
}
```

単一のパスまたは複数のパスを配列構文でマッチさせることができます：

```js filename="middleware.js"
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
}
```

`matcher`設定はフル正規表現をサポートし、否定先読みや文字マッチングのようなマッチングがサポートされています。特定のパスを除くすべてのパスにマッチする否定先読みの例を以下に示します：

```js filename="middleware.js"
export const config = {
  matcher: [
    /*
     * 次のもので始まるパスを除くすべてのリクエストパスをマッチング：
     * - api（APIルート）
     * - _next/static（静的ファイル）
     * - _next/image（画像最適化ファイル）
     * - favicon.ico、sitemap.xml、robots.txt（メタデータファイル）
     */
    '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
  ],
}
```

`missing`または`has`配列、またはその両方を組み合わせて、特定のリクエストをバイパスすることもできます：

```js filename="middleware.js"
export const config = {
  matcher: [
    /*
     * 次のもので始まるパスを除くすべてのリクエストパスをマッチング：
     * - api（APIルート）
     * - _next/static（静的ファイル）
     * - _next/image（画像最適化ファイル）
     * - favicon.ico、sitemap.xml、robots.txt（メタデータファイル）
     */
    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      missing: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },

    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      has: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },

    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      has: [{ type: 'header', key: 'x-present' }],
      missing: [{ type: 'header', key: 'x-missing', value: 'prefetch' }],
    },
  ],
}
```

> **Good to know**： `matcher`の値は、ビルド時に静的に解析できるように定数である必要があります。変数のような動的な値は無視されます。

設定されたマッチャ：

1. `/`で始まる必要があります
2. 名前付きパラメータを含めることができます：`/about/:path`は`/about/a`と`/about/b`にはマッチしますが、`/about/a/c`にはマッチしません
3. 名前付きパラメータに修飾子を付けることができます（`:`で始まります）：`/about/:path*`は`/about/a/b/c`にマッチします。`*`は_ゼロまたはそれ以上_、`?`は_ゼロまたは1_、`+`は_1またはそれ以上_ です
4. 括弧で囲んだ正規表現を使用することができます：`/about/(.*)`は`/about/:path*`と同じです

詳細は[path-to-regexp](https://github.com/pillarjs/path-to-regexp#path-to-regexp-1)のドキュメントを参照してください。

> **Good to know**：後方互換性のため、Next.jsは常に`/public`を`/public/index`と見なします。そのため、`/public/:path`のマッチャは一致します。

### 条件文

```ts filename="middleware.ts" switcher
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }

  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }

  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}
```

## NextResponse

`NextResponse` APIを使用すると、次のことが可能です：

- 受信リクエストを異なるURLに`redirect`
- レスポンスを与えられたURLを表示することによって`rewrite`
- APIルート、`getServerSideProps`、および`rewrite`の宛先に対するリクエストヘッダーを設定
- レスポンスのcookieを設定
- レスポンスヘッダーを設定

<AppOnly>

ミドルウェアからレスポンスを生成するには、次の方法があります：

1. ルートに`rewrite`してレスポンスを生成する（[Page](/docs/app/building-your-application/routing/layouts-and-templates)または[Route Handler](/docs/app/building-your-application/routing/route-handlers)）
2. `NextResponse`を直接返す。「[レスポンスの生成](#producing-a-response)」を参照してください。

</AppOnly>

<PagesOnly>

ミドルウェアからレスポンスを生成するには、次の方法があります：

1. ルートに`rewrite`してレスポンスを生成する（[Page](/docs/pages/building-your-application/routing/pages-and-layouts)または[Edge API Route](/docs/pages/building-your-application/routing/api-routes)）
2. `NextResponse`を直接返す。「[レスポンスの生成](#producing-a-response)」を参照してください。

</PagesOnly>

## クッキーの使用

クッキーは通常のヘッダーです。`Request`ではこれらは`Cookie`ヘッダーに格納されます。`Response`には`Set-Cookie`ヘッダーに格納されます。Next.jsは、`NextRequest`および`NextResponse`の`cookies`拡張を通じてこれらのcookieにアクセスおよび操作するための便利な方法を提供しています。

1. 受信リクエストに対しては、`cookies`は`get`、`getAll`、`set`、および`delete`クッキーのメソッドを備えています。クッキーの存在を`has`で確認するか、`clear`を使用してすべてのクッキーを削除できます。
2. 送信レスポンスに対しては、`cookies`には`get`、`getAll`、`set`、および`delete`のメソッドがあります。

```ts filename="middleware.ts" switcher
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  // 受信リクエストに「Cookie:nextjs=fast」ヘッダーが存在すると仮定
  // `RequestCookies` APIを使用してリクエストからcookieを取得
  let cookie = request.cookies.get('nextjs')
  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll()
  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]

  request.cookies.has('nextjs') // => true
  request.cookies.delete('nextjs')
  request.cookies.has('nextjs') // => false

  // `ResponseCookies` APIを使用してレスポンスにcookieを設定
  const response = NextResponse.next()
  response.cookies.set('vercel', 'fast')
  response.cookies.set({
    name: 'vercel',
    value: 'fast',
    path: '/',
  })
  cookie = response.cookies.get('vercel')
  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
  // 発信レスポンスには`Set-Cookie:vercel=fast;path=/`ヘッダーが含まれます。

  return response
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  // 受信リクエストに「Cookie:nextjs=fast」ヘッダーが存在すると仮定
  // `RequestCookies` APIを使用してリクエストからcookieを取得
  let cookie = request.cookies.get('nextjs')
  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll()
  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]

  request.cookies.has('nextjs') // => true
  request.cookies.delete('nextjs')
  request.cookies.has('nextjs') // => false

  // `ResponseCookies` APIを使用してレスポンスにcookieを設定
  const response = NextResponse.next()
  response.cookies.set('vercel', 'fast')
  response.cookies.set({
    name: 'vercel',
    value: 'fast',
    path: '/',
  })
  cookie = response.cookies.get('vercel')
  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
  // 発信レスポンスには`Set-Cookie:vercel=fast;path=/test`ヘッダーが含まれます。

  return response
}
```

## ヘッダーの設定

`NextResponse` APIを使用してリクエストおよびレスポンスのヘッダーを設定できます（リクエストヘッダーの設定はNext.js v13.0.0から利用可能です）。

```ts filename="middleware.ts" switcher
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  // リクエストヘッダーをクローンし、新しいヘッダー`x-hello-from-middleware1`を設定
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-hello-from-middleware1', 'hello')

  // NextResponse.nextでリクエストヘッダーも設定できます
  const response = NextResponse.next({
    request: {
      // 新しいリクエストヘッダー
      headers: requestHeaders,
    },
  })

  // 新しいレスポンスヘッダー`x-hello-from-middleware2`を設定
  response.headers.set('x-hello-from-middleware2', 'hello')
  return response
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  // リクエストヘッダーをクローンし、新しいヘッダー`x-hello-from-middleware1`を設定
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-hello-from-middleware1', 'hello')

  // NextResponse.nextでリクエストヘッダーも設定できます
  const response = NextResponse.next({
    request: {
      // 新しいリクエストヘッダー
      headers: requestHeaders,
    },
  })

  // 新しいレスポンスヘッダー`x-hello-from-middleware2`を設定
  response.headers.set('x-hello-from-middleware2', 'hello')
  return response
}
```

> **Good to know**：大きなヘッダーを設定することは避けてください。これにより、バックエンドのWebサーバー設定によっては[431 Request Header Fields Too Large](https://developer.mozilla.org/docs/Web/HTTP/Status/431)エラーが発生する可能性があります。

### CORS

クロスオリジンリクエストを許可するためにCORSヘッダーをミドルウェアで設定することができます。[シンプル](https://developer.mozilla.org/ja/docs/Web/HTTP/CORS#%E7%B0%A1%E5%8D%98%E3%81%AA%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88)および[プレフライト](https://developer.mozilla.org/ja/docs/Web/HTTP/CORS#%E3%83%97%E3%83%AC%E3%83%95%E3%83%A9%E3%82%A4%E3%83%88%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88)リクエストの両方を含みます。

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'

const allowedOrigins = ['https://acme.com', 'https://my-app.org']

const corsOptions = {
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
}

export function middleware(request: NextRequest) {
  // リクエストからオリジンを確認
  const origin = request.headers.get('origin') ?? ''
  const isAllowedOrigin = allowedOrigins.includes(origin)

  // プレフライトリクエストを処理
  const isPreflight = request.method === 'OPTIONS'

  if (isPreflight) {
    const preflightHeaders = {
      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),
      ...corsOptions,
    }
    return NextResponse.json({}, { headers: preflightHeaders })
  }

  // シンプルリクエストを処理
  const response = NextResponse.next()

  if (isAllowedOrigin) {
    response.headers.set('Access-Control-Allow-Origin', origin)
  }

  Object.entries(corsOptions).forEach(([key, value]) => {
    response.headers.set(key, value)
  })

  return response
}

export const config = {
  matcher: '/api/:path*',
}
```

```jsx filename="middleware.js" switcher
import { NextResponse } from 'next/server'

const allowedOrigins = ['https://acme.com', 'https://my-app.org']

const corsOptions = {
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
}

export function middleware(request) {
  // リクエストからオリジンを確認
  const origin = request.headers.get('origin') ?? ''
  const isAllowedOrigin = allowedOrigins.includes(origin)

  // プレフライトリクエストを処理
  const isPreflight = request.method === 'OPTIONS'

  if (isPreflight) {
    const preflightHeaders = {
      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),
      ...corsOptions,
    }
    return NextResponse.json({}, { headers: preflightHeaders })
  }

  // シンプルリクエストを処理
  const response = NextResponse.next()

  if (isAllowedOrigin) {
    response.headers.set('Access-Control-Allow-Origin', origin)
  }

  Object.entries(corsOptions).forEach(([key, value]) => {
    response.headers.set(key, value)
  })

  return response
}

export const config = {
  matcher: '/api/:path*',
}
```

<AppOnly>

> **Good to know**：CORSヘッダーを個別のルートに設定するには [Route Handlers](/docs/app/building-your-application/routing/route-handlers#cors) を参照してください。

</AppOnly>

## レスポンスの生成

ミドルウェアから直接`Response`または`NextResponse`インスタンスを返すことで応答することができます（これは [Next.js v13.1.0](https://nextjs.org/blog/next-13-1#nextjs-advanced-middleware) から利用可能です）。

```ts filename="middleware.ts" switcher
import type { NextRequest } from 'next/server'
import { isAuthenticated } from '@lib/auth'

// ミドルウェアを`/api/`で始まるパスに制限
export const config = {
  matcher: '/api/:function*',
}

export function middleware(request: NextRequest) {
  // リクエストを確認するために認証関数を呼び出します
  if (!isAuthenticated(request)) {
    // エラーメッセージを示すJSONで応答
    return Response.json(
      { success: false, message: 'authentication failed' },
      { status: 401 }
    )
  }
}
```

```js filename="middleware.js" switcher
import { isAuthenticated } from '@lib/auth'

// ミドルウェアを`/api/`で始まるパスに制限
export const config = {
  matcher: '/api/:function*',
}

export function middleware(request) {
  // リクエストを確認するために認証関数を呼び出します
  if (!isAuthenticated(request)) {
    // エラーメッセージを示すJSONで応答
    return Response.json(
      { success: false, message: 'authentication failed' },
      { status: 401 }
    )
  }
}
```

### `waitUntil` と `NextFetchEvent`

`NextFetchEvent`オブジェクトはネイティブの[`FetchEvent`](https://developer.mozilla.org/docs/Web/API/FetchEvent)オブジェクトを拡張し、[`waitUntil()`](https://developer.mozilla.org/docs/Web/API/ExtendableEvent/waitUntil)メソッドを含みます。

`waitUntil()`メソッドは、Promiseを引数として受け取り、Promiseが解決されるまでミドルウェアのライフタイムを延長します。これは、バックグラウンドで作業を行うのに便利です。

```ts filename="middleware.ts"
import { NextResponse } from 'next/server'
import type { NextFetchEvent, NextRequest } from 'next/server'

export function middleware(req: NextRequest, event: NextFetchEvent) {
  event.waitUntil(
    fetch('https://my-analytics-platform.com', {
      method: 'POST',
      body: JSON.stringify({ pathname: req.nextUrl.pathname }),
    })
  )

  return NextResponse.next()
}
```

## 高度なミドルウェアフラグ

Next.jsの`v13.1`でミドルウェア用の2つの追加フラグである、`skipMiddlewareUrlNormalize`と`skipTrailingSlashRedirect`が導入され、高度なユースケースに対処しています。

`skipTrailingSlashRedirect`は、末尾のスラッシュを追加または削除するためのNext.jsリダイレクトを無効にします。これにより、特定のパスでは末尾のスラッシュを維持し、他のパスでは維持しないように、ミドルウェア内でカスタム処理が可能になります。これにより、段階的な移行が容易になります。

```js filename="next.config.js"
module.exports = {
  skipTrailingSlashRedirect: true,
}
```

```js filename="middleware.js"
const legacyPrefixes = ['/docs', '/blog']

export default async function middleware(req) {
  const { pathname } = req.nextUrl

  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
    return NextResponse.next()
  }

  // 末尾のスラッシュ処理を適用
  if (
    !pathname.endsWith('/') &&
    !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
  ) {
    return NextResponse.redirect(
      new URL(`${req.nextUrl.pathname}/`, req.nextUrl)
    )
  }
}
```

`skipMiddlewareUrlNormalize`は、Next.jsのURL正規化を無効にして、直接訪問とクライアント遷移の処理を同じにすることを可能にします。一部の高度なケースでは、このオプションを使用して元のURLを使用して完全な制御を行うことが可能です。

```js filename="next.config.js"
module.exports = {
  skipMiddlewareUrlNormalize: true,
}
```

```js filename="middleware.js"
export default async function middleware(req) {
  const { pathname } = req.nextUrl

  // GET /_next/data/build-id/hello.json

  console.log(pathname)
  // このフラグを使用すると、/_next/data/build-id/hello.jsonになります
  // フラグがない場合は/helloに正規化されます
}
```

## ランタイム

ミドルウェアは現時点で[エッジランタイム](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)と互換性のあるAPIのみをサポートしています。Node.js専用のAPIは[サポートされていません](/docs/app/api-reference/edge#unsupported-apis)。

## バージョン履歴

| バージョン   | 変更点                                                                                       |
| --------- | --------------------------------------------------------------------------------------------- |
| `v13.1.0` | 高度なミドルウェアフラグが追加されました                                                               |
| `v13.0.0` | ミドルウェアはリクエストヘッダー、レスポンスヘッダーを変更し、レスポンスを送信できるようになりました                   |
| `v12.2.0` | ミドルウェアが安定版になりました。 [アップグレードガイド](/docs/messages/middleware-upgrade-guide)を参照してください |
| `v12.0.9` | エッジランタイムでの絶対URLの強制([PR](https://github.com/vercel/next.js/pull/33410))   |
| `v12.0.0` | ミドルウェア（ベータ）が追加されました                                                                       |