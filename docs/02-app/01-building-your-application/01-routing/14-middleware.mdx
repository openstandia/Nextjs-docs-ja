---
title: 'Middleware'
description: 'Middlewareを使用してリクエストが完了する前にコードを実行する方法を学びます。'
---

{/* このドキュメントの内容はapp routerとpages routerの間で共有されています。`<PagesOnly>Content</PagesOnly>`コンポーネントを使用してPages Routerに特化したコンテンツを追加できます。共有されたコンテンツはコンポーネント内にラップしないでください。 */}

Middlewareはリクエストが完了する前にコードを実行することができます。その後、受信したリクエストに基づいて、書き換え、リダイレクト、リクエストやレスポンスヘッダーの変更、または直接のレスポンスによってレスポンスを変更できます。

Middlewareはキャッシュされたコンテンツとルートが一致する前に実行されます。詳細については[Matching Paths](#matching-paths)を参照してください。

## 使用事例 {#use-cases}

Middlewareをアプリケーションに統合すると、パフォーマンス、セキュリティ、ユーザーエクスペリエンスが大幅に向上します。Middlewareが特に効果的な一般的なシナリオのいくつかを次に示します。

- 認証と認可: 特定のページやAPIルートへのアクセスを許可する前に、ユーザーの身元を確認し、セッションcookieを検証します
- サーバー側リダイレクト: ある条件（例：ロケール、ユーザーの役割）に基づいて、サーバーレベルでユーザーをリダイレクトします
- パスの書き換え: リクエストのプロパティに基づいて、パスをAPIルートやページに動的に書き換えてA/Bテスト、機能展開、レガシーパスをサポートします
- ボット検出: ボットトラフィックを検出してブロックすることで、リソースを保護します
- ロギングと分析: ページまたはAPIによって処理される前に、洞察を得るためにリクエストデータをキャプチャして分析します
- 機能フラグ: シームレスな機能展開やテストのために、機能を動的に有効化または無効化します

Middlewareが最適なアプローチではない場面を認識することも同様に重要です。注意すべきシナリオをいくつか紹介します。

- 複雑なデータ取得と操作: Middlewareは直接データの取得や操作には設計されていません。これらはRoute Handlersやサーバーサイドユーティリティ内で行うべきです
- 重い計算タスク: Middlewareは軽量で迅速に応答する必要があります。そうでないとページロードが遅くなる可能性があります。重い計算タスクや長時間のプロセスは、専用のRoute Handlers内で行うべきです
- 大規模なセッション管理: Middlewareは基本的なセッションタスクを管理できますが、大規模なセッション管理は専用の認証サービスまたはRoute Handlers内で行うべきです
- 直接的なデータベース操作: Middleware内での直接的なデータベース操作は推奨されません。データベースとのやり取りはRoute Handlersやサーバーサイドユーティリティ内で行うべきです

## 規約 {#convention}

`middleware.ts`（または`.js`）ファイルをプロジェクトのrootに使用してMiddlewareを定義します。例えば、`pages`や`app`と同じレベル、または`src`内に配置します。

> **注意**: プロジェクトごとにサポートされる`middleware.ts`ファイルは1つだけですが、ミドルウェアのロジックをモジュール化して整理することができます。ミドルウェアの機能を個別の`.ts`または`.js`ファイルに分けて、メインの`middleware.ts`ファイルにインポートします。これにより、ルート固有のミドルウェアをクリーンに管理し、`middleware.ts`に集約して集中コントロールを可能にします。1つのミドルウェアファイルを強制することで、設定が簡素化され、潜在的な衝突を回避し、複数のミドルウェア層を避けることでパフォーマンスが最適化されます。

## 例 {#example}

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// この関数は内部で`await`を使用する場合`async`としてマークできます
export function middleware(request: NextRequest) {
  return NextResponse.redirect(new URL('/home', request.url))
}

// 以下の"Matching Paths"を参照してください
export const config = {
  matcher: '/about/:path*',
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'

// この関数は内部で`await`を使用する場合`async`としてマークできます
export function middleware(request) {
  return NextResponse.redirect(new URL('/home', request.url))
}

// 以下の"Matching Paths"を参照してください
export const config = {
  matcher: '/about/:path*',
}
```

</TabItem>
</Tabs>

## パスの一致 {#matching-paths}

Middlewareは**プロジェクト内のすべてのルート**に対して呼び出されます。これに基づいて、特定のルートを正確にターゲットとしたり除外したりするためには、matcherを使用することが重要です。以下が実行順序です。

1. `next.config.js`からの`headers`
2. `next.config.js`からの`redirects`
3. Middleware（`rewrites`、`redirects`など）
4. `next.config.js`からの`beforeFiles`（`rewrites`）
5. ファイルシステムルート（`public/`、`_next/static/`、`pages/`、`app/`など）
6. `next.config.js`からの`afterFiles`（`rewrites`）
7. Dynamic Routes（`/blog/[slug]`）
8. `next.config.js`からの`fallback`（`rewrites`）

Middlewareが実行されるパスを定義する方法は2つあります。

1. [カスタムmatcher設定](#matcher)
2. [条件文](#conditional-statements)

### Matcher {#matcher}

`matcher`を使用すると、特定のパスでMiddlewareを実行するようにフィルタリングできます。

```js title="middleware.js"
export const config = {
  matcher: '/about/:path*',
}
```

単一のパスまたは配列構文で複数のパスを一致させることができます。

```js title="middleware.js"
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
}
```

`matcher`設定は完全な正規表現を許可しているため、否定先読みや文字一致のようなマッチングがサポートされています。特定のパス以外をすべて一致させる否定先読みの例はこちらです。

```js title="middleware.js"
export const config = {
  matcher: [
    /*
     * 以下で始まるパスを除くすべてのリクエストパスに一致させます。
     * - api (APIルート)
     * - _next/static (静的ファイル)
     * - _next/image (画像最適化ファイル)
     * - favicon.ico, sitemap.xml, robots.txt (メタデータファイル)
     */
    '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
  ],
}
```

また、`missing`や`has`の配列、または両者の組み合わせを使用して、特定のリクエストをMiddlewareからバイパスすることもできます。

```js title="middleware.js"
export const config = {
  matcher: [
    /*
     * 以下で始まるパスを除くすべてのリクエストパスに一致させます。
     * - api (APIルート)
     * - _next/static (静的ファイル)
     * - _next/image (画像最適化ファイル)
     * - favicon.ico, sitemap.xml, robots.txt (メタデータファイル)
     */
    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      missing: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },

    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      has: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },

    {
      source:
        '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
      has: [{ type: 'header', key: 'x-present' }],
      missing: [{ type: 'header', key: 'x-missing', value: 'prefetch' }],
    },
  ],
}
```

> **良い情報**: `matcher`の値は定数にする必要があるため、ビルド時に静的に解析できます。動的な値（変数など）は無視されます。

設定されたmatcher：

1. `/`で始める必要があります
2. 名前付きパラメータを含めることができます：`/about/:path`は`/about/a` および`/about/b`に一致しますが、`/about/a/c`には一致しません
3. 名前付きパラメータ（`:`で始まる）に修飾子を持つことができます：`/about/:path*`は`/about/a/b/c`に一致します。なぜなら`*`は*ゼロ以上*の意味だからです。`?`は*ゼロまたは1*で、`+`は*1以上*です
4. カッコ内に囲まれた正規表現を使用できます：`/about/(.*)`は`/about/:path*`と同じです

詳細については、[path-to-regexp](https://github.com/pillarjs/path-to-regexp#path-to-regexp-1)のドキュメントを参照してください。

> **良い情報**: 後方互換性のため、Next.jsは常に`/public`を`/public/index`として考慮します。そのため、`/public/:path`のmatcherは一致します。

### 条件文 {#conditional-statements}

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }

  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }

  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}
```

</TabItem>
</Tabs>

## NextResponse {#nextresponse}

`NextResponse` APIでは次のことが可能です。

- 入ってきたリクエストを別のURLに`redirect`する
- 与えられたURLを表示することでレスポンスを書き換える(`rewrite`)
- API Routes、`getServerSideProps`、および`rewrite`の宛先にリクエストヘッダーを設定する
- レスポンスにcookieを設定する
- レスポンスヘッダーを設定する

<AppOnly>

Middlewareからレスポンスを生成するには、以下のことができます。

1. レスポンスを生成するルート（[ページ](/docs/app/building-your-application/routing/layouts-and-templates)または[Route Handler](/docs/app/building-your-application/routing/route-handlers)）に`rewrite`する
2. `NextResponse`を直接返す。詳しくは[レスポンスの生成](#producing-a-response)を参照してください

</AppOnly>

<PagesOnly>

Middlewareからレスポンスを生成するには、以下のことができます。

1. レスポンスを生成するルート（[ページ](https://nextjs.org/docs/canary/pages/building-your-application/routing/pages-and-layouts)または[Edge API Route](https://nextjs.org/docs/canary/pages/building-your-application/routing/api-routes)）に`rewrite`する
2. `NextResponse`を直接返す。詳しくは[レスポンスの生成](#producing-a-response)を参照してください

</PagesOnly>

## Cookieの使用 {#using-cookies}

Cookieは通常のヘッダーです。`Request`では`Cookie`ヘッダーに格納されます。`Response`では`Set-Cookie`ヘッダーに入っています。Next.jsは、`NextRequest`および`NextResponse`の`cookies`拡張を通して、これらのcookieにアクセスし操作するための便利な方法を提供しています。

1. 受信リクエストの場合、`cookies`は次のメソッドを備えています：`get`、`getAll`、`set`、および`delete` cookies。cookieの存在を確認するために`has`を使用したり、すべてのcookieを削除するために`clear`を使用できます。
2. 発信レスポンスの場合、`cookies`は次のメソッドを備えています：`get`、`getAll`、`set`、および`delete`です。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  // 入力リクエストに"Cookie:nextjs=fast"ヘッダーがあると仮定します
  // `RequestCookies` APIを使用してリクエストからcookieを取得します
  let cookie = request.cookies.get('nextjs')
  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll()
  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]

  request.cookies.has('nextjs') // => true
  request.cookies.delete('nextjs')
  request.cookies.has('nextjs') // => false

  // `ResponseCookies` APIを使用してレスポンスにcookieを設定します
  const response = NextResponse.next()
  response.cookies.set('vercel', 'fast')
  response.cookies.set({
    name: 'vercel',
    value: 'fast',
    path: '/',
  })
  cookie = response.cookies.get('vercel')
  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
  // 発信レスポンスは`Set-Cookie:vercel=fast;path=/`ヘッダーを持っています。

  return response
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  // 入力リクエストに"Cookie:nextjs=fast"ヘッダーがあると仮定します
  // `RequestCookies` APIを使用してリクエストからcookieを取得します
  let cookie = request.cookies.get('nextjs')
  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll()
  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]

  request.cookies.has('nextjs') // => true
  request.cookies.delete('nextjs')
  request.cookies.has('nextjs') // => false

  // `ResponseCookies` APIを使用してレスポンスにcookieを設定します
  const response = NextResponse.next()
  response.cookies.set('vercel', 'fast')
  response.cookies.set({
    name: 'vercel',
    value: 'fast',
    path: '/',
  })
  cookie = response.cookies.get('vercel')
  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
  // 発信レスポンスは`Set-Cookie:vercel=fast;path=/test`ヘッダーを持っています。

  return response
}
```

</TabItem>
</Tabs>

## ヘッダーの設定 {#setting-headers}

`NextResponse` APIを使用してリクエストとレスポンスのヘッダーを設定することができます（*リクエスト*ヘッダーの設定はNext.js v13.0.0以来利用可能になりました）。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  // リクエストヘッダーを複製し、新しいヘッダー `x-hello-from-middleware1` を設定します
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-hello-from-middleware1', 'hello')

  // NextResponse.nextでリクエストヘッダーを設定できます
  const response = NextResponse.next({
    request: {
      // 新しいリクエストヘッダー
      headers: requestHeaders,
    },
  })

  // 新しいレスポンスヘッダー `x-hello-from-middleware2` を設定します
  response.headers.set('x-hello-from-middleware2', 'hello')
  return response
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  // リクエストヘッダーを複製し、新しいヘッダー `x-hello-from-middleware1` を設定します
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-hello-from-middleware1', 'hello')

  // NextResponse.nextでリクエストヘッダーを設定できます
  const response = NextResponse.next({
    request: {
      // 新しいリクエストヘッダー
      headers: requestHeaders,
    },
  })

  // 新しいレスポンスヘッダー `x-hello-from-middleware2` を設定します
  response.headers.set('x-hello-from-middleware2', 'hello')
  return response
}
```

</TabItem>
</Tabs>

> **良い情報**: 大きなヘッダーの設定は避けてください。バックエンドのWebサーバーの設定に応じて[431 Request Header Fields Too Large](https://developer.mozilla.org/docs/Web/HTTP/Status/431)エラーを引き起こす可能性があります。

### CORS {#cors}

MiddlewareでCORSヘッダーを設定して、[シンプル](https://developer.mozilla.org/ja/docs/Web/HTTP/CORS#simple_requests)および[プリフライト](https://developer.mozilla.org/ja/docs/Web/HTTP/CORS#preflighted_requests)リクエストを含むクロスオリジンリクエストを許可することができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'

const allowedOrigins = ['https://acme.com', 'https://my-app.org']

const corsOptions = {
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
}

export function middleware(request: NextRequest) {
  // リクエストからオリジンを確認します
  const origin = request.headers.get('origin') ?? ''
  const isAllowedOrigin = allowedOrigins.includes(origin)

  // プリフライトリクエストを処理します
  const isPreflight = request.method === 'OPTIONS'

  if (isPreflight) {
    const preflightHeaders = {
      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),
      ...corsOptions,
    }
    return NextResponse.json({}, { headers: preflightHeaders })
  }

  // シンプルなリクエストを処理します
  const response = NextResponse.next()

  if (isAllowedOrigin) {
    response.headers.set('Access-Control-Allow-Origin', origin)
  }

  Object.entries(corsOptions).forEach(([key, value]) => {
    response.headers.set(key, value)
  })

  return response
}

export const config = {
  matcher: '/api/:path*',
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="middleware.js" switcher
import { NextResponse } from 'next/server'

const allowedOrigins = ['https://acme.com', 'https://my-app.org']

const corsOptions = {
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
}

export function middleware(request) {
  // リクエストからオリジンを確認します
  const origin = request.headers.get('origin') ?? ''
  const isAllowedOrigin = allowedOrigins.includes(origin)

  // プリフライトリクエストを処理します
  const isPreflight = request.method === 'OPTIONS'

  if (isPreflight) {
    const preflightHeaders = {
      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),
      ...corsOptions,
    }
    return NextResponse.json({}, { headers: preflightHeaders })
  }

  // シンプルなリクエストを処理します
  const response = NextResponse.next()

  if (isAllowedOrigin) {
    response.headers.set('Access-Control-Allow-Origin', origin)
  }

  Object.entries(corsOptions).forEach(([key, value]) => {
    response.headers.set(key, value)
  })

  return response
}

export const config = {
  matcher: '/api/:path*',
}
```

</TabItem>
</Tabs>

<AppOnly>

> **良い情報**：CORSヘッダーは、[Route Handlers](/docs/app/building-your-application/routing/route-handlers#cors)で個別のルートに対して設定できます。

</AppOnly>

## レスポンスの生成 {#producing-a-response}

Middlewareから直接`Response`または`NextResponse`インスタンスを返すことで応答を返すことができます（これは[Next.js v13.1.0](https://nextjs.org/blog/next-13-1#nextjs-advanced-middleware)以来利用可能です）。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import type { NextRequest } from 'next/server'
import { isAuthenticated } from '@lib/auth'

// Middlewareを`/api/`で始まるパスに制限します
export const config = {
  matcher: '/api/:function*',
}

export function middleware(request: NextRequest) {
  // 認証関数を呼び出してリクエストをチェックします
  if (!isAuthenticated(request)) {
    // エラーメッセージを示すJSONで応答します
    return Response.json(
      { success: false, message: 'authentication failed' },
      { status: 401 }
    )
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { isAuthenticated } from '@lib/auth'

// Middlewareを`/api/`で始まるパスに制限します
export const config = {
  matcher: '/api/:function*',
}

export function middleware(request) {
  // 認証関数を呼び出してリクエストをチェックします
  if (!isAuthenticated(request)) {
    // エラーメッセージを示すJSONで応答します
    return Response.json(
      { success: false, message: 'authentication failed' },
      { status: 401 }
    )
  }
}
```

</TabItem>
</Tabs>

### `waitUntil`と`NextFetchEvent` {#waituntil-and-nextfetchevent}

`NextFetchEvent`オブジェクトはネイティブの[`FetchEvent`](https://developer.mozilla.org/docs/Web/API/FetchEvent)オブジェクトを拡張し、[`waitUntil()`](https://developer.mozilla.org/docs/Web/API/ExtendableEvent/waitUntil)メソッドを含んでいます。

`waitUntil()`メソッドはPromiseを引数に取り、Middlewareの寿命をPromiseが解決されるまで延長します。これはバックグラウンドで作業を行うときに便利です。

```ts title="middleware.ts"
import { NextResponse } from 'next/server'
import type { NextFetchEvent, NextRequest } from 'next/server'

export function middleware(req: NextRequest, event: NextFetchEvent) {
  event.waitUntil(
    fetch('https://my-analytics-platform.com', {
      method: 'POST',
      body: JSON.stringify({ pathname: req.nextUrl.pathname }),
    })
  )

  return NextResponse.next()
}
```

## 高度なMiddlewareフラグ {#advanced-middleware-flags}

Next.js の `v13.1` において、`skipMiddlewareUrlNormalize` および `skipTrailingSlashRedirect` の2つの追加フラグがミドルウェア用に導入され、先進的なユースケースに対処できるようになりました。

`skipTrailingSlashRedirect` はトレイリングスラッシュの追加または削除のためのNext.js リダイレクトを無効にします。これにより、一部のパスではトレイリングスラッシュを維持し、他のパスでは削除するというカスタム処理が可能になり、インクリメンタルな移行が容易になります。

```js title="next.config.js"
module.exports = {
  skipTrailingSlashRedirect: true,
}
```

```js title="middleware.js"
const legacyPrefixes = ['/docs', '/blog']

export default async function middleware(req) {
  const { pathname } = req.nextUrl

  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
    return NextResponse.next()
  }

  // トレイリングスラッシュ処理を適用します
  if (
    !pathname.endsWith('/') &&
    !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
  ) {
    return NextResponse.redirect(
      new URL(`${req.nextUrl.pathname}/`, req.nextUrl)
    )
  }
}
```

`skipMiddlewareUrlNormalize` は、Next.jsでのURLの正規化を無効にして、直接のアクセスとクライアントトランジションの処理を同じにします。いくつかの進んだケースでは、このオプションを使用することでオリジナルのURLを使って完全なコントロールを提供します。

```js title="next.config.js"
module.exports = {
  skipMiddlewareUrlNormalize: true,
}
```

```js title="middleware.js"
export default async function middleware(req) {
  const { pathname } = req.nextUrl

  // GET /_next/data/build-id/hello.json

  console.log(pathname)
  // フラグ使用時はこれが /_next/data/build-id/hello.json
  // フラグ未使用時はこれが /hello に正規化されます
}
```

## ユニットテスト（実験的） {#unit-testing-experimental}

Next.js 15.1から、`next/experimental/testing/server`パッケージにはミドルウェアファイルのユニットテストを補助するユーティリティが含まれています。ユニットテストのミドルウェアは、それが望ましいパスでしか実行されないこと、およびカスタムルーティングロジックが意図どおりに動作することをプロダクションに到達する前に保証できます。

`unstable_doesMiddlewareMatch` 関数を使用すると、middlewareが提供されたURL、ヘッダー、およびcookieに対して実行されるかどうかを確認できます。

```js
import { unstable_doesMiddlewareMatch } from 'next/experimental/testing/server'

expect(
  unstable_doesMiddlewareMatch({
    config,
    nextConfig,
    url: '/test',
  })
).toEqual(false)
```

ミドルウェア関数全体をテストすることもできます。

```js
import { isRewrite, getRewrittenUrl } from 'next/experimental/testing/server'

const request = new NextRequest('https://nextjs.org/docs')
const response = await middleware(request)
expect(isRewrite(response)).toEqual(true)
expect(getRewrittenUrl(response)).toEqual('https://other-domain.com/docs')
// レスポンスがリダイレクトだった場合、getRedirectUrlも使用できます
```

## ランタイム {#runtime}

現在、Middlewareは[Edge runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)と互換性のあるAPIのみをサポートしています。Node.js固有のAPIは[サポートしていません](/docs/app/api-reference/edge#unsupported-apis)。

## バージョン履歴 {#version-history}

| バージョン | 変更内容                                                                                                                      |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `v13.1.0`  | 高度なMiddlewareフラグが追加されました                                                                                        |
| `v13.0.0`  | Middlewareがリクエストヘッダー、レスポンスヘッダーを変更し、レスポンスを送信できるようになりました                            |
| `v12.2.0`  | Middlewareは安定版です。[アップグレードガイド](https://nextjs.org/docs/messages/middleware-upgrade-guide)を参照してください。 |
| `v12.0.9`  | Edge Runtimeに絶対URLを強制（[PR](https://github.com/vercel/next.js/pull/33410)）                                             |
| `v12.0.0`  | Middleware（ベータ版）が追加されました                                                                                        |
