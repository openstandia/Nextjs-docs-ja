---
title: 'Custom Server'
description: 'カスタムサーバーを使用してNext.jsアプリをプログラムで開始する方法。'
---

{/* このドキュメントの内容は、app routerとpages routerの両方で共有されています。Pages Routerに特化した内容を追加するには、`<PagesOnly>Content</PagesOnly>` コンポーネントを使用してください。共有コンテンツはどのコンポーネントにもラップされるべきでありません。 */}

Next.jsはデフォルトで`next start`とともに独自のサーバーを含んでいます。既存のバックエンドを持っている場合でも、それを使ってNext.jsを利用できます（これはカスタムサーバーではありません）。カスタムNext.jsサーバーを利用すると、カスタマイズされたパターンのためにサーバーをプログラムで起動できます。多くの場合、このアプローチが必要になることはありません。ただし、必要に応じてこの方法を選べます。

> **Good to know**:
>
> - カスタムサーバーを使用する前に、Next.jsの統合されたルーターではアプリの要件を満たせない場合にのみ使用するべきことを覚えておいてください。カスタムサーバーは、**[Automatic Static Optimization](/docs/pages/building-your-application/rendering/automatic-static-optimization)**のような重要なパフォーマンス最適化を削除します。
> - カスタムサーバーは[Vercel](https://vercel.com/frameworks/nextjs)にデプロイすることは**できません**。
> - スタンドアロンの出力モードを使用する場合、カスタムサーバーファイルのトレースは行いません。このモードでは、代わりに別々の最小限の`server.js`ファイルを出力します。これらを一緒に使用することはできません。

次のカスタムサーバーの[例](https://github.com/vercel/next.js/tree/canary/examples/custom-server)をご覧ください：

```ts filename="server.ts" switcher
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'

const port = parseInt(process.env.PORT || '3000', 10)
const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
  createServer((req, res) => {
    const parsedUrl = parse(req.url!, true)
    handle(req, res, parsedUrl)
  }).listen(port)

  console.log(
    `> Server listening at http://localhost:${port} as ${
      dev ? 'development' : process.env.NODE_ENV
    }`
  )
})
```

```js filename="server.js" switcher
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'

const port = parseInt(process.env.PORT || '3000', 10)
const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
  createServer((req, res) => {
    const parsedUrl = parse(req.url, true)
    handle(req, res, parsedUrl)
  }).listen(port)

  console.log(
    `> Server listening at http://localhost:${port} as ${
      dev ? 'development' : process.env.NODE_ENV
    }`
  )
})
```

> `server.js`は、Next.jsのコンパイラやバンドルプロセスを通りません。このファイルが必要とする構文およびソースコードが、現在使用しているNode.jsバージョンと互換性があることを確認してください。[例を表示する](https://github.com/vercel/next.js/tree/canary/examples/custom-server)。

カスタムサーバーを実行するには、`package.json`内の`scripts`を次のように更新します：

```json filename="package.json"
{
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "NODE_ENV=production node server.js"
  }
}
```

または、`nodemon`を設定することもできます（[例](https://github.com/vercel/next.js/tree/canary/examples/custom-server)）。カスタムサーバーは次のインポートを使用してサーバーをNext.jsアプリケーションと接続します：

```js
import next from 'next'

const app = next({})
```

上記の`next`インポートは、次のオプションを持つオブジェクトを受け取る関数です：

| Option         | Type               | Description                                                                         |
| -------------- | ------------------ | ----------------------------------------------------------------------------------- |
| `conf`         | `Object`           | `next.config.js`で使用するのと同じオブジェクト。デフォルトは`{}`                   |
| `customServer` | `Boolean`          | （_オプション_）サーバーがNext.jsによって作成された場合はfalseに設定する            |
| `dev`          | `Boolean`          | （_オプション_）Next.jsを開発モードで起動するかどうか。デフォルトは`false`          |
| `dir`          | `String`           | （_オプション_）Next.jsプロジェクトの場所。デフォルトは`'.'`                         |
| `quiet`        | `Boolean`          | （_オプション_）サーバー情報を含むエラーメッセージを非表示にする。デフォルトは`false` |
| `hostname`     | `String`           | （_オプション_）サーバーがバックで稼働しているホスト名                               |
| `port`         | `Number`           | （_オプション_）サーバーがバックで稼働しているポート                                 |
| `httpServer`   | `node:http#Server` | （_オプション_）Next.jsがバックで稼働しているHTTPサーバー                            |
| `turbo`        | `Boolean`          | （_オプション_）Turbopackを有効にする                                                |

返された`app`は、Next.jsが要求を必要に応じて処理するために使用できます。

<PagesOnly>

## ファイルシステムルーティングの無効化

デフォルトでは、「Next」は`pages`フォルダ内の各ファイルを、そのファイル名に一致するパス名の下で提供します。プロジェクトがカスタムサーバーを使用している場合、この動作により、同一のコンテンツが複数のパスから提供され、SEOやUXに問題を引き起こす可能性があります。

この動作を無効にし、`pages`内のファイルに基づくルーティングを防ぐために、`next.config.js`を開き、`useFileSystemPublicRoutes`設定を無効にします：

```js filename="next.config.js"
module.exports = {
  useFileSystemPublicRoutes: false,
}
```

> `useFileSystemPublicRoutes`はSSRからファイル名ルートを無効にしますが、クライアントサイドのルーティングは依然としてそれらのパスにアクセスするかもしれません。このオプションを使用する場合、プログラムで望ましくないルートへのナビゲーションを防ぐ必要があります。

> クライアントサイドルーターを構成して、クライアントサイドリダイレクトをファイル名ルートに許可しないようにしたい場合もあります；そのためには[`router.beforePopState`](/docs/pages/api-reference/functions/use-router#routerbeforepopstate)を参照してください。

</PagesOnly>