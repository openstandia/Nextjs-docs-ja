---
title: アプリルーターインクリメンタル導入ガイド
nav_title: アプリルーターマイグレーション
description: 既存のNext.jsアプリケーションをPages RouterからApp Routerにアップグレードする方法を学びます。
---

このガイドでは以下のことをサポートします：

- [Next.jsアプリケーションをバージョン12からバージョン13に更新する](#nextjs-version)
- [`pages`ディレクトリおよび`app`ディレクトリで動作する新機能をアップグレードする](#upgrading-new-features)
- [`pages`から`app`への既存アプリケーションのインクリメンタルマイグレーション](#migrating-from-pages-to-app)

## アップグレード

### Node.js バージョン

最低限のNode.jsバージョンは**v18.17**です。詳細は[Node.jsのドキュメント](https://nodejs.org/docs/latest-v18.x/api/)を参照してください。

### Next.js バージョン

Next.jsバージョン13に更新するには、使用中のパッケージマネージャで次のコマンドを実行してください：

```bash title="Terminal"
npm install next@latest react@latest react-dom@latest
```

### ESLint バージョン

ESLintを使用している場合は、次のコマンドでESLintバージョンをアップグレードする必要があります：

```bash title="Terminal"
npm install -D eslint-config-next@latest
```

> **Good to know**: ESLintの変更を反映させるにはVS CodeでESLintサーバを再起動する必要があるかもしれません。コマンドパレット (`cmd+shift+p` on Mac; `ctrl+shift+p` on Windows) を開き、`ESLint: Restart ESLint Server`を検索してください。

## 次のステップ

更新が完了したら、以下のセクションを確認して次のステップを進めてください：

- [新機能のアップグレード](#upgrading-new-features)：改良されたImageやLinkコンポーネントなどの新機能へのアップグレードをサポートするガイド
- [`pages`から`app`ディレクトリへの移行](#migrating-from-pages-to-app)：`pages`から`app`へのインクリメンタルな移行をサポートするステップバイステップガイド

## 新機能のアップグレード

Next.js 13では、新しい[App Router](/docs/app/building-your-application/routing)が導入され、さまざまな新機能と規約が追加されました。新しいルーターは`app`ディレクトリに存在し、`pages`ディレクトリと共存することができます。

Next.js 13にアップグレードするためには、新しい[App Router](/docs/app/building-your-application/routing#the-app-router)を使用する必要はありません。`pages`ディレクトリを引き続き使用しながらも、両方のディレクトリで動作する新機能を利用することができます。たとえば、改良された[Imageコンポーネント](#image-component)、[Linkコンポーネント](#link-component)、[Scriptコンポーネント](#script-component)、および[フォント最適化](#font-optimization)などです。

### `<Image/>` コンポーネント

Next.js 12では、Imageコンポーネントに一時的なインポート`next/future/image`を使って新しい改良が導入されました。これらの改良には、クライアントサイドのJavaScriptの削減、画像の拡張やスタイルを容易にする方法、アクセシビリティの向上、ネイティブブラウザの遅延読み込みが含まれます。

バージョン13では、この新しい挙動が`next/image`のデフォルトとなりました。

新しいImageコンポーネントへの移行を支援するために2つのコード変換があります：

- [**`next-image-to-legacy-image` コーデモッド**](/docs/app/building-your-application/upgrading/codemods#next-image-to-legacy-image)：`next/image`のインポートを`next/legacy/image`に安全かつ自動的にリネームします。既存のコンポーネントは同じ挙動を維持します
- [**`next-image-experimental` コーデモッド**](/docs/app/building-your-application/upgrading/codemods#next-image-experimental)：インラインスタイルを危険に追加し、未使用のプロップスを削除します。既存のコンポーネントの挙動を新しいデフォルトに合わせるために変更されます。このコーデモッドを使用するには、まず`next-image-to-legacy-image`コーデモッドを実行する必要があります

### `<Link>` コンポーネント

[`<Link>` コンポーネント](/docs/app/building-your-application/routing/linking-and-navigating#link-component)は、もはや子要素に`<a>`タグを手動で追加する必要がありません。この挙動は[バージョン12.2](https://nextjs.org/blog/next-12-2)で実験的なオプションとして追加され、現在ではこれがデフォルトです。Next.js 13では、`<Link>`は常に`<a>`をレンダリングし、基礎となるタグにプロップスをフォワードできるようになりました。

例：

```jsx
import Link from 'next/link'

// Next.js 12: `<a>`がネストされていないと除外されます
<Link href="/about">
  <a>About</a>
</Link>

// Next.js 13: `<Link>`は常に内部で`<a>`をレンダリングします
<Link href="/about">
  About
</Link>
```

Next.js 13にリンクをアップグレードするには、[`new-link` コーデモッド](/docs/app/building-your-application/upgrading/codemods#new-link)を使用することができます。

### `<Script>` コンポーネント

[`next/script`](/docs/app/api-reference/components/script)の挙動は、`pages`と`app`の両方をサポートするように更新されていますが、円滑な移行を保証するためにいくつかの変更を加える必要があります：

- 以前に`_document.js`に含まれていた`beforeInteractive`スクリプトをルートレイアウトファイル(`app/layout.tsx`)に移動してください
- 実験的な`worker`の戦略は`app`ではまだ動作せず、この戦略で指定されたスクリプトは削除するか、異なる戦略（例：`lazyOnload`）に変更する必要があります
- `onLoad`、`onReady`、そして`onError`ハンドラはサーバーコンポーネントでは動作しませんので、クライアントコンポーネントに移動するか、完全に削除してください

### フォント最適化

これまでNext.jsは[フォントCSSのインライン化](/docs/app/building-your-application/optimizing/fonts)によってフォントを最適化していました。バージョン13では新しい[`next/font`](/docs/app/building-your-application/optimizing/fonts)モジュールが導入され、フォントの読み込み体験をカスタマイズできるようになり、優れたパフォーマンスとプライバシーを確保します。`next/font`は`pages`と`app`の両方のディレクトリでサポートされています。

[インライン化CSS](/docs/app/building-your-application/optimizing/fonts)は`pages`では動作しますが、`app`では動作しません。代わりに[`next/font`](/docs/app/building-your-application/optimizing/fonts)を使用してください。

`next/font`の使用方法は[フォント最適化](/docs/app/building-your-application/optimizing/fonts)ページを参照してください。

## `pages`から`app`への移行

> **🎥 視聴:** App Routerのインクリメンタル採用方法を学ぶ → [YouTube (16分間)](https://www.youtube.com/watch?v=YQMSietiFm0)．

App Routerへの移行は、Next.jsが構築するReactの機能（サーバコンポーネント、Suspenseなど）を初めて使用する機会になるかもしれません。新しいNext.jsの機能（特殊ファイルなど）やレイアウトと組み合わせることで、移行は新しい概念、精神的モデル、そして行動変更を学ぶことを意味します。

これらの更新の複雑さを軽減するために、移行を小さなステップに分けることをお勧めします。`app`ディレクトリは、`pages`ディレクトリと同時に動作するように意図的に設計されており、ページごとのインクリメンタルな移行が可能です。

- `app`ディレクトリはネストされたルートとレイアウトをサポートします。[Learn more](/docs/app/building-your-application/routing)
- ネストされたフォルダを使って[ルートを定義し](/docs/app/building-your-application/routing/defining-routes)、特別な`page.js`ファイルを使ってルートセグメントを公開可能にします。[Learn more](#step-4-migrating-pages)
- [特別なファイルの規約](/docs/app/building-your-application/routing#file-conventions)は、各ルートセグメントのユーザーインターフェースを作成するのに使用されます。最も一般的な特別なファイルは`page.js`と`layout.js`です。
  - `page.js`を使って、ルートに固有のUIを定義します。
  - `layout.js`を使って、複数のルートで共有されるUIを定義します。
  - `.js`、`.jsx`、`.tsx`のファイル拡張子が特別なファイルに使用できます。
- `app`ディレクトリ内にコンポーネント、スタイル、テストなどを配置することができます。[Learn more](/docs/app/building-your-application/routing)
- `getServerSideProps`や`getStaticProps`のようなデータ取得関数は`app`内の[新しいAPI](/docs/app/building-your-application/data-fetching)に置き換えられました。`getStaticPaths`は[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)に置き換えられました。
- `pages/_app.js`と`pages/_document.js`は、単一の`app/layout.js`ルートレイアウトに置き換えられました。[Learn more](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)
- `pages/_error.js`は、よりグラニュラーな`error.js`特別ファイルに置き換えられました。[Learn more](/docs/app/building-your-application/routing/error-handling)
- `pages/404.js`は、[`not-found.js`](/docs/app/api-reference/file-conventions/not-found)ファイルに置き換えられました。
- `pages/api/*` API Routesは、[`route.js`](/docs/app/api-reference/file-conventions/route)（ルートハンドラー）特別ファイルに置き換えられました。

### ステップ1：`app`ディレクトリの作成

最新のNext.jsバージョンにアップデートする（13.4以上が必要です）：

```bash
npm install next@latest
```

次に、プロジェクトのルート（または`src/`ディレクトリ）に新しい`app`ディレクトリを作成します。

### ステップ2：ルートレイアウトの作成

`app`ディレクトリ内に新しい`app/layout.tsx`ファイルを作成します。これは、`app`内のすべてのルートに適用される[ルートレイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)です。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  // レイアウトはchildrenプロップを受け入れる必要があります。
  // これはネストされたレイアウトまたはページで埋められます
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({
  // レイアウトはchildrenプロップを受け入れる必要があります。
  // これはネストされたレイアウトまたはページで埋められます
  children,
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```
</TabItem>
</Tabs>


- `app`ディレクトリは**ルートレイアウト**を含んでいる必要があります。
- Next.jsが自動的に作成しないため、ルートレイアウトは`<html>`、および`<body>`タグを定義する必要があります
- ルートレイアウトは、`pages/_app.tsx`と`pages/_document.tsx`ファイルを置き換えます
- `.js`、`.jsx`、`.tsx`の拡張子がレイアウトファイルに使用可能です

`<head>` HTML要素を管理するには、[組み込みのSEOサポートを使用することができます。](/docs/app/building-your-application/optimizing/metadata)

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Home',
  description: 'Welcome to Next.js',
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export const metadata = {
  title: 'Home',
  description: 'Welcome to Next.js',
}
```
</TabItem>
</Tabs>


#### `_document.js`と`_app.js`の移行

`_app`または`_document`ファイルがある場合は、内容（例：グローバルスタイル）をルートレイアウト(`app/layout.tsx`)にコピーすることができます。`app/layout.tsx`のスタイルは`pages/*`には適用されません。`_app` / `_document`を保持して、`pages/*`ルートが壊れないようにしながら移行を進めます。完全に移行が完了したら、安全にそれらを削除することができます。

Reactコンテキストプロバイダーを使用している場合、それらはクライアントコンポーネントに移行する必要があります。[Learn more](/docs/app/building-your-application/rendering/client-components).

#### `getLayout()`パターンをレイアウトに移行する（オプション）

Next.jsは[ページコンポーネントにプロパティを追加して、`pages`ディレクトリでのペーページレイアウトを実現することを推奨しました。](/docs/pages/building-your-application/routing/pages-and-layouts#layout-pattern#per-page-layouts)このパターンは、`app`ディレクトリでの[ネストされたレイアウトのネイティブサポート](/docs/app/building-your-application/routing/layouts-and-templates#layouts)に置き換えられます。

<details>
  <summary>Before と After の例を参照</summary>

**Before**

```jsx title="components/DashboardLayout.js"
export default function DashboardLayout({ children }) {
  return (
    <div>
      <h2>My Dashboard</h2>
      {children}
    </div>
  )
}
```

```jsx title="pages/dashboard/index.js"
import DashboardLayout from '../components/DashboardLayout'

export default function Page() {
  return <p>My Page</p>
}

Page.getLayout = function getLayout(page) {
  return <DashboardLayout>{page}</DashboardLayout>
}
```

**After**

- `pages/dashboard/index.js`から`Page.getLayout`プロパティを削除し、[ページを移行する手順](#step-4-migrating-pages)に従って`app`ディレクトリに移行します。

  ```jsx title="app/dashboard/page.js"
  export default function Page() {
    return <p>My Page</p>
  }
  ```

- `DashboardLayout`の内容を、`pages`ディレクトリの動作を保持するために[クライアントコンポーネント](/docs/app/building-your-application/rendering/client-components)に送信します。

  ```jsx title="app/dashboard/DashboardLayout.js"
  'use client' // この指令はファイルの先頭、インポートの前にあるべきです。

  // これはクライアントコンポーネントです
  export default function DashboardLayout({ children }) {
    return (
      <div>
        <h2>My Dashboard</h2>
        {children}
      </div>
    )
  }
  ```

- `DashboardLayout`を`app`ディレクトリ内の`layout.js`ファイルにインポートします。

  ```jsx title="app/dashboard/layout.js"
  import DashboardLayout from './DashboardLayout'

  // これはサーバコンポーネントです
  export default function Layout({ children }) {
    return <DashboardLayout>{children}</DashboardLayout>
  }
  ```

- `DashboardLayout.js`（クライアントコンポーネント）の非インタラクティブな部分を`layout.js`（サーバコンポーネント）にインクリメンタルに移動して、クライアントに送信するコンポーネントJavaScriptの量を削減することができます。

</details>

### ステップ3：`next/head`の移行

`pages`ディレクトリでは、`next/head` Reactコンポーネントを使用して、`title`や`meta`などの`<head>` HTML要素を管理します。`app`ディレクトリでは、`next/head`は新しい[組み込みSEOサポート](/docs/app/building-your-application/optimizing/metadata)に置き換えられます。

**Before:**

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My page title</title>
      </Head>
    </>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My page title</title>
      </Head>
    </>
  )
}
```
</TabItem>
</Tabs>


**After:**

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'My Page Title',
}

export default function Page() {
  return '...'
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export const metadata = {
  title: 'My Page Title',
}

export default function Page() {
  return '...'
}
```
</TabItem>
</Tabs>


[すべてのメタデータオプションを参照](/docs/app/api-reference/functions/generate-metadata)

### ステップ4：ページの移行

- [`app`ディレクトリのページ](/docs/app/building-your-application/routing)はデフォルトで[サーバコンポーネント](/docs/app/building-your-application/rendering/server-components)です。これは`pages`ディレクトリと異なり、`pages`ディレクトリではページが[クライアントコンポーネント](/docs/app/building-your-application/rendering/client-components)です
- `app`での[データ取得](/docs/app/building-your-application/data-fetching)は変更されました。`getServerSideProps`、`getStaticProps`、および`getInitialProps`はより簡単なAPIに置き換えられました
- `app`ディレクトリはネストされたフォルダを使用して[ルートを定義し](/docs/app/building-your-application/routing/defining-routes)、特別な`page.js`ファイルでルートセグメントを公開可能にします
- | `pages` ディレクトリ | `app` ディレクトリ       | ルート          |
  | ----------------- | --------------------- | -------------- |
  | `index.js`        | `page.js`             | `/`            |
  | `about.js`        | `about/page.js`       | `/about`       |
  | `blog/[slug].js`  | `blog/[slug]/page.js` | `/blog/post-1` |

ページの移行を2つの主要なステップに分けることをお勧めします：

- ステップ1：デフォルトでエクスポートされたページコンポーネントを新しいクライアントコンポーネントに移動します。
- ステップ2：新しいクライアントコンポーネントを`app`ディレクトリ内の新しい`page.js`ファイルにインポートします。

> **Good to know**: これは`pages`ディレクトリに最も類似した動作があるため、最も簡単な移行パスです。

**ステップ1：新しいクライアントコンポーネントを作成**

- クライアントコンポーネントをエクスポートする新しい別のファイルを`app`ディレクトリ内に作成します（例：`app/home-page.tsx`など）。クライアントコンポーネントを定義するには、ファイルの一番上に`'use client'`指令を追加します（インポートの前）。
  - ページルーターと同様に、クライアントコンポーネントを初回ページロード時に静的HTMLとして事前レンダリングする[最適化ステップがあります。](/docs/app/building-your-application/rendering/client-components#full-page-load)
- `pages/index.js`からエクスポートされたデフォルトのページコンポーネントを`app/home-page.tsx`に移動します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/home-page.tsx" switcher
'use client'

// これはクライアントコンポーネントです（`pages`ディレクトリ内のコンポーネントと同じです）
// データをプロップとして受け取り、状態と効果にアクセスし、
// 初期ページ負荷中にサーバーで事前レンダリングされます
export default function HomePage({ recentPosts }) {
  return (
    <div>
      {recentPosts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/home-page.js" switcher
'use client'

// これはクライアントコンポーネントです。プロップとしてデータを受け取り、
// `pages`ディレクトリのページコンポーネントと同様に、状態と効果にアクセスできます
export default function HomePage({ recentPosts }) {
  return (
    <div>
      {recentPosts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```
</TabItem>
</Tabs>


**ステップ2：新しいページを作成**

- `app`ディレクトリ内に新しい`app/page.tsx`ファイルを作成します。これが、デフォルトでサーバーコンポーネントになります。
- ページに`home-page.tsx`クライアントコンポーネントをインポートします。
- `pages/index.js`でデータを取得していた場合は、[新しいデータ取得APIを使用して](/docs/app/building-your-application/data-fetching/fetching)サーバーコンポーネント内でデータ取得ロジックを直接移動します。詳細は[データ取得アップグレードガイド](#step-6-migrating-data-fetching-methods)を参照してください。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
// クライアントコンポーネントをインポート
  import HomePage from './home-page'

  async function getPosts() {
    const res = await fetch('https://...')
    const posts = await res.json()
    return posts
  }

  export default async function Page() {
    // サーバーコンポーネントでデータを直接取得
    const recentPosts = await getPosts()
    // 取得したデータをクライアントコンポーネントに渡す
    return <HomePage recentPosts={recentPosts} />
  }
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
// クライアントコンポーネントをインポート
  import HomePage from './home-page'

  async function getPosts() {
    const res = await fetch('https://...')
    const posts = await res.json()
    return posts
  }

  export default async function Page() {
    // サーバーコンポーネントでデータを直接取得
    const recentPosts = await getPosts()
    // 取得したデータをクライアントコンポーネントに渡す
    return <HomePage recentPosts={recentPosts} />
  }
```
</TabItem>
</Tabs>


- 以前のページで`useRouter`を使用していた場合は、新しいルーティングフックに更新する必要があります。[Learn more](/docs/app/api-reference/functions/use-router).
- 開発用サーバーを起動し、[`http://localhost:3000`](http://localhost:3000)を訪れてください。既存のインデックスルートが`app`ディレクトリを通じて提供されているのが確認できるはずです。

### ステップ5：ルーティングフックの移行

`app`ディレクトリの新しい動作をサポートするための新しいルーターが追加されました。

`app`ディレクトリでは、新しいルーターをサポートするため、`next/navigation`からインポートされる3つの新しいフックを使用する必要があります：[`useRouter()`](/docs/app/api-reference/functions/use-router)、[`usePathname()`](/docs/app/api-reference/functions/use-pathname)、および[`useSearchParams()`](/docs/app/api-reference/functions/use-search-params)。

- 新しい`useRouter`フックは`next/navigation`からインポートされ、`pages`の`useRouter`フック（`next/router`からインポート）の動作と異なります。
  - [`next/router`からインポートした`useRouter`フック](/docs/pages/api-reference/functions/use-router)は、`app`ディレクトリではサポートされていませんが、`pages`ディレクトリでは引き続き使用できます。
- 新しい`useRouter`は`pathname`文字列を返しません。代わりに個別の`usePathname`フックを使用してください。
- 新しい`useRouter`は`query`オブジェクトを返しません。検索パラメータと動的ルートパラメータが分離されました。`useSearchParams`および`useParams`フックを代わりに使用してください。
- `useSearchParams`と`usePathname`を一緒に使用してページの変更をリッスンできます。[Router Events](/docs/app/api-reference/functions/use-router#router-events)セクションで詳細を確認してください。
- これらの新しいフックはクライアントコンポーネントでのみサポートされています。サーバーコンポーネントでは使用できません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example-client-component.tsx" switcher
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // ...
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example-client-component.js" switcher
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // ...
}
```
</TabItem>
</Tabs>


さらに、新しい`useRouter`フックは以下のような変更があります：

- `isFallback`は`fallback`が[置き換えられたため]削除されました
- `locale`、`locales`、`defaultLocales`、`domainLocales`の値は削除されました。`app`ディレクトリでは組み込みi18n Next.js機能が不要となったためです。[i18nの詳細についてはこちらを参照してください](/docs/app/building-your-application/routing/internationalization).
- `basePath`は削除されました。代替案は`useRouter`の一部ではなく、まだ実装されていません。
- `asPath`は、新しいルーターから`as`の概念が削除されたため、削除されました。
- `isReady`はもう必要がないため、削除されました。[`useSearchParams()`フックを使用する](/docs/app/api-reference/functions/use-search-params)コンポーネントは、静的レンダリング中に事前レンダリングステップをスキップし、ランタイムでクライアントでレンダリングされます。
- `route`は削除されました。`usePathname`または`useSelectedLayoutSegments()`が代替案を提供します。

[`useRouter()`のAPIリファレンスを参照](/docs/app/api-reference/functions/use-router)。

#### `pages`と`app`間でのコンポーネントの共有

`pages`と`app`ルーター間でのコンポーネントの互換性を保つには、[`next/compat/router`からの`useRouter`フック](/docs/pages/api-reference/functions/use-router#the-nextcompatrouter-export)を参照してください。
これは`pages`ディレクトリからの`useRouter`フックですが、ルーター間でコンポーネントを共有するときに使用することを意図しています。`app`ルーターのみで使用する準備ができたら、新しい[`next/navigation`からの`useRouter`](/docs/app/api-reference/functions/use-router)にアップデートしてください。

### ステップ6：データ取得方法の移行

`pages`ディレクトリでは、`getServerSideProps`や`getStaticProps`を使用してページのデータを取得します。`app`ディレクトリでは、これらのデータ取得関数が`fetch()`と`async` Reactサーバコンポーネントに基づいた[シンプルなAPI](/docs/app/building-your-application/data-fetching)に置き換えられました。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  // このリクエストは手動で無効にされるまでキャッシュされるべきです。
  // `getStaticProps`に類似しています。
  // `force-cache`がデフォルトで省略可能です。
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })

  // このリクエストはリクエスト毎に再フェッチするべきです。
  // `getServerSideProps`に類似しています。
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })

  // このリクエストは10秒間の有効期間でキャッシュされるべきです。
  // `revalidate`オプションを持つ`getStaticProps`に類似しています。
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })

  return <div>...</div>
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  // このリクエストは手動で無効にされるまでキャッシュされるべきです。
  // `getStaticProps`に類似しています。
  // `force-cache`がデフォルトで、省略可能です。
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })

  // このリクエストはリクエストごとに再フェッチされるべきです。
  // `getServerSideProps`に類似しています。
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })

  // このリクエストは10秒間の有効期間でキャッシュされるべきです。
  // `getStaticProps`の`revalidate`オプションに類似しています。
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })

  return <div>...</div>
}
```
</TabItem>
</Tabs>


#### サーバーサイドレンダリング（`getServerSideProps`）

`pages`ディレクトリでは、`getServerSideProps`を使用してサーバー上でデータを取得し、ファイル内のデフォルトでエクスポートされたReactコンポーネントにプロップスを転送します。ページの初期HTMLはサーバーからプリレンダリングされ、ブラウザでの「ハイドレーション」（インタラクティブにするため）に続きます。

```jsx title="pages/dashboard.js"
// `pages`ディレクトリ

export async function getServerSideProps() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return { props: { projects } }
}

export default function Dashboard({ projects }) {
  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```

App Routerでは、データ取得をReactコンポーネント内に配置することができる[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)を使用します。これにより、サーバーからのレンダリングHTMLを保持しながら、クライアントに送信するJavaScriptの量を減らすことができます。

`cache`オプションを`no-store`に設定することにより、このデータが[決してキャッシュされるべきではないことを示しています。](/docs/app/building-your-application/data-fetching/fetching)これは`pages`ディレクトリにおける`getServerSideProps`と類似しています。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/page.tsx" switcher
// `app`ディレクトリ

// この関数は任意の名前を持つことができます
async function getProjects() {
  const res = await fetch(`https://...`, { cache: 'no-store' })
  const projects = await res.json()

  return projects
}

export default async function Dashboard() {
  const projects = await getProjects()

  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/page.js" switcher
// `app`ディレクトリ

// この関数は任意の名前を持つことができます
async function getProjects() {
  const res = await fetch(`https://...`, { cache: 'no-store' })
  const projects = await res.json()

  return projects
}

export default async function Dashboard() {
  const projects = await getProjects()

  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```
</TabItem>
</Tabs>


#### リクエストオブジェクトへのアクセス

`pages`ディレクトリでは、Node.js HTTP APIに基づいてリクエストベースのデータを取得できます。

たとえば、`getServerSideProps`から`req`オブジェクトを取得し、リクエストのクッキーやヘッダーを取得することができます。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getServerSideProps({ req, query }) {
  const authHeader = req.getHeaders()['authorization'];
  const theme = req.cookies['theme'];

  return { props: { ... }}
}

export default function Page(props) {
  return ...
}
```

`app`ディレクトリはリクエストデータを取得するための新しい読取専用関数を使用します：

- [`headers()`](/docs/app/api-reference/functions/headers)：Web Headers APIをベースにしており、[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)内でリクエストヘッダーを取得するために使用できます。
- [`cookies()`](/docs/app/api-reference/functions/cookies)：Web Cookies APIをベースにしており、[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)内でクッキーを取得するために使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
// `app`ディレクトリ
import { cookies, headers } from 'next/headers'

async function getData() {
  const authHeader = headers().get('authorization')

  return '...'
}

export default async function Page() {
  // サーバーコンポーネント内で`cookies()`または`headers()`を直接
  // 使用するか、データ取得関数を使用できます
  const theme = cookies().get('theme')
  const data = await getData()
  return '...'
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
// `app`ディレクトリ
import { cookies, headers } from 'next/headers'

async function getData() {
  const authHeader = headers().get('authorization')

  return '...'
}

export default async function Page() {
  // サーバーコンポーネント内で`cookies()`または`headers()`を直接
  // 使用するか、データ取得関数を使用できます
  const theme = cookies().get('theme')
  const data = await getData()
  return '...'
}
```
</TabItem>
</Tabs>


#### 静的サイト生成（`getStaticProps`）

`pages`ディレクトリでは、`getStaticProps`関数を使用してビルド時にページを事前レンダリングします。この関数は外部APIやデータベースからデータを取得し、このデータをビルド中にページ全体に渡します。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getStaticProps() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return { props: { projects } }
}

export default function Index({ projects }) {
  return projects.map((project) => <div>{project.name}</div>)
}
```

`app`ディレクトリでは、[`fetch()`](/docs/app/api-reference/functions/fetch)を使用したデータ取得はデフォルトで`cache: 'force-cache'`に設定され、手動で無効化されるまでこのリクエストデータをキャッシュします。これは`pages`ディレクトリの`getStaticProps`に類似しています。

```jsx title="app/page.js"
// `app`ディレクトリ

// この関数は任意の名前を持つことができます
async function getProjects() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return projects
}

export default async function Index() {
  const projects = await getProjects()

  return projects.map((project) => <div>{project.name}</div>)
}
```

#### 動的パス（`getStaticPaths`）

`pages`ディレクトリでは、`getStaticPaths`関数を使用してビルド時に事前レンダリングされる動的パスを定義します。

```jsx title="pages/posts/[id].js"
// `pages`ディレクトリ
import PostLayout from '@/components/post-layout'

export async function getStaticPaths() {
  return {
    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
  }
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  return { props: { post } }
}

export default function Post({ post }) {
  return <PostLayout post={post} />
}
```

`app`ディレクトリでは、`getStaticPaths`は[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)に置き換えられています。

[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)は、`getStaticPaths`と似た動作をしますが、ルートパラメータを返すための簡略化されたAPIを提供し、[レイアウト](/docs/app/building-your-application/routing/layouts-and-templates)内で使用できます。生成される静的パラメータの戻り値の形は、ネストされた`param`オブジェクトの配列または解決されたパスの文字列ではなく、セグメントの配列です。

```jsx title="app/posts/[id]/page.js"
// `app`ディレクトリ
import PostLayout from '@/components/post-layout'

export async function generateStaticParams() {
  return [{ id: '1' }, { id: '2' }]
}

async function getPost(params) {
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  return post
}

export default async function Post({ params }) {
  const post = await getPost(params)

  return <PostLayout post={post} />
}
```

`generateStaticParams`という名前の使用は、`app`ディレクトリの新しいモデルにとって`getStaticPaths`よりも適切です。`get`という接頭辞は、`generate`というより説明的なものに置き換えられており、`getStaticProps`や`getServerSideProps`が必要なくなったため、単独で使用する場合にはより良くなっています。`Paths`の接尾辞は`Params`に置き換えられており、これは複数の動的セグメントを持つネストされたルーティングにとってより適切です。

---

#### `fallback`の置き換え

`pages`ディレクトリでは、`getStaticPaths`から返される`fallback`プロパティは、ビルド時に事前レンダリングされていないページの動作を定義するために使用されます。このプロパティは、ページが生成されている間にフォールバックページを表示するために`true`に設定できます。`false`に設定すると404ページを表示し、リクエスト時にページを生成するために`blocking`に設定できます。

```jsx title="pages/posts/[id].js"
// `pages`ディレクトリ

export async function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking'
  };
}

export async function getStaticProps({ params }) {
  ...
}

export default function Post({ post }) {
  return ...
}
```

`app`ディレクトリでは、[`config.dynamicParams`プロパティ](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)が[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)の外部でどのようにパラメータが扱われるかを制御します：

- **`true`**:（デフォルト）`generateStaticParams`に含まれていない動的セグメントはオンデマンドで生成されます。
- **`false`**: `generateStaticParams`に含まれない動的セグメントは404を返します。

これは`pages`ディレクトリの`getStaticPaths`の`fallback: true | false | 'blocking'`オプションを置き換えます。ストリーミングとの違いは些細なため、`dynamicParams`に`fallback: 'blocking'`オプションは含まれていません。

```jsx title="app/posts/[id]/page.js"
// `app`ディレクトリ

export const dynamicParams = true;

export async function generateStaticParams() {
  return [...]
}

async function getPost(params) {
  ...
}

export default async function Post({ params }) {
  const post = await getPost(params);

  return ...
}
```

[`dynamicParams`](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)を`true`に設定すると（デフォルト）、生成されていないルートセグメントがリクエストされると、それがサーバレンダリングされてキャッシュされます。

#### インクリメンタル静的再生成（`revalidate`を用いた`getStaticProps`）

`pages`ディレクトリでは、`getStaticProps`関数に`revalidate`フィールドを追加することにより、一定時間後にページを自動で再生成できます。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getStaticProps() {
  const res = await fetch(`https://.../posts`)
  const posts = await res.json()

  return {
    props: { posts },
    revalidate: 60,
  }
}

export default function Index({ posts }) {
  return (
    <Layout>
      <PostList posts={posts} />
    </Layout>
  )
}
```

`app`ディレクトリでは、[`fetch()`](/docs/app/api-reference/functions/fetch)を使用したデータ取得で`revalidate`を使用できます。これにより、指定された秒数間リクエストがキャッシュされます。

```jsx title="app/page.js"
// `app`ディレクトリ

async function getPosts() {
  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })
  const data = await res.json()

  return data.posts
}

export default async function PostList() {
  const posts = await getPosts()

  return posts.map((post) => <div>{post.name}</div>)
}
```

#### APIルート

APIルートは、`pages/api`ディレクトリでは変更なしに引き続き動作します。ただし、`app`ディレクトリでは[ルートハンドラー](/docs/app/building-your-application/routing/route-handlers)で置き換えられました。

ルートハンドラーは、Web [Request](https://developer.mozilla.org/docs/Web/API/Request)および[Response](https://developer.mozilla.org/docs/Web/API/Response) APIを使用して、特定のルートのカスタムリクエストハンドラーを作成できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/api/route.ts" switcher
export async function GET(request: Request) {}
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/api/route.js" switcher
export async function GET(request) {}
```
</TabItem>
</Tabs>


> **Good to know**: 以前、クライアントから外部APIを呼び出すためにAPIルートを使用していた場合、代わりに[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)を使用してデータをセキュアに取得することができます。[データ取得](/docs/app/building-your-application/data-fetching/fetching)についての詳細を確認してください。

### ステップ7：スタイリング

`pages`ディレクトリでは、グローバルスタイルシートは`pages/_app.js`にのみ制限されています。`app`ディレクトリでは、この制限が解除されました。グローバルスタイルを任意のレイアウト、ページ、またはコンポーネントに追加できます。

- [CSS Modules](/docs/app/building-your-application/styling/css#css-modules)
- [Tailwind CSS](/docs/app/building-your-application/styling/tailwind-css)
- [グローバルスタイル](/docs/app/building-your-application/styling/css#global-styles)
- [CSS-in-JS](/docs/app/building-your-application/styling/css-in-js)
- [外部スタイルシート](/docs/app/building-your-application/styling/css#external-stylesheets)
- [Sass](/docs/app/building-your-application/styling/sass)

#### Tailwind CSS

Tailwind CSSを使用している場合、`tailwind.config.js`ファイルに`app`ディレクトリを追加する必要があります：

```js title="tailwind.config.js"
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- この行を追加
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
}
```

また、`app/layout.js`ファイルにグローバルスタイルをインポートする必要があります：

```jsx title="app/layout.js"
import '../styles/globals.css'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

[Tailwind CSSを使用したスタイリングの詳細を参照](/docs/app/building-your-application/styling/tailwind-css)

## コーデモッド

Next.jsは、機能が非推奨になるときにコードベースをアップグレードするためのコード変換を提供しています。[Codemods](/docs/app/building-your-application/upgrading/codemods)参照してください。