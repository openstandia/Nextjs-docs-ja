---
title: 'App Router 増分採用ガイド'
nav_title: 'App Router マイグレーション'
description: '既存のNext.jsアプリケーションをPages RouterからApp Routerにアップグレードする方法を学ぶ。'
---

このガイドでは、次のことを支援します：

- [Next.jsアプリケーションをバージョン12からバージョン13に更新する](#nextjs-version)
- [`pages` と `app` 両方のディレクトリで動作する機能をアップグレードする](#upgrading-new-features)
- 既存のアプリケーションを `pages` から `app` へ段階的に移行する](#migrating-from-pages-to-app)

## アップグレード

### Node.js のバージョン

最小のNode.jsバージョンは **v18.17** になりました。詳細については[Node.js ドキュメント](https://nodejs.org/docs/latest-v18.x/api/)を参照してください。

### Next.js のバージョン

Next.jsのバージョン13に更新するには、お気に入りのパッケージマネージャーで以下のコマンドを実行してください：

```bash title="Terminal"
npm install next@latest react@latest react-dom@latest
```

### ESLint のバージョン

ESLintを使用している場合は、ESLintのバージョンをアップグレードする必要があります：

```bash title="Terminal"
npm install -D eslint-config-next@latest
```

> **Good to know**: ESLintサーバーの変更を有効にするため、VS CodeでESLintサーバーを再起動する必要があるかもしれません。コマンドパレットを開き（Macでは`cmd+shift+p`、Windowsでは`ctrl+shift+p`）、`ESLint: Restart ESLint Server`を検索してください。

## 次のステップ

更新後は、次のセクションをご覧ください：

- [新機能のアップグレード](#upgrading-new-features)：改善されたImageおよびLinkコンポーネントなど、新機能をアップグレードするためのガイド。
- [`pages` から `app` ディレクトリへの移行](#migrating-from-pages-to-app)： `pages` から `app` ディレクトリに段階的に移行するためのステップバイステップガイド。

## 新機能のアップグレード

Next.js 13では、[App Router](/docs/app/building-your-application/routing)との新機能と規約が導入されました。新しいRouterは`app`ディレクトリで使用可能で、`pages`ディレクトリと共存しています。

Next.js 13へのアップグレードは、新しい[App Router](/docs/app/building-your-application/routing#the-app-router)を使用することを**必要としません**。`pages`を引き続き使用でき、新しい機能（更新された[Imageコンポーネント](#image-component)、[Linkコンポーネント](#link-component)、[Scriptコンポーネント](#script-component)、および[フォントの最適化](#font-optimization)など）も両ディレクトリで動作します。

### `<Image/>` コンポーネント

Next.js 12では、新しいImageコンポーネントの改良が行われ、一時的なインポート：`next/future/image`が導入されました。これらの改善には、クライアントサイドJavaScriptの削減、画像の拡張とスタイル付けの簡素化、アクセシビリティの向上、ネイティブブラウザーの遅延読み込みが含まれていました。

バージョン13では、この新しい動作が`next/image`のデフォルトになりました。

新しいImageコンポーネントへの移行を支援するために2つのコードモジュールがあります：

- [**`next-image-to-legacy-image` コードモジュール**](/docs/app/building-your-application/upgrading/codemods#next-image-to-legacy-image)：`next/image`インポートを安全に自動で`next/legacy/image`にリネームします。既存のコンポーネントは同じ動作を維持します。
- [**`next-image-experimental` コードモジュール**](/docs/app/building-your-application/upgrading/codemods#next-image-experimental)：危険なことにインラインスタイルを追加し、未使用のpropsを削除します。これにより、既存のコンポーネントの動作を新しいデフォルトに合わせて変更します。このコードモジュールを使用するには、先に`next-image-to-legacy-image`コードモジュールを実行する必要があります。

### `<Link>` コンポーネント

[`<Link>` コンポーネント](/docs/app/building-your-application/routing/linking-and-navigating#link-component)は、もはや手動で`<a>`タグを子として追加する必要がありません。この動作は[バージョン12.2](https://nextjs.org/blog/next-12-2)で実験的オプションとして追加され、デフォルトになりました。Next.js 13で`<Link>` は常に`<a>`をレンダリングし、基礎となるタグにpropsを転送できるようになります。

例えば：

```jsx
import Link from 'next/link'

// Next.js 12: `<a>`をネストしなければならず、さもなければ除外されます
<Link href="/about">
  <a>About</a>
</Link>

// Next.js 13: `<Link>` は常に`<a>`を内部でレンダリングします
<Link href="/about">
  About
</Link>
```

Next.js 13へのリンクのアップグレードには[`new-link`コードモジュール](/docs/app/building-your-application/upgrading/codemods#new-link)を使用できます。

### `<Script>` コンポーネント

[`next/script`](/docs/app/api-reference/components/script)の動作は`pages`と`app`の両方をサポートするように更新されましたが、円滑な移行を確保するために、いくつかの変更が必要です：

- 以前に`_document.js`に含まれていた`beforeInteractive`スクリプトをrootレイアウトファイル（`app/layout.tsx`）に移動します。
- 実験段階の`worker`戦略はまだ`app`で機能しません。この戦略で指定されたスクリプトは削除するか、別の戦略（例：`lazyOnload`）を使用するように変更する必要があります。
- `onLoad`、`onReady`、`onError`のハンドラはServer Componentsでは機能しないため、[Client Component](/docs/app/building-your-application/rendering/server-components)に移動するか、完全に削除してください。

### フォントの最適化

以前は、Next.jsはフォントCSSをインライン化することでフォントを最適化していました。バージョン13では、よりパフォーマンスとプライバシーが確保された状態でフォントの読み込み体験をカスタマイズできる新しい[`next/font`](/docs/app/building-your-application/optimizing/fonts)モジュールが導入されました。`next/font`は`pages`と`app`ディレクトリの両方でサポートされています。

フォントのCSSをインライン化する手法は`pages`ではまだ動作しますが、`app`では動作しません。代わりに[`next/font`](/docs/app/building-your-application/optimizing/fonts)を使用してください。

使用方法については、[フォントの最適化](/docs/app/building-your-application/optimizing/fonts)ページをご覧ください。

## `pages` から `app` への移行

> **🎥 視聴する：** App Routerを段階的に採用する方法を学ぶ → [YouTube (16分)](https://www.youtube.com/watch?v=YQMSietiFm0)。

App Routerへの移行は、Next.jsが提供するServer ComponentsやSuspenseなどのReactの機能を初めて使用する機会になるかもしれません。特別なファイルやレイアウトといった新しいNext.jsの機能と組み合わせることで、移行には新しい概念やメンタルモデル、行動の変化を学ぶことが求められます。

これらの更新の複合的な複雑さを軽減するため、移行を小さなステップに分解することをお勧めします。`app`ディレクトリは意図的に`pages`ディレクトリと同時に動作するように設計されており、ページ単位での段階的な移行を可能にします。

- `app`ディレクトリでは、ネストされたルートとレイアウトをサポートしています。[詳細を学ぶ](/docs/app/building-your-application/routing)。
- ネストされたフォルダを使用してルートを定義し、特別な`page.js`ファイルを使用してルートセグメントを公開します。[詳細を学ぶ](#step-4-migrating-pages)。
- 特別なファイルの規約を使用して各ルートセグメントのUIを作成します。最も一般的な特別なファイルは`page.js`と`layout.js`です。
  - `page.js`を使用してルートに固有のUIを定義します。
  - `layout.js`を使用して複数のルート間で共有されるUIを定義します。
  - 特別なファイルには、`.js`、`.jsx`、または `.tsx`ファイル拡張子を使用できます。
- `app`ディレクトリ内に他のファイルを配置することができます（例：コンポーネント、スタイル、テストなど）。[詳細を学ぶ](/docs/app/building-your-application/routing)。
- `getServerSideProps`や`getStaticProps`のようなデータフェッチ関数は、`app`内で新しい[API](/docs/app/building-your-application/data-fetching)に置き換えられました。`getStaticPaths`は[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)に置き換えられました。
- `pages/_app.js`と`pages/_document.js`は、単一の`app/layout.js` root レイアウトに置き換えられました。[詳細を学ぶ](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)。
- `pages/_error.js`は、より詳細な`error.js`特別なファイルに置き換えられました。[詳細を学ぶ](/docs/app/building-your-application/routing/error-handling)。
- `pages/404.js`は[`not-found.js`](/docs/app/api-reference/file-conventions/not-found)ファイルに置き換えられました。
- `pages/api/*` APIルートは[`route.js`](/docs/app/api-reference/file-conventions/route)（Route Handler）特別なファイルに置き換えられました。

### ステップ 1： `app` ディレクトリの作成

最新のNext.jsバージョンに更新します（13.4以上が必要）：

```bash
npm install next@latest
```

その後、プロジェクトのルート（または`src/`ディレクトリ）に新しい`app`ディレクトリを作成します。

### ステップ 2：Root レイアウトの作成

`app`ディレクトリ内に新しい`app/layout.tsx`ファイルを作成します。これは[Root レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)であり、`app`内のすべてのルートに適用されます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  // Layouts must accept a children prop.
  // This will be populated with nested layouts or pages
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({
  // Layouts must accept a children prop.
  // This will be populated with nested layouts or pages
  children,
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```
</TabItem>
</Tabs>


- `app`ディレクトリは**必ず**root レイアウトを含める必要があります。
- root レイアウトは `<html>`, `<body>` タグを定義する必要があります。Next.jsは自動でそれらを作成しないためです
- root レイアウトは `pages/_app.tsx` および `pages/_document.tsx` ファイルを置き換えます。
- レイアウトファイルには `.js`、`.jsx`、または `.tsx` 拡張子を使用できます。

`<head>` HTML要素を管理するために、[組み込みのSEOサポート](/docs/app/building-your-application/optimizing/metadata)を使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Home',
  description: 'Welcome to Next.js',
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export const metadata = {
  title: 'Home',
  description: 'Welcome to Next.js',
}
```
</TabItem>
</Tabs>


#### `_document.js` と `_app.js` のマイグレーション

既存の`_app`または`_document`ファイルをお持ちの場合は、その内容（例：グローバルスタイル）をrootレイアウト（`app/layout.tsx`）にコピーできます。`app/layout.tsx`内のスタイルは`pages/*`には適用されません。`pages/*`ルートが壊れないようにするため、移行中は`_app`/`_document`を保持する必要があります。完全に移行した後、それらを安全に削除できます。

React Contextプロバイダーを使用している場合、それらを[Client Component](/docs/app/building-your-application/rendering/client-components)に移動する必要があります。

#### `getLayout()` パターンをレイアウトに移行する（オプション）

Next.jsはページコンポーネントにプロパティを追加して`pages`ディレクトリでページごとのレイアウトを実現することを推奨していました。このパターンは`app`ディレクトリでの[ネストされたレイアウト](/docs/app/building-your-application/routing/layouts-and-templates#layouts)のネイティブサポートに置き換えることができます。

<details>
<summary>前後の例を見る</summary>

**Before**

```jsx title="components/DashboardLayout.js"
export default function DashboardLayout({ children }) {
  return (
    <div>
      <h2>My Dashboard</h2>
      {children}
    </div>
  )
}
```

```jsx title="pages/dashboard/index.js"
import DashboardLayout from '../components/DashboardLayout'

export default function Page() {
  return <p>My Page</p>
}

Page.getLayout = function getLayout(page) {
  return <DashboardLayout>{page}</DashboardLayout>
}
```

**After**

- `pages/dashboard/index.js` の `Page.getLayout` プロパティを削除し、`app` ディレクトリへの[ページの移行手順](#step-4-migrating-pages)に従います。

  ```jsx title="app/dashboard/page.js"
  export default function Page() {
    return <p>My Page</p>
  }
  ```

- `DashboardLayout`の内容を新しい[Client Component](/docs/app/building-your-application/rendering/client-components) に移動し、`pages`ディレクトリの動作を保持します。

  ```jsx title="app/dashboard/DashboardLayout.js"
  'use client' // この指示はファイルの最上部、インポートより前に記述します。

  // これはClient Componentです
  export default function DashboardLayout({ children }) {
    return (
      <div>
        <h2>My Dashboard</h2>
        {children}
      </div>
    )
  }
  ```

- `DashboardLayout` を`app` ディレクトリ内の新しい`layout.js` ファイルにインポートします。

  ```jsx title="app/dashboard/layout.js"
  import DashboardLayout from './DashboardLayout'

  // これはServer Componentです
  export default function Layout({ children }) {
    return <DashboardLayout>{children}</DashboardLayout>
  }
  ```

- `DashboardLayout.js`（Client Component）のインタラクティブでない部分を段階的に`layout.js`（Server Component）に移動することで、クライアントに送信するコンポーネントJavaScriptの量を減らすことができます。

</details>

### ステップ 3： `next/head` のマイグレーション

`pages`ディレクトリでは、`next/head` Reactコンポーネントを使用して、`title`や`meta`などの`<head>` HTML要素を管理します。`app`ディレクトリでは、`next/head`は新しい[組み込みのSEOサポート](/docs/app/building-your-application/optimizing/metadata)に置き換えられます。

**前:**

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My page title</title>
      </Head>
    </>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My page title</title>
      </Head>
    </>
  )
}
```
</TabItem>
</Tabs>


**後:**

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'My Page Title',
}

export default function Page() {
  return '...'
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export const metadata = {
  title: 'My Page Title',
}

export default function Page() {
  return '...'
}
```
</TabItem>
</Tabs>


[すべてのメタデータオプションを参照](/docs/app/api-reference/functions/generate-metadata)。

### ステップ 4： ページの移行

- [`app`ディレクトリ](/docs/app/building-your-application/routing)内のページは、デフォルトで[Server Components](/docs/app/building-your-application/rendering/server-components)です。これは`pages`ディレクトリでページが[Client Components](/docs/app/building-your-application/rendering/client-components)であることとは異なります。
- `app`内の[データフェッチ](/docs/app/building-your-application/data-fetching)は変更されました。`getServerSideProps`、`getStaticProps`、`getInitialProps`はよりシンプルなAPIに置き換えられました。
- `app`ディレクトリは、ネストされたフォルダを使用してルートを定義し、特殊な`page.js`ファイルを使用してルートセグメントを公開します。
- | `pages` ディレクトリ | `app` ディレクトリ        | ルート          |
  | ---------------- | ---------------------- | --------------- |
  | `index.js`       | `page.js`              | `/`             |
  | `about.js`       | `about/page.js`        | `/about`        |
  | `blog/[slug].js` | `blog/[slug]/page.js`  | `/blog/post-1` |

ページの移行を二つの主要なステップに分割することをお勧めします：

- ステップ 1： デフォルトエクスポートされたPageコンポーネントを新しいClient Componentに移動します。
- ステップ 2： 新しいClient Componentを`app`ディレクトリ内の新しい`page.js`ファイルにインポートします。

> **Good to know**: これが`pages`ディレクトリに最もよく似た動作をするため、最も簡単な移行方法です。

**ステップ 1： 新しいClient Componentを作成します**

- `app`ディレクトリ内に新しいファイルを作成し（例：`app/home-page.tsx`）、Client Componentをエクスポートします。Client Componentsを定義するためには、`use client`ディレクティブをファイルのトップに（インポートより前に）追加します。
  - Pages Routerと同様に、最初のページロード時にClient Componentsを静的HTMLとしてプリレンダリングする[最適化ステップ](/docs/app/building-your-application/rendering/client-components#full-page-load)があります。
- `pages/index.js`から`app/home-page.tsx`にデフォルトエクスポートされたページコンポーネントを移動します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/home-page.tsx" switcher
'use client'

// これはClient Component（`pages`ディレクトリ内のコンポーネントと同じです）
// データをpropsとして受け取っている状態で、エフェクトにアクセスできます。
// そして、最初のページ読み込み時にサーバー上でプリレンダリングされます。
export default function HomePage({ recentPosts }) {
  return (
    <div>
      {recentPosts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/home-page.js" switcher
'use client'

// これはClient Componentです。データをpropsとして受け取り、
// `pages`ディレクトリのPageコンポーネントと同様に、状態とエフェクトにアクセスできます。
export default function HomePage({ recentPosts }) {
  return (
    <div>
      {recentPosts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```
</TabItem>
</Tabs>


**ステップ 2： 新しいページを作成します**

- `app`ディレクトリ内に新しい`app/page.tsx`ファイルを作成します。これはデフォルトでServer Componentです。
- ページに`home-page.tsx` Client Componentをインポートします。
- `pages/index.js`でデータをフェッチしていた場合、新しい[データ収集API](/docs/app/building-your-application/data-fetching/fetching)を使用してServer Component内にデータ収集ロジックを直接移動します。詳細については、[データフェッチのアップグレードガイド](#step-6-migrating-data-fetching-methods)を参照してください。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
// Client Componentをインポートします
  import HomePage from './home-page'

  async function getPosts() {
    const res = await fetch('https://...')
    const posts = await res.json()
    return posts
  }

  export default async function Page() {
    // Server Componentで直接データをフェッチします
    const recentPosts = await getPosts()
    // フェッチしたデータをClient Componentに転送します
    return <HomePage recentPosts={recentPosts} />
  }
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
// Client Componentをインポートします
  import HomePage from './home-page'

  async function getPosts() {
    const res = await fetch('https://...')
    const posts = await res.json()
    return posts
  }

  export default async function Page() {
    // Server Componentで直接データをフェッチします
    const recentPosts = await getPosts()
    // フェッチしたデータをClient Componentに転送します
    return <HomePage recentPosts={recentPosts} />
  }
```
</TabItem>
</Tabs>


- 以前のページで`useRouter`を使用していた場合、新しいルーティングフックに更新する必要があります。[詳細はこちら](/docs/app/api-reference/functions/use-router)。
- 開発サーバーを起動して[`http://localhost:3000`](http://localhost:3000)を訪れてください。この場合、既存のインデックスルートは`app`ディレクトリを通じて提供されているはずです。

### ステップ 5： ルーティングフックのマイグレーション

新しいルーターが`app`ディレクトリの新しい動作をサポートするために追加されました。

`app`内では、`next/navigation`からインポートされた3つの新しいフック：[`useRouter()`](/docs/app/api-reference/functions/use-router)、[`usePathname()`](/docs/app/api-reference/functions/use-pathname)、および[`useSearchParams()`](/docs/app/api-reference/functions/use-search-params)を使用する必要があります。

- 新しい`useRouter`フックは、`next/navigation`からインポートされ、`pages`の`useRouter`フック（`next/router`からインポートされるフック）とは異なる動作をします。
  - [`next/router`からインポートされる`useRouter`フック](https://nextjs.org/docs/canary/pages/api-reference/functions/use-router)は、`app`ディレクトリではサポートされていませんが、`pages`ディレクトリで引き続き使用できます。
- 新しい`useRouter`は`path

name`文字列を返しません。代わりに別の`usePathname`フックを使用してください。
- 新しい`useRouter`は`query`オブジェクトを返しません。検索パラメーターと動的ルートパラメーターは別々になります。代替として`useSearchParams`と`useParams`フックを使用してください。
- `useSearchParams`と`usePathname`を同時に使用してページの変更を監視できます。詳細は[ルーターイベント](/docs/app/api-reference/functions/use-router#router-events)セクションを参照してください。
- これらの新しいフックはClient Componentsでのみサポートされています。Server Componentsでは使用できません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example-client-component.tsx" switcher
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // ...
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example-client-component.js" switcher
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // ...
}
```
</TabItem>
</Tabs>


加えて、新しい`useRouter`フックには次のような変更があります：

- `isFallback`は削除されました。`fallback`が[置き換えられた](#replacing-fallback)ためです。
- `locale`、`locales`、`defaultLocales`、`domainLocales`の値は削除されました。組み込みのi18n Next.js機能が`app`ディレクトリでは利用できなくなったためです。[i18nについてもっと学ぶ](/docs/app/building-your-application/routing/internationalization)。
- `basePath`は削除されました。この代替は`useRouter`には含まれません。まだ実装されていません。
- `asPath`は削除されました。`as`の概念が新しいルーターから削除されました。
- `isReady`は不要になったため削除されました。[静的レンダリング](/docs/app/building-your-application/rendering/server-components#static-rendering-default)中に、[`useSearchParams()`](/docs/app/api-reference/functions/use-search-params)フックを使用するコンポーネントは、プリレンダーのステップをスキップし、クライアントでランタイムにレンダリングされます。
- `route`は削除されました。代替として`usePathname`や`useSelectedLayoutSegments()`を使用できます。

[`useRouter()`のAPIリファレンスを表示](/docs/app/api-reference/functions/use-router)。

#### `pages` と `app` 間でコンポーネントを共有する

コンポーネントを`pages`と`app`のルーター間で互換性を保つために、[`next/compat/router`の`useRouter`フックを参照してください](https://nextjs.org/docs/canary/pages/api-reference/functions/use-router#the-nextcompatrouter-export)。
これは`pages`ディレクトリの`useRouter`フックですが、ルーター間でコンポーネントを共有する際に使用することを意図しています。`app`ルーターでのみ使用する準備が整ったら、新しい[`next/navigation`の`useRouter`](/docs/app/api-reference/functions/use-router)に更新してください。

### ステップ 6： データフェッチメソッドのマイグレーション

`pages`ディレクトリでは、`getServerSideProps`と`getStaticProps`を使用してページのデータをフェッチします。`app`ディレクトリ内では、これらの以前のデータフェッチ関数は、`fetch()`と非同期のReact Server Componentsを基盤とする[よりシンプルなAPI](/docs/app/building-your-application/data-fetching)に置き換えられています。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  // このリクエストは手動で無効にされるまでキャッシュされるべきです。
  // `getStaticProps`に似ています。
  // `force-cache`はデフォルトであり、省略可能です。
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })

  // このリクエストは毎回再フェッチされるべきです。
  // `getServerSideProps`に似ています。
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })

  // このリクエストは10秒間の有効期限でキャッシュされるべきです。
  // `getStaticProps`の`revalidate`オプションに似ています。
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })

  return <div>...</div>
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  // このリクエストは手動で無効にされるまでキャッシュされるべきです。
  // `getStaticProps`に似ています。
  // `force-cache`はデフォルトであり、省略可能です。
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })

  // このリクエストは毎回再フェッチされるべきです。
  // `getServerSideProps`に似ています。
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })

  // このリクエストは10秒間の有効期限でキャッシュされるべきです。
  // `getStaticProps`の`revalidate`オプションに似ています。
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })

  return <div>...</div>
}
```
</TabItem>
</Tabs>


#### サーバーサイド・レンダリング (`getServerSideProps`)

`pages`ディレクトリでは、`getServerSideProps`を使用してサーバー上でデータをフェッチし、ファイル内のデフォルトでエクスポートされるReactコンポーネントにpropsを転送します。ページの初期HTMLはサーバーからプリレンダリングされ、その後ブラウザーでページを"ハイドレート"（インタラクティブにする）します。

```jsx title="pages/dashboard.js"
// `pages`ディレクトリ

export async function getServerSideProps() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return { props: { projects } }
}

export default function Dashboard({ projects }) {
  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```

App Routerでは、データフェッチをReactコンポーネントに共置することができ、これにより[Server Components](/docs/app/building-your-application/rendering/server-components)を使用したデータ収集が可能です。これにより、サーバーからレンダリングされたHTMLを保持しつつ、クライアントに送るJavaScriptの量を減らすことができます。

フェッチされたデータを[キャッシュしない](/docs/app/building-your-application/data-fetching/fetching)ことを示すため、`cache`オプションを`no-store`に設定できます。これは`pages`ディレクトリの`getServerSideProps`に似ています。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/page.tsx" switcher
// `app`ディレクトリ

// この関数の名前は何でも良い
async function getProjects() {
  const res = await fetch(`https://...`, { cache: 'no-store' })
  const projects = await res.json()

  return projects
}

export default async function Dashboard() {
  const projects = await getProjects()

  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/page.js" switcher
// `app`ディレクトリ

// この関数の名前は何でも良い
async function getProjects() {
  const res = await fetch(`https://...`, { cache: 'no-store' })
  const projects = await res.json()

  return projects
}

export default async function Dashboard() {
  const projects = await getProjects()

  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```
</TabItem>
</Tabs>


#### リクエストオブジェクトへのアクセス

`pages`ディレクトリでは、Node.js HTTP APIに基づいてリクエストベースのデータを取得することができます。

例えば、`getServerSideProps`から`req`オブジェクトを取得し、リクエストのクッキーやヘッダーを取得することができます。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getServerSideProps({ req, query }) {
  const authHeader = req.getHeaders()['authorization'];
  const theme = req.cookies['theme'];

  return { props: { ... }}
}

export default function Page(props) {
  return ...
}
```

`app`ディレクトリでは、リクエストデータを取得するための新しい読み取り専用関数を提供しています：

- [`headers`](/docs/app/api-reference/functions/headers)：WebヘッダーAPIに基づいており、Server Components内でリクエストヘッダーを取得するために使用できます。
- [`cookies`](/docs/app/api-reference/functions/cookies)：WebクッキーAPIに基づいており、Server Components内でクッキーを取得するために使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
// `app`ディレクトリ
import { cookies, headers } from 'next/headers'

async function getData() {
  const authHeader = (await headers()).get('authorization')

  return '...'
}

export default async function Page() {
  const theme = (await cookies()).get('theme')
  const data = await getData()
  return '...'
}
```
</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
// `app`ディレクトリ
import { cookies, headers } from 'next/headers'

async function getData() {
  const authHeader = (await headers()).get('authorization')

  return '...'
}

export default async function Page() {
  const theme = (await cookies()).get('theme')
  const data = await getData()
  return '...'
}
```
</TabItem>
</Tabs>


#### 静的サイト生成 (`getStaticProps`)

`pages`ディレクトリでは、`getStaticProps`関数を使用してビルド時にページを事前レンダリングします。この関数は外部APIからデータをフェッチしたり、直接データベースからデータを取得して、このデータを生成中にページ全体に渡すことができます。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getStaticProps() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return { props: { projects } }
}

export default function Index({ projects }) {
  return projects.map((project) => <div>{project.name}</div>)
}
```

`app`ディレクトリでは、[`fetch()`](/docs/app/api-reference/functions/fetch)を使用したデータフェッチは`cache: 'force-cache'`をデフォルトとし、リクエストデータを手動で無効にするまでキャッシュします。これは`pages`ディレクトリの`getStaticProps`に似ています。

```jsx title="app/page.js"
// `app`ディレクトリ

// この関数の名前は何でも良い
async function getProjects() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return projects
}

export default async function Index() {
  const projects = await getProjects()

  return projects.map((project) => <div>{project.name}</div>)
}
```

#### 動的パス (`getStaticPaths`)

`pages`ディレクトリでは、`getStaticPaths`関数を使用してビルド時に事前レンダリングする動的パスを定義します。

```jsx title="pages/posts/[id].js"
// `pages`ディレクトリ
import PostLayout from '@/components/post-layout'

export async function getStaticPaths() {
  return {
    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
  }
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  return { props: { post } }
}

export default function Post({ post }) {
  return <PostLayout post={post} />
}
```

`app`ディレクトリでは、`getStaticPaths`は[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)に置き換えられました。

[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)は`getStaticPaths`と同様の動作をしますが、ルートパラメータを返すためのシンプルなAPIを提供し、レイアウト内で使用することができます。`generateStaticParams`の戻り値の形はネストされた`param`オブジェクトの配列や解決されたパスの文字列ではなく、セグメントの配列です。

```jsx title="app/posts/[id]/page.js"
// `app`ディレクトリ
import PostLayout from '@/components/post-layout'

export async function generateStaticParams() {
  return [{ id: '1' }, { id: '2' }]
}

async function getPost(params) {
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  return post
}

export default async function Post({ params }) {
  const post = await getPost(params)

  return <PostLayout post={post} />
}
```

`app`ディレクトリでの新しいモデルには、`getStaticPaths`ではなく、`generateStaticParams`という名前がより適しています。`get`プレフィックスはより説明的な`generate`に置き換えられ、`getStaticProps`や`getServerSideProps`が不要になったことでより適しているようになりました。`Paths`サフィックスは`Params`に置き換えられ、複数の動的セグメントを持つネストされたルーティングに適しています。

---

#### `fallback` の置き換え

`pages`ディレクトリでは、`getStaticPaths`から返される`fallback`プロパティを使用して、ビルド時に事前レンダリングされないページの動作を定義します。このプロパティを`true`に設定すると、ページが生成されている間、フォールバックページを表示し、`false`にすると404ページを表示し、`blocking`にするとリクエスト時にページを生成します。

```jsx title="pages/posts/[id].js"
// `pages`ディレクトリ

export async function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking'
  };
}

export async function getStaticProps({ params }) {
  ...
}

export default function Post({ post }) {
  return ...
}
```

`app`ディレクトリでは、[`config.dynamicParams`プロパティ](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)により、[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)の外部のパラメータの取り扱いを制御します：

- **`true`**：（デフォルト）`generateStaticParams`に含まれない動的セグメントは随時生成されます。
- **`false`**：`generateStaticParams`に含まれない動的セグメントは404を返します。

これは`pages`ディレクトリの`getStaticPaths`の`fallback: true | false | 'blocking'`オプションを置き換えます。ストリーミングにより、`'blocking'`と`true`の違いはわずかなため、`dynamicParams`には`fallback: 'blocking'`オプションは含まれていません。

```jsx title="app/posts/[id]/page.js"
// `app`ディレクトリ

export const dynamicParams = true;

export async function generateStaticParams() {
  return [...]
}

async function getPost(params) {
  ...
}

export default async function Post({ params }) {
  const post = await getPost(params);

  return ...
}
```

[`dynamicParams`](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)が`true`に設定されている場合（デフォルト）、生成されていないルートセグメントが要求されるとサーバーレンダリングされてキャッシュされます。

#### 増分静的再生成 (`getStaticProps` with `revalidate`)

`pages`ディレクトリでは、`getStaticProps`関数を使って、特定の時間が経過した後にページを自動的に再生成する`revalidate`フィールドを追加できます。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getStaticProps() {
  const res = await fetch(`https://.../posts`)
  const posts = await res.json()

  return {
    props: { posts },
    revalidate: 60,
  }
}

export default function Index({ posts }) {
  return (
    <Layout>
      <PostList posts={posts} />
    </Layout>
  )
}
```

`app`ディレクトリでは、[`fetch()`](/docs/app/api-reference/functions/fetch)によるデータフェッチには`revalidate`を使用することができ、リクエストを指定された秒数だけキャッシュします。

```jsx title="app/page.js"
// `app`ディレクトリ

async function getPosts() {
  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })
  const data = await res.json()

  return data.posts
}

export default async function PostList() {
  const posts = await getPosts()

  return posts.map((post) => <div>{post.name}</div>)
}
```

#### API ルート

APIルートは、変更なしに`pages/api`ディレクトリで引き続き動作します。ただし、これらは`app`ディレクトリでは[Route Handlers](/docs/app/building-your-application/routing/route-handlers)に置き換えられました。

Route Handlersを使用すると、Web[Request](https://developer.mozilla.org/docs/Web/API/Request)および[Response](https://developer.mozilla.org/docs/Web/API/Response) APIを使用して、特定のルートに対するカスタムリクエストハンドラを作成できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/api/route.ts" switcher
export async function GET(request: Request) {}
```
</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/api/route.js" switcher
export async function GET(request) {}
```
</TabItem>
</Tabs>


> **Good to know**: 以前にクライアントから外部APIを呼び出すのにAPIルートを使用していた場合、セキュアにデータをフェッチするために[Server Components](/docs/app/building-your-application/rendering/server-components)を使用することができます。[データフェッチ](/docs/app/building-your-application/data-fetching/fetching)についてもっと学びましょう。

### ステップ 7： スタイリング

`pages`ディレクトリでは、グローバルスタイルシートは`pages/_app.js`のみで制限されていました。`app`ディレクトリでは、この制約は解除されました。グローバルスタイルは任意のレイアウト、ページ、またはコンポーネントに追加できます。

- [CSS モジュール](/docs/app/building-your-application/styling/css#css-modules)
- [Tailwind CSS](/docs/app/building-your-application/styling/tailwind-css)
- [グローバルスタイル](/docs/app/building-your-application/styling/css#global-styles)
- [CSS-in-JS](/docs/app/building-your-application/styling/css-in-js)
- [外部スタイルシート](/docs/app/building-your-application/styling/css#external-stylesheets)
- [Sass](/docs/app/building-your-application/styling/sass)

#### Tailwind CSS

Tailwind CSSを使用している場合は、`tailwind.config.js`ファイルに`app`ディレクトリを追加する必要があります：

```js title="tailwind.config.js"
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- この行を追加してください
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
}
```

また、グローバルスタイルを`app/layout.js`ファイルにインポートする必要があります：

```jsx title="app/layout.js"
import '../styles/globals.css'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

[Tailwind CSSを用いたスタイリングについての詳細はこちら](/docs/app/building-your-application/styling/tailwind-css)

## コードモジュール

Next.jsは、機能が非推奨になったときにコードベースをアップグレードするのに役立つCodemod変換を提供します。詳しくは[コードモジュール](/docs/app/building-your-application/upgrading/codemods)をご覧ください。