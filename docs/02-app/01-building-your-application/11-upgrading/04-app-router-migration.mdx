---
title: 'App Router Incremental Adoption Guide'
nav_title: 'App Router Migration'
description: '既存のNext.jsアプリケーションをPages RouterからApp Routerにアップグレードする方法を学びます。'
---

このガイドでは、以下のことを行います：

- [Next.jsアプリケーションをバージョン12からバージョン13にアップデートする](#nextjs-version)
- [`pages`ディレクトリと`app`ディレクトリの両方で動作する機能をアップグレードする](#upgrading-new-features)
- [既存のアプリケーションを段階的に`pages`から`app`に移行する](#migrating-from-pages-to-app)

## アップグレード {#upgrading}

### Node.jsバージョン {#node-js-version}

最低限必要なNode.jsのバージョンは**v18.17**です。詳細については、[Node.jsドキュメント](https://nodejs.org/docs/latest-v18.x/api/)をご覧ください。

### Next.jsバージョン {#next-js-version}

Next.jsバージョン13にアップデートするには、普段使用しているパッケージマネージャーで以下のコマンドを実行してください：

```bash title="Terminal"
npm install next@latest react@latest react-dom@latest
```

### ESLintバージョン {#eslint-version}

ESLintを使用している場合、ESLintのバージョンをアップグレードする必要があります：

```bash title="Terminal"
npm install -D eslint-config-next@latest
```

> **Good to know**: VS CodeでESLintの変更を反映させるために、ESLintサーバーを再起動する必要があるかもしれません。コマンドパレット（Macでは`cmd+shift+p`、Windowsでは`ctrl+shift+p`）を開き、`ESLint: Restart ESLint Server`を検索してください。

## 次のステップ {#next-steps}

アップデートが完了したら、次のステップを確認してください：

- [新しい機能をアップグレードする](#upgrading-new-features)：改善されたImageコンポーネントやLinkコンポーネントといった新しい機能にアップグレードするためのガイドです
- [`pages`から`app`ディレクトリに移行する](#migrating-from-pages-to-app)：`pages`から`app`ディレクトリに段階的に移行するためのステップバイステップガイドです

## 新しい機能をアップグレードする {#upgrading-new-features}

Next.js 13では、新しい特徴と規約を持つ[App Router](/docs/app/building-your-application/routing)が導入されました。この新しいRouterは`app`ディレクトリで利用可能であり、`pages`ディレクトリと共存します。

Next.js 13にアップグレードする際に、新しい[App Router](/docs/app/building-your-application/routing#the-app-router)を使用する必要は**ありません**。更新された[Imageコンポーネント](#image-component)、[Linkコンポーネント](#link-component)、[Scriptコンポーネント](#script-component)、および[フォント最適化](#font-optimization)といった、両方のディレクトリで動作する新しい機能を使用し続けることができます。

### `<Image/>`コンポーネント {#image-component}

Next.js 12では、一時的なimportである`next/future/image`によってImageコンポーネントに新たな改善が導入されました。これらの改善には、クライアントサイドのJavaScriptの削減、画像の拡張やスタイル化の容易化、アクセシビリティの向上、ブラウザのネイティブな遅延読み込みが含まれています。

バージョン13では、この新しい動作が`next/image`のデフォルトとなっています。

新しいImageコンポーネントに移行するための2つのコードモッドがあります：

- [**`next-image-to-legacy-image`コードモッド**](/docs/app/building-your-application/upgrading/codemods#next-image-to-legacy-image)：`next/image`のimportを`next/legacy/image`に安全かつ自動的にリネームします。既存のコンポーネントは同じ動作を維持します
- [**`next-image-experimental`コードモッド**](/docs/app/building-your-application/upgrading/codemods#next-image-experimental)：インラインスタイルを危険な方法と未使用のpropsを削除します。既存のコンポーネントの動作を新しいデフォルトに変更します。このコードモッドを使用するには、最初に`next-image-to-legacy-image`コードモッドを実行する必要があります

### `<Link>`コンポーネント {#link-component}

[`<Link>`コンポーネント](/docs/app/building-your-application/routing/linking-and-navigating#link-component)には、手動で子要素として`<a>`タグを追加する必要がなくなりました。この動作は[バージョン12.2](https://nextjs.org/blog/next-12-2)で実験的なオプションとして追加され、現在ではデフォルトです。Next.js 13では、`<Link>`は常に`<a>`としてレンダリングされ、propsを基になるタグに転送することができます。

例えば：

```jsx
import Link from 'next/link'

// Next.js 12: `<a>`はネストさせないと除外されます
<Link href="/about">
  <a>About</a>
</Link>

// Next.js 13: `<Link>`は常に`<a>`を内部でレンダリングします
<Link href="/about">
  About
</Link>
```

Next.js 13のリンクにアップグレードするには、[`new-link`コードモッド](/docs/app/building-your-application/upgrading/codemods#new-link)を使用できます。

### `<Script>`コンポーネント {#script-component}

[`next/script`](/docs/app/api-reference/components/script)の動作は、`pages`と`app`の両方をサポートするように更新されましたが、移行を円滑にするためにいくつか変更が必要です：

- 以前に`_document.js`に含めていた`beforeInteractive`スクリプトをrootレイアウトファイル（`app/layout.tsx`）に移動します
- 実験的な`worker`戦略はまだ`app`では動作しないため、この戦略を指定したスクリプトは削除するか、別の戦略（例：`lazyOnload`）に変更する必要があります
- `onLoad`、`onReady`、および`onError`ハンドラはServer Componentsでは動作しないため、それらを[Client Component](/docs/app/building-your-application/rendering/server-components)に移動するか、完全に削除してください

### フォント最適化 {#font-optimization}

以前、Next.jsは[フォントCSSをインライン化することによって](/docs/app/building-your-application/optimizing/fonts)フォントを最適化するのを支援していました。バージョン13では、[`next/font`](/docs/app/building-your-application/optimizing/fonts)モジュールが導入され、フォントの読み込み体験をカスタマイズしながら、優れたパフォーマンスとプライバシーを確保することができます。`next/font`は`pages`と`app`の両方のディレクトリでサポートされています。

`pages`では[CSSのインライン化](/docs/app/building-your-application/optimizing/fonts)は引き続き機能しますが、`app`では機能しません。代わりに[`next/font`](/docs/app/building-your-application/optimizing/fonts)を使用する必要があります。

[フォント最適化](/docs/app/building-your-application/optimizing/fonts)ページで`next/font`の使用方法を学ぶことができます。

## `pages`から`app`への移行 {#migrating-from-pages-to-app}

> **🎥 視聴する:** App Routerを段階的に導入する方法を学ぶ → [YouTube（16分）](https://www.youtube.com/watch?v=YQMSietiFm0)

App Routerへの移行は、Next.jsが基盤として構築しているReactの機能（例：Server Components, Suspenseなど）を初めて使用する場合があります。新しいNext.jsの機能（例：[特殊ファイル](/docs/app/building-your-application/routing#file-conventions), [レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#layouts)）と組み合わせて、新しいコンセプト、マインドモデル、行動の変化を学ぶ必要があります。

これらのアップデートによる複合的な複雑さを減らすために、移行を小さなステップに分けることをお勧めします。`app`ディレクトリは、段階的なページごとの移行を可能にするために`pages`ディレクトリと同時に機能するように意図的に設計されています。

- `app`ディレクトリは、入れ子ルート*と*レイアウトをサポートしています。[詳細を学ぶ](/docs/app/building-your-application/routing)
- ネストフォルダを使用して[ルートを定義し](/docs/app/building-your-application/routing/defining-routes)、特殊な`page.js`ファイルを使用してルートセグメントを公開にアクセス可能にします。[詳細を学ぶ](#step-4-migrating-pages)
- 各ルートセグメントにUIを作成するために[特殊ファイル規約](/docs/app/building-your-application/routing#file-conventions)が使用されます。最も一般的な特殊ファイルは、`page.js`および`layout.js`です。
  - `page.js`を使用してルートに固有のUIを定義します
  - `layout.js`を使用して、複数のルート間で共有されるUIを定義します
  - 特殊ファイル拡張子として`.js`, `.jsx`, `.tsx`を使用できます
- コンポーネント、スタイル、テストなどの他のファイルを`app`ディレクトリ内に同居させることができます。[詳細を学ぶ](/docs/app/building-your-application/routing)
- `getServerSideProps`および`getStaticProps`のようなデータ取得関数が、`app`内の[新しいAPI](/docs/app/building-your-application/data-fetching)に置き換えられました。`getStaticPaths`は[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)に置き換えられています。
- `pages/_app.js`および`pages/_document.js`は単一の`app/layout.js`のrootレイアウトに置き換えられています。[詳細を学ぶ](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)
- `pages/_error.js`は、より詳細な`error.js`特殊ファイルに置き換えられています。[詳細を学ぶ](/docs/app/building-your-application/routing/error-handling)
- `pages/404.js`は、[`not-found.js`](/docs/app/api-reference/file-conventions/not-found)ファイルに置き換えられています。
- `pages/api/*` APIルートは、[`route.js`](/docs/app/api-reference/file-conventions/route)（Route Handler）特殊ファイルに置き換えられました。

### ステップ1：`app`ディレクトリを作成する {#step-1-creating-the-app-directory}

最新のNext.jsバージョンにアップデートします（13.4以上が必要です）：

```bash
npm install next@latest
```

その後、プロジェクトのroot（または`src/`ディレクトリ）に新しい`app`ディレクトリを作成します。

### ステップ2：Rootレイアウトを作成する {#step-2-creating-a-root-layout}

`app`ディレクトリ内に新しい`app/layout.tsx`ファイルを作成します。これは`app`内のすべてのルートに適用される[rootレイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)です。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  // レイアウトはchildren propを受け入れなければなりません。
  // これはネストされたレイアウトやページで埋められます
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({
  // レイアウトはchildren propを受け入れなければなりません。
  // これはネストされたレイアウトやページで埋められます
  children,
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

</TabItem>
</Tabs>

- `app`ディレクトリは**必ず**rootレイアウトを含める必要があります；
- rootレイアウトは`<html>`および`<body>`タグを定義する必要がありますが、Next.jsは自動的に生成しないため；
- rootレイアウトは`pages/_app.tsx`および`pages/_document.tsx`ファイルを置き換えます；
- レイアウトファイルに`.js`, `.jsx`, `.tsx`拡張子を使用できます；

`<head>` HTML要素を管理するには、[組み込みのSEOサポート](/docs/app/building-your-application/optimizing/metadata)を使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Home',
  description: 'Welcome to Next.js',
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export const metadata = {
  title: 'Home',
  description: 'Welcome to Next.js',
}
```

</TabItem>
</Tabs>

#### `_document.js`と`_app.js`の移行 {#migrating-document-js-and-app-js}

既存の`_app`または`_document`ファイルがある場合、content（例：グローバルスタイル）をrootレイアウト（`app/layout.tsx`）にコピーできます。`app/layout.tsx`にあるスタイルは`pages/*`には適用されません。移行中に`_app` / `_document`を保持することで`pages/*`ルートが壊れないようにします。完全に移行が完了したら、それらを安全に削除できます。

React Contextプロバイダーを使用している場合は、[Client Component](/docs/app/building-your-application/rendering/client-components)に移動する必要があります。

#### レイアウトへの`getLayout()`パターンの移行（オプショナル） {#migrating-the-getlayout-pattern-to-layouts-optional}

Next.jsは、`pages`ディレクトリでページレベルのレイアウトを実現するために[Pageコンポーネントにプロパティを追加する](https://nextjs.org/docs/canary/pages/building-your-application/routing/pages-and-layouts#layout-pattern#per-page-layouts)ことを推奨していました。このパターンは、`app`ディレクトリで[ネストされたレイアウト](/docs/app/building-your-application/routing/layouts-and-templates#layouts)のネイティブサポートに置き換えることができます。

<details>
  <summary>前後の例を参照する</summary>

**前**

```jsx title="components/DashboardLayout.js"
export default function DashboardLayout({ children }) {
  return (
    <div>
      <h2>My Dashboard</h2>
      {children}
    </div>
  )
}
```

```jsx title="pages/dashboard/index.js"
import DashboardLayout from '../components/DashboardLayout'

export default function Page() {
  return <p>My Page</p>
}

Page.getLayout = function getLayout(page) {
  return <DashboardLayout>{page}</DashboardLayout>
}
```

**後**

- `pages/dashboard/index.js`から`Page.getLayout`プロパティを削除し、[ページ移行の手順](#step-4-migrating-pages)に従って`app`ディレクトリに移行します；

  ```jsx title="app/dashboard/page.js"
  export default function Page() {
    return <p>My Page</p>
  }
  ```

- `DashboardLayout`の内容を新しい[Client Component](/docs/app/building-your-application/rendering/client-components)に移動して、`pages`ディレクトリの動作を保持します；

  ```jsx title="app/dashboard/DashboardLayout.js"
  'use client' // このディレクティブはファイルのトップにあり、importの前に置く必要があります。

  // これはClient Componentです
  export default function DashboardLayout({ children }) {
    return (
      <div>
        <h2>My Dashboard</h2>
        {children}
      </div>
    )
  }
  ```

- `DashboardLayout`を`app`ディレクトリ内の新しい`layout.js`ファイルにインポートします；

  ```jsx title="app/dashboard/layout.js"
  import DashboardLayout from './DashboardLayout'

  // これはServer Componentです
  export default function Layout({ children }) {
    return <DashboardLayout>{children}</DashboardLayout>
  }
  ```

- `DashboardLayout.js`（Client Component）のインタラクティブでない部分を段階的に`layout.js`（Server Component）に移動して、クライアントに送信するコンポーネントのJavaScriptの量を減らすことができます；

</details>

### ステップ3：`next/head`の移行 {#step-3-migrating-next-head}

`pages`ディレクトリでは、`next/head` React コンポーネントを使用して`title`や`meta`などの`<head>` HTML要素を管理します。`app`ディレクトリでは、`next/head`が新しい[組み込みのSEOサポート](/docs/app/building-your-application/optimizing/metadata)に置き換えられます。

**前:**

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My page title</title>
      </Head>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My page title</title>
      </Head>
    </>
  )
}
```

</TabItem>
</Tabs>

**後:**

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'My Page Title',
}

export default function Page() {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export const metadata = {
  title: 'My Page Title',
}

export default function Page() {
  return '...'
}
```

</TabItem>
</Tabs>

[すべてのメタデータオプションを参照する](/docs/app/api-reference/functions/generate-metadata)

### ステップ4：ページの移行 {#step-4-migrating-pages}

- [`app`ディレクトリ](/docs/app/building-your-application/routing)内のページは、デフォルトで[Server Components](/docs/app/building-your-application/rendering/server-components)です。これは、`pages`ディレクトリが[Client Components](/docs/app/building-your-application/rendering/client-components)であることとは異なります。
- `app`内の[データ取得](/docs/app/building-your-application/data-fetching)が`getServerSideProps`、`getStaticProps`および`getInitialProps`に置き換えてよりシンプルなAPIを使用します；
- `app`ディレクトリは、ネストフォルダを使用して[ルートを定義](/docs/app/building-your-application/routing/defining-routes)し、特殊な`page.js`ファイルを使用してルートセグメントを公開にアクセス可能にします。
- | `pages`ディレクトリ | `app`ディレクトリ     | ルート         |
  | ------------------- | --------------------- | -------------- |
  | `index.js`          | `page.js`             | `/`            |
  | `about.js`          | `about/page.js`       | `/about`       |
  | `blog/[slug].js`    | `blog/[slug]/page.js` | `/blog/post-1` |

ページの移行を2つの主要なステップに分けることをお勧めします：

- ステップ1：デフォルトでエクスポートされているPageコンポーネントを新しいClientコンポーネントに移動します。
- ステップ2：`app`ディレクトリ内に新しい`page.js`ファイルを作成し、新しいClientコンポーネントをインポートします。

> **Good to know**: これは`pages`ディレクトリとの最も類似する動作を持つため、最も簡単な移行パスです。

**ステップ1：新しいClientコンポーネントを作成する**

- `app`ディレクトリ内に新しい個別のファイル（例：`app/home-page.tsx`）を作成し、Clientコンポーネントをエクスポートします。Clientコンポーネントを定義するには、`'use client'`ディレクティブをファイルの上部（importの前）に追加します。
  - Pages Routerと同様に、初回のページロード時にClientコンポーネントを静的なHTMLとしてプリレンダリングする[最適化ステップ](/docs/app/building-your-application/rendering/client-components#full-page-load)があります。
- `pages/index.js`のデフォルトでエクスポートされたページコンポーネントを`app/home-page.tsx`に移動します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/home-page.tsx" switcher
'use client'

// これはClientコンポーネントであり、`pages`ディレクトリ内のコンポーネントと同様です。
// propsとしてデータを受け取り、状態やエフェクトにアクセス可能であり、
// 初回のページロード時にサーバー上でプリレンダリングされます。
export default function HomePage({ recentPosts }) {
  return (
    <div>
      {recentPosts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/home-page.js" switcher
'use client'

// これはClientコンポーネントです。データをpropsとして受け取り、
// 状態やエフェクトにアクセスすることができ、`pages`ディレクトリのページコンポーネントと同様です。
export default function HomePage({ recentPosts }) {
  return (
    <div>
      {recentPosts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```

</TabItem>
</Tabs>

**ステップ2：新しいページを作成する**

- `app`ディレクトリ内に新しい`app/page.tsx`ファイルを作成します。これはデフォルトでServerコンポーネントです。
- `home-page.tsx` Clientコンポーネントをページにインポートします。
- `pages/index.js`でデータを取得していた場合、新しい[データ取得API](/docs/app/building-your-application/data-fetching/fetching)を使用してServerコンポーネント内にデータ取得ロジックを移動します。詳細については、[データ取得アップグレードガイド](#step-6-migrating-data-fetching-methods)を参照してください。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
// Clientコンポーネントをインポート
import HomePage from './home-page'

async function getPosts() {
  const res = await fetch('https://...')
  const posts = await res.json()
  return posts
}

export default async function Page() {
  // サーバーコンポーネント内で直接データを取得
  const recentPosts = await getPosts()
  // 取得したデータをClientコンポーネントに転送
  return <HomePage recentPosts={recentPosts} />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
// Clientコンポーネントをインポート
import HomePage from './home-page'

async function getPosts() {
  const res = await fetch('https://...')
  const posts = await res.json()
  return posts
}

export default async function Page() {
  // サーバーコンポーネント内で直接データを取得
  const recentPosts = await getPosts()
  // 取得したデータをClientコンポーネントに転送
  return <HomePage recentPosts={recentPosts} />
}
```

</TabItem>
</Tabs>

- 以前のページで`useRouter`を使用していた場合、新しいルートフックにアップデートする必要があります。[詳細を学ぶ](/docs/app/api-reference/functions/use-router)
- 開発サーバーを起動し、[`http://localhost:3000`](http://localhost:3000)にアクセスします。既存のindexルートが`app`ディレクトリを通じて提供されていることが確認できます。

### ステップ5：ルーティングフックの移行 {#step-5-migrating-routing-hooks}

新しいRouterが、`app`ディレクトリでの新しい動作をサポートするために追加されました。

`app`では、`next/navigation`からインポートした3つの新しいフック[`useRouter()`](/docs/app/api-reference/functions/use-router), [`usePathname()`](/docs/app/api-reference/functions/use-pathname), [`useSearchParams()`](/docs/app/api-reference/functions/use-search-params)を使用する必要があります。

- 新しい`useRouter`フックは`next/navigation`からインポートされ、`next/router`からインポートされた`pages`内の`useRouter`とは異なる動作をします；
  - [`next/router`からインポートされた`useRouter`フック](https://nextjs.org/docs/canary/pages/api-reference/functions/use-router)は`app`ディレクトリでサポートされていませんが、`pages`ディレクトリでは引き続き使用できます；
- 新しい`useRouter`は、`pathname`文字列を返しません。代わりに、`usePathname`フックを使用してください；
- 新しい`useRouter`は、`query`オブジェクトを返しません。検索パラメータや動的ルートパラメータは、`useSearchParams`と`useParams`フックを別々に使用します；
- `useSearchParams`と`usePathname`を一緒に使用してページの変更を監視できます。[Router Events](/docs/app/api-reference/functions/use-router#router-events)セクションで詳細を確認することができます；
- これらの新しいフックはClientコンポーネントでのみサポートされています。Serverコンポーネントでは使用できません；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example-client-component.tsx" switcher
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example-client-component.js" switcher
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // ...
}
```

</TabItem>
</Tabs>

加えて、新しい`useRouter`フックには以下の変更があります：

- `isFallback`は削除されました。`fallback`が[置き換えられた](#replacing-fallback)ためです；
- `locale`、`locales`、`defaultLocales`、`domainLocales`の値は削除されました。組み込みのi18n Next.js機能は`app`ディレクトリでは必要ありません；[i18nについての詳細を学ぶ](/docs/app/building-your-application/routing/internationalization)；
- `basePath`は削除されました。代替策は`useRouter`の一部にはなりません。まだ実装されていません；
- `asPath`は削除されました。新しいRouterから`as`の概念が削除されたためです；
- `isReady`は削除されました。もはや必要ありません。 [静的レンダリング](/docs/app/building-your-application/rendering/server-components#static-rendering-default)中に、 [useSearchParams()](/docs/app/api-reference/functions/use-search-params)フックを使用するコンポーネントは、プリレンダリングステップをスキップし、クライアントで実行時にレンダリングされます；
- `route`は削除されました。`usePathname`または`useSelectedLayoutSegments()`が代替手段を提供します；

[`useRouter()` API リファレンスを参照する](/docs/app/api-reference/functions/use-router).

#### `pages`と`app`間でコンポーネントを共有する {#sharing-components-between-pages-and-app}

`pages`と`app`ルーター間のコンポーネントを互換性のある状態に保つため、[`next/compat/router`の`useRouter`フック](https://nextjs.org/docs/canary/pages/api-reference/functions/use-router#the-nextcompatrouter-export)を参照してください。
これは`pages`ディレクトリの`useRouter`フックですが、コンポーネントをルーター間で共有する際に意図されています。`app`ルーターでのみ使用する準備が整ったら、新しい[`next/navigation`の`useRouter`](/docs/app/api-reference/functions/use-router)にアップデートしてください。

### ステップ6：データ取得メソッドの移行 {#step-6-migrating-data-fetching-methods}

`pages`ディレクトリは、ページのデータを取得するために`getServerSideProps`と`getStaticProps`を使用します。`app`ディレクトリ内では、これらの以前のデータ取得関数を、`fetch()`および`async` React Server Componentsの上に構築された[シンプルなAPI](/docs/app/building-your-application/data-fetching)に置き換えます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  // このリクエストは手動で無効化されるまでキャッシュされます。
  // `getStaticProps`に似ています。
  // `force-cache`がデフォルトであり、省略可能です。
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })

  // このリクエストは各リクエストごとに再取得されます。
  // `getServerSideProps`に似ています。
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })

  // このリクエストは10秒間のキャッシュ寿命があります。
  // `revalidate`オプションを持つ`getStaticProps`に似ています。
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })

  return <div>...</div>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  // このリクエストは手動で無効化されるまでキャッシュされます。
  // `getStaticProps`に似ています。
  // `force-cache`がデフォルトであり、省略可能です。
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })

  // このリクエストは各リクエストごとに再取得されます。
  // `getServerSideProps`に似ています。
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })

  // このリクエストは10秒間のキャッシュ寿命があります。
  // `revalidate`オプションを持つ`getStaticProps`に似ています。
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })

  return <div>...</div>
}
```

</TabItem>
</Tabs>

#### サーバーサイドレンダリング（`getServerSideProps`） {#server-side-rendering-getserversideprops}

`pages`ディレクトリでは、サーバー上でデータを取得し、ファイル内のデフォルトエクスポートされたReactコンポーネントにpropsを転送するために`getServerSideProps`が使用されます。ページの初期HTMLはサーバーからプリレンダリングされ、その後のブラウザでの「ハイドレーション」が行われ、インタラクティブになります。

```jsx title="pages/dashboard.js"
// `pages`ディレクトリ

export async function getServerSideProps() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return { props: { projects } }
}

export default function Dashboard({ projects }) {
  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```

App Routerでは、データ取得をReactコンポーネント内にコロケーションすることができ、[Server Components](/docs/app/building-your-application/rendering/server-components)を使用して実現できます。これにより、クライアントに送信するJavaScriptの量を減少させながら、サーバーからレンダリングされたHTMLを維持することができます。

`cache`オプションを`no-store`に設定することで、取得したデータを[キャッシュしないことを指定する](/docs/app/building-your-application/data-fetching/fetching)ことができます。これは`pages`ディレクトリの`getServerSideProps`に類似しています。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/page.tsx" switcher
// `app`ディレクトリ

// この関数は任意の名前を付けることができます
async function getProjects() {
  const res = await fetch(`https://...`, { cache: 'no-store' })
  const projects = await res.json()

  return projects
}

export default async function Dashboard() {
  const projects = await getProjects()

  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/page.js" switcher
// `app`ディレクトリ

// この関数は任意の名前を付けることができます
async function getProjects() {
  const res = await fetch(`https://...`, { cache: 'no-store' })
  const projects = await res.json()

  return projects
}

export default async function Dashboard() {
  const projects = await getProjects()

  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

#### リクエストオブジェクトへのアクセス {#accessing-request-object}

`pages`ディレクトリでは、Node.js HTTP APIに基づいてリクエストベースのデータを取得できます。

たとえば、`getServerSideProps`から`req`オブジェクトを取得し、リクエストのcookieやヘッダを取得するために使用することができます。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getServerSideProps({ req, query }) {
  const authHeader = req.getHeaders()['authorization'];
  const theme = req.cookies['theme'];

  return { props: { ... }}
}

export default function Page(props) {
  return ...
}
```

`app`ディレクトリではリクエストデータを取得するための新しい読み取り専用関数が公開されています：

- [`headers`](/docs/app/api-reference/functions/headers): Web Headers APIに基づいており、リクエストヘッダを取得するために[Server Components](/docs/app/building-your-application/rendering/server-components)内で使用することができます；
- [`cookies`](/docs/app/api-reference/functions/cookies): Web Cookies APIに基づいており、cookieを取得するために[Server Components](/docs/app/building-your-application/rendering/server-components)内で使用することができます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
// `app`ディレクトリ
import { cookies, headers } from 'next/headers'

async function getData() {
  const authHeader = (await headers()).get('authorization')

  return '...'
}

export default async function Page() {
  // サーバーコンポーネント内で直接 `cookies` または `headers` を使用できます
  // またはデータ取得関数内で使用
  const theme = (await cookies()).get('theme')
  const data = await getData()
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
// `app`ディレクトリ
import { cookies, headers } from 'next/headers'

async function getData() {
  const authHeader = (await headers()).get('authorization')

  return '...'
}

export default async function Page() {
  // サーバーコンポーネント内で直接 `cookies` または `headers` を使用できます
  // またはデータ取得関数内で使用
  const theme = (await cookies()).get('theme')
  const data = await getData()
  return '...'
}
```

</TabItem>
</Tabs>

#### 静的サイト生成(`getStaticProps`) {#static-site-generation-getstaticprops}

`pages`ディレクトリでは、`getStaticProps`関数を使用してビルド時にページを事前レンダリングします。この関数は、外部APIからデータをフェッチしたり、データベースから直接データを取得し、このデータをビルド中にページ全体に渡すことができます。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getStaticProps() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return { props: { projects } }
}

export default function Index({ projects }) {
  return projects.map((project) => <div>{project.name}</div>)
}
```

`app`ディレクトリでは、[`fetch()`](/docs/app/api-reference/functions/fetch)を使用したデータ取得は`cache: 'force-cache'`がデフォルトであり、リクエストデータを手動で無効化するまでキャッシュします。これは`pages`ディレクトリの`getStaticProps`に類似しています。

```jsx title="app/page.js"
// `app`ディレクトリ

// この関数は任意の名前を付けることができます
async function getProjects() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return projects
}

export default async function Index() {
  const projects = await getProjects()

  return projects.map((project) => <div>{project.name}</div>)
}
```

#### 動的パス(`getStaticPaths`) {#dynamic-paths-getstaticpaths}

`pages`ディレクトリでは、`getStaticPaths`関数を使用して、ビルド時にプリレンダリングするべき動的なパスを定義します。

```jsx title="pages/posts/[id].js"
// `pages`ディレクトリ
import PostLayout from '@/components/post-layout'

export async function getStaticPaths() {
  return {
    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
  }
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  return { props: { post } }
}

export default function Post({ post }) {
  return <PostLayout post={post} />
}
```

`app`ディレクトリでは、`getStaticPaths`が[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)に置き換えられます。

[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)は`getStaticPaths`と同様に動作しますが、ルートパラメータを返すためのAPIがシンプルになっており、[layouts](/docs/app/building-your-application/routing/layouts-and-templates)の中で使用することができます。`generateStaticParams`の返り値の形式はネストされた`param`オブジェクトの配列ではなく、解決されたパスの文字列です。

```jsx title="app/posts/[id]/page.js"
// `app`ディレクトリ
import PostLayout from '@/components/post-layout'

export async function generateStaticParams() {
  return [{ id: '1' }, { id: '2' }]
}

async function getPost(params) {
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  return post
}

export default async function Post({ params }) {
  const post = await getPost(params)

  return <PostLayout post={post} />
}
```

`app`ディレクトリの新しいモデルにとって`generateStaticParams`という名前を使用することは、`getStaticPaths`よりも適切です。`get`プレフィックスはより説明的な`generate`に置き換えられ、`getStaticProps`と`getServerSideProps`がもはや必要でないため、単独で使うには適しています。`Paths`サフィックスは、動的セグメントを持つネストされたルーティングにとってより適切な`Params`に置き換えられています。

---

#### `fallback`の置き換え {#replacing-fallback}

`pages`ディレクトリでは、`getStaticPaths`から返される`fallback`プロパティを使用して、ビルド時に事前レンダリングされていないページの動作を定義します。このプロパティは、ページが生成されている間にフォールバックページを表示する`true`に設定するか、404ページを表示する`false`、またはリクエスト時にページを生成する`blocking`に設定できます。

```jsx title="pages/posts/[id].js"
// `pages`ディレクトリ

export async function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking'
  };
}

export async function getStaticProps({ params }) {
  ...
}

export default function Post({ post }) {
  return ...
}
```

`app`ディレクトリでは[`config.dynamicParams`プロパティ](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)が[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)の範囲外のparamsの取り扱いを制御します：

- **`true`**：（デフォルト）`generateStaticParams`に含まれていない動的セグメントはオンデマンドで生成されます；
- **`false`**：`generateStaticParams`に含まれていない動的セグメントは404を返します；

これは、`pages`ディレクトリの`getStaticPaths`の`fallback: true | false | 'blocking'`オプションを置き換えます。`fallback: 'blocking'`オプションは`dynamicParams`に含まれていないのは、`'blocking'`と`true`の違いがストリーミングでわずかだからです。

```jsx title="app/posts/[id]/page.js"
// `app`ディレクトリ

export const dynamicParams = true;

export async function generateStaticParams() {
  return [...]
}

async function getPost(params) {
  ...
}

export default async function Post({ params }) {
  const post = await getPost(params);

  return ...
}
```

[`dynamicParams`](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)が`true`（デフォルト）に設定されている場合、生成されていないルートセグメントが要求されると、サーバーでレンダリングされ、キャッシュされます。

#### インクリメンタル静的再生成（`getStaticProps` with `revalidate`） {#incremental-static-regeneration-getstaticprops-with-revalidate}

`pages`ディレクトリでは、`getStaticProps`関数は一定の時間が経過した後に自動的にページを再生成するために`revalidate`フィールドを追加できます。

```jsx title="pages/index.js"
// `pages`ディレクトリ

export async function getStaticProps() {
  const res = await fetch(`https://.../posts`)
  const posts = await res.json()

  return {
    props: { posts },
    revalidate: 60,
  }
}

export default function Index({ posts }) {
  return (
    <Layout>
      <PostList posts={posts} />
    </Layout>
  )
}
```

`app`ディレクトリでは、[`fetch()`](/docs/app/api-reference/functions/fetch)を使用したデータ取得に`revalidate`を使用することができ、指定された秒数間、リクエストをキャッシュします。

```jsx title="app/page.js"
// `app`ディレクトリ

async function getPosts() {
  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })
  const data = await res.json()

  return data.posts
}

export default async function PostList() {
  const posts = await getPosts()

  return posts.map((post) => <div>{post.name}</div>)
}
```

#### APIルート {#api-routes}

APIルートは、変更なしに`pages/api`ディレクトリで引き続き動作します。ただし、これらは`app`ディレクトリ内での[Route Handlers](/docs/app/building-your-application/routing/route-handlers)に置き換えられました。

Route Handlersを使用すると、指定されたルートにカスタムリクエストハンドラを作成し、Web[Request](https://developer.mozilla.org/docs/Web/API/Request)および[Response](https://developer.mozilla.org/docs/Web/API/Response)APIを使用できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/api/route.ts" switcher
export async function GET(request: Request) {}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/api/route.js" switcher
export async function GET(request) {}
```

</TabItem>
</Tabs>

> **Good to know**: クライアントから外部APIを呼び出すために以前APIルートを使用していた場合、代わりに[Server Components](/docs/app/building-your-application/rendering/server-components)を使用してデータを安全にフェッチすることができます。[データ取得について学ぶ](/docs/app/building-your-application/data-fetching/fetching)。

### ステップ7：スタイリング {#step-7-styling}

`pages`ディレクトリでは、グローバルスタイルシートが`pages/_app.js`に限定されています。`app`ディレクトリを使用する際、この制約が解除されました。グローバルスタイルは任意のレイアウト、ページ、またはコンポーネントに追加できます。

- [CSSモジュール](/docs/app/building-your-application/styling/css#css-modules)
- [Tailwind CSS](/docs/app/building-your-application/styling/tailwind-css)
- [グローバルスタイル](/docs/app/building-your-application/styling/css#global-styles)
- [CSS-in-JS](/docs/app/building-your-application/styling/css-in-js)
- [外部スタイルシート](/docs/app/building-your-application/styling/css#external-stylesheets)
- [Sass](/docs/app/building-your-application/styling/sass)

#### Tailwind CSS {#tailwind-css}

Tailwind CSSを使用している場合、`tailwind.config.js`ファイルに`app`ディレクトリを追加する必要があります：

```js title="tailwind.config.js"
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- この行を追加
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
}
```

また、`app/layout.js`ファイルでグローバルスタイルをインポートする必要があります：

```jsx title="app/layout.js"
import '../styles/globals.css'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

[Tailwind CSSを使用したスタイリングについての詳細はこちら](/docs/app/building-your-application/styling/tailwind-css)

## コードモッド {#codemods}

Next.jsは、機能が非推奨になるときにコードベースをアップグレードするのに役立つコードモッド変換を提供しています。[コードモッズ](/docs/app/building-your-application/upgrading/codemods)をご参照ください。
