---
title: 'Fast Refresh'
description: 'Fast Refreshは、Reactコンポーネントに加えた編集内容に即座にフィードバックを与えるホットモジュールリロード体験です。'
---

Fast refreshは、Next.jsに統合されたReactの機能で、ファイルを保存したときに一時的なクライアントサイドの状態を維持しながらブラウザページをライブリロードできるようにします。これは**9.4以降のすべてのNext.jsアプリケーション**でデフォルトで有効になっています。Fast Refreshが有効になっている場合、ほとんどの編集は1秒以内に反映されるはずです。

## 動作の仕組み {#how-it-works}

- **Reactコンポーネントのみをエクスポートする**ファイルを編集すると、Fast Refreshはそのファイルのコードのみを更新し、コンポーネントを再レンダリングします。そのファイル内でスタイル、レンダリングロジック、イベントハンドラ、またはエフェクトを編集できます
- Reactコンポーネントでないエクスポートを持つファイルを編集した場合、Fast Refreshはそのファイルと、インポートしている他のファイルを再実行します。したがって、`Button.js`と`Modal.js`の両方が`theme.js`をインポートしている場合、`theme.js`を編集すると両方のコンポーネントが更新されます
- 最後に、React tree外のファイルによってインポートされている**ファイルを編集**した場合、Fast Refreshは**フルリロードにフォールバック**します。Reactコンポーネントをレンダリングするが、**非Reactコンポーネント**によってインポートされた値もエクスポートするファイルがあるかもしれません。たとえば、コンポーネントが定数もエクスポートし、非Reactユーティリティファイルがそれをインポートする場合です。この場合、定数を別のファイルに移動し、両方のファイルにインポートすることを検討してください。これにより、Fast Refreshが再び機能するようになります。他のケースは通常、同様の方法で解決できます。

## エラーの回復力 {#error-resilience}

### 構文エラー {#syntax-errors}

開発中に構文エラーを起こした場合は、それを修正してファイルを再保存することができます。エラーは自動的に消えるため、アプリをリロードする必要はありません。**コンポーネントの状態を失うことはありません**。

### ランタイムエラー {#runtime-errors}

コンポーネント内でランタイムエラーを引き起こすミスをすると、コンテキストオーバーレイが表示されます。エラーを修正すると、アプリをリロードせずにオーバーレイが自動的に消えます。

エラーがレンダリング中に発生していない場合、コンポーネントの状態は保持されます。エラーがレンダリング中に発生した場合、Reactは更新されたコードを使用してアプリケーションを再マウントします。

アプリに[error boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)がある場合（これは本番環境での優雅な失敗において推奨されます）、レンダリングエラー後の次の編集でレンダリングを再試行します。これにより、エラーバウンダリーがあることで常にrootアプリの状態にリセットされるのを防ぐことができます。ただし、エラーバウンダリーはあまりにも詳細に設定すべきではありません。Reactは本番環境で使用し、常に意図的に設計されるべきです。

## 制限事項 {#limitations}

Fast Refreshは、編集しているコンポーネントのローカルReact状態を保持しようとしますが、あくまで安全である場合に限ります。ファイルを編集するたびにローカル状態がリセットされる理由はいくつかあります：

- ローカル状態はクラスコンポーネントには保持されません（状態が保持されるのは関数コンポーネントとHooksのみです）
- 編集しているファイルには、Reactコンポーネントに加えて**他の**エクスポートが含まれている可能性があります
- 時には、`HOC(WrappedComponent)`のような高階コンポーネントを呼び出す結果をエクスポートするファイルがあります。返されるコンポーネントがクラスである場合、その状態はリセットされます
- `export default () => <div />;`のような匿名アロー関数は、Fast Refreshがローカルコンポーネント状態を保持しない原因となります。大規模なコードベースの場合は、[`name-default-component` codemod](https://nextjs.org/docs/canary/pages/building-your-application/upgrading/codemods#name-default-component)を使用できます。

コードベースが関数コンポーネントとHooksに移行するにつれて、より多くのケースで状態が保持されることが期待されます。

## ヒント {#tips}

- Fast Refreshはデフォルトで関数コンポーネント（およびHooks）内でのReactローカル状態を保持します
- 状態をリセットし、コンポーネントを再マウントさせたい場合があります。例えば、マウント時にのみ発生するアニメーションを調整する場合に便利です。この場合、編集しているファイルのどこかに`// @refresh reset`を追加します。この指示はファイルにローカルであり、そのファイル内で定義されたコンポーネントを編集時に毎回再マウントするようFast Refreshに指示します
- 開発中に編集するコンポーネントに`console.log`または`debugger;`を追加できます
- インポートが大文字小文字を区別することを覚えておいてください。インポートが実際のファイル名と一致しない場合、Fastおよびフルリフレッシュが失敗することがあります。たとえば、`'./header'`と`'./Header'`などです。

## Fast RefreshとHooks {#fast-refresh-and-hooks}

可能な場合、Fast Refreshは編集間でコンポーネントの状態を保持しようとします。特に`useState`と`useRef`は、引数やHook呼び出しの順序が変更されない限り、以前の値を保持します。

依存性のあるHooks—例えば`useEffect`、`useMemo`、`useCallback`—は、Fast Refresh中に**常に**更新されます。Fast Refreshが発生している間は、依存リストは無視されます。

たとえば、`useMemo(() => x * 2, [x])`を`useMemo(() => x * 10, [x])`に編集するとき、`x`（依存性）は変更されていないが、再実行されます。もしReactがそうしなかったら、編集が画面に反映されなかったでしょう！

時には、これが予期しない結果を引き起こすことがあります。例えば、空の依存配列を持つ`useEffect`ですら、Fast Refreshの間に1回再実行されることがあります。

しかし、Fast Refreshがなくても`useEffect`の偶発的な再実行に耐性のあるコードを書くことは良いプラクティスです。これにより、後で新しい依存性を導入するのが容易になり、[React Strict Mode](https://nextjs.org/docs/canary/pages/api-reference/config/next-config-js/reactStrictMode)によって強制されます。これを有効にすることを強くお勧めします。
