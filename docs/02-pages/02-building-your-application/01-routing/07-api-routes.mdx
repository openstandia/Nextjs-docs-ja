---
title: 'API Routes'
description: 'Next.jsはAPI Routesをサポートしており、Next.jsアプリを離れることなくAPIを構築できます。ここでその仕組みを学びましょう。'
---

<details>
  <summary>具体例</summary>

- [API Routes Request Helpers](https://github.com/vercel/next.js/tree/canary/examples/api-routes-middleware)
- [API Routes with GraphQL](https://github.com/vercel/next.js/tree/canary/examples/api-routes-graphql)
- [API Routes with REST](https://github.com/vercel/next.js/tree/canary/examples/api-routes-rest)
- [API Routes with CORS](https://github.com/vercel/next.js/tree/canary/examples/api-routes-cors)

</details>

> **Good to know**: app routerを使用している場合、API Routesの代わりに[Server Components](/docs/app/building-your-application/rendering/server-components)または[Route Handlers](/docs/app/building-your-application/routing/route-handlers)を使用できます。

API routesはNext.jsで**公開API**を構築するためのソリューションを提供します。

`pages/api`フォルダ内の任意のファイルは`/api/*`にマッピングされ、`page`ではなくAPIエンドポイントとして扱われます。これらはサーバーサイドでのみバンドルされ、クライアントサイドのバンドルサイズを増やすことはありません。

たとえば、以下のAPIルートはステータスコード`200`でJSONレスポンスを返します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/hello.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

type ResponseData = {
  message: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  res.status(200).json({ message: 'Hello from Next.js!' })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/hello.js" switcher
export default function handler(req, res) {
  res.status(200).json({ message: 'Hello from Next.js!' })
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - API Routesは、[CORSヘッダーを指定していません](https://developer.mozilla.org/docs/Web/HTTP/CORS)。つまり、デフォルトで**同一オリジンのみ**です。この動作は、リクエストハンドラーを[CORS request helpers](https://github.com/vercel/next.js/tree/canary/examples/api-routes-cors)でラップすることでカスタマイズできます。
> - API Routesは[静的エクスポート](https://nextjs.org/docs/canary/pages/building-your-application/deploying/static-exports)と一緒に使用することはできません。ただし、App Routerの[Route Handlers](/docs/app/building-your-application/routing/route-handlers)は可能です。
> - API Routesは、`next.config.js`内の[`pageExtensions`設定](https://nextjs.org/docs/canary/pages/api-reference/config/next-config-js/pageExtensions)の影響を受けます。

## パラメータ {#parameters}

```tsx
export default function handler(req: NextApiRequest, res: NextApiResponse) {
  // ...
}
```

- `req`: [http.IncomingMessage](https://nodejs.org/api/http.html#class-httpincomingmessage)のインスタンス
- `res`: [http.ServerResponse](https://nodejs.org/api/http.html#class-httpserverresponse)のインスタンス

## HTTPメソッド {#http-methods}

APIルートにおいて異なるHTTPメソッドを処理するには、リクエストハンドラー内で`req.method`を使用することができます。以下のように：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/hello.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    // POSTリクエストを処理
  } else {
    // 他のHTTPメソッドを処理
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/hello.js" switcher
export default function handler(req, res) {
  if (req.method === 'POST') {
    // POSTリクエストを処理
  } else {
    // 他のHTTPメソッドを処理
  }
}
```

</TabItem>
</Tabs>

## リクエストヘルパー {#request-helpers}

API Routesは、受信リクエスト（`req`）を解析する組み込みのリクエストヘルパーを提供します：

- `req.cookies` - リクエストによって送信されたクッキーを含むオブジェクト。デフォルトは`{}`
- `req.query` - [クエリ文字列](https://en.wikipedia.org/wiki/Query_string)を含むオブジェクト。デフォルトは`{}`
- `req.body` - `content-type`によって解析されたボディを含むオブジェクト。ボディが送信されていない場合は`null`

### カスタム設定 {#custom-config}

すべてのAPI Routeは、デフォルトの設定を変更するために`config`オブジェクトをエクスポートできます。デフォルト設定は次のようになります：

```js
export const config = {
  api: {
    bodyParser: {
      sizeLimit: '1mb',
    },
  },
  // この関数を実行するために許可される最大期間を指定（秒単位）
  maxDuration: 5,
}
```

`bodyParser`は自動的に有効になります。ボディを`Stream`として消費したり、[`raw-body`](https://www.npmjs.com/package/raw-body)を使用したりするには、これを`false`に設定できます。

自動`bodyParsing`を無効にするユースケースの1つは、たとえば[GitHubから](https://docs.github.com/en/developers/webhooks-and-events/webhooks/securing-your-webhooks#validating-payloads-from-github)の**Webhook**リクエストの生のボディを検証することです。

```js
export const config = {
  api: {
    bodyParser: false,
  },
}
```

`bodyParser.sizeLimit`は解析されたボディの最大サイズで、[bytes](https://github.com/visionmedia/bytes.js)でサポートされている任意のフォーマットで指定できます。次のようになります：

```js
export const config = {
  api: {
    bodyParser: {
      sizeLimit: '500kb',
    },
  },
}
```

`externalResolver`は、このルートが*express*や*connect*のような外部リゾルバによって処理されていることをサーバーに示す明示的なフラグです。このオプションを有効にすると、未解決のリクエストに対する警告が無効になります。

```js
export const config = {
  api: {
    externalResolver: true,
  },
}
```

`responseLimit`は自動的に有効になり、API Routesのレスポンスボディが4MBを超えると警告します。

Next.jsをサーバーレス環境で使用していない場合、CDNや専用のメディアホストを使用しないことのパフォーマンスへの影響を理解した上で、この制限を`false`に設定できます。

```js
export const config = {
  api: {
    responseLimit: false,
  },
}
```

`responseLimit`は、バイト数または`bytes`がサポートする任意の文字列フォーマット（例：`1000`、`'500kb'`または`'3mb'`）を受け付けることもできます。この値は警告が表示される前の最大レスポンスサイズになります。デフォルトは4MBです（上記参照）

```js
export const config = {
  api: {
    responseLimit: '8mb',
  },
}
```

## レスポンスヘルパー {#response-helpers}

[サーバーレスポンスオブジェクト](https://nodejs.org/api/http.html#http_class_http_serverresponse)（しばしば`res`として略される）は、開発者の体験を向上させ、新しいAPIエンドポイントを迅速に作成するためのExpress.js風のヘルパーメソッドのセットを含んでいます。

含まれるヘルパーは次のとおりです：

- `res.status(code)` - ステータスコードを設定する関数。`code`は有効な[HTTPステータスコード](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)でなければなりません
- `res.json(body)` - JSONレスポンスを送信します。`body`は[直列化可能なオブジェクト](https://developer.mozilla.org/docs/Glossary/Serialization)でなければなりません
- `res.send(body)` - HTTPレスポンスを送信します。`body`は`string`、`object`、または`Buffer`である可能性があります
- `res.redirect([status,] path)` - 指定されたパスまたはURLにリダイレクトします。`status`は有効な[HTTPステータスコード](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)でなければなりません。指定されない場合、`status`は"307"（一時的なリダイレクト）がデフォルトです
- `res.revalidate(urlPath)` - `getStaticProps`を使用して[ページをオンデマンドで再検証](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath)します。`urlPath`は`string`でなければなりません

### レスポンスのステータスコードを設定する {#setting-the-status-code-of-a-response}

クライアントにレスポンスを返す際に、レスポンスのステータスコードを設定することができます。

次の例では、レスポンスのステータスコードを`200` (`OK`)に設定し、`message`プロパティを`Hello from Next.js!`という値でJSONレスポンスとして返します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/hello.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

type ResponseData = {
  message: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  res.status(200).json({ message: 'Hello from Next.js!' })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/hello.js" switcher
export default function handler(req, res) {
  res.status(200).json({ message: 'Hello from Next.js!' })
}
```

</TabItem>
</Tabs>

### JSONレスポンスを送信する {#sending-a-json-response}

クライアントにレスポンスを返す際には、JSONレスポンスを送信することができます。これは[直列化可能なオブジェクト](https://developer.mozilla.org/docs/Glossary/Serialization)でなければなりません。
実際のアプリケーションでは、要求されたエンドポイントの結果に基づいて、リクエストのステータスをクライアントに知らせることができます。

次の例では、ステータスコード`200` (`OK`)と非同期操作の結果でJSONレスポンスを送信します。try catchブロックに含まれているため、エラーが発生する可能性があり、適切なステータスコードとエラーメッセージがクライアントに送信されます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/hello.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const result = await someAsyncOperation()
    res.status(200).json({ result })
  } catch (err) {
    res.status(500).json({ error: 'failed to load data' })
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/hello.js" switcher
export default async function handler(req, res) {
  try {
    const result = await someAsyncOperation()
    res.status(200).json({ result })
  } catch (err) {
    res.status(500).json({ error: 'failed to load data' })
  }
}
```

</TabItem>
</Tabs>

### HTTPレスポンスを送信する {#sending-a-http-response}

HTTPレスポンスの送信は、JSONレスポンスを送信する場合と同じ方法で機能します。唯一の違いは、レスポンスボディが`string`、`object`、または`Buffer`である可能性があることです。

次の例では、非同期操作の結果で、ステータスコード`200` (`OK`)のHTTPレスポンスを送信します。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/hello.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const result = await someAsyncOperation()
    res.status(200).send({ result })
  } catch (err) {
    res.status(500).send({ error: 'failed to fetch data' })
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/hello.js" switcher
export default async function handler(req, res) {
  try {
    const result = await someAsyncOperation()
    res.status(200).send({ result })
  } catch (err) {
    res.status(500).send({ error: 'failed to fetch data' })
  }
}
```

</TabItem>
</Tabs>

### 特定のパスまたはURLにリダイレクトする {#redirects-to-a-specified-path-or-url}

フォームを例に取ると、クライアントがフォームを送信した後に、特定のパスまたはURLにリダイレクトしたいかもしれません。

次の例では、フォームが正常に送信された場合、クライアントを`/`パスにリダイレクトします：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/hello.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { name, message } = req.body

  try {
    await handleFormInputAsync({ name, message })
    res.redirect(307, '/')
  } catch (err) {
    res.status(500).send({ error: 'Failed to fetch data' })
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/hello.js" switcher
export default async function handler(req, res) {
  const { name, message } = req.body

  try {
    await handleFormInputAsync({ name, message })
    res.redirect(307, '/')
  } catch (err) {
    res.status(500).send({ error: 'failed to fetch data' })
  }
}
```

</TabItem>
</Tabs>

### TypeScriptタイプを追加する {#adding-typescript-types}

API RoutesにTypeScriptの型を追加することで、さらに型安全にすることができます。`NextApiRequest`と`NextApiResponse`の型を`next`からインポートすることに加え、レスポンスデータにも型を指定できます：

```ts
import type { NextApiRequest, NextApiResponse } from 'next'

type ResponseData = {
  message: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  res.status(200).json({ message: 'Hello from Next.js!' })
}
```

> **Good to know**: `NextApiRequest`のボディは`any`です。なぜなら、クライアントは任意のペイロードを含めることがあるからです。使用する前に、ランタイムでボディの型や形状を検証してください。

## 動的APIルート {#dynamic-api-routes}

API Routesは[動的ルート](https://nextjs.org/docs/canary/pages/building-your-application/routing/dynamic-routes)をサポートし、`pages/`で使用されるのと同じファイル命名規則に従います。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/post/[pid].ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const { pid } = req.query
  res.end(`Post: ${pid}`)
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/post/[pid].js" switcher
export default function handler(req, res) {
  const { pid } = req.query
  res.end(`Post: ${pid}`)
}
```

</TabItem>
</Tabs>

今、`/api/post/abc`へのリクエストは、テキスト`Post: abc`で応答されます。

### キャッチオールAPIルート {#catch-all-api-routes}

API Routesは、ブラケット内に3つのドット（`...`）を追加することで、すべてのパスをキャッチするように拡張できます。たとえば：

- `pages/api/post/[...slug].js`は、`/api/post/a`だけでなく、`/api/post/a/b`、`/api/post/a/b/c`などにも一致します。

> **Good to know**: `slug`以外の名前（例：`[...param]`）を使用することもできます。

一致したパラメータはクエリパラメータ（例では`slug`）としてページに送信されます。そして、常に配列になります。したがって、パス`/api/post/a`は次の`query`オブジェクトを持ちます：

```json
{ "slug": ["a"] }
```

そして、`/api/post/a/b`の場合や、その他の一致するパスの場合、新しいパラメータが次のように配列に追加されます：

```json
{ "slug": ["a", "b"] }
```

例えば：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/post/[...slug].ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const { slug } = req.query
  res.end(`Post: ${slug.join(', ')}`)
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/post/[...slug].js" switcher
export default function handler(req, res) {
  const { slug } = req.query
  res.end(`Post: ${slug.join(', ')}`)
}
```

</TabItem>
</Tabs>

今、`/api/post/a/b/c`へのリクエストは、テキスト`Post: a, b, c`で応答します。

### オプショナルキャッチオールAPIルート {#optional-catch-all-api-routes}

キャッチオールルートは、パラメータを二重ブラケット（`[[...slug]]`）で囲むことでオプションにできます。

たとえば、`pages/api/post/[[...slug]].js`は`/api/post`、`/api/post/a`、`/api/post/a/b`などに一致します。

キャッチオールルートとオプションキャッチオールルートの主な違いは、オプションを使用することで、パラメータなしのルートも一致することです（上記例の`/api/post`）。

`query`オブジェクトは次のようになります：

```json
{ } // GET `/api/post`（空のオブジェクト）
{ "slug": ["a"] } // `GET /api/post/a`（単一要素の配列）
{ "slug": ["a", "b"] } // `GET /api/post/a/b`（複数要素の配列）
```

### 注意点 {#caveats}

- 事前定義されたAPIルートは、動的APIルートよりも優先され、動的APIルートはキャッチオールAPIルートよりも優先されます。次の例を見てください：
  - `pages/api/post/create.js` - `/api/post/create`に一致します
  - `pages/api/post/[pid].js` - `/api/post/1`、`/api/post/abc`などに一致しますが、`/api/post/create`には一致しません
  - `pages/api/post/[...slug].js` - `/api/post/1/2`、`/api/post/a/b/c`などに一致しますが、`/api/post/create`、`/api/post/abc`には一致しません

## Edge APIルート {#edge-api-routes}

Edge RuntimeでAPI Routesを使用したい場合、App Routerを徐々に採用し、代わりに[Route Handlers](/docs/app/building-your-application/routing/route-handlers)を使用することをお勧めします。

Route Handlersの関数シグネチャは等価であり、EdgeとNode.jsの両方のランタイムで同じ関数を使用できます。
