---
title: 'useRouter'
description: 'Next.js RouterのAPIについて学び、useRouterフックを使ってページ内でrouterインスタンスにアクセスします。'
---

アプリ内の任意の関数コンポーネントで[`router`オブジェクト](#router-object)にアクセスしたい場合、`useRouter`フックを使用できます。以下の例をご覧ください：

```jsx
import { useRouter } from 'next/router'

function ActiveLink({ children, href }) {
  const router = useRouter()
  const style = {
    marginRight: 10,
    color: router.asPath === href ? 'red' : 'black',
  }

  const handleClick = (e) => {
    e.preventDefault()
    router.push(href)
  }

  return (
    <a href={href} onClick={handleClick} style={style}>
      {children}
    </a>
  )
}

export default ActiveLink
```

> `useRouter`は[React Hook](https://react.dev/learn#using-hooks)ですので、クラスでは使用できません。[withRouter](#withrouter)を使用するか、クラスを関数コンポーネントでラップする必要があります。

## `router`オブジェクト {#router-object}

以下は、[`useRouter`](#top)と[`withRouter`](#withrouter)の両方から返される`router`オブジェクトの定義です：

- `pathname`: `String` - 現在のルートファイルのパスで、`/pages`の後に続くものです。したがって、`basePath`、`locale`、末尾のスラッシュ（`trailingSlash: true`）は含まれません
- `query`: `Object` - クエリ文字列がオブジェクトに解析されたものです。[dynamic route](https://nextjs.org/docs/canary/pages/building-your-application/routing/dynamic-routes)のパラメータを含みます。ページが[Server-side Rendering](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-server-side-props)を使用していない場合、生成時には空のオブジェクトになります。デフォルトは`{}`
- `asPath`: `String` - 検索パラメータを含め、ブラウザに表示されるパスで、`trailingSlash`の設定を尊重します。`basePath`と`locale`は含まれません
- `isFallback`: `boolean` - 現在のページが[fallbackモード](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-paths#fallback-true)かどうか
- `basePath`: `String` - アクティブな[basePath](/docs/app/api-reference/config/next-config-js/basePath)（有効の場合）
- `locale`: `String` - アクティブなロケール（有効な場合）
- `locales`: `String[]` - サポートされているすべてのロケール（有効な場合）
- `defaultLocale`: `String` - 現在のデフォルトロケール（有効な場合）
- `domainLocales`: `Array<{domain, defaultLocale, locales}>` - 設定されたドメインロケールが存在する場合
- `isReady`: `boolean` - routerフィールドがクライアントサイドで更新され、使用可能かどうか。`useEffect`メソッド内でのみ使用し、サーバーでの条件付きレンダリングには使用しないでください。[自動静的最適化](https://nextjs.org/docs/canary/pages/building-your-application/rendering/automatic-static-optimization)されたページに関連する使用例については、関連文書を参照してください
- `isPreview`: `boolean` - アプリケーションが現在[プレビューモード](https://nextjs.org/docs/canary/pages/building-your-application/configuring/preview-mode)かどうか

> サーバーサイドレンダリングや[自動静的最適化](https://nextjs.org/docs/canary/pages/building-your-application/rendering/automatic-static-optimization)を使用してページがレンダリングされる場合、`asPath`フィールドを使用するとクライアントとサーバーで不一致が発生する可能性があります。`isReady`フィールドが`true`になるまで`asPath`の使用を避けてください。

`router`に含まれる以下のメソッド：

### router.push {#router-push}

クライアントサイドの遷移を処理します。このメソッドは、[`next/link`](https://nextjs.org/docs/canary/pages/api-reference/components/link)だけでは不十分な場合に便利です。

```js
router.push(url, as, options)
```

- `url`: `UrlObject | String` - 移動先のURLです（`UrlObject`プロパティについては[Node.JS URLモジュールドキュメント](https://nodejs.org/api/url.html#legacy-urlobject)を参照してください）
- `as`: `UrlObject | String` - ブラウザのURLバーに表示されるパスのためのオプションのデコレーターです。Next.js 9.5.3より前ではダイナミックルートに使用されていました
- `options` - 以下の設定オプションを含むオプションのオブジェクト：
  - `scroll` - オプションのブール値で、ナビゲーション後にページの上部にスクロールするかどうかを制御します。デフォルトは`true`
  - [`shallow`](https://nextjs.org/docs/canary/pages/building-your-application/routing/linking-and-navigating#shallow-routing): [`getStaticProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)、[`getServerSideProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-server-side-props)、[`getInitialProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-initial-props)を再実行せずに現在のページのパスを更新します。デフォルトは`false`
  - `locale` - オプションの文字列で、新しいページのロケールを示します

> 外部URLには`router.push`を使用する必要はありません。[window.location](https://developer.mozilla.org/docs/Web/API/Window/location)がその場合に適しています。

事前定義されたルートである`pages/about.js`へのナビゲーション：

```jsx
import { useRouter } from 'next/router'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/about')}>
      Click me
    </button>
  )
}
```

ダイナミックルートである`pages/post/[pid].js`へのナビゲーション：

```jsx
import { useRouter } from 'next/router'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/post/abc')}>
      Click me
    </button>
  )
}
```

[認証](https://nextjs.org/docs/canary/pages/building-your-application/authentication)の背後にあるページに便利な、`pages/login.js`へのユーザーのリダイレクト：

```jsx
import { useEffect } from 'react'
import { useRouter } from 'next/router'

// ここでユーザーを取得して返します
const useUser = () => ({ user: null, loading: false })

export default function Page() {
  const { user, loading } = useUser()
  const router = useRouter()

  useEffect(() => {
    if (!(user || loading)) {
      router.push('/login')
    }
  }, [user, loading])

  return <p>Redirecting...</p>
}
```

#### ナビゲーション後の状態リセット {#resetting-state-after-navigation}

Next.jsで同じページにナビゲーションする場合、Reactは親コンポーネントが変更されていない限りアンマウントされないため、ページの状態はデフォルトでは**リセットされません**：

```jsx title="pages/[slug].js"
import Link from 'next/link'
import { useState } from 'react'
import { useRouter } from 'next/router'

export default function Page(props) {
  const router = useRouter()
  const [count, setCount] = useState(0)
  return (
    <div>
      <h1>Page: {router.query.slug}</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increase count</button>
      <Link href="/one">one</Link> <Link href="/two">two</Link>
    </div>
  )
}
```

上記の例では、`/one`と`/two`の間をナビゲーションしてもカウントは**リセットされません**。トップレベルのReactコンポーネント、`Page`が同じであるため、`useState`がレンダー間で維持されます。

この動作を望まない場合、いくつかのオプションがあります：

- `useEffect`を使用して各状態が手動で更新されるようにします。上記の例では次のようになります：

  ```jsx
  useEffect(() => {
    setCount(0)
  }, [router.query.slug])
  ```

- [Reactの`key`を使用して、コンポーネントの再マウントを指示します](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)。すべてのページでこれを行うには、カスタムアプリを使用できます：

  ```jsx title="pages/_app.js"
  import { useRouter } from 'next/router'

  export default function MyApp({ Component, pageProps }) {
    const router = useRouter()
    return <Component key={router.asPath} {...pageProps} />
  }
  ```

#### URLオブジェクトを使用する場合 {#with-url-object}

[`next/link`](https://nextjs.org/docs/canary/pages/api-reference/components/link#passing-a-url-object)で使用するのと同じ方法でURLオブジェクトを使用できます。`url`と`as`の両方のパラメータに対して機能します：

```jsx
import { useRouter } from 'next/router'

export default function ReadMore({ post }) {
  const router = useRouter()

  return (
    <button
      type="button"
      onClick={() => {
        router.push({
          pathname: '/post/[pid]',
          query: { pid: post.id },
        })
      }}
    >
      Click here to read more
    </button>
  )
}
```

### router.replace {#router-replace}

[`next/link`](https://nextjs.org/docs/canary/pages/api-reference/components/link)の`replace`プロップと同様に、`router.replace`は`history`スタックに新しいURLエントリを追加するのを防ぎます。

```js
router.replace(url, as, options)
```

- `router.replace`のAPIは、[`router.push`](#routerpush)のAPIとまったく同じです。

以下の例をご覧ください：

```jsx
import { useRouter } from 'next/router'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.replace('/home')}>
      Click me
    </button>
  )
}
```

### router.prefetch {#router-prefetch}

クライアントサイドの遷移をより速くするためにページをプリフェッチします。このメソッドは、[`next/link`](https://nextjs.org/docs/canary/pages/api-reference/components/link)を使用しないナビゲーションにのみ有用です。`next/link`はページのプリフェッチを自動的に処理します。

> これは本番専用の機能です。Next.jsは開発中にページをプリフェッチしません。

```js
router.prefetch(url, as, options)
```

- `url` - プリフェッチするURLで、明示的なルート（例：`/dashboard`）や動的ルート（例：`/product/[id]`）を含みます
- `as` - `url`のためのオプションのデコレーターです。Next.js 9.5.3より前では動的ルートのプリフェッチに使用されていました
- `options` - 許可された以下のフィールドを含むオプションのオブジェクト：
  - `locale` - アクティブなロケールとは異なるロケールを指定することができます。`false`の場合、`url`はロケールを含めなければならず、アクティブなロケールは使用されません。

ログインページがあり、ログイン後にダッシュボードにユーザーをリダイレクトする場合、次の例のようにダッシュボードをプリフェッチすることで、遷移をより速くすることができます：

```jsx
import { useCallback, useEffect } from 'react'
import { useRouter } from 'next/router'

export default function Login() {
  const router = useRouter()
  const handleSubmit = useCallback((e) => {
    e.preventDefault()

    fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        /* フォームデータ */
      }),
    }).then((res) => {
      // すでにプリフェッチされたダッシュボードページへの迅速なクライアントサイド遷移を行います
      if (res.ok) router.push('/dashboard')
    })
  }, [])

  useEffect(() => {
    // ダッシュボードページをプリフェッチします
    router.prefetch('/dashboard')
  }, [router])

  return (
    <form onSubmit={handleSubmit}>
      {/* フォームフィールド */}
      <button type="submit">Login</button>
    </form>
  )
}
```

### router.beforePopState {#router-beforepopstate}

場合によっては（たとえば、[カスタムサーバー](https://nextjs.org/docs/canary/pages/building-your-application/configuring/custom-server)を使用する場合）、[popstate](https://developer.mozilla.org/docs/Web/API/Window/popstate_event)をリッスンして、ルーターがその上でアクションを実行する前に何かを行うことを希望するかもしれません。

```js
router.beforePopState(cb)
```

- `cb` - 入ってくる`popstate`イベントに対して実行する関数です。この関数は、以下のプロパティを持つオブジェクトとしてイベントの状態を受け取ります：
  - `url`: `String` - 新しい状態のためのルートです。これは通常、`page`の名前です
  - `as`: `String` - ブラウザに表示されるURL
  - `options`: `Object` - [router.push](#routerpush)によって送信される追加オプション

もし`cb`が`false`を返す場合、Next.jsのルーターは`popstate`を扱わず、その場合にはあなたがそれを処理する責任があります。[ファイルシステムルーティングの無効化](https://nextjs.org/docs/canary/pages/building-your-application/configuring/custom-server#disabling-file-system-routing)を参照してください。

あなたは`beforePopState`を使用してリクエストを操作するか、SSRリフレッシュを強制することができます。以下の例のように：

```jsx
import { useEffect } from 'react'
import { useRouter } from 'next/router'

export default function Page() {
  const router = useRouter()

  useEffect(() => {
    router.beforePopState(({ url, as, options }) => {
      // 私はこの2つのルートのみを許可したいです！
      if (as !== '/' && as !== '/other') {
        // SSRに悪いルートを404としてレンダリングさせます。
        window.location.href = as
        return false
      }

      return true
    })
  }, [router])

  return <p>Welcome to the page</p>
}
```

### router.back {#router-back}

履歴で戻るナビゲーションを行います。ブラウザの戻るボタンをクリックするのと同等です。それは`window.history.back()`を実行します。

```jsx
import { useRouter } from 'next/router'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.back()}>
      Click here to go back
    </button>
  )
}
```

### router.reload {#router-reload}

現在のURLを再読み込みします。これは、ブラウザのリフレッシュボタンをクリックするのと同等です。それは`window.location.reload()`を実行します。

```jsx
import { useRouter } from 'next/router'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.reload()}>
      Click here to reload
    </button>
  )
}
```

### router.events {#router-events}

Next.js Router内で発生するさまざまなイベントをリッスンすることができます。サポートされているイベントのリストはこちらです：

- `routeChangeStart(url, { shallow })` - ルートの変更が開始された時に発生します。
- `routeChangeComplete(url, { shallow })` - ルートが完全に変更された時に発生します。
- `routeChangeError(err, url, { shallow })` - ルートの変更時にエラーが発生した場合、またはルートの読み込みがキャンセルされた場合に発生します。
  - `err.cancelled` - ナビゲーションがキャンセルされたかどうかを示します
- `beforeHistoryChange(url, { shallow })` - ブラウザの履歴が変更される前に発生します。
- `hashChangeStart(url, { shallow })` - ハッシュが変更されるがページは変更されない時に発生します。
- `hashChangeComplete(url, { shallow })` - ハッシュが変更され完了した時に発生しますがページは変更されません。

> **Good to know**: ここでの`url`は、[`basePath`](/docs/app/api-reference/config/next-config-js/basePath)を含むブラウザに表示されるURLです。

例えば、ルーターイベント`routeChangeStart`をリッスンするには、`pages/_app.js`を開くか作成して、次のようにイベントを購読します：

```jsx
import { useEffect } from 'react'
import { useRouter } from 'next/router'

export default function MyApp({ Component, pageProps }) {
  const router = useRouter()

  useEffect(() => {
    const handleRouteChange = (url, { shallow }) => {
      console.log(
        `App is changing to ${url} ${
          shallow ? 'with' : 'without'
        } shallow routing`
      )
    }

    router.events.on('routeChangeStart', handleRouteChange)

    // コンポーネントがアンマウントされた場合、イベントから`off`メソッドで購読解除
    return () => {
      router.events.off('routeChangeStart', handleRouteChange)
    }
  }, [router])

  return <Component {...pageProps} />
}
```

> この例では[カスタムアプリ](https://nextjs.org/docs/canary/pages/building-your-application/routing/custom-app)（`pages/_app.js`）を使用してイベントを購読していますが、それはページ遷移でアンマウントされないためです。ただし、アプリケーション内の任意のコンポーネントでもルーターイベントに購読できます。

ルーターイベントは、コンポーネントがマウントされたときに登録する必要があります（[useEffect](https://react.dev/reference/react/useEffect)や[componentDidMount](https://react.dev/reference/react/Component#componentdidmount) / [componentWillUnmount](https://react.dev/reference/react/Component#componentwillunmount)）。または、イベントが発生したときに命令的に登録します。

ルートの読み込みがキャンセルされる場合（たとえば、2つのリンクを連続して急速にクリックすることによって）、`routeChangeError`が発火されます。そして、渡される`err`には`cancelled`プロパティが`true`に設定されます。次のように：

```jsx
import { useEffect } from 'react'
import { useRouter } from 'next/router'

export default function MyApp({ Component, pageProps }) {
  const router = useRouter()

  useEffect(() => {
    const handleRouteChangeError = (err, url) => {
      if (err.cancelled) {
        console.log(`Route to ${url} was cancelled!`)
      }
    }

    router.events.on('routeChangeError', handleRouteChangeError)

    // コンポーネントがアンマウントされた場合、イベントから`off`メソッドで購読解除
    return () => {
      router.events.off('routeChangeError', handleRouteChangeError)
    }
  }, [router])

  return <Component {...pageProps} />
}
```

## `next/compat/router`のエクスポート {#the-next-compat-router-export}

これは同じ`useRouter`フックですが、`app`ディレクトリと`pages`ディレクトリの両方で使用できます。

それは、pages routerがマウントされていない場合でもエラーをスローせず、`NextRouter | null`の戻り型を持っている点で`next/router`と異なります。
これにより、開発者は`app router`への移行中にコンポーネントを`app`と`pages`の両方で動作するように変換することができます。

以前このように見えたコンポーネント：

```jsx
import { useRouter } from 'next/router'
const MyComponent = () => {
  const { isReady, query } = useRouter()
  // ...
}
```

`next/compat/router`に変換するとエラーが発生します。なぜなら`null`を分割できないからです。代わりに、開発者は新しいフックを利用できるようになります：

```jsx
import { useEffect } from 'react'
import { useRouter } from 'next/compat/router'
import { useSearchParams } from 'next/navigation'
const MyComponent = () => {
  const router = useRouter() // nullかNextRouterインスタンスかもしれません
  const searchParams = useSearchParams()
  useEffect(() => {
    if (router && !router.isReady) {
      return
    }
    // `app/`ではsearchParamsが値と共に即座に準備され、
    // `pages/`ではrouterが準備された後で利用可能になります。
    const search = searchParams.get('search')
    // ...
  }, [router, searchParams])
  // ...
}
```

このコンポーネントは、`pages`ディレクトリと`app`ディレクトリの両方で動作するようになります。コンポーネントが`pages`で使用されなくなった場合、互換routerへの参照を削除できます：

```jsx
import { useSearchParams } from 'next/navigation'
const MyComponent = () => {
  const searchParams = useSearchParams()
  // このコンポーネントは`app/`でのみ使用されているため、互換routerを削除できます。
  const search = searchParams.get('search')
  // ...
}
```

### `pages`でNext.jsコンテキスト外で`useRouter`を使用する {#using-userouter-outside-of-next-js-context-in-pages}

もう1つの特定の使用例として、`pages`ディレクトリでの`getServerSideProps`内など、Next.jsアプリケーションコンテキスト外でコンポーネントをレンダリングする場合があります。この場合、互換routerを使用してエラーを回避できます：

```jsx
import { renderToString } from 'react-dom/server'
import { useRouter } from 'next/compat/router'
const MyComponent = () => {
  const router = useRouter() // nullかNextRouterインスタンスかもしれません
  // ...
}
export async function getServerSideProps() {
  const renderedComponent = renderToString(<MyComponent />)
  return {
    props: {
      renderedComponent,
    },
  }
}
```

## 潜在的なESLintエラー {#potential-eslint-errors}

`router`オブジェクト上でアクセス可能な特定のメソッドはPromiseを返します。ESLintのルール、[no-floating-promises](https://typescript-eslint.io/rules/no-floating-promises)が有効な場合、それをグローバルに、または該当する行で無効にすることを検討してください。

アプリケーションがこのルールを必要とする場合は、Promiseを`void`するか、`async`関数を使用し、Promiseを`await`してから関数呼び出しをvoidにする必要があります。**これは、`onClick`ハンドラー内でメソッドが呼び出される場合には適用されません**。

影響を受けるメソッドは：

- `router.push`
- `router.replace`
- `router.prefetch`

### 潜在的な解決策 {#potential-solutions}

```jsx
import { useEffect } from 'react'
import { useRouter } from 'next/router'

// ここでユーザーを取得して返します
const useUser = () => ({ user: null, loading: false })

export default function Page() {
  const { user, loading } = useUser()
  const router = useRouter()

  useEffect(() => {
    // 次の行でlintingを無効にする - これは最もクリーンな解決策です
    // eslint-disable-next-line no-floating-promises
    router.push('/login')

    // router.push
    // によって返されるPromiseをvoidにする
    if (!(user || loading)) {
      void router.push('/login')
    }
    // またはasync関数を使用し、Promiseをawaitしてから関数呼び出しをvoidにする
    async function handleRouteChange() {
      if (!(user || loading)) {
        await router.push('/login')
      }
    }
    void handleRouteChange()
  }, [user, loading])

  return <p>Redirecting...</p>
}
```

## withRouter {#withrouter}

[`useRouter`](#router-object)が最適でない場合、`withRouter`も同じ[`router`オブジェクト](#router-object)を任意のコンポーネントに追加できます。

### 使用方法 {#usage}

```jsx
import { withRouter } from 'next/router'

function Page({ router }) {
  return <p>{router.pathname}</p>
}

export default withRouter(Page)
```

### TypeScript {#typescript}

`withRouter`でクラスコンポーネントを使用するには、コンポーネントはrouterプロップを受け取る必要があります：

```tsx
import React from 'react'
import { withRouter, NextRouter } from 'next/router'

interface WithRouterProps {
  router: NextRouter
}

interface MyComponentProps extends WithRouterProps {}

class MyComponent extends React.Component<MyComponentProps> {
  render() {
    return <p>{this.props.router.pathname}</p>
  }
}

export default withRouter(MyComponent)
```
