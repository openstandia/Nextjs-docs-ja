---
title: 'Link'
description: '組み込みの `next/link` コンポーネントを使用して、クライアントサイドの高速なナビゲーションを実現します。'
---

{/* このドキュメントの内容は、app router と pages router の間で共有されています。Pages Router に特有の内容を追加するには、`<PagesOnly>Content</PagesOnly>` コンポーネントを使用できます。共有される内容はコンポーネントでラップしないでください。 */}

`<Link>` は、HTML の `<a>` 要素を拡張して、[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)とクライアントサイドのルート間ナビゲーションを提供する React コンポーネントです。Next.js でルート間をナビゲートするための主要な方法です。

基本的な使用法：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

</PagesOnly>

## 参照 {#reference}

`<Link>` コンポーネントに渡すことができる props は次のとおりです：

<PagesOnly>

| Prop                                | 例                       | 型                | 必須 |
| ----------------------------------- | ------------------------ | ----------------- | ---- |
| [`href`](#href-required)            | `href="/dashboard"`      | String or Object  | Yes  |
| [`replace`](#replace)               | `replace={false}`        | Boolean           | -    |
| [`scroll`](#scroll)                 | `scroll={false}`         | Boolean           | -    |
| [`prefetch`](#prefetch)             | `prefetch={false}`       | Boolean           | -    |
| [`legacyBehavior`](#legacybehavior) | `legacyBehavior={true}`  | Boolean           | -    |
| [`passHref`](#passhref)             | `passHref={true}`        | Boolean           | -    |
| [`shallow`](#shallow)               | `shallow={false}`        | Boolean           | -    |
| [`locale`](#locale)                 | `locale="fr"`            | String or Boolean | -    |
| [`onNavigate`](#onnavigate)         | `onNavigate={(e) => {}}` | Function          | -    |

</PagesOnly>

<AppOnly>

| Prop                        | 例                       | 型               | 必須 |
| --------------------------- | ------------------------ | ---------------- | ---- |
| [`href`](#href-required)    | `href="/dashboard"`      | String or Object | Yes  |
| [`replace`](#replace)       | `replace={false}`        | Boolean          | -    |
| [`scroll`](#scroll)         | `scroll={false}`         | Boolean          | -    |
| [`prefetch`](#prefetch)     | `prefetch={false}`       | Boolean or null  | -    |
| [`onNavigate`](#onnavigate) | `onNavigate={(e) => {}}` | Function         | -    |

</AppOnly>

> **Good to know**: `<a>` タグの属性（`className` や `target="_blank"` など）は、props として `<Link>` に追加でき、基になる `<a>` 要素に渡されます。

### `href`（必須） {#href-required}

ナビゲートするパスまたは URL。

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

// /about?name=test にナビゲート
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

// /about?name=test にナビゲート
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

// /about?name=test にナビゲート
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

// /about?name=test にナビゲート
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `replace` {#replace}

**デフォルトは `false` です。** `true` の場合、`next/link` は現在の履歴状態を置き換え、[ブラウザの履歴](https://developer.mozilla.org/docs/Web/API/History_API)スタックに新しい URL を追加しません。

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `scroll` {#scroll}

**デフォルトは `true` です。** Next.js の `<Link>` のデフォルトのスクロール動作は、ブラウザが戻るや進むのナビゲーションを処理する方法に似て、スクロール位置を維持することです。新しい[ページ](/docs/app/api-reference/file-conventions/page)にナビゲートすると、ページがビューポートに表示されている限り、スクロール位置は同じままです。ただし、ページがビューポートに表示されていない場合、Next.js は最初のページ要素の上部にスクロールします。

`scroll = {false}` の場合、Next.js は最初のページ要素にスクロールしようとしません。

> **Good to know**: Next.js はスクロール動作を管理する前に `scroll: false` を確認します。スクロールが有効な場合、ナビゲーションの関連する DOM ノードを特定し、各トップレベル要素を検査します。すべてのスクロール不可能な要素やレンダリングされた HTML がない要素はバイパスされます。これには、固定位置の要素や `getBoundingClientRect` で計算された非表示の要素が含まれます。Next.js は、ビューポートに表示されるスクロール可能な要素を特定するまで、兄弟要素を通過し続けます。

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `prefetch` {#prefetch}

<AppOnly>

プリフェッチは、`<Link />` コンポーネントがユーザーのビューポートに入ったとき（最初またはスクロールによって）に発生します。Next.js はリンクされたルート（`href` で示される）とそのデータをバックグラウンドでプリフェッチして、クライアントサイドのナビゲーションのパフォーマンスを向上させます。プリフェッチされたデータが `<Link />` にユーザーがホバーするまでに期限切れになった場合、Next.js は再度プリフェッチを試みます。**プリフェッチは本番環境でのみ有効です。**

`prefetch` prop に渡すことができる値は次のとおりです：

- **`null`（デフォルト）**: プリフェッチの動作は、ルートが静的か動的かによって異なります。静的ルートの場合、完全なルートがプリフェッチされます（すべてのデータを含む）。動的ルートの場合、[`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states) 境界を持つ最も近いセグメントまでの部分ルートがプリフェッチされます。
- `true`: 静的および動的ルートの両方で完全なルートがプリフェッチされます。
- `false`: ビューポートに入るときもホバー時も、プリフェッチは決して行われません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

プリフェッチは、`<Link />` コンポーネントがユーザーのビューポートに入ったとき（最初またはスクロールによって）に発生します。Next.js はリンクされたルート（`href` で示される）とデータをバックグラウンドでプリフェッチして、クライアントサイドのナビゲーションのパフォーマンスを向上させます。**プリフェッチは本番環境でのみ有効です。**

`prefetch` prop に渡すことができる値は次のとおりです：

- **`true`（デフォルト）**: 完全なルートとそのデータがプリフェッチされます。
- `false`: ビューポートに入るときはプリフェッチされませんが、ホバー時にはプリフェッチされます。ホバー時のフェッチを完全に削除したい場合は、`<a>` タグを使用するか、App Router を[段階的に採用](/docs/app/building-your-application/upgrading/app-router-migration)することを検討してください。これにより、ホバー時のプリフェッチも無効にできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

### `legacyBehavior` {#legacybehavior}

`<a>` 要素は `<Link>` の子としてもはや必要ありません。`legacyBehavior` prop を追加してレガシー動作を使用するか、`<a>` を削除してアップグレードします。コードを自動的にアップグレードするための[コードモッドが利用可能です](/docs/app/building-your-application/upgrading/codemods#new-link)。

> **Good to know**: `legacyBehavior` が `true` に設定されていない場合、すべての [`anchor`](https://developer.mozilla.org/docs/Web/HTML/Element/a) タグのプロパティは `next/link` にも渡すことができます。たとえば、`className`、`onClick` などです。

### `passHref` {#passhref}

`Link` に `href` プロパティをその子に送信させます。デフォルトは `false` です。詳細については、[関数コンポーネントを渡す](#nesting-a-functional-component)例を参照してください。

### `shallow` {#shallow}

[`getStaticProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)、[`getServerSideProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-server-side-props)、または [`getInitialProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-initial-props) を再実行せずに現在のページのパスを更新します。デフォルトは `false` です。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

### `locale` {#locale}

アクティブなロケールは自動的に先頭に追加されます。`locale` を使用して異なるロケールを指定できます。`false` の場合、`href` はデフォルトの動作が無効になっているため、ロケールを含める必要があります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* デフォルトの動作: ロケールが先頭に追加されます */}
      <Link href="/dashboard">Dashboard (with locale)</Link>

      {/* ロケールの先頭追加を無効にします */}
      <Link href="/dashboard" locale={false}>
        Dashboard (without locale)
      </Link>

      {/* 異なるロケールを指定します */}
      <Link href="/dashboard" locale="fr">
        Dashboard (French)
      </Link>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* デフォルトの動作: ロケールが先頭に追加されます */}
      <Link href="/dashboard">Dashboard (with locale)</Link>

      {/* ロケールの先頭追加を無効にします */}
      <Link href="/dashboard" locale={false}>
        Dashboard (without locale)
      </Link>

      {/* 異なるロケールを指定します */}
      <Link href="/dashboard" locale="fr">
        Dashboard (French)
      </Link>
    </>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `onNavigate` {#onnavigate}

クライアントサイドのナビゲーション中に呼び出されるイベントハンドラーです。ハンドラーは `preventDefault()` メソッドを含むイベントオブジェクトを受け取り、必要に応じてナビゲーションをキャンセルできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // SPA ナビゲーション中のみ実行されます
        console.log('Navigating...')

        // ナビゲーションをオプションで防ぐ
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // SPA ナビゲーション中のみ実行されます
        console.log('Navigating...')

        // ナビゲーションをオプションで防ぐ
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

> **Good to know**: `onClick` と `onNavigate` は似ているように見えますが、異なる目的を持っています。`onClick` はすべてのクリックイベントに対して実行されますが、`onNavigate` はクライアントサイドのナビゲーション中にのみ実行されます。いくつかの重要な違い：
>
> - 修飾キー（`Ctrl`/`Cmd` + クリック）を使用する場合、`onClick` は実行されますが、`onNavigate` は実行されません。これは、Next.js が新しいタブのデフォルトのナビゲーションを防ぐためです。
> - 外部 URL は `onNavigate` をトリガーしません。これはクライアントサイドおよび同一オリジンのナビゲーションにのみ適用されるためです。
> - `download` 属性を持つリンクは、ブラウザがリンクされた URL をダウンロードとして扱うため、`onClick` では動作しますが、`onNavigate` では動作しません。

## 例 {#examples}

次の例は、さまざまなシナリオで `<Link>` コンポーネントを使用する方法を示しています。

<AppOnly>

### 動的セグメントへのリンク {#linking-to-dynamic-segments}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)にリンクする場合、[テンプレートリテラルと補間](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals)を使用してリンクのリストを生成できます。たとえば、ブログ投稿のリストを生成するには：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/post-list.tsx" switcher
import Link from 'next/link'

interface Post {
  id: number
  title: string
  slug: string
}

export default function PostList({ posts }: { posts: Post[] }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/post-list.js" switcher
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

### アクティブなリンクの確認 {#checking-active-links}

[`usePathname()`](/docs/app/api-reference/functions/use-pathname) を使用してリンクがアクティブかどうかを判断できます。たとえば、アクティブなリンクにクラスを追加するには、現在の `pathname` がリンクの `href` と一致するかどうかを確認します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/nav-links.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/nav-links.js" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

</TabItem>
</Tabs>

### `id` へのスクロール {#scrolling-to-an-id}

ナビゲーション時に特定の `id` にスクロールしたい場合、URL に `#` ハッシュリンクを追加するか、`href` prop にハッシュリンクを渡すことができます。これは、`<Link>` が `<a>` 要素にレンダリングされるため可能です。

```jsx
<Link href="/dashboard#settings">Settings</Link>

// 出力
<a href="/dashboard#settings">Settings</a>
```

> **Good to know**:
>
> - ナビゲーション時にページがビューポートに表示されていない場合、Next.js は[ページ](/docs/app/api-reference/file-conventions/page)にスクロールします。

</AppOnly>

### 動的ルートセグメントへのリンク {#linking-to-dynamic-route-segments}

[動的ルートセグメント](/docs/app/building-your-application/routing/dynamic-routes)の場合、リンクのパスを作成するためにテンプレートリテラルを使用するのが便利です。

<PagesOnly>

たとえば、動的ルート `pages/blog/[slug].js` へのリンクのリストを生成できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/blog/index.tsx" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/blog/index.js" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}

export default Posts
```

</TabItem>
</Tabs>

</PagesOnly>

<AppOnly>

たとえば、動的ルート `app/blog/[slug]/page.js` へのリンクのリストを生成できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

### 子が `<a>` タグをラップするカスタムコンポーネントの場合 {#if-the-child-is-a-custom-component-that-wraps-an-a-tag}

<AppOnly>

`Link` の子が `<a>` タグをラップするカスタムコンポーネントの場合、`passHref` を `Link` に追加する必要があります。これは、[styled-components](https://styled-components.com/) などのライブラリを使用している場合に必要です。これがないと、`<a>` タグに `href` 属性がなくなり、サイトのアクセシビリティが低下し、SEO に影響を与える可能性があります。[ESLint](https://nextjs.org/docs/canary/pages/api-reference/config/eslint) を使用している場合、`passHref` の正しい使用を保証するための組み込みルール `next/link-passhref` があります。

</AppOnly>

<PagesOnly>

`Link` の子が `<a>` タグをラップするカスタムコンポーネントの場合、`passHref` を `Link` に追加する必要があります。これは、[styled-components](https://styled-components.com/) などのライブラリを使用している場合に必要です。これがないと、`<a>` タグに `href` 属性がなくなり、サイトのアクセシビリティが低下し、SEO に影響を与える可能性があります。[ESLint](https://nextjs.org/docs/canary/pages/api-reference/config/eslint) を使用している場合、`passHref` の正しい使用を保証するための組み込みルール `next/link-passhref` があります。

</PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="components/nav-link.tsx" switcher
import Link from 'next/link'
import styled from 'styled-components'

// これは <a> タグをラップするカスタムコンポーネントを作成します
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="components/nav-link.js" switcher
import Link from 'next/link'
import styled from 'styled-components'

// これは <a> タグをラップするカスタムコンポーネントを作成します
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

</TabItem>
</Tabs>

- [emotion](https://emotion.sh/) の JSX プラグマ機能（`@jsx jsx`）を使用している場合、直接 `<a>` タグを使用していても `passHref` を使用する必要があります。
- コンポーネントは `onClick` プロパティをサポートして、ナビゲーションを正しくトリガーする必要があります。

### 関数コンポーネントのネスト {#nesting-a-functional-component}

`Link` の子が関数コンポーネントの場合、`passHref` と `legacyBehavior` を使用することに加えて、コンポーネントを [`React.forwardRef`](https://react.dev/reference/react/forwardRef) でラップする必要があります：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'
import React from 'react'

// MyButton の props 型を定義
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// 転送された ref を適切に型付けするために React.ForwardRefRenderFunction を使用
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// コンポーネントをラップするために React.forwardRef を使用
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`、`href`、および `ref` は、適切な処理のために DOM 要素に渡す必要があります
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// コンポーネントの表示名を追加（デバッグに役立ちます）
MyButton.displayName = 'MyButton'

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'
import React from 'react'

// MyButton の props 型を定義
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// 転送された ref を適切に型付けするために React.ForwardRefRenderFunction を使用
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// コンポーネントをラップするために React.forwardRef を使用
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`、`href`、および `ref` は、適切な処理のために DOM 要素に渡す必要があります
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// コンポーネントの表示名を追加（デバッグに役立ちます）
MyButton.displayName = 'MyButton'

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

<PagesOnly>

### URL オブジェクトの渡し {#passing-a-url-object}

`Link` は URL オブジェクトを受け取ることもでき、自動的にフォーマットして URL 文字列を作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.ts" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

</TabItem>
</Tabs>

上記の例には、次のリンクがあります：

- 事前定義されたルート：`/about?name=test`
- [動的ルート](/docs/app/building-your-application/routing/dynamic-routes)：`/blog/my-post`

[Node.js URL モジュールのドキュメント](https://nodejs.org/api/url.html#url_url_strings_and_url_objects)で定義されているすべてのプロパティを使用できます。

</PagesOnly>

### URL をプッシュする代わりに置き換える {#replace-the-url-instead-of-push}

`Link` コンポーネントのデフォルトの動作は、`history` スタックに新しい URL を `push` することです。次の例のように、新しいエントリを追加しないようにするには、`replace` prop を使用できます：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### ページの上部へのスクロールを無効にする {#disable-scrolling-to-the-top-of-the-page}

<AppOnly>

Next.js の `<Link>` のデフォルトのスクロール動作は、ブラウザが戻るや進むのナビゲーションを処理する方法に似て、スクロール位置を維持することです。新しい[ページ](/docs/app/api-reference/file-conventions/page)にナビゲートすると、ページがビューポートに表示されている限り、スクロール位置は同じままです。

ただし、ページがビューポートに表示されていない場合、Next.js は最初のページ要素の上部にスクロールします。この動作を無効にしたい場合は、`<Link>` コンポーネントに `scroll={false}` を渡すか、`router.push()` または `router.replace()` に `scroll: false` を渡すことができます。

<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</TabItem>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</TabItem>
</Tabs>

`router.push()` または `router.replace()` を使用する：

```jsx
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

</AppOnly>

<PagesOnly>

`Link` のデフォルトの動作は、ページの上部にスクロールすることです。ハッシュが定義されている場合、通常の `<a>` タグのように特定の id にスクロールします。上部/ハッシュへのスクロールを防ぐには、`Link` に `scroll={false}` を追加できます：

<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</TabItem>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### ミドルウェアでのリンクのプリフェッチ {#prefetching-links-in-middleware}

[ミドルウェア](/docs/app/building-your-application/routing/middleware)を使用して、認証やユーザーを別のページにリダイレクトするなどの目的で使用することが一般的です。ミドルウェアを介してリライトされたリンクを `<Link />` コンポーネントが適切にプリフェッチするためには、Next.js に表示する URL とプリフェッチする URL の両方を伝える必要があります。これは、ミドルウェアに不要なフェッチを避け、正しいルートをプリフェッチするために必要です。

たとえば、認証済みと訪問者のビューを持つ `/dashboard` ルートを提供したい場合、ミドルウェアでユーザーを正しいページにリダイレクトするために次のように追加できます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse } from 'next/server'

export function middleware(request: Request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

</TabItem>
</Tabs>

この場合、`<Link />` コンポーネントで次のコードを使用することをお勧めします：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/page.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/index.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

<PagesOnly>

> **Good to know**: [Dynamic Routes](/docs/app/building-your-application/routing/dynamic-routes) を使用している場合、`as` と `href` props を適応させる必要があります。たとえば、ミドルウェアを介して異なる表示をしたい `/dashboard/authed/[user]` のような Dynamic Route がある場合、次のように書きます：`<Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as="/dashboard/[user]">Profile</Link>`。

</PagesOnly>

### ナビゲーションのブロック {#blocking-navigation}

`onNavigate` prop を使用して、特定の条件が満たされたときにナビゲーションをブロックできます。たとえば、フォームに未保存の変更がある場合などです。アプリ内の複数のコンポーネントでナビゲーションをブロックする必要がある場合（たとえば、フォームが編集中のときにすべてのリンクからのナビゲーションを防ぐ）、React Context を使用してこのブロック状態を共有するクリーンな方法を提供します。まず、ナビゲーションブロック状態を追跡するコンテキストを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/contexts/navigation-blocker.tsx" switcher
'use client'

import { createContext, useState, useContext } from 'react'

interface NavigationBlockerContextType {
  isBlocked: boolean
  setIsBlocked: (isBlocked: boolean) => void
}

export const NavigationBlockerContext =
  createContext<NavigationBlockerContextType>({
    isBlocked: false,
    setIsBlocked: () => {},
  })

export function NavigationBlockerProvider({
  children,
}: {
  children: React.ReactNode
}) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/contexts/navigation-blocker.js" switcher
'use client'

import { createContext, useState, useContext } from 'react'

export const NavigationBlockerContext = createContext({
  isBlocked: false,
  setIsBlocked: () => {},
})

export function NavigationBlockerProvider({ children }) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

</TabItem>
</Tabs>

コンテキストを使用するフォームコンポーネントを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/components/form.tsx" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Save</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/components/form.js" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Save</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

ナビゲーションをブロックするカスタムリンクコンポーネントを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/components/custom-link.tsx" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

interface CustomLinkProps extends React.ComponentProps<typeof Link> {
  children: React.ReactNode
}

export function CustomLink({ children, ...props }: CustomLinkProps) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('You have unsaved changes. Leave anyway?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/components/custom-link.js" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

export function CustomLink({ children, ...props }) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('You have unsaved changes. Leave anyway?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

</TabItem>
</Tabs>

ナビゲーションコンポーネントを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/components/nav.tsx" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
    </nav>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/components/nav.js" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
    </nav>
  )
}
```

</TabItem>
</Tabs>

最後に、root レイアウトで `NavigationBlockerProvider` でアプリをラップし、ページでコンポーネントを使用します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

次に、ページで `Nav` と `Form` コンポーネントを使用します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Welcome to the Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Welcome to the Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

</TabItem>
</Tabs>

ユーザーがフォームに未保存の変更がある状態で `CustomLink` を使用して移動しようとすると、離れる前に確認を求められます。

## バージョン履歴 {#version-history}

| バージョン | 変更点                                                                                                                                                                                             |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `v15.3.0`  | `onNavigate` API を追加                                                                                                                                                                            |
| `v13.0.0`  | 子 `<a>` タグが不要になりました。コードベースを自動的に更新するための[コードモッド](/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components)が提供されています。 |
| `v10.0.0`  | 動的ルートを指す `href` props は自動的に解決され、`as` prop を必要としなくなりました。                                                                                                             |
| `v8.0.0`   | プリフェッチのパフォーマンスが向上しました。                                                                                                                                                       |
| `v1.0.0`   | `next/link` が導入されました。                                                                                                                                                                     |
