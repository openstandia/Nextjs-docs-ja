---
title: 'Instrumentation'
description: 'Next.jsアプリでサーバー起動時にコードを実行するためのInstrumentlizationの方法を学ぶ'
related:
  title: 'Instrumentationについてさらに学ぶ'
  links:
    - app/api-reference/file-conventions/instrumentation
---

{/* このドキュメントの内容は、app routerとpages routerで共有されています。Pages Router専用のコンテンツを追加するには、`<PagesOnly>Content</PagesOnly>`コンポーネントを使用できます。すべての共有されるコンテンツには、コンポーネントをラップしないでください。 */}

Instrumentationは、モニタリングやロギングツールをアプリケーションに統合するためにコードを使用するプロセスです。これにより、アプリケーションのパフォーマンスと動作を追跡し、本番環境での問題をデバッグできます。

## 規約 {#convention}

Instrumentationをセットアップするには、プロジェクトの**ルートディレクトリ**に`instrumentation.ts|js`ファイルを作成します（または[`src`](/docs/app/building-your-application/configuring/src-directory)フォルダー内に作成します）。

その後、ファイル内で`register`関数をエクスポートします。この関数は、新しいNext.jsサーバーインスタンスが開始されると**一度**実行されます。

たとえば、Next.jsを[OpenTelemetry](https://opentelemetry.io/)および[@vercel/otel](https://vercel.com/docs/observability/otel-overview)と一緒に使用するには、次のようにします。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="instrumentation.ts" switcher
import { registerOTel } from '@vercel/otel'

// Next.js アプリで OpenTelemetryを登録する
export function register() {
  registerOTel('next-app')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="instrumentation.js" switcher
import { registerOTel } from '@vercel/otel'

// Next.js アプリで OpenTelemetryを登録する
export function register() {
  registerOTel('next-app')
}
```

</TabItem>
</Tabs>

完全な実装については、[Next.js with OpenTelemetry example](https://github.com/vercel/next.js/tree/canary/examples/with-opentelemetry)を参照してください。

> **Good to know**：
>
> - `instrumentation`ファイルは、プロジェクトのrootに置く必要があります。`app`または`pages`ディレクトリ内に配置しないでください。`src`フォルダーを使用している場合、`src`内の`pages`および`app`と同じ場所にファイルを置いてください。
> - [`pageExtensions` config option](/docs/app/api-reference/config/next-config-js/pageExtensions)を使用してサフィックスを追加する場合、`instrumentation`ファイル名もそれに合わせて更新する必要があります。

## 例 {#examples}

### 副作用のあるファイルのインポート {#importing-files-with-side-effects}

場合によっては、コードに副作用を引き起こすファイルをインポートすることが役立つ場合があります。たとえば、一連のグローバル変数を定義するファイルをインポートするかもしれませんが、明示的にそのファイルをコードで使用しない場合があります。それでも、パッケージが宣言したグローバル変数にアクセスできます。

`register`関数内でJavaScriptの`import`構文を使用してファイルをインポートすることをお勧めします。以下の例は、`register`関数での`import`の基本的な使用法を示しています。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="instrumentation.ts" switcher
export async function register() {
  // 副作用を持つパッケージをインポート
  await import('package-with-side-effect')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="instrumentation.js" switcher
export async function register() {
  // 副作用を持つパッケージをインポート
  await import('package-with-side-effect')
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> ファイルの先頭ではなく、`register`関数内からファイルをインポートすることをお勧めします。これにより、すべての副作用をコード内の1つの場所に集約し、ファイルの先頭からのグローバルインポートによる意図しない結果を避けることができます。

### 実行時特有のコードのインポート {#importing-runtime-specific-code}

Next.jsはすべての環境で`register`を呼び出すため、特定のランタイム（例：[EdgeまたはNode.js](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)）をサポートしないコードを条件付きでインポートすることが重要です。現在の環境を取得するには、`NEXT_RUNTIME`環境変数を使用できます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="instrumentation.ts" switcher
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    // Node.js環境に特化したインストルメンテーションをインポート
    await import('./instrumentation-node')
  }

  if (process.env.NEXT_RUNTIME === 'edge') {
    // Edge環境に特化したインストルメンテーションをインポート
    await import('./instrumentation-edge')
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="instrumentation.js" switcher
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    // Node.js環境に特化したインストルメンテーションをインポート
    await import('./instrumentation-node')
  }

  if (process.env.NEXT_RUNTIME === 'edge') {
    // Edge環境に特化したインストルメンテーションをインポート
    await import('./instrumentation-edge')
  }
}
```

</TabItem>
</Tabs>
