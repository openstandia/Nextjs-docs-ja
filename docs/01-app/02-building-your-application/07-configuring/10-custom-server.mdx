---
title: 'カスタムサーバー'
description: 'カスタムサーバーを使用してNext.jsアプリをプログラムによって起動します。'
---

{/* このドキュメントの内容はapp routerとpages routerの間で共有されています。Pages Routerに特化した内容を追加するには、<PagesOnly>Content</PagesOnly>コンポーネントを使用できます。共有コンテンツはコンポーネント内にラップしないでください。 */}

Next.jsはデフォルトで`next start`を使って独自のサーバーを含んでいます。既存のバックエンドがあっても、Next.jsと一緒に使用することができます（これはカスタムサーバーではありません）。カスタムNext.jsサーバーを使用すると、カスタムパターン用にサーバーをプログラムで起動することができます。しかし、ほとんどの場合、このアプローチを必要としません。ただし、必要に応じてejectするオプションがあります。

> **Good to know**:
>
> - カスタムサーバーを使用する前に覚えておくべきことは、Next.jsの統合されたルーターがあなたのアプリの要件を満たせない場合にのみ使用するべきだということです。カスタムサーバーは、**[Automatic Static Optimization](https://nextjs.org/docs/canary/pages/building-your-application/rendering/automatic-static-optimization)**などの重要なパフォーマンス最適化を取り除きます；
> - カスタムサーバーは [Vercel](https://vercel.com/frameworks/nextjs)にデプロイできません；
> - スタンドアロンの出力モードを使用する場合、カスタムサーバーファイルのトレースは行いません。このモードは、別の最小限の`server.js`ファイルを出力します。これらは一緒に使用することはできません；

カスタムサーバーの[次の例](https://github.com/vercel/next.js/tree/canary/examples/custom-server)をご覧ください：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="server.ts" switcher
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'

// ポート番号を環境変数から取得し、整数に変換します
const port = parseInt(process.env.PORT || '3000', 10)
// 環境変数NODE_ENVが'production'でない場合は開発モードに設定
const dev = process.env.NODE_ENV !== 'production'
// Next.jsアプリを作成
const app = next({ dev })
// リクエストハンドラーを取得
const handle = app.getRequestHandler()

app.prepare().then(() => {
  // HTTPサーバーを作成
  createServer((req, res) => {
    // リクエストURLを解析
    const parsedUrl = parse(req.url!, true)
    // 解析したURLでリクエストを処理
    handle(req, res, parsedUrl)
  }).listen(port)

  // サーバーがどのモードで起動しているかをコンソールに出力
  console.log(
    `> Server listening at http://localhost:${port} as ${
      dev ? 'development' : process.env.NODE_ENV
    }`
  )
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="server.js" switcher
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'

// ポート番号を環境変数から取得し、整数に変換します
const port = parseInt(process.env.PORT || '3000', 10)
// 環境変数NODE_ENVが'production'でない場合は開発モードに設定
const dev = process.env.NODE_ENV !== 'production'
// Next.jsアプリを作成
const app = next({ dev })
// リクエストハンドラーを取得
const handle = app.getRequestHandler()

app.prepare().then(() => {
  // HTTPサーバーを作成
  createServer((req, res) => {
    // リクエストURLを解析
    const parsedUrl = parse(req.url, true)
    // 解析したURLでリクエストを処理
    handle(req, res, parsedUrl)
  }).listen(port)

  // サーバーがどのモードで起動しているかをコンソールに出力
  console.log(
    `> Server listening at http://localhost:${port} as ${
      dev ? 'development' : process.env.NODE_ENV
    }`
  )
})
```

</TabItem>
</Tabs>

> `server.js` はNext.jsのコンパイラやバンドルプロセスを通しません。このファイルが必要とする構文やソースコードが、現在使用しているNode.jsバージョンと互換性があることを確認してください。 [例を表示](https://github.com/vercel/next.js/tree/canary/examples/custom-server)。

カスタムサーバーを実行するには、`package.json`の`scripts`を次のように更新する必要があります：

```json title="package.json"
{
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "NODE_ENV=production node server.js"
  }
}
```

または、`nodemon`をセットアップすることもできます（[例](https://github.com/vercel/next.js/tree/canary/examples/custom-server)）。カスタムサーバーは次のインポートを使用してサーバーとNext.jsアプリケーションを接続します：

```js
import next from 'next'

const app = next({})
```

上記の`next`インポートは、次のオプションを持つオブジェクトを受け取る関数です：

| オプション        | タイプ               | 説明                                                                                                                    |
| ----------------- | -------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `conf`            | `Object`             | `next.config.js`で使用するオブジェクトと同じ。デフォルトは`{}`                                                          |
| `dev`             | `Boolean`            | (_オプション_) Next.jsを開発モードで起動するかどうか。デフォルトは`false`                                               |
| `dir`             | `String`             | (_オプション_) Next.jsプロジェクトの場所。デフォルトは`'.'`                                                             |
| `quiet`           | `Boolean`            | (_オプション_) サーバー情報を含むエラーメッセージを非表示にする。デフォルトは`false`                                    |
| `hostname`        | `String`             | (_オプション_) サーバーが実行されているホスト名                                                                         |
| `port`            | `Number`             | (_オプション_) サーバーが実行されているポート番号                                                                       |
| `httpServer`      | `node:http#Server`   | (_オプション_) Next.jsが実行されているHTTPサーバー                                                                      |
| `turbo`           | `Boolean`            | (_オプション_) Turbopackを有効にする                                                                                    |
| `preloadedConfig` | `NextConfigComplete` | (_オプション_) `next.config.js`から読み込む代わりに使用されるプレロード済みの設定。`dev`が`false`の場合にのみ機能します |

返された`app`は、要求に応じてNext.jsにリクエストを処理させるために使用されます。

<PagesOnly>

## ファイルシステムルーティングの無効化 {#disabling-file-system-routing}

デフォルトでは、`Next`は`pages`フォルダ内の各ファイルをファイル名に一致するパス名で提供します。プロジェクトがカスタムサーバーを使用している場合、この動作は同じコンテンツが複数のパスから提供されることになり、SEOやUXに問題が発生する可能性があります。

この動作を無効にし、`pages`内のファイルに基づくルーティングを防ぐには、`next.config.js`を開き`useFileSystemPublicRoutes`設定を無効にします：

```js title="next.config.js"
module.exports = {
  useFileSystemPublicRoutes: false,
}
```

> `useFileSystemPublicRoutes`はSSRからのファイル名ルートを無効にしますが、クライアントサイドルーティングはこれらのパスにアクセスできる可能性があります。このオプションを使用する場合、プログラムで望まないルートへのナビゲーションを防ぐべきです；

> また、クライアントサイドルーターを設定して、クライアントサイドのリダイレクトをファイル名ルートに許可しないようにすることもお勧めします。この点については[`router.beforePopState`](https://nextjs.org/docs/canary/pages/api-reference/functions/use-router#routerbeforepopstate)を参照してください；

</PagesOnly>
