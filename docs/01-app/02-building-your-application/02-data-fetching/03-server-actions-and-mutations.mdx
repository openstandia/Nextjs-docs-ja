---
title: 'Server Actions and Mutations'
nav_title: 'Server Actions and Mutations'
description: 'Next.js でのフォーム送信とデータ変異の処理方法を学びましょう。'
related:
  description: 'Next.jsでサーバーアクションの設定方法を学びましょう'
  links:
    - app/api-reference/config/next-config-js/serverActions
---

[Server Actions](https://react.dev/reference/rsc/server-actions)は、**非同期関数**で、サーバー上で実行されます。これらは、Next.jsアプリケーションでのフォーム送信およびデータ変異を処理するために、ServerとClient Componentで呼び出すことができます。

> **🎥 視聴:** サーバーアクションを使った変異についてもっと知りましょう → [YouTube (10分)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg)。

## 規約 {#convention}

Server Actionは、Reactの[`"use server"`](https://react.dev/reference/react/use-server)ディレクティブを使用して定義できます。このディレクティブを`async`関数の上に配置してその関数をServer Actionとしてマークするか、または別のファイルの上に配置してそのファイルのすべてのエクスポートをServer Actionsとしてマークすることができます。

### Server Components {#server-components}

Server Componentは、インライン関数レベルまたはモジュールレベルの`"use server"`ディレクティブを使用できます。Server Actionをインライン化するには、関数本体の上に`"use server"`を追加してください：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default function Page() {
  // Server Action
  async function create() {
    'use server'
    // データを変異させる
  }

  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default function Page() {
  // Server Action
  async function create() {
    'use server'
    // データを変異させる
  }

  return '...'
}
```

</TabItem>
</Tabs>

### Client Components {#client-components}

Client ComponentでServer Actionを呼び出すには、新しいファイルを作成し、その上に`"use server"`ディレクティブを追加してください。ファイル内のすべてのエクスポートされた関数は、ClientとServer Componentの両方で再利用可能なServer Actionsとしてマークされます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

export async function create() {}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

export async function create() {}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/button.tsx" switcher
'use client'

import { create } from '@/app/actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/button.js" switcher
'use client'

import { create } from '@/app/actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```

</TabItem>
</Tabs>

### アクションをpropsとして渡す {#passing-actions-as-props}

Server ActionをClient Componentにpropとして渡すことも可能です：

```jsx
<ClientComponent updateItemAction={updateItem} />
```

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
'use client'

export default function ClientComponent({
  updateItemAction,
}: {
  updateItemAction: (formData: FormData) => void
}) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
'use client'

export default function ClientComponent({ updateItemAction }) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

</TabItem>
</Tabs>

通常、Next.js TypeScriptプラグインは`client-component.tsx`内の`updateItemAction`をタグ付けします。これは、一般に`updateItemAction`はクライアント-サーバー間の境界を越えてシリアル化できない関数であるためです。
ただし、`action`と名付けられたpropsや`Action`で終わるpropsは、Server Actionsを受け取るものと仮定されます。
これはあくまでヒューリスティックで、TypeScriptプラグインは、実際にServer Actionを受け取るか通常の関数を受け取るかを知りません。
ランタイムの型チェックにより、誤ってクライアントコンポーネントに関数を渡さないようにします。

## 動作 {#behavior}

- Server Actionsは、[`<form>`要素](#forms)の`action`属性を使用して呼び出すことができます：
  - Server Componentはデフォルトでプログレッシブエンハンスメントをサポートしており、JavaScriptがまだ読み込まれていないか無効になっていてもフォームが送信されます。
  - Client Componentでは、JavaScriptがまだ読み込まれていない場合に、Server Actionsを呼び出すフォームは送信をキューに入れ、クライアントヒュードレーションを優先します。
  - ヒュードレーション後、フォーム送信時にブラウザはリフレッシュしません。
- Server Actionは`<form>`に限定されず、イベントハンドラ、`useEffect`、サードパーティのライブラリ、`<button>`などの他のフォーム要素から呼び出すことができます。
- Server Actionsは、Next.jsの[キャッシュおよび再検証](/docs/app/building-your-application/caching)アーキテクチャと統合されています。アクションが呼び出されると、Next.jsは更新されたUIと新しいデータを1回のサーバーラウンドトリップで返すことができます。
- バックグラウンドでは、アクションは`POST`メソッドを使用し、これによりのみHTTPメソッドがそれらを呼び出すことができます。
- Server Actionの引数と戻り値は、Reactによってシリアル化可能である必要があります。シリアル化可能な引数と値のリストについては、Reactのドキュメントを参照してください：[シリアル化可能なパラメータと戻り値](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)。
- Server Actionは関数です。つまり、それらはアプリケーション内のどこでも再利用可能です。
- Server Actionは、使用されるページまたはレイアウトの[runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を継承します。
- Server Actionは、使用されるページまたはレイアウトの[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)を継承します。`maxDuration`などのフィールドが含まれます。

## 例 {#examples}

### フォーム {#forms}

ReactはHTMLの[`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form)要素を拡張して、Server Actionsを`action`propで呼び出すことを可能にします。

フォームで呼び出されると、アクションは[`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData)オブジェクトを自動的に受け取ります。フィールドを管理するためにReactの`useState`を使用する必要はなく、代わりにネイティブの[`FormData`メソッド](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods)を使用してデータを抽出できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/invoices/page.tsx" switcher
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // データを変異させる
    // キャッシュを再検証する
  }

  return <form action={createInvoice}>...</form>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/invoices/page.js" switcher
export default function Page() {
  async function createInvoice(formData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // データを変異させる
    // キャッシュを再検証する
  }

  return <form action={createInvoice}>...</form>
}
```

</TabItem>
</Tabs>

> **お役立ち情報:**
>
> - 例：[Form with Loading & Error States](https://github.com/vercel/next.js/tree/canary/examples/next-forms)
> - 多くのフィールドを持つフォームを扱う場合、JavaScriptの[`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)メソッドを使用して[`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries)メソッドを使用することを検討してください。例として：`const rawFormData = Object.fromEntries(formData)`。1つ注意点として、`formData`には追加の`$ACTION_`プロパティが含まれます。
> - 詳細はReact `<form>` ドキュメントを参照してください。[Server Actionを使用したフォーム送信の処理について](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-action)。

### 追加の引数を渡す {#passing-additional-arguments}

JavaScriptの`bind`メソッドを使用して、Server Actionに追加の引数を渡すことができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">ユーザー名を更新する</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">ユーザー名を更新する</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

Server Actionは、formデータに加えて`userId`引数を受け取ります：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

export async function updateUser(userId: string, formData: FormData) {}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

export async function updateUser(userId, formData) {}
```

</TabItem>
</Tabs>

> **お役立ち情報**:
>
> - 代替方法として、引数をフォーム内のhidden inputフィールドとして渡すことができます（例：`<input type="hidden" name="userId" value={userId} />`）。ただし、値はレンダリングされたHTMLの一部となり、エンコードされません。
> - `.bind`はServerとClient Componentの両方で機能します。プログレッシブエンハンスメントもサポートしています。

### ネストされたフォーム要素 {#nested-form-elements}

サーバーアクションは、`<form>`内のネストされた`<button>`, `<input type="submit">`, `<input type="image">`などの要素内でも呼び出すことができます。これらの要素は、`formAction`プロップスまたは[イベントハンドラ](#event-handlers)を受け入れます。

これは、フォーム内で複数のサーバーアクションを呼び出したい場合に役立ちます。例えば、投稿の草稿を保存するための特定の`<button>`要素を、公開するためのものに加えて作成することができます。詳細は、[React `<form>` ドキュメント](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types)を参照してください。

### プログラムによるフォーム送信 {#programmatic-form-submission}

[`requestSubmit()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit)メソッドを使用して、プログラムによるフォーム送信をトリガーできます。例えば、ユーザーが`⌘` + `Enter`キーボードショートカットを使ってフォームを送信する場合、`onKeyDown`イベントをリスニングできます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/entry.tsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/entry.js" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

</TabItem>
</Tabs>

これにより、最寄りの`<form>`祖先の送信がトリガーされ、Server Actionが呼び出されます。

### サーバーサイドのフォーム検証 {#server-side-form-validation}

HTML属性の `required` や `type="email"` を使用して、基本的なクライアントサイドのフォーム検証を行うことができます。

より高度なサーバーサイドの検証には、[zod](https://zod.dev/)のようなライブラリを使用してデータを変異させる前にフォームフィールドを検証することができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: '無効なメールアドレス',
  }),
})

export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // フォームデータが無効であれば早期に戻る
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // データを変異させる
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions.js" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: '無効なメールアドレス',
  }),
})

export default async function createsUser(formData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // フォームデータが無効であれば早期に戻る
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // データを変異させる
}
```

</TabItem>
</Tabs>

フィールドがサーバー側で検証されたら、アクションでシリアル化可能なオブジェクトを返し、Reactの`useActionState`フックを使用してユーザーにメッセージを表示できます。

- アクションを`useActionState`に渡すことで、アクションの関数シグネチャが変更され、新しい`prevState`または`initialState`パラメータを第1引数として受け取るようになります。
- `useActionState`はReactフックであるため、Client Componentで使用する必要があります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState: any, formData: FormData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '有効なメールアドレスを入力してください' }
  }

  redirect('/dashboard')
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState, formData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '有効なメールアドレスを入力してください' }
  }

  redirect('/dashboard')
}
```

</TabItem>
</Tabs>

その後、アクションを`useActionState`フックに渡し、返された`state`を使用してエラーメッセージを表示できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup.tsx" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">メールアドレス</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>登録する</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup.js" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">メールアドレス</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>登録する</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

### ペンディング状態 {#pending-states}

[`useActionState`](https://react.dev/reference/react/useActionState)フックは、アクションが実行中にローディングインジケーターを表示するために使用できる`pending`ブール値を公開します。

代わりに、[`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)フックを使用して、アクションが実行中にローディングインジケーターを表示することもできます。このフックを使用する場合、ローディングインジケーターをレンダリングするための別のコンポーネントを作成する必要があります。例えば、アクションが保留中の場合にボタンを無効にするには：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/button.tsx" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      登録する
    </button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/button.js" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      登録する
    </button>
  )
}
```

</TabItem>
</Tabs>

その後、`SubmitButton`コンポーネントをフォーム内にネストすることができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup.tsx" switcher
import { SubmitButton } from './button'
import { createUser } from '@/app/actions'

export function Signup() {
  return (
    <form action={createUser}>
      {/* その他のフォーム要素 */}
      <SubmitButton />
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup.js" switcher
import { SubmitButton } from './button'
import { createUser } from '@/app/actions'

export function Signup() {
  return (
    <form action={createUser}>
      {/* その他のフォーム要素 */}
      <SubmitButton />
    </form>
  )
}
```

</TabItem>
</Tabs>

> **お役立ち情報:** React 19では、`useFormStatus`には返されたオブジェクトのデータ、メソッド、アクションのような追加のキーが含まれます。React 19を使用していない場合は、`pending`キーのみが利用可能です。

### 楽観的更新 {#optimistic-updates}

Reactの[`useOptimistic`](https://react.dev/reference/react/useOptimistic)フックを使用して、Server Actionが実行を完了する前にUIを楽観的に更新することができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

type Message = {
  message: string
}

export function Thread({ messages }: { messages: Message[] }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic<
    Message[],
    string
  >(messages, (state, newMessage) => [...state, { message: newMessage }])

  const formAction = async (formData: FormData) => {
    const message = formData.get('message') as string
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m, i) => (
        <div key={i}>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">送信</button>
      </form>
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )

  const formAction = async (formData) => {
    const message = formData.get('message')
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">送信</button>
      </form>
    </div>
  )
}
```

</TabItem>
</Tabs>

### イベントハンドラ {#event-handlers}

ほとんどの場合、Server Actionsは`<form>`要素内で使用されますが、`onClick`のようなイベントハンドラを使用して呼び出すこともできます。例えば、いいねの数を増やす場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>総いいね数: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        いいね
      </button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>総いいね数: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        いいね
      </button>
    </>
  )
}
```

</TabItem>
</Tabs>

フォーム要素にイベントハンドラを追加することも可能です。例えば、`onChange`でフィールドを保存する場合：

```tsx title="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">公開する</button>
    </form>
  )
}
```

このような場合、複数のイベントが短期間に連続して発生する可能性があるので、不要なServer Actionsの呼び出しを防ぐために**デバウンス**をお勧めします。

### `useEffect` {#useeffect}

Reactの[`useEffect`](https://react.dev/reference/react/useEffect)フックを使用して、コンポーネントのマウント時や依存関係が変更されたときにServer Actionを呼び出すことができます。これは、グローバルイベントに依存する変更や自動的にトリガーする必要がある変更に役立ちます。例えば、アプリのショートカットに対して`onKeyDown`を使用する場合や、無限スクロールのためのインタクション観測フック、あるいはコンポーネントのマウント時にビューのカウントを更新する場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>総ビュー数: {views}</p>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>総ビュー数: {views}</p>
}
```

</TabItem>
</Tabs>

`useEffect`の[動作と注意点](https://react.dev/reference/react/useEffect#caveats)を検討することを忘れないでください。

### エラーハンドリング {#error-handling}

エラーがスローされると、それはクライアント上の最も近い`error.js`または`<Suspense>`境界でキャッチされます。[エラーハンドリング](/docs/app/building-your-application/routing/error-handling)についての詳細を参照してください。

> **お役立ち情報:**
>
> - エラーをスローする以外にも、`useActionState`で処理できるオブジェクトを返すこともできます。[サーバーサイドの検証とエラーハンドリング](#server-side-form-validation)を参照してください。

### データの再検証 {#revalidating-data}

Next.jsのキャッシュで`revalidatePath` APIを使用してServer Actions内でデータを再検証することができます：[Next.js Cache](/docs/app/building-your-application/caching):

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

</TabItem>
</Tabs>

または、キャッシュタグを使用して特定のデータフェッチを無効化することもできます。[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag):

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

</TabItem>
</Tabs>

### リダイレクト {#redirecting}

Server Actionの完了後にユーザーを異なるルートにリダイレクトしたい場合は、[`redirect`](/docs/app/api-reference/functions/redirect) APIを使用できます。`redirect`は`try/catch`ブロックの外で呼び出す必要があります：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // キャッシュされた投稿を更新する
  redirect(`/post/${id}`) // 新しい投稿ページにナビゲートする
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // キャッシュされた投稿を更新する
  redirect(`/post/${id}`) // 新しい投稿ページにナビゲートする
}
```

</TabItem>
</Tabs>

### Cookie {#cookies}

Server Action内で`cookies` APIを使用して、cookieを`get`, `set`, および`delete`することができます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  const cookieStore = await cookies()

  // Cookieを取得する
  cookieStore.get('name')?.value

  // Cookieを設定する
  cookieStore.set('name', 'Delba')

  // Cookieを削除する
  cookieStore.delete('name')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // Cookieを取得する
  const cookieStore = await cookies()

  // Cookieを取得する
  cookieStore.get('name')?.value

  // Cookieを設定する
  cookieStore.set('name', 'Delba')

  // Cookieを削除する
  cookieStore.delete('name')
}
```

</TabItem>
</Tabs>

Server Actionsからのcookieの削除については[追加の例](/docs/app/api-reference/functions/cookies#deleting-cookies)を参照してください。

## セキュリティ {#security}

デフォルトでは、Server Actionが作成されてエクスポートされると、公開されたHTTPエンドポイントとして機能し、同じセキュリティ仮定と認可チェックで扱うべきです。これは、Server Actionやユーティリティ関数がコードの他のどこにもインポートされなくても、公開されたアクセスポイントとなります。

セキュリティを向上させるために、Next.jsには次の組み込み機能があります：

- **セキュアなアクションID：** Next.jsは暗号化されかつ非決定論的なIDを作成し、クライアントがServer Actionを参照して呼び出すことを可能にします。これらのIDは、セキュリティを高めるためにビルド間で定期的に再計算されます。
- **デッドコードの削除：** クライアントバンドルからアクセス防止するためにServer Actionの未使用（IDで参照されている）が除去されます。

> **お役立ち情報**:
>
> IDはコンパイル中に作成され、最大14日間キャッシュされます。それらは新しいビルドが開始されるか、ビルドキャッシュが無効化されると再生成されます。
> このセキュリティの向上は、認証レイヤーが欠如している場合のリスクを低減します。ただし、Server Actionsは公開されたHTTPエンドポイントのように扱うべきです。

```jsx
// app/actions.js
'use server'

// このアクションはアプリケーションで使用されていますので、Next.js
// はクライアントがServer Actionを参照して呼び出すための
// セキュアIDを作成します。
export async function updateUserAction(formData) {}

// このアクションはアプリケーションで使用されていないので、Next.js
// は自動的にこのコードを`next build`中に削除し、
// 公開されたエンドポイントを作成しません。
export async function deleteUserAction(formData) {}
```

### 認証と認可 {#authentication-and-authorization}

ユーザーがアクションを実行する権限を持っていることを確認する必要があります。例えば：

```tsx title="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('このアクションを実行するにはサインインする必要があります')
  }

  // ...
}
```

### クロージャと暗号化 {#closures-and-encryption}

コンポーネント内でServer Actionを定義すると、そのアクションは外部関数のスコープへのアクセスを持つ[クロージャ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)を作成します。例えば、`publish`アクションは`publishVersion`変数にアクセスできます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('公開をクリックしてからバージョンが変更されました');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>公開する</button>
    </form>
  );
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('公開をクリックしてからバージョンが変更されました');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>公開する</button>
    </form>
  );
}
```

</TabItem>
</Tabs>

クロージャは、アクションが呼び出されたときに使用できるように、レンダリング時にデータ（例：`publishVersion`）のスナップショットをキャプチャする必要がある場合に役立ちます。

ただし、これを行うには、キャプチャされた変数がクライアントに送信され、アクションが呼び出されたときにサーバーに戻されます。センシティブなデータがクライアントに公開されるのを防ぐために、Next.jsは自動的にクロールド変数を暗号化します。新しい秘密鍵は、Next.jsアプリケーションがビルドされるたびに、各アクションごとに生成されます。つまり、そのアクションは特定のビルドでのみ呼び出すことができます。

> **お役立ち情報:** センシティブな値がクライアントに公開されるのを防ぐために、暗号化に単独で頼ることはお勧めしません。代わりに、[React taint API](/docs/app/building-your-application/data-fetching/fetching#preventing-sensitive-data-from-being-exposed-to-the-client)を使用して、クライアントに送信される特定のデータを積極的に防ぐことをお勧めします。

### 暗号化キーの上書き（上級） {#overwriting-encryption-keys-advanced}

複数のサーバーでNext.jsアプリケーションをセルフホスティングする場合、それぞれのサーバーインスタンスが異なる暗号化キーを持つ可能性があり、不整合を引き起こすことがあります。

これを緩和するために`process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY`環境変数を使用して暗号化キーを上書きすることができます。この変数を指定することで暗号化キーがビルド間で永続化され、すべてのサーバーインスタンスが同じキーを使用するようになります。

これは、複数のデプロイメントにわたる暗号化動作がアプリケーションにとって重要である場合の高度なユースケースです。キーのローテーションや署名など通常のセキュリティプラクティスを考慮する必要があります。

> **お役立ち情報:** VercelにデプロイされたNext.jsアプリケーションは自動的にこれを処理します。

### 許可されたオリジン（上級） {#allowed-origins-advanced}

Server Actionsは`<form>`要素内で呼び出されることができるため、[CSRF攻撃](https://developer.mozilla.org/en-US/docs/Glossary/CSRF)にさらされることがあります。

Server Actionsの裏では`POST`メソッドが使用されており、このHTTPメソッドのみがそれらを呼び出すことができます。これにより、[SameSite cookie](https://web.dev/articles/samesite-cookies-explained)がデフォルトである現代のブラウザにおける大半のCSRFの脆弱性を防ぐようになっています。

追加の保護として、Next.jsのServer Actionsは[Originヘッダー](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin)と[Hostヘッダー](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host)（または`X-Forwarded-Host`）を比較します。これらが一致しない場合、リクエストは中止されます。つまり、Server Actionsはそれをホストするページと同じホスト上でのみ呼び出されることができます。

リバースプロキシやマルチレイヤーのバックエンドアーキテクチャを使用する大規模なアプリケーション（サーバーAPIがプロダクションドメインと異なる場合）においては、設定オプション[`serverActions.allowedOrigins`](/docs/app/api-reference/config/next-config-js/serverActions)を使用して安全なオリジンのリストを指定することをお勧めします。このオプションは文字列の配列を受け入れます。

```js title="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

[セキュリティとServer Actions](https://nextjs.org/blog/security-nextjs-server-components-actions)についてもっと詳しく知ることができます。

## 追加のリソース {#additional-resources}

詳細については、以下のReactのドキュメントを参照してください：

- [Server Actions](https://react.dev/reference/rsc/server-actions)
- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useActionState`](https://react.dev/reference/react/useActionState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)
