---
title: 'Incremental Static Regeneration (ISR)'
description: 'Incremental Static Regenerationを使って、実行時に静的ページを作成または更新する方法を学びます。'
---

<details>
  <summary>Examples</summary>

- [Next.js Commerce](https://vercel.com/templates/next.js/nextjs-commerce)
- [On-Demand ISR](https://on-demand-isr.vercel.app)
- [Next.js Forms](https://github.com/vercel/next.js/tree/canary/examples/next-forms)

</details>

Incremental Static Regeneration (ISR)を使用すると以下が可能になります；

- サイト全体を再構築しなくても静的コンテンツを更新できる
- プリレンダリングされた静的ページを大半のリクエストに対して提供することでサーバー負荷を軽減できる
- 適切な`cache-control`ヘッダーが自動的にページに追加されることを保証できる
- 大量のコンテンツページを長時間の`next build`なしで処理できる

以下は最小限の例です；

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/[id]/page.tsx" switcher
interface Post {
  id: string
  title: string
  content: string
}

// Next.jsはリクエストが来た際、キャッシュを無効化します；
// 最大で60秒ごとです。
export const revalidate = 60

// ビルド時に`generateStaticParams`で取得したパラメータのみをプリレンダリングします。
// 生成されていないパスにリクエストが来た場合、Next.jsはオンデマンドでページをサーバーレンダリングします。
export const dynamicParams = true // またはfalseにして未知のパスで404を表示します

export async function generateStaticParams() {
  const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  return posts.map((post) => ({
    id: String(post.id),
  }))
}

export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  const post: Post = await fetch(`https://api.vercel.app/blog/${id}`).then(
    (res) => res.json()
  )
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/[id]/page.js" switcher
// Next.jsはリクエストが来た際、キャッシュを無効化します；
// 最大で60秒ごとです。
export const revalidate = 60

// ビルド時に`generateStaticParams`で取得したパラメータのみをプリレンダリングします。
// 生成されていないパスにリクエストが来た場合、Next.jsはオンデマンドでページをサーバーレンダリングします。
export const dynamicParams = true // またはfalseにして未知のパスで404を表示します

export async function generateStaticParams() {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  return posts.map((post) => ({
    id: String(post.id),
  }))
}

export default async function Page({ params }) {
  const { id } = await params
  const post = await fetch(`https://api.vercel.app/blog/${id}`).then((res) =>
    res.json()
  )
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/blog/[id].tsx" switcher
import type { GetStaticPaths, GetStaticProps } from 'next'

interface Post {
  id: string
  title: string
  content: string
}

interface Props {
  post: Post
}

export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  const paths = posts.map((post: Post) => ({
    params: { id: String(post.id) },
  }))

  // これらのパスのみをビルド時にプリレンダリングします；
  // { fallback: 'blocking' }を使用することで、パスが存在しない場合にオンデマンドでサーバーレンダリングされます。
  return { paths, fallback: false }
}

export const getStaticProps: GetStaticProps<Props> = async ({
  params,
}: {
  params: { id: string }
}) => {
  const post = await fetch(`https://api.vercel.app/blog/${params.id}`).then(
    (res) => res.json()
  )

  return {
    props: { post },
    // Next.jsはリクエストが来た際、キャッシュを無効化します；
    // 最大で60秒ごとです。
    revalidate: 60,
  }
}

export default function Page({ post }: Props) {
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/blog/[id].jsx" switcher
export async function getStaticPaths() {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  const paths = posts.map((post) => ({
    params: { id: post.id },
  }))

  // これらのパスのみをビルド時にプリレンダリングします；
  // { fallback: false }を使用することで、他のルートは404を表示します。
  return { paths, fallback: false }
}

export async function getStaticProps({ params }) {
  const post = await fetch(`https://api.vercel.app/blog/${params.id}`).then(
    (res) => res.json()
  )

  return {
    props: { post },
    // Next.jsはリクエストが来た際、キャッシュを無効化します；
    // 最大で60秒ごとです。
    revalidate: 60,
  }
}

export default function Page({ post }) {
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

この例がどのように機能するかを説明します；

1. `next build`の際、既知のブログ投稿がすべて生成されます（この例では25個あります）
2. これらのページへのすべてのリクエスト（例：`/blog/1`）はキャッシュされ、即時に提供されます
3. 60秒経過後に次のリクエストが来ると、依然としてキャッシュされた（古い）ページが表示されます
4. キャッシュが無効化され、ページの新しいバージョンがバックグラウンドで生成され始めます
5. 正常に生成されると、Next.jsは更新されたページを表示し、キャッシュします
6. `/blog/26`がリクエストされた場合、Next.jsはオンデマンドでこのページを生成しキャッシュします

## 参照 {#reference}

<AppOnly>

### Route segment config {#route-segment-config}

- [`revalidate`](/docs/app/api-reference/file-conventions/route-segment-config#revalidate)
- [`dynamicParams`](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)

### 関数 {#functions}

- [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)
- [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)

</AppOnly>

<PagesOnly>

### 関数 {#functions}

- [`getStaticProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)
- [`res.revalidate`](https://nextjs.org/docs/canary/pages/building-your-application/routing/api-routes#response-helpers)

</PagesOnly>

## 例 {#examples}

<AppOnly>

### 時間ベースのリバリデート {#time-based-revalidation}

この例では、`/blog`上にブログの投稿一覧を取得して表示します。1時間後、このページのキャッシュが次の訪問時に無効化されます。そしてバックグラウンドで最新のブログ投稿を含む新しいバージョンのページが生成されます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
interface Post {
  id: string
  title: string
  content: string
}

export const revalidate = 3600 // 毎時無効化する

export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts: Post[] = await data.json()
  return (
    <main>
      <h1>Blog Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
export const revalidate = 3600 // 毎時無効化する

export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <main>
      <h1>Blog Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  )
}
```

</TabItem>
</Tabs>

高いリバリデート時間を設定することをお勧めします；例えば、1秒ではなく1時間です。より精密なリバリデートが必要な場合は、on-demand revalidationの使用をご検討ください；リアルタイムデータが必要な場合は、[dynamic rendering](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)への切り替えを検討してください。

### `revalidatePath`を使用したオンデマンドリバリデート {#on-demand-revalidation-with-revalidatepath}

より精密なリバリデート方法として、`revalidatePath`関数を使ってページをオンデマンドで無効化します。

例えば、新しい投稿を追加した後に呼び出されるServer Actionです；Server Component内でデータを取得する方法に関わらず、`fetch`を使用する場合でも、データベースに接続する場合でも、これによりルート全体のキャッシュがクリアされ、Server Componentが最新のデータを取得できるようになります。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  // キャッシュ内の/postsルートを無効化
  revalidatePath('/posts')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  // キャッシュ内の/postsルートを無効化
  revalidatePath('/posts')
}
```

</TabItem>
</Tabs>

[デモを見る](https://on-demand-isr.vercel.app)または[ソースコードを探索する](https://github.com/vercel/on-demand-isr)。

### `revalidateTag`を使用したオンデマンドリバリデート {#on-demand-revalidation-with-revalidatetag}

ほとんどのユースケースでは、ルート全体をリバリデートすることをお勧めします；もしより細かい制御が必要な場合は、`revalidateTag`関数を使用することができます。例えば、個別の`fetch`呼び出しにタグを付けることができます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog', {
    next: { tags: ['posts'] },
  })
  const posts = await data.json()
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog', {
    next: { tags: ['posts'] },
  })
  const posts = await data.json()
  // ...
}
```

</TabItem>
</Tabs>

ORMを使用している場合やデータベースに接続している場合は`unstable_cache`を使うことができます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getCachedPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const posts = getCachedPosts()
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getCachedPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const posts = getCachedPosts()
  // ...
}
```

</TabItem>
</Tabs>

また、[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)または[Route Handler](/docs/app/building-your-application/routing/route-handlers)で`revalidateTag`を使用することができます；

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  // キャッシュ内の'tags'でタグ付けされたすべてのデータを無効化
  revalidateTag('posts')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  // キャッシュ内の'tags'でタグ付けされたすべてのデータを無効化
  revalidateTag('posts')
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

### `res.revalidate()`によるオンデマンドリバリデート {#on-demand-validation-with-res-revalidate}

より精密なリバリデート方法として、API Routerから`res.revalidate`を使用してオンデマンドで新しいページを生成します；

例えば、このAPI Routeは`/api/revalidate?secret=<token>`で呼び出すことができ、指定されたブログ投稿をリバリデートします；Next.jsアプリケーションだけが知っている秘密のトークンを作成します；このシークレットはリバリデートAPI Routeへの不正アクセスを防ぐために使用されます；

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/revalidate.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // このリクエストが有効かどうかを確認するために秘密をチェックします
  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' })
  }

  try {
    // これはリライトされたパスではなく、実際のパスである必要があります；
    // 例："/posts/[id]"の場合、"/posts/1"にする必要があります
    await res.revalidate('/posts/1')
    return res.json({ revalidated: true })
  } catch (err) {
    // エラーが発生した場合、Next.jsは引き続き
    // 最後に成功したページを表示し続けます
    return res.status(500).send('Error revalidating')
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/revalidate.js" switcher
export default async function handler(req, res) {
  // このリクエストが有効かどうかを確認するために秘密をチェックします
  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' })
  }

  try {
    // これはリライトされたパスではなく、実際のパスである必要があります；
    // 例："/posts/[id]"の場合、"/posts/1"にする必要があります
    await res.revalidate('/posts/1')
    return res.json({ revalidated: true })
  } catch (err) {
    // エラーが発生した場合、Next.jsは引き続き
    // 最後に成功したページを表示し続けます
    return res.status(500).send('Error revalidating')
  }
}
```

</TabItem>
</Tabs>

オンデマンドリバリデートを使用する場合、`getStaticProps`内に`revalidate`時間を指定する必要はありません；Next.jsはデフォルト値の`false`（リバリデートなし）を使用し、`res.revalidate()`が呼び出されたときのみオンデマンドでページをリバリデートします。

</PagesOnly>

### 捕捉されない例外の処理 {#handling-uncaught-exceptions}

<AppOnly>

データをリバリデートしようとしてエラーが発生した場合、最後に成功したデータがキャッシュから提供され続けます；以降の次のリクエストで、Next.jsはデータのリバリデートを再試行します；[エラー処理についてさらに学ぶ](/docs/app/building-your-application/routing/error-handling)；

</AppOnly>

<PagesOnly>

バックグラウンド再生成を処理中に`getStaticProps`内でエラーが発生した場合、または手動でエラーをスローした場合、最後に成功したページが表示され続けます；次に続くリクエストで、Next.jsは再び`getStaticProps`を呼び出すことを試みます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/blog/[id].tsx" switcher
import type { GetStaticProps } from 'next'

interface Post {
  id: string
  title: string
  content: string
}

interface Props {
  post: Post
}

export const getStaticProps: GetStaticProps<Props> = async ({
  params,
}: {
  params: { id: string }
}) => {
  // このリクエストが捕捉されないエラーを投げた場合、Next.jsは
  // 現在表示中のページを無効化せず
  // 次のリクエストで再びgetStaticPropsを試みます；
  const res = await fetch(`https://api.vercel.app/blog/${params.id}`)
  const post: Post = await res.json()

  if (!res.ok) {
    // サーバーエラーがある場合、キャッシュが更新されることを
    // 避けるためにエラーを投げたいかもしれません；
    // 次の成功したリクエストまで
    throw new Error(`Failed to fetch posts, received status ${res.status}`)
  }

  return {
    props: { post },
    // Next.jsはリクエストが来た際、キャッシュを無効化します；
    // 最大で60秒ごとです。
    revalidate: 60,
  }
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/blog/[id].jsx" switcher
export async function getStaticProps({ params }) {
  // このリクエストが捕捉されないエラーを投げた場合、Next.jsは
  // 現在表示中のページを無効化せず
  // 次のリクエストで再びgetStaticPropsを試みます；
  const res = await fetch(`https://api.vercel.app/blog/${params.id}`)
  const post = await res.json()

  if (!res.ok) {
    // サーバーエラーがある場合、キャッシュが更新されることを
    // 避けるためにエラーを投げたいかもしれません；
    // 次の成功したリクエストまで
    throw new Error(`Failed to fetch posts, received status ${res.status}`)
  }

  return {
    props: { post },
    // Next.jsはリクエストが来た際、キャッシュを無効化します；
    // 最大で60秒ごとです。
    revalidate: 60,
  }
}
```

</TabItem>
</Tabs>

</PagesOnly>

### キャッシュ場所のカスタマイズ {#customizing-the-cache-location}

ページのキャッシングとリバリデートは（Incremental Static Regenerationを使用する際に）同じ共有キャッシュを使用します；[Vercelにデプロイする際](https://vercel.com/docs/incremental-static-regeneration?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)、ISRキャッシュは自動的に耐久性のあるストレージに保存されます；

セルフホスティング時にはISRキャッシュがNext.jsサーバー上にファイルシステム（ディスク）に保存されます；これはPagesとApp Routerの両方を使用してセルフホスティングする際に自動的に機能します；

キャッシュされたページとデータを耐久性のあるストレージに保存したり、Next.jsアプリケーションの複数のコンテナまたはインスタンス間でキャッシュを共有したりする場合、Next.jsのキャッシュの場所を設定できます；[詳細を見る](/docs/app/building-your-application/deploying#caching-and-isr)。

## トラブルシューティング {#troubleshooting}

### ローカル開発でのキャッシュデータのデバッグ {#debugging-cached-data-in-local-development}

`fetch` APIを使用している場合、追加のロギングを追加して、どのリクエストがキャッシュされているか、キャッシュされていないかを理解することができます；[`logging`オプションについてもっと学ぶ](/docs/app/api-reference/config/next-config-js/logging)；

```jsx title="next.config.js"
module.exports = {
  logging: {
    fetches: {
      fullUrl: true,
    },
  },
}
```

### 正しい本番環境の動作を確認する {#verifying-correct-production-behavior}

本番環境でページが正しくキャッシュされリバリデートされることを確認するには、`next build`を実行してから`next start`を実行して本番Next.jsサーバーをローカルでテストすることができます；

これにより、本番環境でISRの動作をテストできます；さらにデバッグするには以下の環境変数を`.env`ファイルに追加してください；

```bash title=".env"
NEXT_PRIVATE_DEBUG_CACHE=1
```

これによりNext.jsサーバーのコンソールにISRキャッシュのヒットとミスがログ出力されます；出力内容を調査して、`next build`中にどのページが生成されるか、パスがオンデマンドアクセスされた際にどのようにページが更新されるかを確認することができます；

## 注意事項 {#caveats}

<AppOnly>

- ISRはNode.jsランタイム（デフォルト）を使用している場合のみサポートされます；
- [Static Export](/docs/app/building-your-application/deploying/static-exports)を作成する場合、ISRはサポートされていません；
- 静的にレンダリングされたルートに複数の`fetch`リクエストがあり、それぞれ異なる`revalidate`頻度を持つ場合、ISRには最小の時間が使用されます；ただし、これらのリバリデート頻度は[Data Cache](/docs/app/building-your-application/caching#data-cache)によって引き続き維持されます；
- あるルートで使用される`fetch`リクエストのいずれかが`revalidate`時間`0`を持つ場合、または明示的な`no-store`である場合、そのルートは[動的にレンダリング](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)されます；
- オンデマンドISRリクエストに対するミドルウェアは実行されないため、ミドルウェア内のパスのリライトやロジックは適用されません；正確なパスを再検証していることを確認してください；たとえば、`/post-1`ではなく、リライトされていない`/post/1`を使用してください；

</AppOnly>

<PagesOnly>

- ISRはNode.jsランタイム（デフォルト）を使用している場合のみサポートされます；
- [Static Export](/docs/app/building-your-application/deploying/static-exports)を作成する場合、ISRはサポートされていません；
- オンデマンドISRリクエストに対するミドルウェアは実行されないため、ミドルウェア内のパスのリライトやロジックは適用されません；正確なパスを再検証していることを確認してください；たとえば、`/post-1`ではなく、リライトされていない`/post/1`を使用してください；

</PagesOnly>

## バージョン履歴 {#version-history}

| Version   | Changes                                                                                                          |
| --------- | ---------------------------------------------------------------------------------------------------------------- |
| `v14.1.0` | カスタム`cacheHandler`が正式になりました；                                                                       |
| `v13.0.0` | App Routerが導入されました；                                                                                     |
| `v12.2.0` | Pages Router: On-Demand ISRが正式になりました；                                                                  |
| `v12.0.0` | Pages Router: [Bot-aware ISR fallback](https://nextjs.org/blog/next-12#bot-aware-isr-fallback)が追加されました； |
| `v9.5.0`  | Pages Router: [Stable ISRが導入されました](https://nextjs.org/blog/next-9-5)；                                   |
