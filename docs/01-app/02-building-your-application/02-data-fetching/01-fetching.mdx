---
title: 'データの取得とキャッシング'
nav_title: 'データの取得とキャッシング'
description: 'Next.jsでサーバーまたはクライアントでデータを取得する際のベストプラクティスを学びましょう。'
---

<details>
  <summary>例</summary>

- [Next.js Commerce](https://vercel.com/templates/next.js/nextjs-commerce)
- [On-Demand ISR](https://on-demand-isr.vercel.app)
- [Next.js Forms](https://github.com/vercel/next.js/tree/canary/examples/next-forms)

</details>

このガイドでは、Next.jsでのデータ取得とキャッシングの基本を、実践的な例やベストプラクティスを交えて説明します。

次に示すのは、Next.jsでのデータ取得の最小限の例です：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  let data = await fetch('https://api.vercel.app/blog')
  let posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  let data = await fetch('https://api.vercel.app/blog')
  let posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

この例では、非同期のReact server componentで`fetch` APIを使用した基本的なサーバーサイドのデータ取得を示しています。

## 参考資料 {#reference}

- [`fetch`](/docs/app/api-reference/functions/fetch)
- React [`cache`](https://react.dev/reference/react/cache)
- Next.js [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)

## 例 {#examples}

### `fetch` APIを使用したサーバーでのデータ取得 {#fetching-data-on-the-server-with-the-fetch-api}

このコンポーネントは、ブログ記事のリストを取得して表示します。`fetch`からのレスポンスはデフォルトではキャッシュされません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  let data = await fetch('https://api.vercel.app/blog')
  let posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  let data = await fetch('https://api.vercel.app/blog')
  let posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

このルートで他のどこにも [Dynamic APIs](/docs/app/building-your-application/rendering/server-components#dynamic-rendering) を使用していない場合、ルートは`next build`中に静的ページとして事前レンダリングされます；データは、その後、[incremental static regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)を使用して更新できます；

ページの事前レンダリングを防ぐには、次のコードをファイルに追加できます：

```js
export const dynamic = 'force-dynamic'
```

ただし、通常`cookies`、`headers`、またはページpropsから来る`searchParams`を読み取る関数を使用する場合、この場合、ページは自動的に動的にレンダリングされるため、明示的に`force-dynamic`を使用する必要はありません。

### ORMまたはデータベースを使用したサーバーでのデータ取得 {#fetching-data-on-the-server-with-an-orm-or-database}

このコンポーネントは、ブログ記事のリストを取得して表示します。データベースからのレスポンスはデフォルトではキャッシュされませんが、[追加の設定](#caching-data-with-an-orm-or-database)でキャッシュできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { db, posts } from '@/lib/db'

export default async function Page() {
  let allPosts = await db.select().from(posts)
  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { db, posts } from '@/lib/db'

export default async function Page() {
  let allPosts = await db.select().from(posts)
  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

このルートで他のDynamic APIsを使用していない場合、ルートは`next build`中に静的ページとして事前レンダリングされます；データは、その後、incremental static regenerationを使用して更新できます；

ページの事前レンダリングを防ぐには、次のコードをファイルに追加できます：

```js
export const dynamic = 'force-dynamic'
```

ただし、通常cookies、`headers`、またはページpropsから来る`searchParams`を読み取る関数を使用する場合、この場合、ページは自動的に動的にレンダリングされるため、明示的にforce-dynamicを使用する必要はありません。

### クライアントでのデータ取得 {#fetching-data-on-the-client}

最初にサーバーサイドでデータを取得することをお勧めします；

しかし、クライアントサイドでのデータ取得が理にかなっているケースもあります；これらのシナリオでは、`useEffect`で手動で`fetch`を呼び出す（推奨されません）か、クライアントの取得にはコミュニティ内の人気のあるReactライブラリ（[SWR](https://swr.vercel.app/)や[React Query](https://tanstack.com/query/latest)など）に頼ることができます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import { useState, useEffect } from 'react'

export function Posts() {
  const [posts, setPosts] = useState(null)

  useEffect(() => {
    async function fetchPosts() {
      let res = await fetch('https://api.vercel.app/blog')
      let data = await res.json()
      setPosts(data)
    }
    fetchPosts()
  }, [])

  if (!posts) return <div>Loading...</div>

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
'use client'

import { useState, useEffect } from 'react'

export function Posts() {
  const [posts, setPosts] = useState(null)

  useEffect(() => {
    async function fetchPosts() {
      let res = await fetch('https://api.vercel.app/blog')
      let data = await res.json()
      setPosts(data)
    }
    fetchPosts()
  }, [])

  if (!posts) return <div>Loading...</div>

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

### ORMまたはデータベースでデータをキャッシュする {#caching-data-with-an-orm-or-database}

`unstable_cache` APIを使用してレスポンスをキャッシュし、`next build`を実行するときにページを事前レンダリングできるようにします；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const allPosts = await getPosts()

  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const allPosts = await getPosts()

  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

この例では、データベースクエリの結果を1時間（3600秒）キャッシュします；また、キャッシュタグ`posts`が追加され、incremental static regenerationで無効化することができます；

### 複数の関数でデータを再利用する {#reusing-data-across-multiple-functions}

Next.jsは、`generateMetadata`や`generateStaticParams`のようなAPIを使用します；これらのAPIでは、`page`で取得された同じデータを使用する必要があります；

もし`fetch`を使用している場合、リクエストは`cache: 'force-cache'`を追加することで[memoized](/docs/app/building-your-application/caching#request-memoization)できます；これは、同じオプションで同じURLを安全に呼び出すことができ、1つのリクエストだけが行われることを意味します；

> **Good to know:**
>
> - 以前のバージョンのNext.jsでは、`fetch`を使用するとデフォルトで`cache`の値が`force-cache`でした；これはバージョン15で変更され、デフォルトで`cache: no-store`になりました；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/[id]/page.tsx" switcher
import { notFound } from 'next/navigation'

interface Post {
  id: string
  title: string
  content: string
}

async function getPost(id: string) {
  const res = await fetch(`https://api.vercel.app/blog/${id}`, {
    cache: 'force-cache',
  })
  const post: Post = await res.json()
  if (!post) notFound()
  return post
}

export async function generateStaticParams() {
  const posts = await fetch('https://api.vercel.app/blog', {
    cache: 'force-cache',
  }).then((res) => res.json())

  return posts.map((post: Post) => ({
    id: String(post.id),
  }))
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post = await getPost(id)

  return {
    title: post.title,
  }
}

export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post = await getPost(id)

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/[id]/page.js" switcher
import { notFound } from 'next/navigation'

async function getPost(id) {
  const res = await fetch(`https://api.vercel.app/blog/${id}`)
  const post = await res.json()
  if (!post) notFound()
  return post
}

export async function generateStaticParams() {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )

  return posts.map((post) => ({
    id: String(post.id),
  }))
}

export async function generateMetadata({ params }) {
  const { id } = await params
  const post = await getPost(id)

  return {
    title: post.title,
  }
}

export default async function Page({ params }) {
  const { id } = await params
  const post = await getPost(id)

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

</TabItem>
</Tabs>

`fetch`を使用していない場合、代わりにORMやデータベースを直接使用する場合は、Reactの`cache`関数でデータ取得をラップできます；これにより、重複が削除され、1回のクエリのみが行われます；

```jsx
import { cache } from 'react'
import { db, posts, eq } from '@/lib/db' // Drizzle ORMの例
import { notFound } from 'next/navigation'

export const getPost = cache(async (id) => {
  const post = await db.query.posts.findFirst({
    where: eq(posts.id, parseInt(id)),
  })

  if (!post) notFound()
  return post
})
```

### キャッシュされたデータの再検証 {#revalidating-cached-data}

[incremental static regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)を使用して、キャッシュされたデータを再検証する方法を学びましょう；

## パターン {#patterns}

### 並列データ取得と順次データ取得 {#parallel-and-sequential-data-fetching}

コンポーネント内でデータを取得するときは、2つのデータ取得パターンに注意する必要があります：並列と順次です；

<Image
  alt="順次と並列データ取得"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

- **順次**：コンポーネントtree内のリクエストが互いに依存している場合；これにより、読み込み時間が長くなる可能性があります；
- **並列**：route内のリクエストは積極的に開始され、同時にデータが読み込まれます；これにより、データを読み込むのにかかる総時間が短縮されます；

#### 順次データ取得 {#sequential-data-fetching}

ネストされたコンポーネントを持ちながら、それぞれのコンポーネントが独自のデータを取得する場合、それらのデータ要求が[memoized](/docs/app/building-your-application/caching#request-memoization)されていない場合、データ取得は順次で行われます；

このパターンが求められるケースもあります；なぜなら、1つの取得が別の取得結果に依存しているからです；たとえば、`Playlists`コンポーネントは`Playlists`が`artistID` propに依存しているため、`Artist`コンポーネントがデータの取得を終えるまでデータの取得を始めません：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/artist/[username]/page.tsx" switcher
export default async function Page({
  params: { username },
}: {
  params: Promise<{ username: string }>
}) {
  // アーティストの情報を取得
  const artist = await getArtist(username)

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Playlistsコンポーネントの読み込み中にフォールバックUIを表示 */}
      <Suspense fallback={<div>Loading...</div>}>
        {/* アーティストIDをPlaylistsコンポーネントに渡す */}
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  )
}

async function Playlists({ artistID }: { artistID: string }) {
  // アーティストIDを使用してプレイリストを取得
  const playlists = await getArtistPlaylists(artistID)

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/artist/[username]/page.js" switcher
export default async function Page({ params: { username } }) {
  // アーティストの情報を取得
  const artist = await getArtist(username)

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Playlistsコンポーネントの読み込み中にフォールバックUIを表示 */}
      <Suspense fallback={<div>Loading...</div>}>
        {/* アーティストIDをPlaylistsコンポーネントに渡す */}
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  )
}

async function Playlists({ artistID }) {
  // アーティストIDを使用してプレイリストを取得
  const playlists = await getArtistPlaylists(artistID)

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

[`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming)（routeセグメント用）や[React `<Suspense>`](/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense)（ネストされたコンポーネント用）を使用して、即時のローディング状態を表示し、Reactが結果をストリーミングする間に表示を続行できます；

これによりデータ要求でroute全体がブロックされるのを防ぎ、準備ができているページの部分を操作できるようになります；

#### 並列データ取得 {#parallel-data-fetching}

デフォルトでは、レイアウトとページセグメントは並列にレンダリングされます；つまり、リクエストは並列で開始されます；

しかし、`async` / `await`の性質上、同じセグメントまたはコンポーネント内で待機しているリクエストは、その下にあるリクエストをブロックします；

データを並列に取得するには、データを使用するコンポーネントの外でリクエストを積極的に開始することで、時間を節約します；これにより、両方のリクエストが並列に開始されます；ただし、ユーザーは両方のPromiseが解決されるまで表示結果を見られません；

以下の例では、`getArtist`と`getAlbums`の関数が`Page`コンポーネント外で定義され、`Promise.all`を使用してコンポーネント内で開始されます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/artist/[username]/page.tsx" switcher
import Albums from './albums'

async function getArtist(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}`)
  return res.json()
}

async function getAlbums(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`)
  return res.json()
}

export default async function Page({
  params: { username },
}: {
  params: Promise<{ username: string }>
}) {
  const artistData = getArtist(username)
  const albumsData = getAlbums(username)

  // 両方のリクエストを並列に開始
  const [artist, albums] = await Promise.all([artistData, albumsData])

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums} />
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/artist/[username]/page.js" switcher
import Albums from './albums'

async function getArtist(username) {
  const res = await fetch(`https://api.example.com/artist/${username}`)
  return res.json()
}

async function getAlbums(username) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`)
  return res.json()
}

export default async function Page({ params: { username } }) {
  const artistData = getArtist(username)
  const albumsData = getAlbums(username)

  // 両方のリクエストを並列に開始
  const [artist, albums] = await Promise.all([artistData, albumsData])

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums} />
    </>
  )
}
```

</TabItem>
</Tabs>

さらに，[Suspense Boundary](/docs/app/building-your-application/routing/loading-ui-and-streaming)を追加してレンダリング作業を分割し、できるだけ早く部分的な結果を表示できます；

### データのプリロード {#preloading-data}

ウォーターフォールを防ぐもう1つの方法は、ユーティリティ関数を作成してブロッキングリクエストの上で積極的に呼び出す`preload`パターンを使用することです；たとえば、`checkIsAvailable()` は`<Item/>`のレンダリングをブロックします；そのため`preload()`をその前に呼び出して<Item/>`のデータ依存関係を積極的に開始します；`<Item/>`がレンダリングされる頃には、データはすでに取得されています；

`preload`関数はが` checkIsAvailable()`の実行をブロックしないことに注意してください；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="components/Item.tsx" switcher
import { getItem } from '@/utils/get-item'

export const preload = (id: string) => {
  // voidは指定された式を評価し、undefinedを返します
  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void
  void getItem(id)
}
export default async function Item({ id }: { id: string }) {
  const result = await getItem(id)
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="components/Item.js" switcher
import { getItem } from '@/utils/get-item'

export const preload = (id) => {
  // voidは指定された式を評価し、undefinedを返します
  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void
  void getItem(id)
}
export default async function Item({ id }) {
  const result = await getItem(id)
  // ...
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/item/[id]/page.tsx" switcher
import Item, { preload, checkIsAvailable } from '@/components/Item'

export default async function Page({
  params: { id },
}: {
  params: Promise<{ id: string }>
}) {
  // アイテムデータの読み込みを開始
  preload(id)
  // 他の非同期タスクを実行
  const isAvailable = await checkIsAvailable()

  return isAvailable ? <Item id={id} /> : null
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/item/[id]/page.js" switcher
import Item, { preload, checkIsAvailable } from '@/components/Item'

export default async function Page({ params: { id } }) {
  // アイテムデータの読み込みを開始
  preload(id)
  // 他の非同期タスクを実行
  const isAvailable = await checkIsAvailable()

  return isAvailable ? <Item id={id} /> : null
}
```

</TabItem>
</Tabs>

> **Good to know:** "preload"関数はAPIではなくパターンなので、名前は任意です；

#### React `cache`と`server-only`を使用するPreload Pattern {#using-react-cache-and-server-only-with-the-preload-pattern}

React `cache`関数、`preload`パターン、および`server-only`パッケージを組み合わせて、アプリ全体で使用できるデータ取得ユーティリティを作成できます；

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import 'server-only'

export const preload = (id: string) => {
  void getItem(id)
}

export const getItem = cache(async (id: string) => {
  // ...
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import 'server-only'

export const preload = (id) => {
  void getItem(id)
}

export const getItem = cache(async (id) => {
  // ...
})
```

</TabItem>
</Tabs>

このアプローチを使用すると、データを積極的に取得し、レスポンスをキャッシュし、このデータ取得が[サーバーでのみ行われることを保証](/docs/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment)することができます；

`utils/get-item`のエクスポートは、レイアウト、ページ、または他のコンポーネントで使用され、アイテムのデータが取得されるタイミングを制御できます；

> **Good to know:**
>
> - [`server-only` パッケージ](/docs/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment)を使用して、サーバーデータ取得関数が決してクライアントで使用されないようにすることをお勧めします；

### クライアントへの機密データの露出を防ぐ {#preventing-sensitive-data-from-being-exposed-to-the-client}

Reactの汚染API、[`taintObjectReference`](https://react.dev/reference/react/experimental_taintObjectReference)と[`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue)を使用して、クライアントに渡すオブジェクト全体のインスタンスや機密値を防ぐことをお勧めします；

アプリケーションで汚染を有効にするには、Next.js Configの`experimental.taint`オプションを`true`に設定します：

```js title="next.config.js"
module.exports = {
  experimental: {
    taint: true,
  },
}
```

次に、`experimental_taintObjectReference`または`experimental_taintUniqueValue`関数に渡したいオブジェクトまたは値を渡します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/utils.ts" switcher
import { queryDataFromDB } from './api'
import {
  experimental_taintObjectReference,
  experimental_taintUniqueValue,
} from 'react'

export async function getUserData() {
  const data = await queryDataFromDB()
  experimental_taintObjectReference(
    'クライアントに全体のユーザーオブジェクトを渡さないでください',
    data
  )
  experimental_taintUniqueValue(
    'クライアントにユーザーのアドレスを渡さないでください',
    data,
    data.address
  )
  return data
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/utils.js" switcher
import { queryDataFromDB } from './api'
import {
  experimental_taintObjectReference,
  experimental_taintUniqueValue,
} from 'react'

export async function getUserData() {
  const data = await queryDataFromDB()
  experimental_taintObjectReference(
    'クライアントに全体のユーザーオブジェクトを渡さないでください',
    data
  )
  experimental_taintUniqueValue(
    'クライアントにユーザーのアドレスを渡さないでください',
    data,
    data.address
  )
  return data
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { getUserData } from './data'

export async function Page() {
  const userData = getUserData()
  return (
    <ClientComponent
      user={userData} // これはtaintObjectReferenceのためにエラーを引き起こします
      address={userData.address} // これはtaintUniqueValueのためにエラーを引き起こします
    />
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { getUserData } from './data'

export async function Page() {
  const userData = await getUserData()
  return (
    <ClientComponent
      user={userData} // これはtaintObjectReferenceのためにエラーを引き起こします
      address={userData.address} // これはtaintUniqueValueのためにエラーを引き起こします
    />
  )
}
```

</TabItem>
</Tabs>
