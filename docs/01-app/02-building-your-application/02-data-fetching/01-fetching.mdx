---
title: 'Data Fetching and Caching'
nav_title: 'Data Fetching and Caching'
description: 'Next.jsでサーバまたはクライアントでのデータ取得のベストプラクティスを学びます。'
---

<details>
  <summary>Examples</summary>

- [Next.js Commerce](https://vercel.com/templates/next.js/nextjs-commerce)
- [On-Demand ISR](https://on-demand-isr.vercel.app)
- [Next.js Forms](https://github.com/vercel/next.js/tree/canary/examples/next-forms)

</details>

このガイドでは、Next.jsにおけるデータ取得とキャッシュの基本を実用的な例とベストプラクティスを提供しながら紹介します。

こちらがNext.jsにおけるデータ取得の最小限の例です：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

この例は、非同期なReact Server Component内での`fetch` APIを使用した基本的なサーバーサイドデータ取得を示しています。

## 参照 {#reference}

- [`fetch`](/docs/app/api-reference/functions/fetch)
- React [`cache`](https://react.dev/reference/react/cache)
- Next.js [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)

## 例 {#examples}

### `fetch` APIを使用したサーバーでのデータ取得 {#fetching-data-on-the-server-with-the-fetch-api}

このコンポーネントはブログ投稿のリストを取得して表示します。`fetch`の応答はデフォルトではキャッシュされません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

このルート内で他に[Dynamic APIs](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)を使用していない場合、このルートは`next build`時に静的ページとしてプリレンダリングされます。データはその後[Incremental Static Regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)を使用して更新できます。

ページのプリレンダリングを防ぐには、次のようにファイルに追加できます：

```js
export const dynamic = 'force-dynamic'
```

ただし、`cookies`、`headers`、またはページpropsからの`searchParams`の読み取りなどの関数を一般的に使用して、ページが自動的に動的にレンダリングされます。この場合、明示的に`force-dynamic`を使用する必要はありません。

### ORMやデータベースを使用したサーバーでのデータ取得 {#fetching-data-on-the-server-with-an-orm-or-database}

このコンポーネントはブログ投稿のリストを取得して表示します。データベースからの応答はデフォルトではキャッシュされませんが、[追加設定](#caching-data-with-an-orm-or-database)でキャッシュできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { db, posts } from '@/lib/db'

export default async function Page() {
  const allPosts = await db.select().from(posts)
  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { db, posts } from '@/lib/db'

export default async function Page() {
  const allPosts = await db.select().from(posts)
  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

### クライアントでのデータ取得 {#fetching-data-on-the-client}

最初にサーバーサイドでのデータ取得を試みることをお勧めします。

ただし、クライアントサイドでデータ取得することが適切な場合もあります。そのような状況では、手動で`useEffect`（推奨されない）で`fetch`を呼び出すか、クライアント取得のためにコミュニティの人気のあるReactライブラリ（例：[SWR](https://swr.vercel.app/)や[React Query](https://tanstack.com/query/latest)）を活用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import { useState, useEffect } from 'react'

export function Posts() {
  const [posts, setPosts] = useState(null)

  useEffect(() => {
    async function fetchPosts() {
      const res = await fetch('https://api.vercel.app/blog')
      const data = await res.json()
      setPosts(data)
    }
    fetchPosts()
  }, [])

  if (!posts) return <div>Loading...</div>

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
'use client'

import { useState, useEffect } from 'react'

export function Posts() {
  const [posts, setPosts] = useState(null)

  useEffect(() => {
    async function fetchPosts() {
      const res = await fetch('https://api.vercel.app/blog')
      const data = await res.json()
      setPosts(data)
    }
    fetchPosts()
  }, [])

  if (!posts) return <div>Loading...</div>

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

### ORMやデータベースでのデータキャッシュ {#caching-data-with-an-orm-or-database}

`unstable_cache` APIを使用して応答をキャッシュし、`next build`を実行したときにページがプリレンダリングされるようにできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const allPosts = await getPosts()

  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const allPosts = await getPosts()

  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

この例では、データベースクエリの結果を1時間（3600秒）キャッシュします。これはキャッシュタグ`posts`も追加し、[Incremental Static Regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)で無効化できます。

### 複数の関数間でデータを再利用する {#reusing-data-across-multiple-functions}

Next.jsは`generateMetadata`や`generateStaticParams`などのAPIを使用します。これにより、`page`で取得したのと同じデータを使用する必要が生じます。

`fetch`を使用している場合、`cache: 'force-cache'`を追加することでリクエストを[メモ化](/docs/app/building-your-application/caching#request-memoization)できます。これは、同じURLを同じオプションで安全に呼び出すことができ、1つのリクエストだけが行われることを意味します。

```tsx
import { notFound } from 'next/navigation'

interface Post {
  id: string
  title: string
  content: string
}

async function getPost(id: string) {
  const res = await fetch(`https://api.vercel.app/blog/${id}`, {
    cache: 'force-cache',
  })
  const post: Post = await res.json()
  if (!post) notFound()
  return post
}

export async function generateStaticParams() {
  const posts = await fetch('https://api.vercel.app/blog', {
    cache: 'force-cache',
  }).then((res) => res.json())

  return posts.map((post: Post) => ({
    id: String(post.id),
  }))
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post = await getPost(id)

  return {
    title: post.title,
  }
}

export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post = await getPost(id)

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/[id]/page.js" switcher
import { notFound } from 'next/navigation'

async function getPost(id) {
  const res = await fetch(`https://api.vercel.app/blog/${id}`)
  const post = await res.json()
  if (!post) notFound()
  return post
}

export async function generateStaticParams() {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )

  return posts.map((post) => ({
    id: String(post.id),
  }))
}

export async function generateMetadata({ params }) {
  const { id } = await params
  const post = await getPost(id)

  return {
    title: post.title,
  }
}

export default async function Page({ params }) {
  const { id } = await params
  const post = await getPost(id)

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

</TabItem>
</Tabs>

`fetch`を使用せず、直接ORMやデータベースを使用する場合は、React `cache`関数でデータ取得をラップできます。これにより、重複が排除され、1つのクエリのみが実行されます。

### キャッシュされたデータの再検証 {#revalidating-cached-data}

キャッシュされたデータの再検証については、[Incremental Static Regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)に関する詳細をご覧ください。

## パターン {#patterns}

### 並行および逐次データ取得 {#parallel-and-sequential-data-fetching}

コンポーネント内でデータを取得する場合、並行および逐次の2つのデータ取得パターンに注意する必要があります。

- **逐次**：コンポーネントtree内のリクエストが互いに依存している場合です。これにより、読み込み時間が長くなる可能性があります
- **並行**：ルート内のリクエストが必要に応じて開始され、データが同時に読み込まれます。これにより、データを読み込むのにかかる総時間が短縮されます

#### 逐次データ取得 {#sequential-data-fetching}

ネストされたコンポーネントがあり、それぞれのコンポーネントが自身のデータを取得する場合、それらのデータリクエストが[メモ化](/docs/app/building-your-application/caching#request-memoization)されていない限り、データの取得は逐次的に行われます。

このパターンを使用したい理由がある場合があります。たとえば、`Playlists`コンポーネントは、`artistID` propに依存しているため、`Playlists`が`getArtist`データの取得が完了するまで開始されない場合があります：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/artist/[username]/page.tsx" switcher
export default async function Page({
  params,
}: {
  params: Promise<{ username: string }>
}) {
  const { username } = await params
  // アーティスト情報を取得
  const artist = await getArtist(username)

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Playlistsコンポーネントの読み込み中にフォールバックUIを表示 */}
      <Suspense fallback={<div>Loading...</div>}>
        {/* artist IDをPlaylistsコンポーネントに渡す */}
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  )
}

async function Playlists({ artistID }: { artistID: string }) {
  // artist IDを使ってプレイリストを取得
  const playlists = await getArtistPlaylists(artistID)

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/artist/[username]/page.js" switcher
export default async function Page({ params }) {
  const { username } = await params
  // アーティスト情報を取得
  const artist = await getArtist(username)

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Playlistsコンポーネントの読み込み中にフォールバックUIを表示 */}
      <Suspense fallback={<div>Loading...</div>}>
        {/* artist IDをPlaylistsコンポーネントに渡す */}
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  )
}

async function Playlists({ artistID }) {
  // artist IDを使ってプレイリストを取得
  const playlists = await getArtistPlaylists(artistID)

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

#### 並行データ取得 {#parallel-data-fetching}

デフォルトで、レイアウトおよびページセグメントは並行してレンダリングされます。これによりリクエストは並行して開始されます。

ただし、`async`/`await`の特性により、同じセグメントやコンポーネントの中で待機されるリクエストは、その下にあるリクエストをブロックします。

データを並行して取得するには、データを使用するコンポーネントの外でリクエストを定義し、積極的にリクエストを開始できます。これにより、両方のリクエストが並行して開始されるため時間が節約されますが、両方のプロミスが解決されるまでユーザーにレンダリング結果は表示されません。

以下の例では、`getArtist`および`getAlbums`関数が`Page`コンポーネントの外で定義され、コンポーネント内で`Promise.all`を使用して開始されています：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/artist/[username]/page.tsx" switcher
import Albums from './albums'

async function getArtist(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}`)
  return res.json()
}

async function getAlbums(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`)
  return res.json()
}

export default async function Page({
  params,
}: {
  params: Promise<{ username: string }>
}) {
  const { username } = await params
  const artistData = getArtist(username)
  const albumsData = getAlbums(username)

  // 両方のリクエストを並行して開始
  const [artist, albums] = await Promise.all([artistData, albumsData])

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums} />
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/artist/[username]/page.js" switcher
import Albums from './albums'

async function getArtist(username) {
  const res = await fetch(`https://api.example.com/artist/${username}`)
  return res.json()
}

async function getAlbums(username) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`)
  return res.json()
}

export default async function Page({ params }) {
  const { username } = await params
  const artistData = getArtist(username)
  const albumsData = getAlbums(username)

  // 両方のリクエストを並行して開始
  const [artist, albums] = await Promise.all([artistData, albumsData])

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums} />
    </>
  )
}
```

</TabItem>
</Tabs>

さらに、データを内側の[Suspense Boundary](/docs/app/building-your-application/routing/loading-ui-and-streaming)で分割し、一部の結果を迅速に表示することもできます。

### データのプリロード {#preloading-data}

ウォーターフォールを防ぐもう1つの方法は、ユーティリティ関数を作成して、ブロッキングリクエストの上で積極的に呼び出す*preloud*パターンを使用することです。たとえば、`checkIsAvailable()`は`<Item/>`のレンダリングをブロックするので、`preload()`を呼び出して積極的に`<Item/>`のデータ依存関係を開始できます。`<Item/>`がレンダリングされるときには、データはすでに取得されています。

`preload`関数は`checkIsAvailable()`の実行をブロックしないことに注意してください。

```tsx
import { getItem } from '@/utils/get-item'

export const preload = (id: string) => {
  // voidは指定した式を評価し、undefinedを返します
  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void
  void getItem(id)
}
export default async function Item({ id }: { id: string }) {
  const result = await getItem(id)
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="components/Item.js" switcher
import { getItem } from '@/utils/get-item'

export const preload = (id) => {
  // voidは指定した式を評価し、undefinedを返します
  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void
  void getItem(id)
}
export default async function Item({ id }) {
  const result = await getItem(id)
  // ...
}
```

</TabItem>
</Tabs>

`utils/get-item`のエクスポートはLayouts、Pages、あるいは他のコンポーネントが管理するために使用できます。

> **Good to know:**
>
> - サーバーデータ取得関数がクライアントで使用されることがないようにするためには、[`server-only`パッケージ](/docs/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment)を使用することをお勧めします。

### クライアントに機密データが露出しないようにする {#preventing-sensitive-data-from-being-exposed-to-the-client}

クライアントに対してオブジェクト全体のインスタンスや機密値を渡さないようにするために、Reactの`taint` APIs、[`taintObjectReference`](https://react.dev/reference/react/experimental_taintObjectReference)、[`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue)の使用をお勧めします。

アプリケーションでたいんを有効にするには、Next.js Configの`experimental.taint`オプションを`true`に設定します：

```js title="next.config.js"
module.exports = {
  experimental: {
    taint: true,
  },
}
```

その後、`experimental_taintObjectReference`または`experimental_taintUniqueValue`関数に渡したいオブジェクトや値を渡します。：
