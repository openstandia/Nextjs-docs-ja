---
title: 'ServerとClientのコンポジションパターン'
nav_title: 'コンポジションパターン'
description: 'Server ComponentとClient Componentの使用における推奨パターン。'
---

Reactアプリケーションを構築する際には、どの部分をサーバーやクライアントでレンダリングすべきか考える必要があります。このページでは、Server ComponentとClient Componentを使用する際に推奨されるコンポジションパターンについて説明します。

## Server ComponentとClient Componentを使用するタイミング {#when-to-use-server-and-client-components}

以下は、Server ComponentとClient Componentのさまざまなユースケースの簡単なまとめです：

| 何をする必要がありますか？                                                            | Server Component    | Client Component    |
| ------------------------------------------------------------------------------------- | ------------------- | ------------------- |
| データを取得する                                                                      | <Check size={18} /> | <Cross size={18} /> |
| バックエンドリソースに直接アクセスする                                                | <Check size={18} /> | <Cross size={18} /> |
| サーバーで機密情報を保持する（アクセストークン、APIキーなど）                         | <Check size={18} /> | <Cross size={18} /> |
| サーバー上で大きな依存性を保持する / クライアントサイドのJavaScriptを削減する         | <Check size={18} /> | <Cross size={18} /> |
| インタラクティビティとイベントリスナーを追加する（`onClick()`、`onChange()`など）     | <Cross size={18} /> | <Check size={18} /> |
| 状態とライフサイクル効果を使用する（`useState()`、`useReducer()`、`useEffect()`など） | <Cross size={18} /> | <Check size={18} /> |
| ブラウザー専用のAPIを使用する                                                         | <Cross size={18} /> | <Check size={18} /> |
| 状態、効果、またはブラウザー専用APIに依存するカスタムフックを使用する                 | <Cross size={18} /> | <Check size={18} /> |
| [React クラスコンポーネント](https://react.dev/reference/react/Component)を使用する   | <Cross size={18} /> | <Check size={18} /> |

## Server Componentパターン {#server-component-patterns}

クライアントサイドレンダリングを選択する前に、データの取得やデータベースやバックエンドサービスへのアクセスなどをサーバー上で行うことを検討するかもしれません。

以下は、Server Componentを使用する際の一般的なパターンです：

### コンポーネント間でデータを共有する {#sharing-data-between-components}

サーバーでデータを取得する際には、異なるコンポーネント間でデータを共有する必要がある場合があります。たとえば、同じデータに依存しているレイアウトとページがあるかもしれません。

React Context（サーバー上では利用できない）を使用する代わりに、`props`としてデータを渡すことができます。コンポーネントで必要な同じデータを取得するために`fetch`やReactの`cache`関数を使用し、同じデータへの重複リクエストを心配する必要がありません。これは、Reactがデータリクエストを自動的にメモ化するために`fetch`を拡張しており、`fetch`が利用できないときに`cache`関数を使用できるからです。

このパターンの[例を表示する](/docs/app/building-your-application/data-fetching/fetching#reusing-data-across-multiple-functions)。

### Server専用コードをクライアント環境から排除する {#keeping-server-only-code-out-of-the-client-environment}

JavaScriptモジュールはServer ComponentとClient Componentのモジュール間で共有できるため、サーバーでしか実行されることを意図していなかったコードがクライアントに紛れ込む可能性があります。

たとえば、以下のようなデータ取得関数を考えてみましょう：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="lib/data.ts" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="lib/data.js" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

</TabItem>
</Tabs>

一見すると、`getData`はサーバーとクライアントの両方で機能するように見えます。しかし、この関数には`API_KEY`が含まれており、サーバーでのみ実行されることを意図しています。

環境変数`API_KEY`は`NEXT_PUBLIC`で始まっていないため、サーバー上でのみアクセス可能なプライベート変数です。環境変数がクライアントに漏れないようにするため、Next.jsはプライベートな環境変数を空文字列に置き換えます。

その結果、`getData()`はクライアントでインポートして実行できますが、期待通りには動作しません。変数を公開することで、関数をクライアントで動作させることはできますが、機密情報をクライアントに公開したくないかもしれません。

この種の意図しないクライアントでのサーバーコード使用を防ぐために、`server-only`パッケージを使用して、これらのモジュールをClient Componentにインポートした場合にビルドタイムエラーを発生させることができます。

`server-only`を使用するには、まずパッケージをインストールします：

```bash title="Terminal"
npm install server-only
```

その後、サーバー専用コードを含むモジュールにパッケージをインポートします：

```js title="lib/data.js"
import 'server-only'

export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

これで、`getData()`をインポートするClient Componentは、このモジュールがサーバーでのみ使用できることを示すビルドタイムエラーを受け取ります。

対応するパッケージ`client-only`は、クライアント専用コード（たとえば、`window`オブジェクトにアクセスするコード）を含むモジュールをマークするために使用できます。

### サードパーティパッケージとプロバイダの使用 {#using-third-party-packages-and-providers}

Server Componentは新しいReactの機能であるため、エコシステム内のサードパーティパッケージやプロバイダは、`useState`、`useEffect`、`createContext`などのクライアント専用機能を使用するコンポーネントに`"use client"`ディレクティブを追加し始めたところです。

現在、クライアント専用機能を使用する`npm`パッケージの多くのコンポーネントには、まだディレクティブがありません。これらのサードパーティコンポーネントは、Client Component内で`"use client"`ディレクティブを持っているため、期待通り動作しますが、Server Component内では動作しません。

たとえば、`useState`を使用する`<Carousel />`コンポーネントを持つ仮の`acme-carousel`パッケージをインストールしたとします。このコンポーネントにはまだ`"use client"`ディレクティブがありません。

Client Component内で`<Carousel />`を使用すると、期待通り動作します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/gallery.tsx" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* This works because Carousel is used within a Client Component */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/gallery.js" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* This works because Carousel is used within a Client Component */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
</Tabs>

しかし、Server Component内で直接使用しようとすると、エラーが発生します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

これは、Next.jsが`<Carousel />`がクライアント専用機能を使用していることを認識できないためです。

これを修正するには、クライアント専用機能に依存するサードパーティコンポーネントを独自のClient Componentでラップします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/carousel.tsx" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/carousel.js" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
</Tabs>

これで、Server Component内で`<Carousel />`を直接使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* This works because Carousel is a Client Component */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* This works because Carousel is a Client Component */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

ほとんどのサードパーティコンポーネントをラップする必要はないと思われますが、これは通常、Client Component内で使用するためです。ただし、プロバイダは例外です。プロバイダは通常、Reactの状態と文脈に依存しており、アプリケーションのrootに必要だからです。[サードパーティコンテキストプロバイダについて詳しく学ぶ](#using-context-providers)。

#### コンテキストプロバイダの使用 {#using-context-providers}

コンテキストプロバイダは、通常、現在のテーマのようなグローバルな関心を共有するためにアプリケーションのroot付近にレンダリングされます。[Reactコンテキスト](https://react.dev/learn/passing-data-deeply-with-context)はServer Componentではサポートされていないため、アプリケーションのrootでコンテキストを作成しようとすると、エラーが発生します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import { createContext } from 'react'

// createContext is not supported in Server Components
export const ThemeContext = createContext({})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import { createContext } from 'react'

// createContext is not supported in Server Components
export const ThemeContext = createContext({})

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

これを修正するには、コンテキストを作成し、Client Component内でそのプロバイダをレンダリングします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/theme-provider.tsx" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode
}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/theme-provider.js" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
</Tabs>

your Server Component will now be able to directly render your provider since it's been marked as a Client Component.

Server Componentは、プロバイダがClient Componentとしてマークされているため、プロバイダを直接レンダリングできるようになります：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

プロバイダがrootにレンダリングされていると、アプリケーション内の他のすべてのClient Componentはこのコンテキストを消費できるようになります。

> **Good to know**: プロバイダは、ツリーの中でできるだけ深くレンダリングするべきです。`ThemeProvider`が`{children}`のみをラップしており、`<html>`文書全体をラップしていないことに注意してください。これは、Next.jsがサーバーコンポーネントの静的部分を最適化しやすくするためです。

#### ライブラリア著者へのアドバイス {#advice-for-library-authors}

同様に、他の開発者によって消費されるパッケージを作成するライブラリア著者は、`"use client"`ディレクティブを使用してパッケージのクライアントエントリポイントをマークすることができます。これにより、ユーザーはパッケージコンポーネントを直接Server Componentにインポートし、ラッピング境界を作成する必要がなくなります。

あなたのパッケージを最適化するために、ツリーの中で`'use client'`をより深く使用すると、インポートされたモジュールがServer Componentのモジュールグラフの一部になります。

一部のバンドラーは`"use client"`ディレクティブを削除するかもしれないことに注意する価値があります。`"use client"`ディレクティブを含めるようにesbuildを設定する方法の例は、[React Wrap Balancer](https://github.com/shuding/react-wrap-balancer/blob/main/tsup.config.ts#L10-L13)および[Vercel Analytics](https://github.com/vercel/analytics/blob/main/packages/web/tsup.config.js#L26-L30)リポジトリで見つけることができます。

## Client Components {#client-components}

### Client Componentsをツリーの下に配置する {#moving-client-components-down-the-tree}

Client JavaScriptバンドルサイズを削減するために、Client Componentsをコンポーネントツリーの下部に配置することをお勧めします。

たとえば、静的な要素（例：ロゴ、リンクなど）を持つレイアウトと、状態を使用するインタラクティブな検索バーがあるかもしれません。

レイアウト全体をClient Componentにするのではなく、インタラクティブなロジックをClient Component（例：`<SearchBar />`）に移し、レイアウトはServer Componentとして保ちます。これにより、レイアウトのすべてのコンポーネントJavaScriptをクライアントに送信する必要がなくなります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
// SearchBarはClient Component
import SearchBar from './searchbar'
// LogoはServer Component
import Logo from './logo'

// LayoutはデフォルトでServer Componentです
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
// SearchBarはClient Component
import SearchBar from './searchbar'
// LogoはServer Component
import Logo from './logo'

// LayoutはデフォルトでServer Componentです
export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
</Tabs>

### ServerからClient Componentsへのpropsの渡し方（シリアライゼーション） {#passing-props-from-server-to-client-components-serialization}

Server Componentでデータを取得する場合、そのデータをClient Componentへのpropsとして渡すことがあります。Server ComponentsからClient Componentsに渡されるpropsは、Reactによって[シリアライズ可能](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)である必要があります。

Client Componentsがシリアライズ可能でないデータに依存する場合、[サードパーティライブラリを使用してクライアント上でデータを取得](/docs/app/building-your-application/data-fetching/fetching#fetching-data-on-the-client)するか、[ルートハンドラを使用してサーバー上でデータを取得](/docs/app/building-your-application/routing/route-handlers)できます。

## ServerとClient Componentsを交互に組み込む {#interleaving-server-and-client-components}

ClientとServer Componentsを交互に組み込む際、UIをコンポーネントのツリーとして視覚化するのが役立つかもしれません。[root レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)から始めて、これはServer Componentです、`"use client"`ディレクティブを追加することで、特定のコンポーネントのサブツリーをクライアントでレンダリングできます。

{/* 図 - 交差 */}

これらのクライアントサブツリーの中では、Server ComponentsをネストしたりServer Actionsを呼び出したりできます。ただし、次の点を考慮に入れてください：

- リクエスト-レスポンスライフサイクル中にコードがサーバーからクライアントに移動します。クライアント側でサーバー上のデータやリソースにアクセスする必要がある場合、新しいリクエストをサーバーに送信します。切り替えるのではありません。
- 新しいリクエストがサーバーに送信されると、まずすべてのServer Componentsがレンダリングされます。これには、Client Componentsにネストされたものも含まれます。レンダリングされた結果（[RSCペイロード](/docs/app/building-your-application/rendering/server-components#what-is-the-react-server-component-payload-rsc)）には、クライアントコンポーネントの場所への参照が含まれます。その後、クライアント側でReactはRSCペイロードを使用してServer ComponentsとClient Componentsを単一のツリーに調整します。

{/* 図 */}

- Client ComponentsはServer Componentsの後にレンダリングされるため、Client ComponentモジュールにServer Componentをインポートすることはできません（これはサーバーへの新しいリクエストを必要とするためです）。代わりに、Server ComponentをClient Componentに`props`として渡すことができます。[サポートされていないパターン](#unsupported-pattern-importing-server-components-into-client-components)とされているパターンです。[サポートされているパターン](#supported-pattern-passing-server-components-to-client-components-as-props)セクション以下。

### サポートされていないパターン: Client ComponentsへのServer Componentsのインポート {#unsupported-pattern-importing-server-components-into-client-components}

以下のパターンはサポートされていません。Client ComponentにServer Componentをインポートすることはできません：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={3,4,17}
'use client'

// Client ComponentにServer Componentをインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={3,13}
'use client'

// Client ComponentにServer Componentをインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
</Tabs>

### サポートされているパターン: Client ComponentsへのServer Componentsをpropsとして渡す {#supported-pattern-passing-server-components-to-client-components-as-props}

以下のパターンはサポートされています。Client ComponentにServer Componentを`props`として渡すことができます。

一般的なパターンは、Reactの`children``props`を使用して、Client Component内に*"スロット"*を作成することです。

以下の例では、`<ClientComponent>`が`children`の`props`を受け入れます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={6,15}
'use client'

import { useState } from 'react'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={5,12}
'use client'

import { useState } from 'react'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      {children}
    </>
  )
}
```

</TabItem>
</Tabs>

`<ClientComponent>`は、最終的に`children`がServer Componentの結果によって補完されることを知りません。`<ClientComponent>`の唯一の責任は、`children`が最終的にどこに配置されるかを決定することです。

親Server Componentでは、`<ClientComponent>`と`<ServerComponent>`の両方をインポートし、`<ServerComponent>`を`<ClientComponent>`の子として渡すことができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" highlight={11} switcher
// このパターンは機能します：
// サーバーコンポーネントをクライアントコンポーネントの子またはプロップとして渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.jsのページはデフォルトでServer Componentsです。
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" highlight={11} switcher
// このパターンは機能します：
// サーバーコンポーネントをクライアントコンポーネントの子またはプロップとして渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.jsのページはデフォルトでServer Componentsです。
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
</Tabs>

このアプローチでは、`<ClientComponent>`と`<ServerComponent>`がデカップルされており、それぞれ独立してレンダリングできます。この場合、子の`<ServerComponent>`はクライアントがレンダリングされる前にサーバーでレンダリングできます。

> **Good to know:**
>
> - 親コンポーネントが再レンダリングされる際にネストされた子コンポーネントの再レンダリングを避けるために、「コンテンツを持ち上げる」パターンが使用されています。
> - `children``props`に限定されません。任意の`props`を使用してJSXを渡すことができます。
