---
title: 'サーバーとクライアントのコンポジションパターン'
nav_title: 'コンポジションパターン'
description: 'Server ComponentとClient Componentを使用するための推奨パターン。'
---

Reactアプリケーションを構築する際に、どの部分をサーバーでレンダリングするべきか、クライアントでレンダリングするべきかを考慮する必要があります。このページでは、Server ComponentとClient Componentを使用する際の推奨されるコンポジションパターンについて説明します。

## Server ComponentとClient Componentをいつ使用するか？ {#when-to-use-server-and-client-components}

Server ComponentとClient Componentのさまざまなユースケースを簡単にまとめたものです。

| 何をする必要がありますか？                                                                  | Server Component    | Client Component    |
| ------------------------------------------------------------------------------------------- | ------------------- | ------------------- |
| データを取得する                                                                            | <Check size={18} /> | <Cross size={18} /> |
| バックエンドリソースに直接アクセスする                                                      | <Check size={18} /> | <Cross size={18} /> |
| 機密情報（アクセストークンやAPIキーなど）をサーバーに保持する                               | <Check size={18} /> | <Cross size={18} /> |
| 大きな依存関係をサーバーに保持する / クライアントサイドのJavaScriptを削減する               | <Check size={18} /> | <Cross size={18} /> |
| 双方向機能やイベントリスナー（`onClick()`、`onChange()`など）を追加する                     | <Cross size={18} /> | <Check size={18} /> |
| 状態やライフサイクルエフェクト（`useState()`、`useReducer()`、`useEffect()`など）を使用する | <Cross size={18} /> | <Check size={18} /> |
| ブラウザ専用APIを使用する                                                                   | <Cross size={18} /> | <Check size={18} /> |
| 状態、エフェクト、またはブラウザ専用APIに依存するカスタムフックを使用する                   | <Cross size={18} /> | <Check size={18} /> |
| [React Class components](https://react.dev/reference/react/Component)を使用する             | <Cross size={18} /> | <Check size={18} /> |

## Server Componentのパターン {#server-component-patterns}

クライアントサイドレンダリングを選択する前に、サーバーで行う作業を検討する場合があります。例えば、データの取得やデータベースやバックエンドサービスへのアクセスなどです。

以下は、Server Componentを使用する際の一般的なパターンです。

### コンポーネント間でデータを共有する {#sharing-data-between-components}

サーバーでデータを取得する場合、異なるコンポーネント間でデータを共有する必要があることがあります。たとえば、同じデータに依存するレイアウトとページがある場合です。

[React Context](https://react.dev/learn/passing-data-deeply-with-context)（サーバーでは利用できません）を使用したり、propsとしてデータを渡す代わりに、`fetch`やReactの`cache`関数を使用して必要なコンポーネント内で同じデータを取得できます。この方法は、同じデータに対して重複したリクエストが発生する心配がありません。これは、Reactが`fetch`を拡張してデータリクエストを自動的にメモ化するためです。`fetch`が利用できない場合は、`cache`関数を使用できます。

[このパターンの例を参照](/docs/app/building-your-application/data-fetching/fetching#reusing-data-across-multiple-functions)してください。

### サーバー専用コードをクライアント環境から排除する {#keeping-server-only-code-out-of-the-client-environment}

JavaScriptモジュールはServer ComponentとClient Componentの両方で共有できるため、サーバーでのみ実行するつもりのコードがクライアントに持ち込まれる可能性があります。

たとえば、次のデータ取得関数を考えてみましょう。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="lib/data.ts" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="lib/data.js" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

</TabItem>
</Tabs>

一見すると、`getData`はサーバーとクライアントの両方で動作するように見えます。しかし、この関数にはサーバーでのみ実行することを前提に書かれた`API_KEY`が含まれています。

環境変数`API_KEY`は`NEXT_PUBLIC`で始まっていないため、サーバーでのみアクセスできるプライベート変数です。環境変数がクライアントに漏れるのを防ぐため、Next.jsはプライベート環境変数を空の文字列に置き換えます。

その結果、`getData()`をクライアントでインポートして実行することは可能ですが、期待どおりに動作しません。また、変数を公開すればクライアントで関数が動作するようになってしまいますが、機密情報をクライアントに公開したくない場合もあるでしょう。

このようなサーバーコードの意図しないクライアント使用を防ぐために、`server-only`パッケージを使用して、これらのモジュールをClient Componentに誤ってインポートした場合にビルド時エラーを発生させることができます。

`server-only`を使用するには、まずパッケージをインストールします。

```bash title="Terminal"
npm install server-only
```

その後、サーバー専用コードを含むモジュールにパッケージをインポートします。

```js title="lib/data.js"
import 'server-only'

export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

これで、`getData()`をインポートする任意のClient Componentは、このモジュールはサーバーでのみ使用可能であることを説明するビルド時エラーを受け取ります。

対応するパッケージの`client-only`を使用して、クライアント専用コードを含むモジュールをマークできます。たとえば、`window`オブジェクトにアクセスするコードです。

### サードパーティパッケージとプロバイダを使用する {#using-third-party-packages-and-providers}

Server ComponentはReactの新機能であるため、エコシステム内のサードパーティパッケージおよびプロバイダは現在、クライアント専用機能（`useState`、`useEffect`、および`createContext`など）を使用しているコンポーネントに`"use client"`ディレクティブを追加し始めています。

現在、`npm`パッケージからの多くのクライアント専用機能を使用しているコンポーネントにはまだこのディレクティブがありません。これらのサードパーティのコンポーネントはClient Component内で期待通りに動作しますが、Server Component内では動作しません。

たとえば、クライアント専用機能を使用している`<Carousel />`コンポーネントを持つ架空の`acme-carousel`パッケージをインストールしたとします。このコンポーネントは`useState`を使用しますが、まだ`"use client"`ディレクティブがありません。

`<Carousel />`をClient Component内で使用すると、期待どおりに動作します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/gallery.tsx" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* Works, since Carousel is used within a Client Component */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/gallery.js" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/*  Works, since Carousel is used within a Client Component */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
</Tabs>

ただし、Server Component内で直接使用しようとすると、エラーが表示されます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/*  Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

これは、Next.jsが`<Carousel />`がクライアント専用機能を使用していることを知らないためです。

これを解決するには、クライアント専用機能に依存するサードパーティのコンポーネントを自己のClient Componentでラップできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/carousel.tsx" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/carousel.js" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
</Tabs>

これで、<Carousel />をServer Component内で直接使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/*  Works, since Carousel is a Client Component */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/*  Works, since Carousel is a Client Component */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

ほとんどのサードパーティコンポーネントをラップする必要はないと期待しています。なぜなら、通常、Client Components内で使用すると思われるからです。ただし、プロバイダは例外です。これらは通常、Reactの状態とコンテキストに依存し、アプリケーションのルートで必要とされます。 [サードパーティのコンテキストプロバイダについて詳しく学ぶ](#using-context-providers)。

#### コンテキストプロバイダを使用する {#using-context-providers}

コンテキストプロバイダは、通常、現在のテーマなどのグローバル問題を共有するためにアプリケーションのルート近くにレンダリングされます。 [Reactコンテキスト](https://react.dev/learn/passing-data-deeply-with-context)はServer Componentではサポートされていないため、アプリケーションのルートでコンテキストを作成しようとするとエラーが発生します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import { createContext } from 'react'

//  createContext is not supported in Server Components
export const ThemeContext = createContext({})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import { createContext } from 'react'

//  createContext is not supported in Server Components
export const ThemeContext = createContext({})

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

これを修正するには、コンテキストを作成し、そのプロバイダをClient Component内でレンダリングします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/theme-provider.tsx" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode
}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/theme-provider.js" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
</Tabs>

Server Componentは、Client Componentとしてマークされたプロバイダを直接レンダリングできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

プロバイダをルートにレンダリングすることで、アプリ内の他のすべてのClient Componentがこのコンテキストを消費できます。

> **Good to know**: プロバイダはできるだけtreeの奥深くにレンダリングするべきです。`ThemeProvider`が`{children}`をwrapしていて、`<html>`ドキュメント全体をwrapしていないことに注意してください。これにより、Next.jsがServer Componentの静的な部分を最適化しやすくなります。

### ライブラリアーサーへのアドバイス {#advice-for-library-authors}

同様に、他の開発者が消費するパッケージを作成するライブラリアーサは、パッケージのクライアントエントリポイントをマークするために`"use client"`ディレクティブを使用できます。これにより、パッケージユーザーはラップバウンダリを作成せずに、Server Componentにパッケージコンポーネントを直接インポートできます。

パッケージを最適化するために、[`"use client"`をtreeの詳細を指定すると](#moving-client-components-down-the-tree)、インポートされたモジュールがServer Componentのモジュールグラフの一部になるようにします。

一部のバンドラは`"use client"`ディレクティブを取り除くことがあることに注意してください。`React Wrap Balancer`と`Vercel Analytics`リポジトリで `"use client"` 指令を含めるようにesbuildを構成する例を確認できます。

## Client Component {#client-components}

### クライアントコンポーネントをツリーの下に移動する {#moving-client-components-down-the-tree}

クライアントJavaScriptバンドルサイズを削減するために、Client Componentをコンポーネントツリーの下に移動することをお勧めします。

たとえば、レイアウトには静的要素（例: ロゴ、リンクなど）があり、状態を使用するインタラクティブな検索バーがあることがあります。

レイアウト全体をClient Componentにするのではなく、インタラクティブなロジックをClient Component（例: `<SearchBar />`）に移動し、レイアウトをServer Componentとして保持します。これにより、レイアウトのすべてのコンポーネントJavaScriptをクライアントに送信する必要がなくなります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
// SearchBarはClient Componentです
import SearchBar from './searchbar'
// LogoはServer Componentです
import Logo from './logo'

// LayoutはデフォルトでServer Componentです
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
// SearchBarはClient Componentです
import SearchBar from './searchbar'
// LogoはServer Componentです
import Logo from './logo'

// LayoutはデフォルトでServer Componentです
export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
</Tabs>

### ServerからClient Componentsへのpropsの渡し（シリアル化） {#passing-props-from-server-to-client-components-serialization}

Server Componentでデータを取得した場合、そのデータをClient Componentにpropsとして渡したいことがあります。ServerからClient Componentに渡されるpropsはReactによって[シリアライズ可能](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)である必要があります。

Client Componentがシリアライズできないデータに依存する場合、[サードパーティライブラリを使用してクライアントでデータを取得する](/docs/app/building-your-application/data-fetching/fetching#fetching-data-on-the-client)か、[Route Handler](/docs/app/building-your-application/routing/route-handlers)でサーバー上でデータを取得することができます。

## ServerとClient Componentsの織り交ぜ {#interleaving-server-and-client-components}

Client ComponentとServer Componentを織り交ぜる際に、UIをコンポーネントのtreeとして視覚化することが役立ちます。 [rootレイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)、これはServer Componentです、から始めて、 `"use client"`ディレクティブを追加することで、クライアント上でコンポーネントの特定のsubtreeをレンダリングすることができます。

{/* 図：織り交ぜ */}

そのクライアントのsubtree内に、依然としてServer ComponentをネストしたりServer Actionsを呼び出すことができますが、いくつか注意点があります。

- リクエストとレスポンスのライフサイクル中に、コードはサーバーからクライアントに移動します。クライアント上でサーバーのデータやリソースにアクセスする必要がある場合、新たに**サーバーにリクエスト**をすることになります - サーバーとクライアントを行ったり来たりするのではありません。
- 新しいリクエストがサーバーに行われると、すべてのServer Componentが最初にレンダリングされます。これにはClient Component内にネストされているものも含まれます。レンダリングの結果（[RSC Payload](/docs/app/building-your-application/rendering/server-components#what-is-the-react-server-component-payload-rsc)）には、Client Componentの場所への参照が含まれます。その後、クライアント側で、ReactはRSC Payloadを使用してServerとClient Componentsを単一のツリーに精製します。

{/* 図 */}

- Client ComponentはServer Componentの後にレンダリングされるため、Client ComponentモジュールにServer Componentをインポートすることはできません（サーバーへの新しいリクエストが必要になるため）。代わりに、Server ComponentをClient Componentに`props`として渡すことができます。次の[非サポートパターン](#unsupported-pattern-importing-server-components-into-client-components)と[サポートパターン](#supported-pattern-passing-server-components-to-client-components-as-props)を参照してください。

### サポートされていないパターン: Client ComponentにServer Componentをインポートする {#unsupported-pattern-importing-server-components-into-client-components}

次のパターンはサポートされていません。Client ComponentにServer Componentをインポートすることはできません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={3,4,17}
'use client'

// Client ComponentにServer Componentをインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={3,13}
'use client'

// Client ComponentにServer Componentをインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
</Tabs>

### サポートされるパターン: Server ComponentをClient Componentにpropsとして渡す {#supported-pattern-passing-server-components-to-client-components-as-props}

以下のパターンはサポートされています。Server ComponentをClient Componentにpropとして渡すことができます。

一般的なパターンとして、Reactの`children` propを使用してClient Componentに*"スロット"*を作成します。

以下の例では、`<ClientComponent>`は`children` propを受け取ります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={6,15}
'use client'

import { useState } from 'react'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={5,12}
'use client'

import { useState } from 'react'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      {children}
    </>
  )
}
```

</TabItem>
</Tabs>

`<ClientComponent>`は、`children`が最終的にServer Componentの結果で埋められることを知りません。 `<ClientComponent>`の唯一の責任は、`children`が最終的にどこに配置されるかを決定することです。

親Server Componentでは、`<ClientComponent>`と`<ServerComponent>`の両方をインポートして、`<ServerComponent>`を`<ClientComponent>`の子として渡すことができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" highlight={11} switcher
// このパターンは動作します：
// Server ComponentをClient Componentの子またはプロップとして渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.jsのページはデフォルトでServer Componentです
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" highlight={11} switcher
// このパターンは動作します：
// Server ComponentをClient Componentの子またはプロップとして渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.jsのページはデフォルトでServer Componentです
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
</Tabs>

このアプローチでは、`<ClientComponent>`と`<ServerComponent>`は分離され、独立してレンダリングできます。この場合、子の`<ServerComponent>`は、`<ClientComponent>`がクライアントでレンダリングされるずっと前にサーバー上でレンダリングできます。

> **Good to know:**
>
> - "コンテンツを持ち上げる"というパターンは、親コンポーネントが再レンダリングされたときにネストされた子コンポーネントを再レンダリングしないために使用されてきました。
> - `children` propに限定されているわけではありません。JSXを渡すために任意のpropを使用できます。
