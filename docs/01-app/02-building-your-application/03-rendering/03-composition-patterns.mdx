---
title: 'Server と Client の構成パターン'
nav_title: '構成パターン'
description: 'Server と Client Components を使用するための推奨パターン。'
---

React アプリケーションを構築する際には、アプリケーションのどの部分をサーバーまたはクライアントでレンダリングすべきかを検討する必要があります。ここでは、Server と Client Components を使用する際の推奨される構成パターンについて説明します。

## Server と Client Components をいつ使用するか？ {#when-to-use-server-and-client-components}

Server と Client Components 用途の要約は次のとおりです：

| 何をする必要がありますか？                                                                   | Server Component    | Client Component    |
| -------------------------------------------------------------------------------------------- | ------------------- | ------------------- |
| データをフェッチする                                                                         | <Check size={18} /> | <Cross size={18} /> |
| バックエンドリソースに直接アクセス                                                           | <Check size={18} /> | <Cross size={18} /> |
| 機密情報をサーバーに保存（アクセストークン、API キーなど）                                   | <Check size={18} /> | <Cross size={18} /> |
| 大きな依存関係をサーバーに保持 / クライアント側の JavaScript を削減                          | <Check size={18} /> | <Cross size={18} /> |
| インタラクティビティとイベントリスナーを追加（`onClick()`, `onChange()` など）               | <Cross size={18} /> | <Check size={18} /> |
| 状態とライフサイクルエフェクトを使用する（`useState()`, `useReducer()`, `useEffect()` など） | <Cross size={18} /> | <Check size={18} /> |
| ブラウザ専用 API を使う                                                                      | <Cross size={18} /> | <Check size={18} /> |
| 状態、エフェクト、またはブラウザ専用 API に依存するカスタムフックを使用する                  | <Cross size={18} /> | <Check size={18} /> |
| [React クラスコンポーネント](https://react.dev/reference/react/Component) を使用する         | <Cross size={18} /> | <Check size={18} /> |

## サーバーコンポーネントのパターン {#server-component-patterns}

クライアントサイドのレンダリングを選択する前に、データのフェッチやデータベースやバックエンドサービスへのアクセスなど、サーバーでの作業を行いたい場合があります。

ここでは、サーバーコンポーネントで作業する際の一般的なパターンをいくつか紹介します：

### コンポーネント間でデータを共有する {#sharing-data-between-components}

サーバーでデータをフェッチする際には、異なるコンポーネント間でデータを共有する必要がある場合があります。たとえば、レイアウトとページが同じデータに依存している場合です。

[React Context](https://react.dev/learn/passing-data-deeply-with-context)（サーバーでは使用できない）を使用したり、データを props として渡したりする代わりに、`fetch` や React の `cache` 関数を使用して、必要なコンポーネントで同じデータを取得できます。この場合、重複したデータリクエストを心配することなく取得できます。この理由は、React が `fetch` を拡張してデータリクエストを自動的にメモ化し、`fetch` が利用できない場合に `cache` 関数を使用できるためです。

このパターンの[例を見る](/docs/app/building-your-application/data-fetching/fetching#reusing-data-across-multiple-functions)。

### サーバー専用コードをクライアント環境から排除する {#keeping-server-only-code-out-of-the-client-environment}

JavaScript のモジュールは、Server コンポーネントと Client コンポーネントモジュールの両方で共有できるため、サーバー上でのみ実行することを意図していたコードがクライアントに混入する可能性があります。

例えば、以下のデータフェッチ機能を考えてみましょう：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="lib/data.ts" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="lib/data.js" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

</TabItem>
</Tabs>

一見すると、`getData` はサーバーとクライアントの両方で動作しているように見えます。しかし、この関数には `API_KEY` が含まれ、これはサーバー上でのみ実行されることを意図しています。

環境変数 `API_KEY` は `NEXT_PUBLIC` でプレフィックスされていないため、サーバーでのみアクセス可能なプライベート変数です。環境変数がクライアントに漏れないようにするために、Next.js はプライベート環境変数を空の文字列で置き換えます。

その結果、`getData()` はクライアント上でインポートおよび実行できますが、期待どおりに動作しません。そして、変数を公開することでその関数がクライアントで動作するようにすることはできますが、クライアントに機密情報を公開することは望まないかもしれません。

このようなサーバーコードの意図しないクライアントでの使用を防ぐために、`server-only` パッケージを使用して、他の開発者がこれらのモジュールを Client Component に誤ってインポートした場合にビルドタイムエラーを発生させることができます。

`server-only` を使用するには、まずパッケージをインストールします：

```bash title="Terminal"
npm install server-only
```

次に、サーバー専用コードを含む任意のモジュールにパッケージをインポートします：

```js title="lib/data.js"
import 'server-only'

export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

これで、`getData()` をインポートする Client Component は、このモジュールがサーバー上でのみ使用できることを説明するビルドタイムエラーを受け取ります。

対応するパッケージ `client-only` は、たとえば `window` オブジェクトにアクセスするコードのようなクライアント専用のコードを含むモジュールをマークするために使用できます。

### サードパーティパッケージとプロバイダーの使用 {#using-third-party-packages-and-providers}

Server コンポーネントは新しい React の機能であるため、エコシステムのサードパーティパッケージやプロバイダーは、`useState`、`useEffect`、`createContext` などのクライアント専用機能を使用するコンポーネントに `"use client"` ディレクティブを追加し始めています。

現在、多くの `npm` パッケージのクライアント専用機能を使用するコンポーネントはまだディレクティブを持っていません。これらのサードパーティコンポーネントは、クライアントコンポーネント内で期待どおりに機能しますが、サーバーコンポーネント内では動作しません。

たとえば、`useState` を使用しているが、まだ `"use client"` ディレクティブを持っていない `<Carousel />` コンポーネントを持つ仮の `acme-carousel` パッケージをインストールしたとしましょう。

クライアントコンポーネント内で `<Carousel />` を使用すると、期待どおりに動作します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/gallery.tsx" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* クライアントコンポーネント内で使用しているため機能します */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/gallery.js" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* クライアントコンポーネント内で使用しているため機能します */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
</Tabs>

しかし、サーバーコンポーネント内で直接使用しようとすると、エラーが表示されます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* エラー: `useState` はサーバーコンポーネント内で使用できません */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* エラー: `useState` はサーバーコンポーネント内で使用できません */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

これは Next.js が `<Carousel />` がクライアント専用の機能を使用していることを知らないためです。

これを修正するには、クライアント専用機能に依存するサードパーティコンポーネントを独自のクライアントコンポーネントでラップします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/carousel.tsx" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/carousel.js" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
</Tabs>

これで、サーバーコンポーネント内で `<Carousel />` を直接使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* クライアントコンポーネントであるため機能します */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* クライアントコンポーネントであるため機能します */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

ほとんどのサードパーティコンポーネントをラップする必要はないと予想していますが、例外はプロバイダーです。プロバイダーは React の状態とコンテキストに依存しており、通常アプリケーションの root で必要です。サードパーティのコンテキストプロバイダーについては[さらに詳しく学ぶ](#using-context-providers)。

#### コンテキストプロバイダーの使用 {#using-context-providers}

コンテキストプロバイダーは、アプリケーションの root 近くで、現在のテーマなどのグローバルな問題を共有するためにレンダリングされることがよくあります。[React コンテキスト](https://react.dev/learn/passing-data-deeply-with-context) はサーバーコンポーネントではサポートされていないため、アプリケーションの root でコンテキストを作成しようとするとエラーが発生します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import { createContext } from 'react'

// createContext はサーバーコンポーネントではサポートされていません
export const ThemeContext = createContext({})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import { createContext } from 'react'

// createContext はサーバーコンポーネントではサポートされていません
export const ThemeContext = createContext({})

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

これを修正するには、クライアントコンポーネント内でコンテキストを作成し、そのプロバイダーをレンダリングします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/theme-provider.tsx" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode
}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/theme-provider.js" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
</Tabs>

サーバーコンポーネントは、クライアントコンポーネントとしてマークされたプロバイダーを直接レンダリングできるようになります：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

プロバイダーは root にレンダリングされるため、アプリ全体の他のクライアントコンポーネントはこのコンテキストを消費できます。

> **Good to know**: プロバイダーは tree の中できるだけ深くレンダリングするべきです。`ThemeProvider` が `{children}` のみをラップし、`<html>` 全体をラップしていないことに注意してください。これにより、Next.js がサーバーコンポーネントの静的部分を最適化しやすくなります。

#### ライブラリ作者へのアドバイス {#advice-for-library-authors}

同様に、他の開発者が使用するためのパッケージを作成するライブラリの作者は、`"use client"` ディレクティブを使用してパッケージのクライアントエントリポイントをマークすることができます。これにより、パッケージのユーザーは、ラッピング境界を作成することなく、サーバーコンポーネントにパッケージコンポーネントを直接インポートできます。

インポートされたモジュールをサーバーコンポーネントのモジュールグラフの一部にするために、package 内で 'use client' を [tree の奥深くに移動させる](#moving-client-components-down-the-tree) ことによってパッケージを最適化できるでしょう。

一部のバンドラーは `"use client"` の指令を除去するかもしれません。[React Wrap Balancer](https://github.com/shuding/react-wrap-balancer/blob/main/tsup.config.ts#L10-L13) や [Vercel Analytics](https://github.com/vercel/analytics/blob/main/packages/web/tsup.config.js#L26-L30) のリポジトリで、`esbuild` を `"use client"` 指令を含めるように設定する例を見ることができます。

## クライアントコンポーネント {#client-components}

### クライアントコンポーネントを tree の奥深くに移動 {#moving-client-components-down-the-tree}

クライアント JavaScript バンドルのサイズを削減するために、クライアントコンポーネントをコンポーネント tree の奥深くに移動することをお勧めします。

たとえば、静的な要素（ロゴやリンクなど）を持ち、状態を使用しているインタラクティブな検索バーがあるレイアウトがあるかもしれません。

レイアウト全体をクライアントコンポーネントにする代わりに、インタラクティブなロジックをクライアントコンポーネント（例：`<SearchBar />`）に移動し、レイアウトをサーバーコンポーネントとして保持します。これにより、レイアウトのすべてのコンポーネント JavaScript をクライアントに送信する必要がなくなります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
// SearchBarはクライアントコンポーネントです
import SearchBar from './searchbar'
// Logoはサーバーコンポーネントです
import Logo from './logo'

// Layoutはデフォルトでサーバーコンポーネントです
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
// SearchBar はクライアントコンポーネントです
import SearchBar from './searchbar'
// Logo はサーバーコンポーネントです
import Logo from './logo'

// Layout はデフォルトでサーバーコンポーネントです
export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
</Tabs>

### Server から Client Components への props の受け渡し（シリアル化） {#passing-props-from-server-to-client-components-serialization}

サーバーコンポーネントでデータを取得した場合、データを props としてクライアントコンポーネントに渡すことができます。Server から Client Components に渡される props は React によって [シリアル化可能](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values) である必要があります。

クライアントコンポーネントがシリアル化されていないデータに依存している場合、[サードパーティのライブラリを使用してクライアントでデータを取得](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching#fetching-data-on-the-client)するか、[Route Handler](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)でサーバーでフェッチすることが可能です。

## Server と Client Components の組み合わせ {#interleaving-server-and-client-components}

Client と Server Components を組み合わせる際、UI をコンポーネントの tree として視覚化すると役立ちます。[root レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)（サーバーコンポーネント）から始めて、`"use client"` 指令を追加することにより、コンポーネントの特定のサブ tree をクライアントでレンダリングできます。

{/* 図 - インターレイビング */}

そのクライアントサブ tree 内で、依然としてサーバーコンポーネントをネストしたり、サーバーアクションを呼び出したりすることができますが、以下の点に留意してください：

- リクエスト-レスポンスライフサイクル中、コードはサーバーからクライアントに移動します。クライアント上でサーバー上のデータやリソースにアクセスする必要がある場合、サーバーへの**新しい**リクエストを行うことになります - 行ったり来たりすることはありません。
- 新しいリクエストがサーバーに送信されると、全てのサーバーコンポーネントが最初にレンダリングされます。その中には、クライアントコンポーネント内にネストされているものも含まれます。レンダリングの結果（[RSC Payload](/docs/app/building-your-application/rendering/server-components#what-is-the-react-server-component-payload-rsc)）には、クライアントコンポーネントの位置への参照が含まれます。次に、クライアントで、React は RSC ペイロードを使用して、サーバーコンポーネントとクライアントコンポーネントを一つの tree に統合します。

{/* 図 */}

- Client Components はサーバーコンポーネントの後にレンダリングされるため、クライアントコンポーネントモジュールにサーバーコンポーネントをインポートすることはできません（新たなリクエストを再びサーバーに送り返す必要があるため）。代わりに、Server コンポーネントを Client Component の `props` として渡すことができます。以下の[非推奨のパターン](#unsupported-pattern-importing-server-components-into-client-components)と[サポートされているパターン](#supported-pattern-passing-server-components-to-client-components-as-props)を参照してください。

### 非サポートパターン：Server コンポーネントをクライアントコンポーネントにインポート {#unsupported-pattern-importing-server-components-into-client-components}

以下のパターンはサポートされていません。Server コンポーネントを Client コンポーネントにインポートすることはできません：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={3,4,17}
'use client'

// Server コンポーネントを Client コンポーネントにインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={3,13}
'use client'

// Server コンポーネントを Client コンポーネントにインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
</Tabs>

### サポートされているパターン：Server コンポーネントをクライアントコンポーネントに props として渡すこと {#supported-pattern-passing-server-components-to-client-components-as-props}

次のパターンはサポートされています。サーバーコンポーネントをクライアントコンポーネントの prop として渡すことができます。

よくあるパターンとして、React の `children` prop を使用してクライアントコンポーネント内でスロットを作成する方法があります。

以下の例では、`<ClientComponent>` は `children` prop を受け入れます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={6,15}
'use client'

import { useState } from 'react'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={5,12}
'use client'

import { useState } from 'react'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      {children}
    </>
  )
}
```

</TabItem>
</Tabs>

`<ClientComponent>` は `children` が最終的にサーバーコンポーネントの結果によって埋められることを知りません。`<ClientComponent>` の唯一の責任は、`children` が最終的に**どこに**配置されるかを決定することです。

親のサーバーコンポーネントで、`<ClientComponent>` と `<ServerComponent>` の両方をインポートし、`<ServerComponent>` を `<ClientComponent>` の子として渡すことができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" highlight={11} switcher
// このパターンは機能します：
// サーバーコンポーネントをクライアントコンポーネントの子や prop として渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.js のページはデフォルトでサーバーコンポーネントです
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" highlight={11} switcher
// このパターンは機能します：
// サーバーコンポーネントをクライアントコンポーネントの子や prop として渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.js のページはデフォルトでサーバーコンポーネントです
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
</Tabs>

このアプローチを使用すると、`<ClientComponent>` と `<ServerComponent>` がデカップルされ、独立してレンダリングされることが可能です。このケースでは、子の `<ServerComponent>` はサーバーにレンダリングすることが可能で、`<ClientComponent>` がクライアントにレンダリングされるはるか前に行われます。

> **Good to know:**
>
> - 親コンポーネントが再レンダリングされるときにネストされた子コンポーネントを再レンダリングすることを避けるために、「コンテンツを上に持ち上げる」パターンが使用されてきました。
> - `children` prop に限定されません。任意の prop を使用して JSX を渡すことができます。
