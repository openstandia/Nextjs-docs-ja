---
title: 'Server と Client の構成パターン'
nav_title: '構成パターン'
description: 'Server and Client Components の使用に関する推奨パターン。'
---

React アプリケーションを構築する際には、アプリケーションのどの部分をサーバーでレンダリングするのか、またはクライアントでレンダリングするのかを考慮する必要があります。このページでは、Server と Client Components を使用する際の推奨構成パターンを紹介します。

## Server と Client Components を使用するタイミング {#when-to-use-server-and-client-components}

Server と Client Components のさまざまな使用ケースについて簡単にまとめました：

| 何をする必要がありますか？                                                                 | Server Component    | Client Component    |
| ------------------------------------------------------------------------------------------ | ------------------- | ------------------- |
| データを取得する                                                                           | <Check size={18} /> | <Cross size={18} /> |
| バックエンドのリソースに直接アクセスする                                                   | <Check size={18} /> | <Cross size={18} /> |
| 機密情報をサーバー上に保持する（アクセストークン、API キーなど）                           | <Check size={18} /> | <Cross size={18} /> |
| 大きな依存関係をサーバーに保持する / クライアント側の JavaScript を削減する                | <Check size={18} /> | <Cross size={18} /> |
| インタラクティブ性とイベントリスナーを追加する (`onClick()`, `onChange()`など)             | <Cross size={18} /> | <Check size={18} /> |
| 状態とライフサイクルエフェクトを使用する (`useState()`, `useReducer()`, `useEffect()`など) | <Cross size={18} /> | <Check size={18} /> |
| ブラウザ専用の API を使用する                                                              | <Cross size={18} /> | <Check size={18} /> |
| 状態やエフェクト、ブラウザ専用 API に依存するカスタムフックを使用する                      | <Cross size={18} /> | <Check size={18} /> |
| [React Class components](https://react.dev/reference/react/Component) を使用する           | <Cross size={18} /> | <Check size={18} /> |

## Server Component のパターン {#server-component-patterns}

クライアントサイドのレンダリングを選択する前に、データの取得、データベースやバックエンドサービスへのアクセスなど、サーバー上で作業を行うことを検討するかもしれません。

Server Components を使用するときの一般的なパターンをいくつか紹介します：

### コンポーネント間でデータを共有する {#sharing-data-between-components}

サーバーでデータを取得する際に、異なるコンポーネント間でデータを共有する必要がある場合があります。たとえば、同じデータに依存するレイアウトとページがあるかもしれません。

[React Context](https://react.dev/learn/passing-data-deeply-with-context)（サーバーでは使用できません）や props としてデータを渡す代わりに、`fetch` や React の `cache` 関数を使用して、データを必要とするコンポーネントで同じデータを取得することができます。これにより、同じデータに対して重複したリクエストを心配することなく、React が `fetch` を拡張してデータリクエストを自動的にメモ化し、`fetch` が利用できない場合には `cache` 関数を使用できます。

このパターンの例は [こちら](/docs/app/building-your-application/data-fetching/fetching#reusing-data-across-multiple-functions) でご覧ください。

### サーバ専用コードをクライアント環境から除外する {#keeping-server-only-code-out-of-the-client-environment}

JavaScript モジュールは Server と Client の両方の Components モジュール間で共有できるため、本来サーバー上でのみ実行されるべきコードがクライアントに紛れ込む可能性があります。

例として、次のデータ取得関数をご覧ください：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="lib/data.ts" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    // 環境変数からの API キーを使用して、リクエストを送信します
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json() // レスポンスを JSON に変換して返します
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="lib/data.js" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    // 環境変数からの API キーを使用して、リクエストを送信します
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json() // レスポンスを JSON に変換して返します
}
```

</TabItem>
</Tabs>

一見すると、`getData` がサーバーとクライアントの両方で動作するように見えます。しかし、この関数はサーバー上でのみ実行されることを意図した `API_KEY` を含んでいます。

環境変数 `API_KEY` は `NEXT_PUBLIC` で始まっていないため、サーバー上でのみアクセスできるプライベート変数です。環境変数がクライアントに漏れないように、Next.js はプライベート環境変数を空文字列に置き換えます。

その結果、`getData()` はクライアントでインポートして実行できますが、期待どおりには動作しません。そして、変数を公開することでクライアントで関数が動作するようになりますが、クライアントに機密情報を公開したくないかもしれません。

このような意図しないサーバーコードのクライアント使用を防ぐために、`server-only` パッケージを使用して、こうしたモジュールを Client Component に誤ってインポートした際に、他の開発者にビルド時エラーを発生させることができます。

`server-only` を使用するには、まずパッケージをインストールします：

```bash title="Terminal"
npm install server-only
```

次に、サーバ専用のコードが含まれるモジュールにパッケージをインポートします：

```js title="lib/data.js"
import 'server-only'

export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    // 環境変数からの API キーを使用して、リクエストを送信します
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json() // レスポンスを JSON に変換して返します
}
```

これで、`getData()` をインポートする Client Component は、このモジュールがサーバー上でのみ使用できる旨のビルド時エラーを受け取ります。

逆に、クライアント専用のコードが含まれるモジュールをマークするには、`client-only` パッケージを使用できます。たとえば、`window` オブジェクトにアクセスするコードなどです。

### サードパーティのパッケージやプロバイダーを使用する {#using-third-party-packages-and-providers}

Server Components は新しい React の機能であるため、クライアント専用の機能（`useState`、`useEffect`、`createContext`）を使用するコンポーネントに `"use client"` 指令を追加するサードパーティのパッケージやプロバイダーがエコシステムに登場し始めています。

今日、多くのサードパーティの `npm` パッケージのコンポーネントは、クライアント専用の機能を使用していても指令がまだ含まれていません。これらのサードパーティコンポーネントは Client Components 内で期待どおり動作しますが、サーバーコンポーネント内では動作しません。

例えば、まだ `"use client"` 指令を持たない `acme-carousel` というパッケージの `<Carousel />` コンポーネントがあるとします。このコンポーネントは `useState` を使用していますが、`"use client"` 指令を持っていません。

Client Component 内で `<Carousel />` を使用する場合、期待どおりに動作します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/gallery.tsx" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* Client Component 内で使用するため動作します */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/gallery.js" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* Client Component 内で使用するため動作します */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
</Tabs>

しかし、Server Component 内で直接使用しようとすると、エラーが発生します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* エラー：Server Component 内では `useState` を使用できません */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* エラー：Server Component 内では `useState` を使用できません */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

これは、Next.js が `<Carousel />` がクライアント専用機能を使用していることを知らないためです。

これを修正するには、クライアント専用機能に依存するサードパーティのコンポーネントを自分の Client Components でラップします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/carousel.tsx" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/carousel.js" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
</Tabs>

これで、Server Component 内で直接 `<Carousel />` を使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* Client Component であるため動作します */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* Client Component であるため動作します */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

多くのサードパーティのコンポーネントをラップする必要がないことを期待しています。なぜなら、それらは Client Components 内で使用される可能性が高いからです。ただし、例外となるのはプロバイダーで、それらは React の状態とコンテキストに依存し、通常アプリケーションの root に必要とされます。[サードパーティのコンテキストプロバイダーについては以下をご覧ください](#using-context-providers)。

#### コンテキストプロバイダーの使用 {#using-context-providers}

コンテキストプロバイダーは、現在のテーマのようなグローバルな関心事を共有するために、アプリケーションの root 付近でレンダリングされるのが一般的です。[React コンテキスト](https://react.dev/learn/passing-data-deeply-with-context) は Server Components でサポートされていないため、アプリケーションの root でコンテキストを作成しようとするとエラーが発生します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import { createContext } from 'react'

// Server Components では createContext はサポートされていません
export const ThemeContext = createContext({})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import { createContext } from 'react'

// Server Components では createContext はサポートされていません
export const ThemeContext = createContext({})

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

これを修正するには、クライアントコンポーネント内でコンテキストを作成し、そのプロバイダーをレンダリングします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/theme-provider.tsx" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode
}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/theme-provider.js" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
</Tabs>

Server Component は、プロバイダーが Client Component としてマークされているため、プロバイダーを直接レンダリングできるようになります：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

プロバイダーが root にレンダリングされた状態で、アプリ内の他の全ての Client Components はこのコンテキストを消費できるようになります。

> **Good to know**: プロバイダーはツリー内でできるだけ深くレンダリングするべきです - `ThemeProvider` が `<html>` ドキュメント全体ではなく `{children}` のみを囲んでいることに注目してください。これにより、Next.js が Server Components の静的な部分を最適化しやすくなります。

#### ライブラリ作者へのアドバイス {#advice-for-library-authors}

同様に、他の開発者が消費するパッケージを作成するライブラリ作者は、`"use client"` 指令を使用して、パッケージのクライアントエントリポイントをマークできます。これにより、利用者はパッケージコンポーネントを Server Components に直接インポートし、ラッピング境界を作成する必要がありません。

パッケージを最適化するには、[ツリー内で 'use client' を下の方に移動する](#moving-client-components-down-the-tree)ことを推奨し、インポートされたモジュールを Server Component モジュールグラフの一部にします。

なお、一部のバンドラーは `"use client"` 指令を取り除く可能性があります。esbuild を設定して `"use client"` 指令を含める方法の例は、[React Wrap Balancer](https://github.com/shuding/react-wrap-balancer/blob/main/tsup.config.ts#L10-L13) および [Vercel Analytics](https://github.com/vercel/analytics/blob/main/packages/web/tsup.config.js#L26-L30) リポジトリにあります。

## Client Components {#client-components}

### Client Components をツリーの下部に移動する {#moving-client-components-down-the-tree}

クライアントの JavaScript バンドルサイズを削減するために、Client Components をコンポーネントツリーの下へ移動することをお勧めします。

たとえば、静的要素（ロゴやリンクなど）と、状態を使用するインタラクティブな検索バーを含むレイアウトがあるとします。

レイアウト全体を Client Component にする代わりに、インタラクティブなロジックを Client Component（例：`<SearchBar />`）に移し、レイアウトを Server Component に保ちます。これにより、レイアウトのすべてのコンポーネント JavaScript をクライアントに送信する必要がなくなります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
// SearchBar は Client Component です
import SearchBar from './searchbar'
// Logo は Server Component です
import Logo from './logo'

// Layout はデフォルトで Server Component です
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
// SearchBar は Client Component です
import SearchBar from './searchbar'
// Logo は Server Component です
import Logo from './logo'

// Layout はデフォルトで Server Component です
export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
</Tabs>

### Server から Client Components に props を渡す（シリアライズ） {#passing-props-from-server-to-client-components-serialization}

もしサーバーコンポーネントでデータを取得する場合、そのデータを props として Client Components に渡したいことがあるでしょう。Server から Client Components に渡される prop は React によって[直列化可能](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)である必要があります。

もし Client Components が直列化できないデータに依存している場合は、[サードパーティのライブラリでクライアントでデータを取得](/docs/app/building-your-application/data-fetching/fetching#fetching-data-on-the-client)するか、[Route Handler](/docs/app/building-your-application/routing/route-handlers) を使用してサーバーで取得することができます。

## Server と Client Components のインタリーブ {#interleaving-server-and-client-components}

Client と Server Components をインタリーブする場合、UI をコンポーネントのツリーとして視覚化することが役立つかもしれません。[root レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)を始めとして、これは Server Component であり、`"use client"` 指令を追加することで、コンポーネントの特定のサブツリーをクライアントにレンダリングすることができます。

{/* Diagram - interleaving */}

そのクライアントサブツリー内では、依然として Server Components をネストすることができますが、以下のことに注意が必要です：

- リクエスト・レスポンスライフサイクル中に、コードがサーバーからクライアントに移動します。クライアント上でサーバーのデータやリソースにアクセスする必要がある場合は、新たな**リクエスト**をサーバーに行うことになります - 行き来するのではなく。
- 新たなリクエストがサーバーに行われると、すべての Server Components がまずレンダリングされ、Client Components 内にネストされた Server Components も含まれます。レンダリング結果([RSC Payload](/docs/app/building-your-application/rendering/server-components#what-is-the-react-server-component-payload-rsc)) は Client Components の場所への参照を含みます。その後、クライアントで React は RSC Payload を使用して Server と Client Components を単一のツリーに合わせます。

{/* Diagram */}

- Client Components は、Server Components がレンダリングされた後にレンダリングされるため、Client Component モジュール内で Server Component をインポートすることはできません（新たなリクエストがサーバーに戻ってしまうため）。代わりに、Server Component を props として Client Component に渡すことができます。以下の[サポートされていないパターン](#unsupported-pattern-importing-server-components-into-client-components)と[サポートされているパターン](#supported-pattern-passing-server-components-to-client-components-as-props)を参照してください。

### サポートされていないパターン: Server Components を Client Components にインポートする {#unsupported-pattern-importing-server-components-into-client-components}

次のパターンはサポートされていません。Server Component を Client Component にインポートすることはできません：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={3,4,17}
'use client'

// Server Component を Client Component にインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={3,13}
'use client'

// Server Component を Client Component にインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
</Tabs>

### サポートされているパターン: Server Components を Client Components に props として渡す {#supported-pattern-passing-server-components-to-client-components-as-props}

次のパターンはサポートされています。Server Component を Client Component に prop として渡すことができます。

一般的なパターンとして、React の `children` prop を使用して Client Component に*"スロット"*を作成します。

以下の例で、`<ClientComponent>` は `children` prop を受け取ります：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={6,15}
'use client'

import { useState } from 'react'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={5,12}
'use client'

import { useState } from 'react'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      {children}
    </>
  )
}
```

</TabItem>
</Tabs>

`<ClientComponent>` は `children` が最終的に Server Component の結果で埋められることを知りません。`<ClientComponent>` の唯一の責任は、`children` がどこに配置されるかを決定することです。

親 Server Component では、`<ClientComponent>` と `<ServerComponent>` の両方をインポートし、`<ServerComponent>` を `<ClientComponent>` の子要素として渡せます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" highlight={11} switcher
// このパターンは動作します:
// Server Component は Client Component の子または prop として渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.js のページはデフォルトで Server Components です。
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" highlight={11} switcher
// このパターンは動作します:
// Server Component は Client Component の子または prop として渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.js のページはデフォルトで Server Components です。
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
</Tabs>

このアプローチにより、`<ClientComponent>` と `<ServerComponent>` はデカップリングされ、独立してレンダリングできるようになります。この場合、子の `<ServerComponent>` はクライアントで `<ClientComponent>` がレンダリングされる前にサーバーでレンダリングできます。

> **Good to know:**
>
> - "コンテンツを持ち上げる" というパターンは、親コンポーネントが再レンダリングされたときに子コンポーネントが再レンダリングされるのを避けるために使用されてきました。
> - `children` prop に制限されていません。他の prop を使用して JSX を渡すこともできます。
