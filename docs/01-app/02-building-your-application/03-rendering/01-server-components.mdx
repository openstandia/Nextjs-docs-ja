---
title: 'Server Components'
description: 'React Server Componentsを活用してあなたのアプリケーションの一部をサーバ上でレンダリングする方法を学びましょう。'
related:
  description: 'Next.jsがどのようにデータと静的レンダリングの結果をキャッシュするか学びましょう。'
  links:
    - app/building-your-application/caching
---

React Server Componentsを利用することで、UIをサーバ上でレンダリングし、オプションでキャッシュすることができます。Next.jsでは、ルートセグメントごとにレンダリング作業をさらに分割することで、ストリーミングや部分的なレンダリングを可能にしており、サーバレンダリングには次の3つの戦略があります：

- [Static Rendering](#static-rendering-default)
- [Dynamic Rendering](#dynamic-rendering)
- [Streaming](#streaming)

このページでは、Server Componentsがどのように動作するか、どのような状況で使用されるか、そして様々なサーバレンダリング戦略について説明します。

## サーバレンダリングの利点 {#benefits-of-server-rendering}

サーバでレンダリング作業を行うことにはいくつかの利点があります：

- **データフェッチング**：Server Componentsを使用すると、データフェッチングをデータソースに近いサーバ側に移動できます。これにより、レンダリングに必要なデータをフェッチする時間を短縮し、クライアントが行うリクエストの数を減らすことでパフォーマンスが向上します。
- **セキュリティ**：Server Componentsを使用することで、トークンやAPIキーなどの機密データやロジックをクライアントに露出するリスクなくサーバ側に保つことができます。
- **キャッシング**：サーバでレンダリングすることで、その結果をキャッシュし、次回のリクエスト時や複数のユーザー間で再利用できます。これにより、各リクエストで行われるレンダリングやデータフェッチングの量を削減し、パフォーマンスを向上させ、コストを削減できます。
- **パフォーマンス**：Server Componentsは、パフォーマンスを基盤から最適化するための追加ツールを提供します。例えば、すべてのClient Componentsから構成されたアプリから始めた場合、UIの非対話的な部分をServer Componentsに移行することで、必要なクライアント側のJavaScriptの量を削減できます。これは、インターネットが遅かったり、性能の低いデバイスを使用しているユーザーにとって有益です。ブラウザがダウンロード、解析、実行するクライアント側のJavaScriptの量が少なくなります。
- **初回ページ読み込みと[First Contentful Paint (FCP)](https://web.dev/fcp/)**：サーバでは、ユーザーがページを見ることができるようにHTMLを生成し、クライアントがページをレンダリングするために必要なJavaScriptをダウンロード、解析、実行するのを待つことなく、即座にページを表示できます。
- **検索エンジン最適化とソーシャルネットワークでの共有性**：レンダリングされたHTMLは、検索エンジンのボットによってページをインデックス化するためや、ソーシャルネットワークのボットがページのソーシャルカードプレビューを生成するために使用されます。
- **ストリーミング**：Server Componentsを使用すると、レンダリング作業をチャンクに分割し、それらが準備ができ次第、クライアントにストリーミングすることができます。これにより、ユーザーはページの一部を早いうちに見ることができ、サーバでページ全体がレンダリングされるのを待つ必要がありません。

## Next.jsでのServer Componentsの使用 {#using-server-components-in-next-js}

デフォルトでは、Next.jsはServer Componentsを使用します。これにより、追加の設定なしで自動的にサーバレンダリングを実装でき、必要に応じてClient Componentsを使用することができます。詳細は[Client Components](/docs/app/building-your-application/rendering/client-components)をご覧ください。

## Server Componentsはどのようにレンダリングされるのか？ {#how-are-server-components-rendered}

サーバでは、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントと[サスペンス境界](https://react.dev/reference/react/Suspense)によってチャンクに分割されます。

各チャンクは以下の2段階でレンダリングされます：

1. ReactはServer Componentsを、**React Server Component Payload (RSC Payload)**と呼ばれる特別なデータ形式にレンダリングします。
2. Next.jsはRSC PayloadとClient ComponentのJavaScript命令を使用して、サーバで**HTML**をレンダリングします。

{/* レンダリング図 */}

その後、クライアントでは：

1. HTMLは、非対話的なルートのプレビューを即座に表示するために使用されます。これは初回ページ読み込み時のみのものです。
2. React Server Components Payloadは、クライアントコンポーネントとサーバコンポーネントのtreeを調整し、DOMを更新するために使用されます。
3. JavaScript命令はClient Componentsを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションを対話的にします。

> #### React Server Component Payload (RSC)とは？
>
> RSC Payloadは、レンダリングされたReact Server Componentsのtreeのコンパクトなバイナリ表現です。これは、クライアントのブラウザのDOMを更新するためにReactによって使用されます。RSC Payloadには以下が含まれます：
>
> - Server Componentsのレンダリング結果
> - Client Componentsがレンダリングされるべき場所のプレースホルダーと、そのJavaScriptファイルへの参照
> - Server ComponentからClient Componentに渡される任意のprops

## サーバレンダリング戦略 {#server-rendering-strategies}

サーバレンダリングには3つのサブセットがあります：静的、動的、ストリーミングレンダリング。

### 静的レンダリング（デフォルト） {#static-rendering-default}

静的レンダリングでは、ルートは**ビルド時**または[データ再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)の後にバックグラウンドでレンダリングされます。その結果はキャッシュされ、[コンテンツデリバリネットワーク（CDN）](https://developer.mozilla.org/docs/Glossary/CDN)にプッシュされることがあります。この最適化により、レンダリング作業の結果をユーザー間やサーバリクエスト間で共有することができます。

静的レンダリングは、ユーザーにパーソナライズされておらず、ビルド時に既知であるデータを持つルート（例えば、静的なブログ記事や商品ページ）に有用です。

### 動的レンダリング {#dynamic-rendering}

動的レンダリングでは、ルートはユーザーごとに**リクエスト時**にレンダリングされます。

動的レンダリングは、ユーザーにパーソナライズされたデータを持つルートや、リクエスト時にしか知らない情報（クッキーやURLの検索パラメータなど）を持つルートに有用です。

> **キャッシュされたデータを持つ動的ルート**
>
> ほとんどのウェブサイトでは、ルートは完全に静的でも完全に動的でもありません——スペクトラムです。例えば、キャッシュされた商品データを使用する（一定間隔で再検証される）eコマースページがありつつ、キャッシュされていないパーソナライズされた顧客データも保持しているとします。
>
> Next.jsでは、キャッシュされたデータとキャッシュされていないデータの両方を含む動的にレンダリングされたルートを作成できます。これは、RSC Payloadとデータが別々にキャッシュされるためです。これにより、すべてのデータをリクエスト時にフェッチすることでのパフォーマンスへの影響を心配することなく動的レンダリングを選択することができます。
>
> [full-route cache](/docs/app/building-your-application/caching#full-route-cache)と[Data Cache](/docs/app/building-your-application/caching#data-cache)について詳しく学ぶことができます。

#### 動的レンダリングへの切り替え {#switching-to-dynamic-rendering}

レンダリング中に[Dynamic API](#dynamic-apis)や`{ cache: 'no-store' }`の[fetch](/docs/app/api-reference/functions/fetch)オプションが見つかった場合、Next.jsはルート全体を動的レンダリングするように切り替えます。この表は、Dynamic APIとデータキャッシングがルートが静的または動的にレンダリングされるかどうかにどのように影響するかをまとめたものです：

| Dynamic APIs | Data       | Route                |
| ------------ | ---------- | -------------------- |
| No           | Cached     | Statically Rendered  |
| Yes          | Cached     | Dynamically Rendered |
| No           | Not Cached | Dynamically Rendered |
| Yes          | Not Cached | Dynamically Rendered |

上記の表では、ルートが完全に静的であるためには、すべてのデータがキャッシュされていなければなりません。しかし、キャッシュされたデータフェッチとキャッシュされていないデータフェッチを使用している動的にレンダリングされたルートを持つことができます。

開発者としては、静的レンダリングと動的レンダリングの間で選択する必要はなく、Next.jsが使用されている機能やAPIに基づいて各ルートに最適なレンダリング戦略を自動的に選択します。その代わりに、[データをキャッシュ](/docs/app/building-your-application/data-fetching/fetching)するか、特定のデータを[再検証するか](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)を選択し、UIの一部を[ストリーム](#streaming)することもできます。

### Dynamic API {#dynamic-apis}

Dynamic APIは、事前レンダリング中の先読み段階ではわからないリクエスト時にのみ知られる情報に依存します。これらのAPIを使用することは、開発者の意図を示し、リクエスト時にルート全体を動的レンダリングに移行します。これらのAPIには次のようなものがあります：

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)

### ストリーミング {#streaming}

<Image
  alt="ストリーミング中にルートセグメントが並列化される様子を示す図で、個々のチャンクのデータフェッチ、レンダリング、ハイドレーションを示しています。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

ストリーミングはサーバからのUIの漸進的なレンダリングを可能にします。作業はチャンクに分割され、準備ができ次第クライアントにストリーミングされます。これにより、ユーザーはコンテンツ全体がレンダリングを終了する前にすぐにページの一部を確認することができます。

<Image
  alt="クライアント上で部分的にレンダリングされたページを示す図で、ストリーミングされているチャンクの読み込みUIを表示しています。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

ストリーミングは、デフォルトでNext.jsのApp Routerに組み込まれています。これにより、初回ページ読み込みのパフォーマンスが向上し、ルート全体のレンダリングをブロックする遅いデータフェッチに依存するUIも改善されます。例えば、商品ページのレビューなどです。

`loading.js`とUIコンポーネントを使ってルートセグメントのストリーミングを開始できます。[React Suspense](/docs/app/building-your-application/routing/loading-ui-and-streaming)の詳細は、[Loading UI and Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming)セクションをご覧ください。
