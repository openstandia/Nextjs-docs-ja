---
title: 'Server Components'
description: 'React Server Component を使用して、アプリケーションの一部をサーバーでレンダリングする方法を学ぶ。'
related:
  description: 'Next.js がデータと静的レンダリングの結果をどのようにキャッシュするかを学ぶ。'
  links:
    - app/building-your-application/caching
---

React Server Component により、サーバーでレンダリングされ、オプションでキャッシュされる UI を記述できます。Next.js では、レンダリング作業がルートセグメントによってさらに分割され、ストリーミングおよび部分的なレンダリングを可能にし、3 つの異なるサーバーレンダリング戦略があります；

- [Static Rendering](#static-rendering-default)
- [Dynamic Rendering](#dynamic-rendering)
- [Streaming](#streaming)

このページでは、Server Component の動作、使用する状況、および異なるサーバーレンダリング戦略について説明します。

## サーバーレンダリングの利点 {#benefits-of-server-rendering}

サーバーでレンダリング作業を行うことには、いくつかの利点があります；

- **データ取得**: Server Component を使用すると、データ取得をデータソースに近いサーバーに移動できます。これにより、レンダリングに必要なデータを取得する時間が短縮され、クライアントが行う必要のあるリクエストの数が減少するため、パフォーマンスが向上します。
- **セキュリティ**: Server Component は、トークンや API キーなど、クライアントに公開するリスクなくサーバー上で機密データとロジックを保持できます。
- **キャッシュ**: サーバーでレンダリングすることにより、結果をキャッシュし、後続のリクエストおよびユーザー間で再利用できます。これにより、各リクエストに対するレンダリングとデータ取得の量を減少させ、パフォーマンスを向上させ、コストを削減できます。
- **パフォーマンス**: Server Component は、ベースラインからパフォーマンスを最適化するための追加ツールを提供します。たとえば、完全に Client Component で構成されたアプリから始める場合、UI の対話型でない部分を Server Component に移行することで、必要なクライアントサイド JavaScript の量を減少させることができます。これは、インターネットが遅いユーザーや性能が低いデバイスに役立ちます。このようなユーザーにはダウンロード、解析、実行する必要のあるクライアントサイド JavaScript が減少します。
- **初回ページロードと[First Contentful Paint（FCP）](https://web.dev/fcp/)**: サーバー上で HTML を生成し、ユーザーがクライアントがページをレンダリングするために必要な JavaScript をダウンロード、解析、実行するのを待たずにページを即座に表示できるようにします。
- **検索エンジン最適化とソーシャルネットワーク共有性**: レンダリング済み HTML は、検索エンジンのボットによりページをインデックス化し、ソーシャルネットワークのボットによりページのソーシャルカードプレビューを生成するために使用されます。
- **ストリーミング**: Server Component を使用することで、レンダリング作業をチャンクに分割し、準備ができ次第クライアントにストリーミングできます。これにより、ユーザーはサーバー上でページ全体がレンダリングされるのを待たずにページの一部を早く見ることができます。

## Next.js での Server Component の使用 {#using-server-components-in-next-js}

デフォルトでは、Next.js は Server Component を使用しています。これにより、追加の設定なしで自動的にサーバーレンダリングを実装でき、必要に応じて Client Component を使用することができます。詳細は [Client Components](/docs/app/building-your-application/rendering/client-components) を参照してください。

## Server Component のレンダリング方法 {#how-are-server-components-rendered}

サーバー上で Next.js は、React の API を使用してレンダリングを管理します。レンダリング作業は、個別のルートセグメントと [Suspense Boundaries](https://react.dev/reference/react/Suspense) によってチャンクに分割されます。

各チャンクは 2 ステップでレンダリングされます；

1. React は、Server Component を **React Server Component Payload (RSC Payload)** と呼ばれる特別なデータ形式にレンダリングします。
2. Next.js は RSC Payload と Client Component の JavaScript 命令を使用してサーバー上で **HTML** をレンダリングします。

{/* Rendering Diagram */}

次に、クライアント上では；

1. HTML は、ルートを即座に表示するための高速な非対話型プレビューで使用されます - これは初回ページロードのみに使用されます。
2. React Server Component Payload を使用して、Client および Server Component tree を調整し、DOM を更新します。
3. JavaScript 命令を使用して、Client Component を[ハイドレーション](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションを対話型にします。

> #### React Server Component Payload (RSC) とは？
>
> RSC Payload は、レンダリングされた React Server Component tree のコンパクトなバイナリ表現です。クライアント上の React によってブラウザの DOM を更新するために使用されます。RSC Payload には次のものが含まれます；
>
> - Server Component のレンダリング結果
> - Client Component がレンダリングされるべき場所のプレースホルダと、その JavaScript ファイルの参照
> - Server Component から Client Component に渡される すべてのprops

## サーバーレンダリング戦略 {#server-rendering-strategies}

サーバーレンダリングには、Static, Dynamic, Streaming の3つのサブセットがあります。

### Static Rendering (デフォルト) {#static-rendering-default}

Static Rendering では、ルートが **ビルド時** にレンダリングされるか、[データの再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)後にバックグラウンドでレンダリングされます。結果はキャッシュされ、[コンテンツデリバリネットワーク (CDN)](https://developer.mozilla.org/docs/Glossary/CDN) にプッシュされる可能性があります。この最適化により、レンダリング作業の結果をユーザーおよびサーバーリクエスト間で共有できます。

静的レンダリングは、ルートがユーザーに対して個別化されておらず、ビルド時に既知となるデータを持つ場合に有用です。例えば、静的なブログ投稿や製品ページです。

### Dynamic Rendering {#dynamic-rendering}

Dynamic Rendering では、ルートは **リクエスト時** に各ユーザーに対してレンダリングされます。

動的レンダリングは、ルートがユーザーに対して個別化されたデータを持っている場合や、クッキーや URL の検索パラメータなど、リクエスト時にのみ既知となる情報を持つ場合に有用です。

> **Cached Data を伴った Dynamic Routes**
>
> ほとんどのウェブサイトでは、ルートは完全に静的でも完全に動的でもありません - それはスペクトラムです。たとえば、定期的に再検証されるキャッシュされた製品データを使用する e コマースページがありますが、キャッシュされていない個別化された顧客データもあります。
>
> Next.js では、動的にレンダリングされたルートにはキャッシュされたデータとキャッシュされていないデータの両方が含まれている可能性があります。これは RSC Payload とデータが別々にキャッシュされているためです。これにより、すべてのデータをリクエスト時に取得することによるパフォーマンスの影響を心配することなく、動的レンダリングを選択できます。
>
> [full-route cache](/docs/app/building-your-application/caching#full-route-cache) と [Data Cache](/docs/app/building-your-application/caching#data-cache) についてさらに学びましょう。

#### Dynamic Rendering への切り替え {#switching-to-dynamic-rendering}

レンダリング中に [Dynamic API](#dynamic-apis) および `{ cache: 'no-store' }` の [fetch](/docs/app/api-reference/functions/fetch) オプションが発見された場合、Next.js はそのルート全体を動的にレンダリングするよう切り替えます。以下の表は、Dynamic API とデータキャッシュがルートが静的または動的にレンダリングされるかどうかにどのように影響するかを要約したものです；

| Dynamic APIs | Data       | Route                |
| ------------ | ---------- | -------------------- |
| No           | Cached     | Statically Rendered  |
| Yes          | Cached     | Dynamically Rendered |
| No           | Not Cached | Dynamically Rendered |
| Yes          | Not Cached | Dynamically Rendered |

上の表では、ルートが完全に静的であるためには、すべてのデータがキャッシュされている必要があります。ただし、キャッシュされたデータフェッチとキャッシュされていないデータフェッチの両方を使用する動的にレンダリングされたルートを持つことができます。

開発者としては、Next.js が使用される機能と API に基づいて各ルートに最適なレンダリング戦略を自動的に選択してくれるので、静的と動的レンダリングのどちらかを選ぶ必要はありません。代わりに、[キャッシュ](/docs/app/building-your-application/data-fetching/fetching) する時期や特定のデータを[再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)する時期を選択し、UI の一部を[ストリーミング](#streaming)することもできます。

### Dynamic APIs {#dynamic-apis}

Dynamic API は、リクエスト時にのみ既知である情報（プレンダー時には既知ではない情報）に依存します。これらの API のいずれかを使用することは、開発者の意図を示し、リクエスト時にルート全体を動的レンダリングに選択するシグナルとなります。これらの API には次のものが含まれます；

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)

### Streaming {#streaming}

<Image
  alt="ストリーミング中のルートセグメントの並列化を示す図で、個々のチャンクのデータ取得、レンダリング、およびハイドレーションを示しています。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

Streaming によって、サーバーから UI を逐次レンダリングできます。作業はチャンクに分割され、準備ができ次第クライアントにストリーミングされます。これにより、すべてのコンテンツがレンダリングを終了する前に、ユーザーがページの一部をすぐに見ることができます。

<Image
  alt="クライアント上で部分的にレンダリングされたページを示す図で、ストリーミングされているチャンクのローディング UI があります。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

Streaming はデフォルトで Next.js App Router に組み込まれています。これにより初回ページ読み込みのパフォーマンスの向上、およびルート全体のレンダリングをブロックするような遅いデータ取得に依存する UI のパフォーマンスが向上します。たとえば、製品ページのレビューです。

`loading.js` と UI コンポーネントを使用してルートセグメントのストリーミングを開始し、[React Suspense](/docs/app/building-your-application/routing/loading-ui-and-streaming) を使用できます。[Loading UI and Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming) セクションを参照して詳細を確認してください。
