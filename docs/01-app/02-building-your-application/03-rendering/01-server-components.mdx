---
title: 'Server Components'
description: 'React Server Components を使用して、アプリケーションの一部をサーバーでレンダーおよびキャッシュする方法を学びましょう。'
related:
  description: 'Next.js がデータと静的レンダリングの結果をどのようにキャッシュするかを学びましょう。'
  links:
    - app/building-your-application/caching
---

React Server Components を利用すると、UI をサーバーでレンダーし、オプションでキャッシュすることができます。Next.js では、レンダリング作業がルートセグメントによってさらに分割され、ストリーミングや部分的なレンダリングが可能になります。次の3つのサーバーレンダリング戦略があります：

- [Static Rendering](#static-rendering-default)
- [Dynamic Rendering](#dynamic-rendering)
- [Streaming](#streaming)

このページでは、Server Components がどのように機能するか、それを使用する場面、そして異なるサーバーレンダリング戦略について解説します。

## サーバーレンダリングの利点 {#benefits-of-server-rendering}

サーバーでレンダリング作業を行うことには、いくつかの利点があります；

- **データフェッチング**：Server Components を使用すると、データフェッチングをサーバー、つまりデータソースに近い場所に移動できます。これにより、レンダリングに必要なデータを取得するための時間が短縮され、クライアントが行う必要のあるリクエスト数が削減されるため、パフォーマンスが向上します
- **セキュリティ**：Server Components を利用することで、トークンや API キーなどの機密データやロジックをサーバーに保持し、それらをクライアントに露出させるリスクを避けることができます
- **キャッシング**：サーバーでレンダリングすることで、その結果をキャッシュし、後続のリクエストやユーザー間で再利用できます。これにより、各リクエストでのレンダリングとデータフェッチングの作業量を削減し、パフォーマンスを向上させ、コストを削減することができます
- **パフォーマンス**：Server Components を利用することで、ベースラインからパフォーマンスを最適化するための追加ツールを使用できます。たとえば、すべてが Client Components で構成されたアプリから始め、非対話型部分の UI を Server Components に移動すると、必要なクライアントサイドの JavaScript の量を削減できます。これは、インターネットの速度が遅いユーザーや、性能が低いデバイスのユーザーにとって有益です。なぜなら、ブラウザはダウンロード、解析、実行するクライアントサイドの JavaScript が少なくて済むからです
- **初期ページ読み込みと[First Contentful Paint (FCP)](https://web.dev/fcp/)**：サーバー上で、HTML を生成し、ユーザーがページを直ちに見ることができるようにします。これにより、クライアントがページをレンダリングするために必要な JavaScript をダウンロード、解析、実行するのを待つ必要がなくなります
- **検索エンジン最適化とソーシャルネットワークの共有性**：レンダリングされた HTML は、検索エンジンのボットがページをインデックス付けし、ソーシャルネットワークのボットがページのソーシャルカードプレビューを生成するために使用されます
- **ストリーミング**：Server Components を使用すると、レンダリング作業をチャンクに分け、準備が整うとすぐにクライアントにストリーミングできます。これにより、ユーザーはページの一部を、サーバーでページ全体がレンダリングされるのを待たずに見ることができます

## Next.js での Server Components の使用 {#using-server-components-in-next-js}

Next.js では、デフォルトで Server Components が使用されます。これにより、追加の設定を必要とせず、サーバーレンダリングを自動的に実装でき、必要に応じて Client Components を使用できます。詳細は、[Client Components](/docs/app/building-your-application/rendering/client-components) を参照してください。

## Server Components はどのようにレンダリングされるのか？ {#how-are-server-components-rendered}

サーバー上で、Next.js は React の API を使用してレンダリングを調整します。レンダリング作業は個別のルートセグメントと [Suspense Boundaries](https://react.dev/reference/react/Suspense) によってチャンクに分けられます。

各チャンクは次の2ステップでレンダリングされます：

1. React は Server Components を特別なデータ形式である **React Server Component Payload (RSC Payload)** にレンダリングします。
2. Next.js は RSC Payload と Client Component の JavaScript 命令を使用してサーバー上で **HTML** をレンダリングします。

{/* レンダリング図 */}

次に、クライアント上で：

1. HTML が使用され、ルートの非対話型の高速プレビューを即座に表示します。これは初期ページ読み込みのみに適用されます。
2. React Server Components Payload が使用され、Client Component と Server Component の tree が調整され、DOM が更新されます。
3. JavaScript 命令を使用して、Client Components を[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションを対話可能にします。

> #### React Server Component Payload (RSC) とは？
>
> RSC Payload は、レンダリングされた React Server Components tree のコンパクトなバイナリ表現です。クライアント上の React によってブラウザの DOM を更新するために使用されます。RSC Payload には次のものが含まれます：
>
> - Server Components のレンダリング結果
> - Client Components がレンダリングされるべき場所のプレースホルダーと、その JavaScript ファイルへの参照
> - Server Component から Client Component へ渡されるすべての props

## サーバーレンダリング戦略 {#server-rendering-strategies}

サーバーレンダリングには、Static、Dynamic、Streaming の3つのサブセットがあります。

### Static Rendering (デフォルト) {#static-rendering-default}

Static Rendering では、ルートは **ビルド時**、または[データ再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)後のバックグラウンドでレンダリングされます。その結果はキャッシュされ、[コンテンツデリバリネットワーク (CDN)](https://developer.mozilla.org/docs/Glossary/CDN) に送信できます。この最適化により、ユーザーとサーバーリクエスト間でレンダリング作業の結果を共有できます。

Static rendering は、ユーザーにカスタマイズされていないデータを持ち、ビルド時に既知のデータを持つルート、例えば静的なブログ投稿や製品ページに役立ちます。

### Dynamic Rendering {#dynamic-rendering}

Dynamic Rendering では、ルートは **リクエスト時** に各ユーザーのためにレンダリングされます。

Dynamic rendering は、ユーザーにカスタマイズされたデータを持つルートや、cookie や URL の検索パラメータのようにリクエスト時にのみ知られる情報を持つルートに役立ちます。

> **キャッシュされたデータを持つダイナミックルート**
>
> ほとんどのWebサイトでは、ルートは完全に静的でも完全に動的でもなく、スペクトラム上にあります。たとえば、キャッシュされた製品データを使用し、一定の間隔で再検証を行うeコマースページがありますが、キャッシュされていない、個人化された顧客データも含まれます。
>
> Next.js では、キャッシュされたデータとキャッシュされていないデータの両方を持つ動的にレンダリングされたルートを持つことができます。これは、RSC Payload とデータが個別にキャッシュされるためです。これにより、リクエスト時にすべてのデータを取得することによるパフォーマンスの影響を心配することなく、動的レンダリングを選択できます。
>
> [フルルートキャッシュ](/docs/app/building-your-application/caching#full-route-cache)と[データキャッシュ](/docs/app/building-your-application/caching#data-cache)について詳しく学びましょう。

#### Dynamic Rendering への切り替え {#switching-to-dynamic-rendering}

レンダリング中に、[Dynamic API](#dynamic-apis) または `{ cache: 'no-store' }` オプションの [fetch](/docs/app/api-reference/functions/fetch) が検出された場合、Next.js はルート全体を動的にレンダリングするように切り替えます。このテーブルは、Dynamic API とデータキャッシュがルートが静的にまたは動的にレンダリングされるかどうかにどのように影響するかを要約しています：

| Dynamic APIs | Data       | Route                |
| ------------ | ---------- | -------------------- |
| No           | Cached     | Statically Rendered  |
| Yes          | Cached     | Dynamically Rendered |
| No           | Not Cached | Dynamically Rendered |
| Yes          | Not Cached | Dynamically Rendered |

上記のテーブルでは、ルートが完全に静的であるためには、すべてのデータがキャッシュされている必要があります。ただし、キャッシュされたデータとキャッシュされていないデータのフェッチを使用する動的にレンダリングされたルートを持つことができます。

開発者として、静的と動的のどちらのレンダリングを選択する必要はありません。Next.js は、使用された機能とAPIに基づいて、各ルートに最適なレンダリング戦略を自動的に選択します。代わりに、[キャッシュ](/docs/app/building-your-application/data-fetching/fetching)するタイミングや[特定のデータを再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)するタイミングを選択し、UI の一部を[ストリーミング](#streaming)することを選択できます。

### Dynamic APIs {#dynamic-apis}

Dynamic APIs は、リクエスト時にのみ知られる情報に依存しています（プリレンダリング中には事前に知ることができません）。これらの API を使用することは、開発者の意図を示し、リクエスト時にルート全体を動的レンダリングに切り替えます。これらの API には次のものがあります：

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)

### Streaming {#streaming}

<Image
  alt="ストリーミング中のルートセグメントの並列化を示す図。個々のチャンクのデータフェッチ、レンダリング、およびハイドレーションが示されている。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

Streaming を使用すると、サーバーからの UI の段階的なレンダリングが可能になります。作業はチャンクに分割され、準備が整うとすぐにクライアントにストリーミングされます。これにより、ユーザーはページ全体のコンテンツがレンダリングされる前に、ページの一部を即座に見ることができます。

<Image
  alt="クライアント上で部分的にレンダリングされたページを示す図。ストリーミングされているチャンクのためのローディングUIが表示されている。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

Streaming はデフォルトで Next.js の app router に組み込まれています。これにより、初期ページの読み込みパフォーマンスと、ルート全体のレンダリングをブロックする可能性のある遅いデータフェッチに依存する UI の両方が改善されます。例えば、製品ページのレビューのようなものです。

`loading.js` と UI コンポーネントを使用して、ルートセグメントのストリーミングを開始できます。[React Suspense](/docs/app/building-your-application/routing/loading-ui-and-streaming) を参照してください。[Loading UI and Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming) セクションで詳しく説明しています。
