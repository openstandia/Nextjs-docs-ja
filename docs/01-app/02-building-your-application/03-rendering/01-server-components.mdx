---
title: 'Server Components'
description: 'アプリケーションの一部をサーバーでレンダリングするためのReact Server Componentsの使用方法を学びましょう。'
related:
  description: 'Next.jsがデータと静的レンダリングの結果をどのようにキャッシュするかを学びましょう。'
  links:
    - app/building-your-application/caching
---

React Server Componentsを使用すると、UIをサーバー上でレンダリングし、オプションでキャッシュできます。Next.jsでは、レンダリング作業がルートセグメントによってさらに分割され、ストリーミングと部分的なレンダリングが可能になっています。サーバーレンダリングには以下の3つの戦略があります：

- [Static Rendering](#static-rendering-default)
- [Dynamic Rendering](#dynamic-rendering)
- [Streaming](#streaming)

このページでは、Server Componentsがどのように動作するか、いつ使用するのか、そして異なるサーバーレンダリング戦略について説明します。

## サーバーレンダリングの利点 {#benefits-of-server-rendering}

サーバーでレンダリング作業を行うことにはいくつかの利点があります：

- **データフェッチング**：Server Componentsを使用すると、データフェッチングをサーバーに移動でき、データソースに近づけることができます。これにより、レンダリングに必要なデータのフェッチ時間を短縮し、クライアントが行うリクエストの数を減らせるため、パフォーマンスが向上します。
- **セキュリティ**：Server Componentsを使用すると、トークンやAPIキーなどの機密データとロジックをクライアントに公開することなく、サーバー上に保持できます。
- **キャッシング**：サーバーでレンダリングすることで、その結果をキャッシュし、後続のリクエストや他のユーザーと共有できます。これにより、各リクエストでのレンダリングやデータフェッチングの回数を減らし、パフォーマンスを向上させると共にコストを削減します。
- **パフォーマンス**：Server Componentsを使用することで、パフォーマンスを最適化するための追加のツールを使用できます。たとえば、完全にClient Componentsで構成されたアプリを始め、UIの非インタラクティブな部分をServer Componentsに移すと、クライアントサイドで必要なJavaScriptの量が減少します。これは、遅いインターネットや性能の低いデバイスを使用しているユーザーにとって、ブラウザがダウンロード、解析、実行するクライアントサイドのJavaScriptが減少するため、有益です。
- **初期ページロードと[First Contentful Paint (FCP)](https://web.dev/fcp/)**：サーバー上でHTMLを生成することにより、ユーザーはクライアントがページをレンダリングするために必要なJavaScriptをダウンロード、解析、実行するのを待つことなく、ページをすぐに見ることができます。
- **検索エンジン最適化とソーシャルネットワークでの共有性**：レンダリングされたHTMLを使用して、検索エンジンのボットがページをインデックス化したり、ソーシャルネットワークのボットがページのソーシャルカードプレビューを生成することができます。
- **ストリーミング**：Server Componentsを使用すると、レンダリング作業をチャンクに分割し、それらが準備でき次第クライアントにストリームすることができます。これにより、ユーザーはページ全体がサーバーでレンダリングされるのを待たずに、ページの一部を早く見ることができます。

## Next.jsでのサーバーコンポーネントの使用 {#using-server-components-in-next-js}

デフォルトで、Next.jsはServer Componentsを使用します。これにより、追加の設定なしでサーバーレンダリングを自動的に実装でき、必要に応じてClient Componentsの使用を選択できます。詳しくは[Client Components](/docs/app/building-your-application/rendering/client-components)をご覧ください。

## サーバーコンポーネントはどのようにレンダリングされるか？ {#how-are-server-components-rendered}

サーバーでは、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントと[Suspense Boundaries](https://react.dev/reference/react/Suspense)によってチャンクに分割されます。

それぞれのチャンクは2段階でレンダリングされます：

1. Reactがサーバーコンポーネントを**React Server Component Payload (RSC Payload)**という特別なデータ形式にレンダリングします。
2. Next.jsはRSC PayloadとClient ComponentのJavaScript命令を使用して、サーバー上で**HTML**をレンダリングします。

{/* Rendering Diagram */}

その後、クライアントでは：

1. HTMLを使用して、ルートの迅速な非インタラクティブなプレビューを即座に表示します - これは初期ページロード時のみです。
2. React Server Components Payloadを使用して、Client ComponentとServer Componentのツリーを調整し、DOMを更新します。
3. JavaScriptの指示を使用して、Client Componentsを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにします。

> #### React Server Component Payload (RSC)とは？
>
> RSC Payloadは、レンダリングされたReact Server Componentsツリーのコンパクトなバイナリ表現です。クライアントのReactがブラウザのDOMを更新するのに使用します。RSC Payloadには次のものが含まれています：
>
> - Server Componentsのレンダリング結果
> - Client Componentsをレンダリングすべき場所のプレースホルダーと、それらのJavaScriptファイルへの参照
> - Server ComponentからClient Componentに渡されるprops

## サーバーレンダリング戦略 {#server-rendering-strategies}

サーバーレンダリングには、Static、Dynamic、Streamingという3つのサブセットがあります。

### Static Rendering (デフォルト) {#static-rendering-default}

Static Renderingでは、ルートは**ビルド時**または[データ再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)後のバックグラウンドでレンダリングされます。結果はキャッシュされ、[Content Delivery Network (CDN)](https://developer.mozilla.org/docs/Glossary/CDN)にプッシュすることができます。この最適化により、ユーザとサーバーリクエスト間でレンダリング作業の結果を共有できます。

Static renderingは、ユーザに個別化されていないデータが含まれ、ビルド時に既知であるルートにとって有用です。例えば静的なブログ投稿や商品ページなどです。

### Dynamic Rendering {#dynamic-rendering}

Dynamic Renderingでは、ルートは各ユーザーに対して**リクエスト時**にレンダリングされます。

Dynamic renderingは、ユーザーに個別化されたデータや、リクエスト時にのみ既知である情報（cookieやURLの検索パラメータなど）が含まれるルートにとって有用です。

> **キャッシュされたデータを持つ動的なルート**
>
> ほとんどのウェブサイトでは、ルートは完全に静的でも完全に動的でもありません - スペクトラムです。例えば、間隔ごとに再検証されるキャッシュされた商品データを使用しながら、キャッシュされていない個別化された顧客データも含むeコマースページを持つことができます。
>
> Next.jsでは、キャッシュされたデータとキャッシュされていないデータの両方を持つ動的にレンダリングされたルートを作成することができます。これは、RSC Payloadとデータが別々にキャッシュされるためです。これにより、リクエスト時にすべてのデータを取得することによるパフォーマンスへの影響を心配することなく、動的レンダリングを選択できます。
>
> [full-route cache](/docs/app/building-your-application/caching#full-route-cache)と[Data Cache](/docs/app/building-your-application/caching#data-cache)について詳しく学びましょう。

#### Dynamic Renderingへの切り替え {#switching-to-dynamic-rendering}

レンダリング中に[Dynamic API](#dynamic-apis)または`{ cache: 'no-store' }`オプションの[fetch](/docs/app/api-reference/functions/fetch)が見つかった場合、Next.jsはルート全体を動的にレンダリングするように切り替えます。この表は、Dynamic APIとデータキャッシングがルートが静的または動的にレンダリングされるかどうかにどのように影響するかを示しています：

| Dynamic APIs | データ       | ルート             |
| ------------ | ------------ | ------------------ |
| No           | Cached       | 静的にレンダリング |
| Yes          | Cached       | 動的にレンダリング |
| No           | 未キャッシュ | 動的にレンダリング |
| Yes          | 未キャッシュ | 動的にレンダリング |

上記の表では、ルートを完全に静的にするには、すべてのデータがキャッシュされている必要があります。ただし、キャッシュされたデータフェッチとキャッシュされていないデータフェッチの両方を使用する動的にレンダリングされたルートを持つことができます。

開発者としては、Next.jsが使用された機能とAPIに基づいて各ルートに最適なレンダリング戦略を自動的に選択するため、静的レンダリングと動的レンダリングを選択する必要はありません。代わりに、データを[キャッシュする](/docs/app/building-your-application/data-fetching/fetching)または[特定のデータを再検証する](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)時期を選択でき、UIの一部を[ストリーミング](#streaming)することを選択するかもしれません。

### Dynamic APIs {#dynamic-apis}

Dynamic APIsは、リクエスト時にのみ既知である情報に依存しています（事前レンダリング中に先行して知られていない）。これらのAPIのいずれかを使用することは、開発者の意図を示しており、リクエスト時にルート全体を動的レンダリングにオプトインします。これらのAPIには以下が含まれます：

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)

### Streaming {#streaming}

<Image
  alt="ストリーミング中のルートセグメントの並列化を示す図で、データの取得、レンダリング、個々のチャンクのハイドレーションが示されています。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

Streamingにより、UIを順次サーバーからレンダリングできます。作業はチャンクに分割され、準備ができ次第、クライアントにストリームされます。これにより、ユーザーはコンテンツ全体がレンダリングを終了する前に、ページの一部を見ることができます。

<Image
  alt="クライアント上で部分的にレンダリングされたページを示す図で、ストリーミング中のチャンク用のUIが読み込み中を示しています。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

StreamingはデフォルトでNext.js App Routerに組み込まれています。これにより、初期ページの読み込みパフォーマンスと、ルート全体のレンダリングをブロックするような遅延のあるデータフェッチに依存するUIのパフォーマンスが向上します。例えば、商品ページのレビューなどです。

`loading.js`とUIコンポーネントを使用してルートセグメントのストリーミングを開始できます。[React Suspense](/docs/app/building-your-application/routing/loading-ui-and-streaming)についての詳細は、[Loading UI and Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming)セクションをご覧ください。
