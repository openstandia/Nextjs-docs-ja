---
title: 'Server Components'
description: 'React Server Componentsを使用してアプリケーションの一部をサーバーでレンダリングする方法を学びましょう。'
related:
  description: 'Next.jsがデータと静的レンダリングの結果をどのようにキャッシュするかを学びましょう。'
  links:
    - app/building-your-application/caching
---

React Server Componentsは、サーバーでレンダリングされオプションでキャッシュされるUIを書くことを可能にします。Next.jsでは、ルートセグメントによってレンダリング作業がさらに分割され、ストリーミングや部分的なレンダリングが可能になります。3つの異なるサーバーレンダリング戦略があります：

- [Static Rendering](#static-rendering-default)
- [Dynamic Rendering](#dynamic-rendering)
- [Streaming](#streaming)

このページでは、Server Componentsがどのように機能するか、いつ使用するか、そして異なるサーバーレンダリング戦略について説明します。

## サーバーレンダリングの利点 {#benefits-of-server-rendering}

サーバー上でレンダリング作業を行うことには、次のような利点があります：

- **データフェッチ**: Server Componentsを使用すると、データフェッチをデータソースに近いサーバー側に移動できます。これにより、レンダリングに必要なデータをフェッチする時間を削減し、クライアントが行うリクエストの数を減らすことで、パフォーマンスが向上します。
- **セキュリティ**: Server Componentsを使用すると、トークンやAPIキーなどの機密データやロジックをクライアントに露出するリスクなしにサーバー側に保持できます。
- **キャッシュ**: サーバーでレンダリングすることで、結果をキャッシュし、後続のリクエストやユーザー間で再利用できます。これにより、各リクエスト時のレンダリングやデータフェッチの量を削減してパフォーマンスが向上し、コストが削減されます。
- **パフォーマンス**: Server Componentsは、基本的なパフォーマンスを最適化するための追加のツールを提供します。たとえば、すべてがClient Componentで構成されているアプリから始める場合、非インタラクティブなUI部分をServer Componentsに移動することで、必要なクライアント側JavaScriptの量を削減できます。これにより、インターネット接続が遅い、または処理能力が低いデバイスを使用しているユーザーにとって、ブラウザがダウンロード、解析、実行するクライアント側JavaScriptの量が減るという利点があります。
- **初回ページロードと[First Contentful Paint (FCP)](https://web.dev/fcp/)**: サーバーでは、ユーザーがページを即座に閲覧できるようにHTMLを生成できます。これにより、クライアントがページのレンダリングに必要なJavaScriptをダウンロード、解析、実行するのを待つ必要がありません。
- **検索エンジン最適化とソーシャルネットワークの共有性**: レンダリングされたHTMLは、検索エンジンボットがページを索引登録するのに使用したり、ソーシャルネットワークボットがページ用のソーシャルカードプレビューを生成するのに使用できます。
- **ストリーミング**: Server Componentsを使用すると、レンダリング作業をチャンクに分割し、クライアントにストリームすることができます。これにより、ページ全体がサーバーでレンダリングされるまで待つことなく、ユーザーはページの一部を早く見ることができます。

## Next.jsでServer Componentsを使用する {#using-server-components-in-next-js}

デフォルトで、Next.jsはServer Componentsを使用します。これにより、追加の設定なしでサーバーレンダリングを自動的に実装でき、必要に応じてClient Componentsの使用を選択できます。詳しくは[Client Components](/docs/app/building-your-application/rendering/client-components)をご覧ください。

## Server Componentsはどのようにレンダリングされるか {#how-are-server-components-rendered}

サーバー上では、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントと[Suspense Boundaries](https://react.dev/reference/react/Suspense)によってチャンクに分割されます。

各チャンクは次の2つのステップでレンダリングされます：

1. ReactがServer Componentsを特殊なデータ形式である**React Server Component Payload (RSC Payload)**としてレンダリングします。
2. Next.jsは、RSC PayloadとClient Component JavaScriptの指示を使用してサーバー上で**HTML**をレンダリングします。

{/* レンダリング図 */}

その後、クライアントで：

1. HTMLは、ルートの高速で非インタラクティブなプレビューを即座に表示するために使用されます - これは初回ページロード時のみです。
2. React Server Components Payloadは、ClientとServer Componentのtreeを調整し、DOMを更新するために使用されます。
3. JavaScriptの指示は、Client Componentsを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにするために使用されます。

> #### React Server Component Payload (RSC)とは？
>
> RSC Payloadは、レンダリング済みのReact Server Components treeのコンパクトなバイナリ表現です。クライアント上でReactがブラウザのDOMを更新するために使用されます。RSC Payloadには以下が含まれます：
>
> - Server Componentsのレンダリング結果
> - Client Componentsがレンダリングされるべき位置のプレースホルダーと、そのJavaScriptファイルへの参照
> - Server ComponentからClient Componentに渡された任意のprops

## サーバーレンダリング戦略 {#server-rendering-strategies}

サーバーレンダリングには、Static、Dynamic、Streamingの3つのサブセットがあります。

### Static Rendering（デフォルト） {#static-rendering-default}

Static Renderingでは、ルートは**ビルド時**もしくは[データ再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)の後にバックグラウンドでレンダリングされます。その結果はキャッシュされ、[コンテンツデリバリネットワーク (CDN)](https://developer.mozilla.org/docs/Glossary/CDN)にプッシュできます。この最適化により、レンダリング作業の結果をユーザーやサーバーリクエストの間で共有できます。

Static renderingは、ブログの投稿や製品ページのように、ユーザーに個別化されていないデータが使用され、ビルド時に既知であるルートに役立ちます。

### Dynamic Rendering {#dynamic-rendering}

Dynamic Renderingでは、ルートは各ユーザーごとに**リクエスト時**にレンダリングされます。

Dynamic renderingは、クッキーやURLの検索パラメータのように、リクエスト時にのみ知ることができる情報を持つ、ユーザーに個別化されたデータを持つルートに役立ちます。

> **Dynamic Routes with Cached Data**
>
> 多くのウェブサイトでは、ルートは完全に静的または完全に動的ではなく、スペクトルがあります。たとえば、キャッシュされた商品データを使用し、一定間隔で再検証されるeコマースページと、キャッシュされていない個別化された顧客データを持つページがあります。
>
> Next.jsでは、キャッシュされたデータとキャッシュされていないデータの両方を持つ動的にレンダリングされたルートを持つことができます。これはRSC Payloadとデータが別々にキャッシュされるためです。これにより、すべてのデータをリクエスト時にフェッチすることでパフォーマンスへの影響を心配することなく、動的レンダリングを選択できます。
>
> [full-route cache](/docs/app/building-your-application/caching#full-route-cache)と[Data Cache](/docs/app/building-your-application/caching#data-cache)について詳しく学びましょう。

#### Dynamic Renderingへの切り替え {#switching-to-dynamic-rendering}

レンダリング中に[Dynamic API](#dynamic-apis)または`{ cache: 'no-store' }`オプションを使用した[fetch](/docs/app/api-reference/functions/fetch)が検出された場合、Next.jsはルート全体の動的レンダリングに切り替えます。この表はDynamic APIとデータキャッシングがルートが静的または動的にレンダリングされるかどうかにどのように影響するかをまとめたものです：

| Dynamic APIs | データ     | ルート             |
| ------------ | ---------- | ------------------ |
| No           | Cached     | 静的にレンダリング |
| Yes          | Cached     | 動的にレンダリング |
| No           | Not Cached | 動的にレンダリング |
| Yes          | Not Cached | 動的にレンダリング |

上記の表では、ルートが完全に静的であるためには、すべてのデータがキャッシュされている必要があります。しかし、キャッシュされたデータフェッチとキャッシュされていないデータフェッチの両方を使用する動的にレンダリングされたルートが可能です。

開発者としては、Next.jsが使用される機能とAPIに基づいて各ルートに最適なレンダリング戦略を自動的に選択してくれるため、静的と動的レンダリングを選択する必要はありません。代わりに、特定のデータを[キャッシュ](/docs/app/building-your-application/data-fetching/fetching)または[再検証](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)するタイミングを選び、UIの一部を[ストリーム](/docs/app/building-your-application/routing/loading-ui-and-streaming)することを選べます。

### Dynamic APIs {#dynamic-apis}

Dynamic APIsは、リクエスト時にのみ知ることができる情報に依存します（事前レンダリング時にあらかじめ知ることはできません）。これらのAPIを使用することで、開発者は意図を示し、リクエスト時にルート全体を動的レンダリングにオプトインします。これらのAPIには以下が含まれます：

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)

### Streaming {#streaming}

<Image
  alt="ストリーミング中にルートセグメントを並列化する様子を示す図。データフェッチ、レンダリング、各チャンクのハイドレーションを示しています。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

Streamingは、サーバーからの段階的なUIのレンダリングを可能にします。作業はチャンクに分割され、準備ができ次第クライアントへストリームされます。これにより、ユーザーはコンテンツ全体がレンダリングされる前にページの一部を即座に見ることができます。

<Image
  alt="クライアント側で部分的にレンダリングされたページを示す図。ストリーム中のチャンクを読み込むUIを表示します。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

Streamingは、デフォルトでNext.jsのapp routerに組み込まれています。これにより、初回ページロードのパフォーマンスが向上し、遅いデータフェッチに依存するUIも、ルート全体のレンダリングを妨げることなく向上します。たとえば、商品ページのレビューなどです。

`loading.js`を使用してルートセグメントをストリーミングし、UIコンポーネントを[React Suspense](/docs/app/building-your-application/routing/loading-ui-and-streaming)と組み合わせて使用することができます。[Loading UI and Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming)セクションを参照してください。
