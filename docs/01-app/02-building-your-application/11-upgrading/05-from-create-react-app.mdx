---
title: 'Create React Appからの移行'
description: '既存のCreate React AppアプリケーションをNext.jsに移行する方法を学びましょう。'
---

このガイドは、既存のCreate React AppサイトをNext.jsに移行するのに役立つものです。

## なぜ切り替えるのか？ {#why-switch}

Create React AppからNext.jsに切り替える理由はいくつかあります。

### 初期ページの読み込み速度が遅い {#slow-initial-page-loading-time}

Create React Appは純粋にクライアントサイドのReactを使用します。クライアントサイドのみのアプリケーション、またはシングルページアプリケーション（SPA）として知られるこれらのアプリケーションは、しばしば初期ページの読み込み時間が遅くなることがあります。これは以下の理由によります。

1. ブラウザは、Reactコードとアプリケーション全体のバンドルがダウンロードされて実行されるのを待つ必要があります。そしてそれが完了するまでは、コードがデータをロードするためのリクエストを送信することができません。
2. 新しい機能や依存関係を追加するたびにアプリケーションコードが成長します。

### 自動コード分割がない {#no-automatic-code-splitting}

前述の読み込み速度の遅さの問題は、コード分割を行うことである程度管理できます。しかし、コード分割を手動で試みると、パフォーマンスを悪化させることがよくあります。手動でコード分割を行うと、ネットワークのウォーターフォール（リソースが逐次的にロードされる現象）を意図せずに引き起こすことが容易です。Next.jsは、ルーターに組み込まれた自動コード分割を提供しています。

### ネットワークウォーターフォール {#network-waterfalls}

パフォーマンスが悪くなる一般的な原因の1つは、アプリケーションがデータを取得するために逐次的にクライアント-サーバーリクエストを行うときです。SPAのデータ取得の一般的なパターンは、最初にプレースホルダーをレンダリングし、コンポーネントがマウントされた後データを取得することです。残念ながら、これはデータをフェッチする子コンポーネントが親コンポーネントのデータ取得が完了するまでフェッチを開始できないことを意味します。

Next.jsではクライアント上でのデータ取得もサポートされていますが、データ取得をサーバー側で行うことで、クライアント-サーバーウォーターフォールを排除するオプションも提供されています。

### 素早く意図的な読み込みステート {#fast-and-intentional-loading-states}

[React Suspenseを使用したストリーミング](/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense)の組み込みサポートにより、ネットワークのウォーターフォールを引き起こすことなく、UIのどの部分を最初に読み込むか、どの順序で読み込むかを意図的に選ぶことができます。

これにより、読み込みがより速く、[レイアウトシフト](https://vercel.com/blog/how-core-web-vitals-affect-seo)を排除したページを構築することができます。

### データフェッチング戦略を選ぶ {#choose-the-data-fetching-strategy}

ニーズに応じて、ページおよびコンポーネント単位でNext.jsのデータフェッチング戦略を選ぶことができます。ビルド時に、サーバー上でリクエスト時に、またはクライアントでのフェッチを決定できます。例えば、CMSからデータをフェッチしてビルド時にブログポストをレンダリングし、それをCDNで効率的にキャッシュすることができます。

### ミドルウェア {#middleware}

[Next.jsのミドルウェア](/docs/app/building-your-application/routing/middleware)は、リクエストが完了する前にサーバー上でコードを実行することができます。これは特に、認証が必要なページにユーザーがアクセスした際に、ログインページにリダイレクトすることによって、非認証コンテンツのフラッシュを防ぐのに役立ちます。また、ミドルウェアは実験や[国際化](/docs/app/building-your-application/routing/internationalization)にも便利です。

### 組み込み最適化 {#built-in-optimizations}

[画像](/docs/app/building-your-application/optimizing/images)、[フォント](/docs/app/building-your-application/optimizing/fonts)、および[サードパーティスクリプト](/docs/app/building-your-application/optimizing/scripts)は、アプリケーションのパフォーマンスに大きな影響を与えることがよくあります。Next.jsにはこれらを自動的に最適化するための組み込みコンポーネントがあります。

## 移行手順 {#migration-steps}

この移行の目的は、可能な限り迅速に稼働するNext.jsアプリケーションを取得し、それによってNext.jsの機能を段階的に採用できるようにすることです。まず、既存のルーターを移行せずに純粋なクライアントサイドアプリケーション（SPA）として保持します。これにより、移行プロセス中に問題が発生する可能性を最小限に抑え、マージの競合も減らします。

### 手順1: Next.js依存関係のインストール {#step-1-install-the-next-js-dependency}

まず、`next`を依存関係としてインストールする必要があります。

```bash title="ターミナル"
npm install next@latest
```

### 手順2: Next.jsの設定ファイルの作成 {#step-2-create-the-next-js-configuration-file}

プロジェクトのルートに`next.config.mjs`を作成してください。このファイルには[Next.jsの設定オプション](/docs/app/api-reference/next-config-js)が格納されます。

```js title="next.config.mjs"
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export', // 単一ページアプリケーション(SPA)を出力します。
  distDir: './build', // ビルド出力ディレクトリを `./dist` に変更します。
}

export default nextConfig
```

### 手順3: Root レイアウトの作成 {#step-3-create-the-root-layout}

Next.jsの[App Router](/docs/app)アプリケーションは、アプリケーション内のすべてのページをラップする[root レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)ファイルを含む必要があります。このファイルは、`app`ディレクトリの最上位に定義されます。

CRAアプリケーションにおけるroot レイアウトファイルの最も近いものは`index.html`ファイルです; これは、ご自身の `<html>` 、 `<head>` 、 `<body>` タグが含まれています。

この手順では、`index.html`ファイルをroot レイアウトファイルに変換します。

1. `src`ディレクトリ内に新しい`app`ディレクトリを作成します。
2. その`app`ディレクトリ内に新しい`layout.tsx`ファイルを作成します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({ children }) {
  return '...'
}
```

</TabItem>
</Tabs>

> **Good to know**: レイアウトファイルには`.js`, `.jsx`, または`.tsx`拡張子を使用できます。

次に、`index.html`ファイルの内容を以前に作成した`<RootLayout>`コンポーネントにコピーし、`body.div#root`および`body.noscript`タグを`<div id="root">{children}</div>`に置き換えます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <meta charSet="UTF-8" />
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

> **Good to know**: Next.jsはCRAの`public/manifest.json`ファイル、追加のアイコン（[`favicon`、`icon`、および`apple-icon`](/docs/app/api-reference/file-conventions/metadata/app-icons)を除く）および[テスト設定](/docs/app/building-your-application/testing)を無視します; ただし、これらが要件である場合、Next.jsもこれらのオプションをサポートしています。詳細については、[Metadata API](/docs/app/building-your-application/optimizing/metadata)および[Testing](/docs/app/building-your-application/testing)ドキュメントを参照してください。

### 手順4: メタデータ {#step-4-metadata}

Next.jsは、デフォルトで[meta charset](https://developer.mozilla.org/docs/Web/HTML/Element/meta#charset)および[meta viewport](https://developer.mozilla.org/docs/Web/HTML/Viewport_meta_tag)タグを含んでいますので、 `<head>` からこれらタグを安全に削除できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

`favicon.ico`、`icon.png`、`robots.txt`のような[メタデータファイル](/docs/app/building-your-application/optimizing/metadata#file-based-metadata)は、`app`ディレクトリのトップレベルに配置しておくだけで、アプリケーションの`<head>`タグに自動的に追加されます。[すべてのサポートされているファイル](/docs/app/building-your-application/optimizing/metadata#file-based-metadata)を`app`ディレクトリに移動した後、`<link>`タグを安全に削除することができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

最後に、Next.jsは[Metadata API](/docs/app/building-your-application/optimizing/metadata)を使用して、最後の`<head>`タグを管理できます。エクスポートされた[`metadata`オブジェクト](/docs/app/api-reference/functions/generate-metadata#metadata-object)に最終的なメタデータ情報を移動します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'React App',
  description: 'Web site created with Next.js.',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export const metadata = {
  title: 'React App',
  description: 'Web site created with Next.js.',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

上記の変更により、`index.html`で宣言されていたすべてをNext.jsのフレームワークに組み込まれた規約ベースのアプローチを使用するように切り替えました([Metadata API](/docs/app/building-your-application/optimizing/metadata))。このアプローチは、ページのSEOおよびウェブシェアの改善をより簡単に行うことを可能にします。

### 手順5: スタイル {#step-5-styles}

Create React Appと同様に、Next.jsは[CSSモジュール](/docs/app/building-your-application/styling/css#css-modules)をサポートしています。

グローバルCSSファイルを使用している場合は、それを`app/layout.tsx`ファイルにインポートします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import '../index.css'

// ...
```

</TabItem>
</Tabs>

Tailwindを使用している場合は、`postcss`と`autoprefixer`をインストールする必要があります：

```bash title="ターミナル"
npm install postcss autoprefixer
```

次に、プロジェクトのルートに`postcss.config.js`ファイルを作成します。

```js title="postcss.config.js"
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

### 手順6: エントリーポイントページの作成 {#step-6-create-the-entrypoint-page}

Next.jsでは、`page.tsx`ファイルを作成してアプリケーションのエントリーポイントを宣言します。このファイルのCRAの最も近い同等物は`src/index.tsx`ファイルです。このステップでは、アプリケーションのエントリーポイントを設定します。

**`app`ディレクトリ内に`[[...slug]]`ディレクトリを作成します。**

このガイドは、まずNext.jsをSPA（シングルページアプリケーション）としてセットアップすることを目的としているため、アプリケーションのすべての可能なルートをキャッチするページエントリーポイントが必要です。そのため、`app`ディレクトリ内に新しい`[[...slug]]`ディレクトリを作成します。

このディレクトリは、[オプショナルキャッチオールルートセグメント](/docs/app/building-your-application/routing/dynamic-routes#optional-catch-all-segments)と呼ばれています。Next.jsは[ディレクトリをルートとして定義するためのファイルシステムベースのルーター](/docs/app/building-your-application/routing/defining-routes#creating-routes)を使用します。この特別なディレクトリは、アプリケーションのすべてのルートがその中の`page.tsx`ファイルに向けられることを保証します。

**`app/[[...slug]]`ディレクトリ内に新しい`page.tsx`ファイルを次の内容で作成します：**

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[[...slug]]/page.tsx" switcher
export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return '...' // ここを更新します
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[[...slug]]/page.js" switcher
export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return '...' // ここを更新します
}
```

</TabItem>
</Tabs>

このファイルは[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)です。`next build`を実行すると、このファイルは静的アセットとしてプレンダーされます。動的なコードは必要ありません。

このファイルはグローバルCSSをインポートし、 `[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)`に対して、インデックスルートである`/`という1つのルートだけを生成する予定であることを示しています。

次に、クライアントのみで実行される私たちのCRAアプリケーションの残りの部分を移動させましょう。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[[...slug]]/client.tsx" switcher
'use client'

import dynamic from 'next/dynamic'

const App = dynamic(() => import('../../App'), { ssr: false })

export function ClientOnly() {
  return <App />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[[...slug]]/client.js" switcher
'use client'

import dynamic from 'next/dynamic'

const App = dynamic(() => import('../../App'), { ssr: false })

export function ClientOnly() {
  return <App />
}
```

</TabItem>
</Tabs>

このファイルは[クライアントコンポーネント](/docs/app/building-your-application/rendering/client-components)です; これは`'use client'`ディレクティブによって定義されています。クライアントコンポーネントは、クライアントに送信される前にサーバー側で[HTMLにプリレンダーされます](/docs/app/building-your-application/rendering/client-components#how-are-client-components-rendered)。

最初にクライアントのみのアプリケーションを開始したいので、`App`コンポーネントからプレンダーリングを無効にするようにNext.jsを設定できます。

```tsx
const App = dynamic(() => import('../../App'), { ssr: false })
```

次に、エントリーポイントページを新しいコンポーネントを使用するように更新します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[[...slug]]/page.tsx" switcher
import { ClientOnly } from './client'

export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return <ClientOnly />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[[...slug]]/page.js" switcher
import { ClientOnly } from './client'

export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return <ClientOnly />
}
```

</TabItem>
</Tabs>

### 手順7: 静的な画像インポートの更新 {#step-7-update-static-image-imports}

Next.jsは静的な画像インポートをCRAとは少し異なる方法で処理します。CRAでは、画像ファイルをインポートすると、そのパブリックURLが文字列として返されます。

```tsx title="App.tsx"
import image from './img.png'

export default function App() {
  return <img src={image} />
}
```

Next.jsでは、静的画像のインポートはオブジェクトを返します。このオブジェクトはNext.jsの[`<Image>`コンポーネント](/docs/app/api-reference/components/image)で直接使用することができます。または、既存の`<img>`タグでオブジェクトの`src`プロパティを使用することもできます。

`<Image>`コンポーネントには[自動画像最適化](/docs/app/building-your-application/optimizing/images)の追加の利点があります。`<Image>`コンポーネントは、画像の寸法に基づいて結果の`<img>`の`width`と`height`属性を自動的に設定します; これにより、画像が読み込まれるときのレイアウトシフトを防ぐことができます。しかし、アプリに寸法が片方だけスタイルされていて、それ以外が`auto`になっていない画像が含まれている場合には問題を引き起こすことがあります。`auto`にスタイルされていない場合、寸法は`<img>`寸法属性の値にデフォルトになります; これにより画像が歪んで見える可能性があります。

`<img>`タグを保持することで、アプリケーションの変更を減らし、上記の問題を防ぐことができます。次に、最適化された画像を活用するために[ローダーを設定](/docs/app/building-your-application/optimizing/images#loaders)したり、自動画像最適化が備わったNext.jsのデフォルトサーバーに移行したりして、任意に`<Image>`コンポーネントに移行することができます。

**`/public`からインポートされた画像の絶対インポートパスを相対インポートに変換します：**

```tsx
// 前
import logo from '/logo.png'

// 後
import logo from '../public/logo.png'
```

**画像の`src`プロパティを使用し、画像全体のオブジェクトではなく、`<img>`タグに渡します：**

```tsx
// 前
<img src={logo} />

// 後
<img src={logo.src} />
```

または、ファイル名に基づいて画像アセットのパブリックURLを参照することもできます。たとえば、`public/logo.png`はアプリケーションに対して`/logo.png`で画像を提供します; これは`src`値となります。

> **警告：** TypeScriptを使用している場合、`src` プロパティにアクセスするときに型エラーが発生する可能性があります; それらを修正するには、`tsconfig.json`ファイルの[`include`配列](https://www.typescriptlang.org/tsconfig#include)に`next-env.d.ts`を追加する必要があります; Next.jsはアプリケーションの手順9で実行するときにこのファイルを自動生成します。

### 手順8: 環境変数の移行 {#step-8-migrate-the-environment-variables}

Next.jsはCRAと同様に`.env` [環境変数](/docs/app/building-your-application/configuring/environment-variables)をサポートしています。

主な違いは、クライアントサイドで環境変数を公開するために使用される接頭辞です。`REACT_APP_`の接頭辞を使用する環境変数を`NEXT_PUBLIC_`に変更します。

### 手順9: `package.json`のスクリプトの更新 {#step-9-update-scripts-in-package-json}

これで、アプリケーションを実行して、Next.jsへの移行が正常に行われたかどうかを確認することができるはずです; しかしその前に、`package.json`のスクリプトをNext.js関連のコマンドで更新し、`.next`および`next-env.d.ts`を`.gitignore`ファイルに追加する必要があります：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "npx serve@latest ./build"
  }
}
```

```txt title=".gitignore"
# ... {#}
.next
next-env.d.ts
```

`npm run dev`を実行し、[`http://localhost:3000`](http://localhost:3000)を開いてください; 現在、Next.jsでアプリケーションが動作しているのが確認できるはずです。

### 手順10: クリーンアップ {#step-10-clean-up}

Create React App関連のアーティファクトをコードベースからクリーンアップできます：

- `public/index.html`を削除する
- `src/index.tsx`を削除する
- `src/react-app-env.d.ts`を削除する
- `reportWebVitals`のセットアップを削除する
- CRAの依存関係（`react-scripts`）をアンインストールする

## バンドラーの互換性 {#bundler-compatibility}

Create React AppとNext.jsは共に、デフォルトでバンドリングにwebpackを使用しています。

CRAアプリケーションをNext.jsに移行する際、移行を検討しているカスタムwebpack設定を持っている場合があります。Next.jsは[カスタムwebpack設定](/docs/app/api-reference/next-config-js/webpack)を提供することをサポートしています。

さらに、Next.jsはTurbopackを`next dev --turbopack`経由でサポートしており、ローカルの開発パフォーマンスを向上させます; Turbopackは、互換性と段階的な採用のために一部の[webpackローダー](/docs/app/api-reference/next-config-js/turbo)もサポートしています。

## 今後のステップ {#next-steps}

すべてが計画通りに進んだ場合、現在Next.jsアプリケーションが単一ページアプリケーションとして動作しているはずです; しかし、Next.jsの利点をいまだに最大限に活用しているわけではありません; 今後は段階的に変更を加えて、すべての利点を享受することができます; 次に行うと良いことの提案です：

- React Routerから[Next.js App Router](/docs/app/building-your-application/routing)に移行して、次の利点を得る：
  - 自動コード分割
  - [ストリーミングサーバーレンダリング](/docs/app/building-your-application/routing/loading-ui-and-streaming)
  - [Reactサーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)
- [`<Image>`コンポーネントで画像を最適化する](/docs/app/building-your-application/optimizing/images)
- [`next/font`でフォントを最適化する](/docs/app/building-your-application/optimizing/fonts)
- [`<Script>`コンポーネントでサードパーティスクリプトを最適化する](/docs/app/building-your-application/optimizing/scripts)
- [Next.jsルールをサポートするようにESLint設定を更新する](/docs/app/api-reference/config/eslint)

> **Good to know:** 静的エクスポートは、現時点では`useParams`フック[を使用することをサポートしていません](https://github.com/vercel/next.js/issues/54393)。
