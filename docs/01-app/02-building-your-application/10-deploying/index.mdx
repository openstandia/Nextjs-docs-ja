---
title: 'デプロイする'
description: 'Next.jsアプリを本番環境にデプロイする方法を学びましょう。マネージドかセルフホストかを選べます。'
---

{/* このドキュメントの内容は、app router と pages router の両方に共通です。Pages Router に特有の内容を追加するには `<PagesOnly>Content</PagesOnly>` コンポーネントを使用できます。共通の内容はコンポーネントでラップしないでください。 */}

おめでとうございます。いよいよ本番環境に出荷する時です。

[マネージドNext.jsをVercelでデプロイ](#managed-nextjs-with-vercel)するか、Node.jsサーバー、Dockerイメージ、または静的HTMLファイルでセルフホストできます。`next start`を使用してデプロイすると、すべてのNext.js機能がサポートされます。

## 本番ビルド {#production-builds}

`next build`を実行すると、本番環境向けに最適化されたアプリケーションのバージョンが生成されます。HTML、CSS、およびJavaScriptファイルは、ページに基づいて作成されます。JavaScriptは[Next.jsコンパイラ](/docs/architecture/nextjs-compiler)を使用して**コンパイル**され、ブラウザバンドルは**短縮**されて、最良のパフォーマンスを達成し[すべての最新ブラウザ](/docs/architecture/supported-browsers)をサポートします。

Next.jsは、マネージドおよびセルフホストNext.jsに使用される標準のデプロイ出力を生成します。これにより、両方のデプロイ方法でのすべての機能がサポートされることが保証されます。次のメジャーバージョンでは、この出力を[Build Output API仕様](https://vercel.com/docs/build-output-api/v3?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)に変換します。

## VercelでのマネージドNext.js {#managed-next-js-with-vercel}

Next.jsの作成者および保守者である[Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)は、Next.jsアプリケーション用のマネージドインフラストラクチャと開発者体験プラットフォームを提供しています。

Vercelへのデプロイは設定不要で、グローバルに拡張性、可用性、およびパフォーマンスにおいて追加の強化を提供します。ただし、セルフホストでもすべてのNext.js機能がサポートされています。

[Next.js on Vercel]についてさらに詳しく学ぶことや、[無料でテンプレートをデプロイ](https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)して試してみることができます。

## セルフホスティング {#self-hosting}

Next.jsは次の3つの方法でセルフホストできます：

- [Node.jsサーバー](#nodejs-server)
- [Dockerコンテナ](#docker-image)
- [静的エクスポート](#static-html-export)

> **🎥 視聴:** Next.jsセルフホスティングについてさらに学ぶ → [YouTube (45分間)](https://www.youtube.com/watch?v=sIVL4JMqRfc).

次のプロバイダーに関するコミュニティが保守するデプロイ例があります：

- [Deno](https://github.com/nextjs/deploy-deno)
- [DigitalOcean](https://github.com/nextjs/deploy-digitalocean)
- [Flightcontrol](https://github.com/nextjs/deploy-flightcontrol)
- [Fly.io](https://github.com/nextjs/deploy-fly)
- [GitHub Pages](https://github.com/nextjs/deploy-github-pages)
- [Google Cloud Run](https://github.com/nextjs/deploy-google-cloud-run)
- [Railway](https://github.com/nextjs/deploy-railway)
- [Render](https://github.com/nextjs/deploy-render)
- [SST](https://github.com/nextjs/deploy-sst)

### Node.jsサーバー {#node-js-server}

Next.jsは、Node.jsをサポートする任意のホスティングプロバイダーにデプロイできます。`package.json`に `"build"` および `"start"` スクリプトを追加してください：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

次に、`npm run build`を実行してアプリケーションをビルドします。最後に、`npm run start`を実行してNode.jsサーバーを起動します。このサーバーはNext.jsのすべての機能をサポートしています。

### Dockerイメージ {#docker-image}

Next.jsは、[Docker](https://www.docker.com/)コンテナをサポートする任意のホスティングプロバイダーにデプロイできます。これは、[Kubernetes](https://kubernetes.io/)のようなコンテナオーケストレーターにデプロイするか、任意のクラウドプロバイダー内でコンテナとして実行する場合に使用できます。

1. マシンに[Dockerをインストール](https://docs.docker.com/get-docker/)します
2. [例をクローン](https://github.com/vercel/next.js/tree/canary/examples/with-docker)（または[マルチ環境の例](https://github.com/vercel/next.js/tree/canary/examples/with-docker-multi-env)）
3. コンテナをビルド： `docker build -t nextjs-docker .`
4. コンテナを実行：`docker run -p 3000:3000 nextjs-docker`

Dockerを通じたNext.jsは、すべてのNext.js機能をサポートします。

### 静的HTMLエクスポート {#static-html-export}

Next.jsは、静的サイトやシングルページアプリケーション（SPA）として開始し、後でサーバーを必要とする機能を使用するようにアップグレードすることができます。

Next.jsはこの[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)をサポートしているため、HTML/CSS/JSの静的アセットを提供できる任意のウェブサーバーにデプロイしてホスティングすることができます。これには、AWS S3、Nginx、またはApacheのようなツールが含まれます。

[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)として実行する場合、Next.js のサーバーを必要とする機能はサポートされません。[詳細はこちら](/docs/app/building-your-application/deploying/static-exports#unsupported-features).

> **Good to know:**
>
> - [Server Components](/docs/app/building-your-application/rendering/server-components) は静的エクスポートでもサポートされています。

## 機能 {#features}

### 画像最適化 {#image-optimization}

`next/image`による[画像最適化](/docs/app/building-your-application/optimizing/images)は、`next start`を使用してデプロイする際にセルフホストでゼロ設定で動作します。画像を最適化するための別のサービスを持ちたい場合は、[画像ローダーを設定](/docs/app/building-your-application/optimizing/images#loaders)することができます。

画像最適化は[type]を定義することで[静的エクスポート](/docs/app/building-your-application/deploying/static-exports#image-optimization)でも使用できます。`next.config.js`でカスタム画像ローダーを設定する必要があります。画像はビルド時ではなく、ランタイムで最適化されます。

> **Good to know:**
>
> - glibcベースのLinuxシステムでは、画像最適化は[追加の設定](https://sharp.pixelplumbing.com/install#linux-memory-allocator)が必要になる場合があります。過剰なメモリ使用を防ぐために。
> - 最適化された画像の[キャッシュ動作について](/docs/app/api-reference/components/image#caching-behavior)詳しく学び、TTLを設定する方法も知ることができます。
> - 画像を最適化する以外の`next/image`を使用する利点を保ちつつ、[画像最適化を無効](/docs/app/api-reference/components/image#unoptimized)にすることもできます。たとえば、別の方法で画像を自分で最適化している場合です。

### ミドルウェア {#middleware}

[ミドルウェア](/docs/app/building-your-application/routing/middleware)は、`next start`を使用してデプロイする際にセルフホスティングでゼロ設定で動作します。これには、受信リクエストへのアクセスが必要であるため、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)の使用時にはサポートされません。

ミドルウェアはランタイムを使用します。これは使用可能なすべてのNode.js APIのサブセットで、低遅延を確保するために役立ちます。なぜなら、アプリケーション内のすべてのルートやアセットの前で実行される可能性があるためです。このランタイムは“エッジ”での実行を必要とせず、単一の地域のサーバーで動作します。複数の地域でミドルウェアを実行するには、追加の設定とインフラストラクチャが必要です。

Node.jsのすべてのAPIを必要とするロジックを追加したり、外部パッケージを使用したりしたい場合は、このロジックを[Server Componentを使用して](docs/app/building-your-application/rendering/server-components)[レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#layouts)に移動することができるかもしれません。たとえば、[headersの確認](/docs/app/api-reference/functions/headers)や、[リダイレクト](/docs/app/api-reference/functions/redirect)を行う場合です。また、`next.config.js`を通じて、headers、cookies、またはクエリパラメーターを使用して[リダイレクト](/docs/app/api-reference/config/next-config-js/redirects#header-cookie-and-query-matching)や[書き換え](/docs/app/api-reference/config/next-config-js/rewrites#header-cookie-and-query-matching)をすることもできます。それがうまくいかない場合は、[カスタムサーバー](https://nextjs.org/docs/canary/pages/building-your-application/configuring/custom-server) を使用することもできます。

### 環境変数 {#environment-variables}

Next.jsはビルド時とランタイムの両方で環境変数をサポートすることが可能です。

**デフォルトでは、環境変数はサーバーでのみ利用可能です。** しかし、環境変数をブラウザに公開するためには、`NEXT_PUBLIC_`で始める必要があります。ただし、これらの公開環境変数は `next build` 中にJavaScriptバンドルにインライン化されます。

<PagesOnly>

ランタイム環境変数を読み取るには、`getServerSideProps`または[アプリルーターのインクリメンタルな導入](/docs/app/building-your-application/upgrading/app-router-migration)を使用することをお勧めします。

</PagesOnly>

<AppOnly>

動的レンダリング中にサーバーで安全に環境変数を読み取ることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.ts" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookie、header、その他の動的APIも動的レンダリングを採用します。
  // この環境変数はランタイムで評価されます。
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // クッキー、ヘッダー、その他の動的APIは、動的レンダリングを採用するため
  // この環境変数はランタイムで評価されます。
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
</Tabs>

</AppOnly>

これにより、異なる値で複数の環境を経由して昇格できる単一のDockerイメージを使用することが可能になります。

> **Good to know:**
>
> - [`register`関数](/docs/app/building-your-application/optimizing/instrumentation)を使用して、サーバー起動時にコードを実行できます。
> - [runtimeConfig](https://nextjs.org/docs/canary/pages/api-reference/config/next-config-js/runtime-configuration)オプションは、スタンドアロン出力モードで機能しないため、使用を推奨していません。代わりに、[インクリメンタルにアプルーターを導入することをお勧めします](/docs/app/building-your-application/upgrading/app-router-migration)。

### キャッシングとISR {#caching-and-isr}

Next.jsはレスポンス、生成された静的ページ、ビルド出力、画像、フォント、スクリプトなどの静的アセットをキャッシュできます。

[インクリメンタル静的再生成](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)を使用して、ページをキャッシュおよび再検証するには**同じ共有キャッシュ**を使用します。デフォルトでは、このキャッシュはファイルシステム（ディスク上）に保存されます。**セルフホスティング時には自動的に機能します**。Pages.RouterとApp.Routerでの使用時の両方です。

Next.jsキャッシュの場所を設定して、キャッシュされたページとデータを耐久性のあるストレージに保存するか、複数のコンテナまたはNext.jsアプリケーションのインスタンス間でキャッシュを共有することができます。

#### 自動キャッシング {#automatic-caching}

- Next.jsは`public, max-age=31536000, immutable`という`Cache-Control`ヘッダーを真の最小限のアセットに設定します。上書きできません。これらの不変ファイルにはファイル名にSHAハッシュが含まれているため、安全に無期限キャッシュできます。たとえば、[静的画像インポート](/docs/app/building-your-application/optimizing/images#local-images)です。画像の[TTLを設定](/docs/app/api-reference/components/image#caching-behavior)できます。
- インクリメンタル静的再生成（ISR）は`s-maxage: <revalidate in getStaticProps>`, stale-while-revalidate`という`Cache-Control`ヘッダーを設定します。この再検証時間は秒単位で[`getStaticProps` 関数](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)で定義されます。`revalidate: false`が設定されている場合、キャッシュ期間は1年になります。
- 動的にレンダリングされたページは`private, no-cache, no-store, max-age=0, must-revalidate`という`Cache-Control`ヘッダーを設定して、ユーザー固有のデータがキャッシュされないようにします。これはApp.RouterとPages.Routerの両方に適用されます。また、[Draft Mode](/docs/app/building-your-application/configuring/draft-mode)も含まれます。

#### 静的アセット {#static-assets}

静的アセットを別のドメインまたはCDNにホストしたい場合は、`next.config.js`で`assetPrefix` [設定](/docs/app/api-reference/config/next-config-js/assetPrefix)を使用できます。Next.jsはJavaScriptまたはCSSファイルを取得する際にこのアセット前に接頭辞を使用します。アセットを別のドメインに分離するとDNSおよびTLSの解決に追加の時間がかかるデメリットがあります。

[`assetPrefix`についての詳細を学ぶ。](/docs/app/api-reference/config/next-config-js/assetPrefix)。

#### キャッシングの設定 {#configuring-caching}

デフォルトで、生成されたキャッシュアセットはメモリ（デフォルトは50MB）およびディスク上に保存されます。Kubernetesのようなコンテナオーケストレーションプラットフォームを使用してNext.jsをホスティングする場合、各ポッドにはキャッシュのコピーがあります。デフォルトでポッド間でキャッシュが共有されないために表示される古いデータを防ぐため、Next.jsキャッシュを設定してキャッシュハンドラーを提供し、メモリキャッシュを無効にすることができます。

セルフホスティング時のISR/データキャッシュの場所を設定するには、`next.config.js`ファイルでカスタムハンドラーを設定することができます：

```jsx title="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // デフォルトのメモリキャッシュを無効にする
}
```

次に、プロジェクトのrootに`cache-handler.js`を作成します。たとえば：

```jsx title="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // これは耐久ストレージのような任意の場所に保存される可能性があります
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // これは耐久ストレージのような任意の場所に保存される可能性があります
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // tagsは文字列か文字列の配列のいずれかです
    tags = [tags].flat()
    // キャッシュ内のすべてのエントリを反復する
    for (let [key, value] of cache) {
      // 指定されたタグを含む値が含まれている場合、このエントリを削除する
      if (value.tags.some((tag) => tags.include(tag))) {
        cache.delete(key)
      }
    }
  }
}
```

カスタムキャッシュハンドラーを使用すると、Next.jsアプリケーションをホスティングするすべてのポッド間で一貫性を確保することができます。たとえば、キャッシュされた値は[Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis)やAWS S3のような任意の場所に保存することができます。

> **Good to know:**
>
> - `revalidatePath`はキャッシュタグの上にある利便レイヤーです。`revalidatePath`を呼び出すと、指定されたページに特定のデフォルトタグを持つ`revalidateTag`関数が呼び出されます。

### ビルドキャッシュ {#build-cache}

Next.jsは、`next build`の実行中に、提供されるアプリケーションのバージョンを識別するためのIDを生成します。それぞれのステージング環境で再ビルドしている場合は、コンテナ間で使用するための一貫性のあるビルドIDを生成する必要があります。`next.config.js`で`generateBuildId`コマンドを使用してください：

```jsx title="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // これは最新のgitハッシュのような任意のものである可能性があります
    return process.env.GIT_HASH
  },
}
```

### バージョン スキュー {#version-skew}

Next.jsは[バージョンスキュー](https://www.industrialempathy.com/posts/version-skew/)のほとんどの例を自動的に軽減し、新しいアセットを取得するためにアプリケーションを自動的にリロードします。たとえば、`deploymentId`に不一致がある場合、ページ間の遷移はプレフェッチされた値を使用するのではなく、ハードナビゲーションを実行します。

アプリケーションがリロードされると、ページナビゲーション間で状態を保持するように設計されていない場合、アプリケーションの状態が失われる可能性があります。たとえば、URL状態やローカルストレージを使用することで、ページの更新後も状態が保持されます。ただし `useState`のようなコンポーネントの状態は、そのようなナビゲーションでは失われます。

Vercelは、Next.jsアプリケーションのために、[スキュー保護](https://vercel.com/docs/deployments/skew-protection?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)を提供して、お客様が、新しいバージョンをデプロイした後も、古いクライアントに前のバージョンのアセットと機能がまだ利用可能であることを確認します。

次のリクエストが `?dpl`クエリ文字列や `x-deployment-id`ヘッダーを使用することを確認するために、`next.config.js`ファイルに`deploymentId`プロパティを手動で設定することができます。

<AppOnly>

### ストリーミング と サスペンス {#streaming-and-suspense}

Next.jsのApp Routerは、セルフホスティング時に[ストリーミングレスポンス](/docs/app/building-your-application/routing/loading-ui-and-streaming)をサポートしています。Nginxや同様のプロキシを使用する場合は、ストリーミングを有効にするためにバッファリングを無効にするように設定する必要があります。

たとえば、Nginxで `X-Accel-Buffering`を `no`に設定することでバッファリングを無効にできます：

```js title="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

### 部分的な事前レンダリング {#partial-prerendering}

Next.jsは[部分的事前レンダリング（実験的）](/docs/app/building-your-application/rendering/partial-prerendering)をデフォルトで動作させることができ、これはCDNの機能ではありません。これには、Node.jsサーバーとしてのデプロイ（`next start`を介して）およびDockerコンテナを使用した場合が含まれます。

### CDNsとの使用 {#usage-with-cdns}

Next.jsアプリケーションの前にCDNを配置する場合、ページには動的APIにアクセスできる場合には`Cache-Control: private`レスポンスヘッダーが含まれます。これにより、結果的なHTMLページがキャッシュされないようにマークされます。ページが完全に静的に事前レンダリングされる場合、CDN上でそのページをキャッシュできるように`Cache-Control: public`が含まれます。

静的および動的コンポーネントの両方の組み合わせが必要でない場合は、ルート全体を静的にし、CDNに出力HTMLをキャッシュすることができます。これは、動的なAPIが使用されていない場合は、`next build`実行時のデフォルト動作です。

</AppOnly>

<PagesOnly>

## 手動での優雅なシャットダウン {#manual-graceful-shutdowns}

セルフホスティング時、`SIGTERM`や`SIGINT`シグナルでサーバーをシャットダウン時にコードを実行したい場合があります。

環境変数`NEXT_MANUAL_SIG_HANDLE`を`true`に設定し、`_document.js`ファイル内でそのシグナルのハンドラーを登録できます。環境変数は直接`package.json`スクリプトで登録し、`.env`ファイルでは登録しないでください。

> **Good to know**: 手動のシグナル処理は `next dev` では利用できません。

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js title="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('SIGTERMを受信しました。クリーンアップ中です。')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('SIGINTを受信しました。クリーンアップ中です。')
    process.exit(0)
  })
}
```

</PagesOnly>
