---
title: 'デプロイ'
description: 'Next.js アプリケーションを本番環境にデプロイする方法を学びます．マネージドとセルフホスティングのいずれかを選択できます．'
---

{/* このドキュメントの内容は app router と pages router の間で共有されています．Pages Router の特定の内容を追加するには `<PagesOnly>Content</PagesOnly>` コンポーネントを使用できます．共有される内容はコンポーネントで囲んではいけません． */}

おめでとうございます。いよいよ本番環境に公開する時が来ました。

[managed Next.js with Vercel](#managed-next-js-with-vercel)を使用するか、Node.js サーバー、Docker イメージ、または静的 HTML ファイル上でセルフホストすることができます。 `next start` を使用してデプロイする場合、すべての Next.js 機能がサポートされます。

## プロダクションビルド {#production-builds}

`next build` を実行すると、本番環境向けに最適化されたアプリケーションのバージョンが生成されます。ページに基づいて HTML、CSS、JavaScript ファイルが作成されます。JavaScript は**コンパイル**され、ブラウザのバンドルは [Next.js Compiler](/docs/architecture/nextjs-compiler) を使用して**縮小**され、最高のパフォーマンスを実現し、[すべてのモダンブラウザ](/docs/architecture/supported-browsers)をサポートするのに役立ちます。

Next.js は、マネージドとセルフホスト型の Next.js むけに標準のデプロイメント出力を生成します。これにより、デプロイメントの両方の方法ですべての機能がサポートされることが保証されます。次のメジャーバージョンでは、この出力を [Build Output API 仕様](https://vercel.com/docs/build-output-api/v3?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)に変換する予定です。

## managed Next.js with Vercel {#managed-next-js-with-vercel}

[Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) は、Next.js のクリエーターおよびメンテナーであり、Next.js アプリケーション用のマネージドインフラストラクチャと開発者体験プラットフォームを提供します。

Vercel にデプロイする際、設定不要で世界規模でのスケーラビリティ、可用性、パフォーマンスのための追加機能が提供されます。ただし、セルフホスト型でもすべての Next.js の機能がサポートされます。

[Next.js の Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)についての詳細を確認するか、無料で [テンプレートをデプロイ](https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)して試してみてください。

## セルフホスティング {#self-hosting}

Next.js を異なる方法でセルフホストすることができます：

- [Node.js サーバー](#node-js-server)
- [Docker コンテナ](#docker-image)
- [静的エクスポート](#static-html-export)

> **🎥 視聴:** Next.js のセルフホスティングについて学びます→ [YouTube (45 分)](https://www.youtube.com/watch?v=sIVL4JMqRfc).

次のプロバイダー向けに、コミュニティが維持するデプロイメント例があります：

- [Deno](https://github.com/nextjs/deploy-deno)
- [DigitalOcean](https://github.com/nextjs/deploy-digitalocean)
- [Flightcontrol](https://github.com/nextjs/deploy-flightcontrol)
- [Fly.io](https://github.com/nextjs/deploy-fly)
- [GitHub Pages](https://github.com/nextjs/deploy-github-pages)
- [Google Cloud Run](https://github.com/nextjs/deploy-google-cloud-run)
- [Railway](https://github.com/nextjs/deploy-railway)
- [Render](https://github.com/nextjs/deploy-render)
- [SST](https://github.com/nextjs/deploy-sst)

### Node.js サーバー {#node-js-server}

Next.js は、Node.js をサポートするホスティングプロバイダーにデプロイできます。 `package.json` に `"build"` と `"start"` スクリプトがあることを確認してください：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

次に、`npm run build` を実行してアプリケーションをビルドします。最後に、`npm run start` を実行して Node.js サーバを開始します。このサーバは Next.js のすべての機能をサポートしています。

### Docker イメージ {#docker-image}

Next.js は、[Docker](https://www.docker.com/) コンテナをサポートする任意のホスティングプロバイダーにデプロイできます。このアプローチは [Kubernetes](https://kubernetes.io/) のようなコンテナオーケストレーターにデプロイする場合や、任意のクラウドプロバイダーでコンテナ内で実行する場合に使用できます。

1. 自分のマシンに [Docker をインストール](https://docs.docker.com/get-docker/) します
2. [例をクローン](https://github.com/vercel/next.js/tree/canary/examples/with-docker)します（または[マルチ環境の例](https://github.com/vercel/next.js/tree/canary/examples/with-docker-multi-env))
3. コンテナをビルドします：`docker build -t nextjs-docker .`
4. コンテナを実行します：`docker run -p 3000:3000 nextjs-docker`

Docker を通じての Next.js は、すべての Next.js 機能をサポートしています。

### 静的 HTML エクスポート {#static-html-export}

Next.js は最初は静的サイトやシングルページアプリケーション (SPA) として開始し、その後、サーバを必要とする機能をオプションでアップグレードすることを可能にします。

Next.js がこの [静的エクスポート](/docs/app/building-your-application/deploying/static-exports) をサポートしているため、AWS S3、Nginx、または Apache のような HTML/CSS/JS 静的アセットを配信できる任意のウェブサーバにデプロイしてホスティングすることができます。

[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)として実行する場合、Next.js のサーバが必要な機能はサポートされていません。[詳細はこちらをご覧ください](/docs/app/building-your-application/deploying/static-exports#unsupported-features)。

> **Good to know:**
>
> - [Server Components](/docs/app/building-your-application/rendering/server-components)は静的エクスポートを使用してサポートされます。

## 機能 {#features}

### 画像最適化 {#image-optimization}

`next/image` を使用しての [画像最適化](/docs/app/building-your-application/optimizing/images) は、`next start` を使用してデプロイする時に、セルフホストでのゼロコンフィギュレーションで動作します。画像を最適化するための別のサービスを使用したい場合は、[画像ローダーを設定する](/docs/app/building-your-application/optimizing/images#loaders)ことができます。

公式には画像最適化は定義したカスタムイメージローダーを使用して [静的エクスポート](/docs/app/building-your-application/deploying/static-exports#image-optimization)と共に使用できます。ただし、画像はビルド中ではなく、ランタイム時に最適化されます。

> **Good to know:**
>
> - glibcベースのLinuxシステム上では、画像最適化には過剰なメモリ使用を防止するために[追加設定](https://sharp.pixelplumbing.com/install#linux-memory-allocator)が必要な場合があります。
> - 最適化された画像の[キャッシュ動作](/docs/app/api-reference/components/image#caching-behavior)やTTLの設定方法について学びます。
> - 画像を最適化している別の方法を使用する場合、画像最適化を[無効にする](/docs/app/api-reference/components/image#unoptimized)こともでき、`next/image`を使用する他の利点はそのままにすることが可能です。

### ミドルウェア {#middleware}

[ミドルウェア](/docs/app/building-your-application/routing/middleware)は、`next start` を使用してデプロイする際、セルフホストでのゼロコンフィギュレーションで動作します。入力されるリクエストへのアクセスが必要であるため、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)時にはサポートされていません。

ミドルウェアは、アプリケーション内の各ルートまたはアセットの前で実行される場合があるため、低遅延を確保するために利用可能なすべてのNode.js APIのサブセットである[runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を使用します。このruntimeは「エッジで」実行する必要はなく、単一リージョンサーバで動作します。ミドルウェアを複数のリージョンで実行するには追加の設定とインフラストラクチャが必要です。

すべてのNode.js APIを必要とするロジック（または外部パッケージの使用）を追加したい場合、このロジックを[Server Component](/docs/app/building-your-application/rendering/server-components)として[layout](/docs/app/building-your-application/routing/layouts-and-templates#layouts)に移動することができる場合があります。ヘッダーの[チェック](/docs/app/api-reference/functions/headers)や[リダイレクト](/docs/app/api-reference/functions/redirect)の例としても同様です。また、`next.config.js`を通じてヘッダーやクッキー、クエリパラメータを使用して[リダイレクト](/docs/app/api-reference/config/next-config-js/redirects#header-cookie-and-query-matching)や[書き換える](/docs/app/api-reference/config/next-config-js/rewrites#header-cookie-and-query-matching)こともできます。それが機能しない場合、[custom server](https://nextjs.org/docs/canary/pages/building-your-application/configuring/custom-server)を使用することも可能です。

### 環境変数 {#environment-variables}

Next.js はビルド時および実行時の環境変数両方をサポートできます。

**デフォルトでは環境変数はサーバ上のみで利用可能です**。環境変数をブラウザに公開するには、`NEXT_PUBLIC_`をプレフィックスとして付ける必要があります。ただし、これらの公開環境変数は `next build` の間にJavaScriptバンドルにインライン化されます。

<PagesOnly>

実行時の環境変数を読み取るには、`getServerSideProps`もしくは [app routerを段階的に採用](/docs/app/building-your-application/upgrading/app-router-migration)することを推奨します。

</PagesOnly>

<AppOnly>

動的レンダリング中にサーバ上で安全に環境変数を読み取ることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.ts" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies、headers、およびその他の動的API
  // も動的レンダリングに適合し、この
  // 環境変数はランタイムで評価されます
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies、headers、およびその他の動的API
  // も動的レンダリングに適合し、この
  // 環境変数はランタイムで評価されます
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
</Tabs>

</AppOnly>

これにより、異なる値で複数の環境を通して昇進させることができる単一の Docker イメージを使用できます。

> **Good to know:**
>
> - [`register` 関数](/docs/app/building-your-application/optimizing/instrumentation)を使用して、サーバ起動時にコードを実行できます。
> - [runtimeConfig](https://nextjs.org/docs/canary/pages/api-reference/config/next-config-js/runtime-configuration) オプションは使用を推奨していません。これはスタンドアロン出力モードでは機能しません。代わりに、[app routerを段階的に採用](/docs/app/building-your-application/upgrading/app-router-migration)することを推奨しています。

### キャッシングとISR {#caching-and-isr}

Next.js はレスポンス、生成された静的ページ、ビルド出力、および画像、フォント、スクリプトなどのその他の静的アセットをキャッシュできます。

ページのキャッシングと再検証（[Incremental Static Regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)を使用）では、**同じ共有キャッシュ**を使用します。デフォルトでは、このキャッシュは Next.js サーバ上のファイルシステム（ディスク上）に保存されます。**セルフホスティング時に自動的に動作**します。Pages Router と App Router の両方を使用します。

キャッシュされたページやデータを永続ストレージに保存したり、Next.js アプリケーションの複数のコンテナやインスタンス間でキャッシュを共有したい場合は、Next.js のキャッシュ場所を設定できるます。

#### 自動キャッシュ {#automatic-caching}

- Next.js は `public, max-age=31536000, immutable` の `Cache-Control` ヘッダーを設定して実際には修正不可能なアセットとします。これを上書きすることはできません。これらの修正不可能なファイルはファイル名に SHA-ハッシュを含んでいるため、安全に無期限にキャッシュすることができます。例えば[Static Image Imports](/docs/app/building-your-application/optimizing/images#local-images)があります。画像用のTTLを[設定できます](/docs/app/api-reference/components/image#caching-behavior)。
- Incremental Static Regeneration (ISR) は、`s-maxage: <revalidate in getStaticProps>, stale-while-revalidate` の `Cache-Control` ヘッダーを設定します。この再検証時間は、秒単位であなたの[`getStaticProps` 関数](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)で定義されます。`revalidate: false`を設定すると、デフォルトで1年間のキャッシュ期間に設定されます。
- 動的にレンダリングされたページは、`private, no-cache, no-store, max-age=0, must-revalidate` の `Cache-Control` ヘッダーを設定してユーザ固有のデータのキャッシュを防ぎます。これは App Router と Pages Router の両方に適用されます。これには [Draft Mode](/docs/app/building-your-application/configuring/draft-mode)も含まれます。

#### 静的アセット {#static-assets}

静的アセットを異なるドメインやCDNにホストする場合は、`next.config.js`で `assetPrefix` [構成例](/docs/app/api-reference/config/next-config-js/assetPrefix)を使用できます。Next.js は JavaScript や CSS ファイルを取得する際にこのアセットプレフィックスを使用します。アセットを異なるドメインに分割することは、DNSやTLS の解決に余計な時間がかかるという欠点があります。

[`assetPrefix` についての詳細](/docs/app/api-reference/config/next-config-js/assetPrefix)を学びましょう。

#### キャッシュの設定 {#configuring-caching}

デフォルトで、生成されたキャッシュアセットはメモリ（デフォルトで50 MB）とディスクに保存されます。Kubernetes のようなコンテナオーケストレーションプラットフォームを使用して Next.js をホスティングしている場合、各ポッドにはキャッシュのコピーがあります。ポッド間でデフォルトで共有されないキャッシュがあるために表示される古いデータを防ぐために、Next.js キャッシュを構成してキャッシュハンドラを提供し、メモリキャッシュを無効にすることができます。

セルフホスティング時のISR/データキャッシュ場所を設定するには、`next.config.js`ファイルにカスタムハンドラを構成できます：

```jsx title="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // デフォルトのメモリ内キャッシュを無効にします
}
```

次に、プロジェクトのrootで `cache-handler.js`を作成します。以下の例を参照してください：

```jsx title="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // これはどこでも保存できます、例えば、耐久ストレージなど
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // これはどこでも保存できます、例えば、耐久ストレージなど
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // tags は文字列または文字列の配列です
    tags = [tags].flat()
    // キャッシュ内のすべてのエントリを反復処理します
    for (let [key, value] of cache) {
      // 指定されたタグが値のタグに含まれている場合、このエントリを削除します
      if (value.tags.some((tag) => tags.include(tag))) {
        cache.delete(key)
      }
    }
  }
}
```

カスタムキャッシュハンドラを使用することで、Next.js アプリケーションをホスティングしているすべてのポッド間での一貫性を保証することができます。例えば、キャッシュされた値をどこにでも保存できます、例えば [Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis) や AWS S3)。

> **Good to know:**
>
> - `revalidatePath` は、キャッシュタグの上に便利なレイヤーです。`revalidatePath` を呼び出すと、提供されたページの特別なデフォルトタグで `revalidateTag` 関数が呼び出されます。

### ビルドキャッシュ {#build-cache}

Next.js は `next build` 中に、提供されているアプリケーションのバージョンを識別するための ID を生成します。同じビルドを使用して、複数のコンテナを起動するべきです。

環境の各段階について再ビルドしている場合、コンテナ間で使用するための一貫性のあるビルドIDを生成する必要があります。`next.config.js`で `generateBuildId` コマンドを使用します：

```jsx title="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // この部分は何でもかまいません。例えば最新のgit hashを使用します。
    return process.env.GIT_HASH
  },
}
```

### バージョンスキュー {#version-skew}

Next.js は多くの [version skew](https://www.industrialempathy.com/posts/version-skew/) のインスタンスを自動的に緩和し、自動的にアプリケーションをリロードして、新しいアセットを取得します。たとえば、`deploymentId` に不一致がある場合、ページ間の移行はプレフェッチされた値を使用せず、ハードナビゲーションを実行します。

アプリケーションがリロードされた場合、ページナビゲーション間で持続するように設計されていない場合、アプリケーションの状態が失われる可能性があります。たとえば、URL状態やローカルストレージを使用すると、ページ更新後も状態が保持されます。ただし、`useState`のようなコンポーネント状態は、そのようなナビゲーションでは失われます。

Vercel は、Next.js アプリケーションにおける [スキュー保護](https://vercel.com/docs/deployments/skew-protection?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)を追加で提供し、新しいバージョンがデプロイされた後でも、古いクライアントが以前のバージョンのアセットや機能にアクセスできるようにします。

それぞれのリクエストが `?dpl` クエリ文字列または `x-deployment-id` ヘッダを使用するようにするために、`next.config.js` ファイルで `deploymentId` プロパティを手動で設定することができます。

<AppOnly>

### ストリーミング と サスペンス {#streaming-and-suspense}

Next.js App Router はセルフホスト型で[ストリーミングレスポンス](/docs/app/building-your-application/routing/loading-ui-and-streaming)をサポートしています。Nginx などのプロキシを使用している場合、ストリーミングを有効にするためには、バッファリングを無効に設定する必要があります。

たとえば、Nginx で `X-Accel-Buffering` を `no` に設定してバッファリングを無効にすることができます：

```js title="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

### 部分プリレンダリング {#partial-prerendering}

[部分プリレンダリング（実験的）](/docs/app/building-your-application/rendering/partial-prerendering)は、Next.js でデフォルトで動作し、CDN 機能ではありません。これは、Node.js サーバ（`next start` 経由）としてのデプロイと、Docker コンテナと一緒に使用した場合です。

### CDNs での使用方法 {#usage-with-cdns}

Next.js アプリケーションの前に CDN を使用すると、動的APIがアクセスされた場合に、ページは `Cache-Control: private` レスポンスヘッダーを含みます。これにより、生成された HTML ページがキャッシュ不能として指定されます。ページが完全に静的にプリレンダリングされると、`Cache-Control: public` を含め、ページがCDNにキャッシュされることを許可します。

静的コンポーネントと動的コンポーネントの両方を混在させる必要がない場合は、ルート全体を静的にして、生成されたHTMLをCDN上でキャッシュできます。この自動静的最適化は、動的APIが使用されていない場合に `next build`を実行するときのデフォルトの動作です。

</AppOnly>

<AppOnly>

### `after` {#after}

[`after`](/docs/app/api-reference/functions/after)は、`next start`を使用したセルフホスティングで完全にサポートされています。

サーバを停止するときには、`SIGINT` または `SIGTERM` シグナルを送信して待つことで優雅なシャットダウンを保証します。これにより、Next.js サーバは `after`内で使用される保留中のコールバック関数またはプロミスを完了するまで待機できるようになります。

カスタムインフラストラクチャで `after` を使用したい場合、プロバイダーのドキュメントをチェックして `after` のサポートを確認してください。

<details id="after-serverless">
  <summary>サーバーレスプラットフォームでの`after`のサポートに関する参考情報</summary>
  サーバーレスコンテキストで `after` を使用するには、レスポンスが送信された後に非同期タスクが完了するまで待つことが必要です。Next.js と Vercel では、すべてのプロミスが[`waitUntil`](https://vercel.com/docs/functions/functions-api-reference#waituntil) に渡された後に解決されるまで、サーバーレスの呼び出しの有効期限を延長する `waitUntil(promise)` というプリミティブを使用してこれを実現しています。

ユーザーに `after` を実行させたい場合、類似の方法で動作する `waitUntil`の実装を提供する必要があります。

`after` が呼び出されたとき、Next.js が以下のように `waitUntil` にアクセスします：

```jsx
const RequestContext = globalThis[Symbol.for('@next/request-context')]
const contextValue = RequestContext?.get()
const waitUntil = context?.waitUntil
```

つまり、`globalThis[Symbol.for('@next/request-context')]` は次のようなオブジェクトを含むことが期待されています：

```tsx
type NextRequestContext = {
  get(): NextRequestContextValue | undefined
}

type NextRequestContextValue = {
  waitUntil?: (promise: Promise<any>) => void
}
```

こちらは実装の一例です：

```tsx
import { AsyncLocalStorage } from 'node:async_hooks'

const RequestContextStorage = new AsyncLocalStorage<NextRequestContextValue>()

// 次が使用されるアクセサを定義し挿入する
const RequestContext: NextRequestContext = {
  get() {
    return RequestContextStorage.getStore()
  },
}
globalThis[Symbol.for('@next/request-context')] = RequestContext

const handler = (req, res) => {
  const contextValue = { waitUntil: YOUR_WAITUNTIL }
  // 値を提供する
  return RequestContextStorage.run(contextValue, () => nextJsHandler(req, res))
}
```

</details>

</AppOnly>

<PagesOnly>

## 手動優雅なシャットダウン {#manual-graceful-shutdowns}

セルフホスティングする場合、`SIGTERM`または`SIGINT`シグナルでサーバーがシャットダウンする際にコードを実行したい場合があるかもしれません。

環境変数 `NEXT_MANUAL_SIG_HANDLE` を `true`に設定し、そのシグナルのハンドラを `_document.js` ファイル内で登録することができます。この環境変数を `.env` ファイルではなく、直接に `package.json` のスクリプトに登録する必要があります。

> **Good to know**：手動シグナルハンドリングは `next dev` では利用できません。

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js title="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('Received SIGTERM: cleaning up')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('Received SIGINT: cleaning up')
    process.exit(0)
  })
}
```

</PagesOnly>
