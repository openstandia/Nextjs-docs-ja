---
title: 'Redirecting'
description: 'Next.jsでリダイレクトを処理するさまざまな方法を学びます'
related:
  links:
    - 'app/api-reference/functions/redirect'
    - 'app/api-reference/functions/permanentRedirect'
    - 'app/building-your-application/routing/middleware'
    - 'app/api-reference/config/next-config-js/redirects'
---

Next.jsでは、リダイレクトを処理するためのいくつかの方法があります。このページでは、それぞれの利用可能なオプション、ユースケース、および大量のリダイレクトをどのように管理するかについて説明します。

<AppOnly>

| API                                                            | 目的                                                       | 使用場所                                          | ステータスコード                           |
| -------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------- | ------------------------------------------ |
| [`redirect`](#redirect-function)                               | ミューテーションやイベント後にユーザーをリダイレクトします | Server Components, Server Actions, Route Handlers | 307（Temporary）または303（Server Action） |
| [`permanentRedirect`](#permanentredirect-function)             | ミューテーションやイベント後にユーザーをリダイレクトします | Server Components, Server Actions, Route Handlers | 308（Permanent）                           |
| [`useRouter`](#userouter-hook)                                 | クライアント側のナビゲーションを実行します                 | Client Componentsのイベントハンドラー             | N/A                                        |
| [`redirects` in `next.config.js`](#redirects-in-nextconfigjs)  | パスに基づいて受信リクエストをリダイレクトします           | `next.config.js` ファイル                         | 307（Temporary）または308（Permanent）     |
| [`NextResponse.redirect`](#nextresponseredirect-in-middleware) | 条件に基づいて受信リクエストをリダイレクトします           | Middleware                                        | 何でも                                     |

</AppOnly>

<PagesOnly>

| API                                                            | 目的                                             | 使用場所                  | ステータスコード                       |
| -------------------------------------------------------------- | ------------------------------------------------ | ------------------------- | -------------------------------------- |
| [`useRouter`](#userouter-hook)                                 | クライアント側のナビゲーションを実行します       | Components                | N/A                                    |
| [`redirects` in `next.config.js`](#redirects-in-nextconfigjs)  | パスに基づいて受信リクエストをリダイレクトします | `next.config.js` ファイル | 307（Temporary）または308（Permanent） |
| [`NextResponse.redirect`](#nextresponseredirect-in-middleware) | 条件に基づいて受信リクエストをリダイレクトします | Middleware                | 何でも                                 |

</PagesOnly>

<AppOnly>

## `redirect` 関数 {#redirect-function}

`redirect` 関数を使用すると、ユーザーを別のURLにリダイレクトすることができます。`redirect` を [Server Components](/docs/app/building-your-application/rendering/server-components)、[Route Handlers](/docs/app/building-your-application/routing/route-handlers)、および [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) で呼び出すことができます。

`redirect` は、ミューテーションやイベント後によく使用されます。たとえば、投稿を作成する場合：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'

export async function createPost(id: string) {
  try {
    // データベースを呼び出します
  } catch (error) {
    // エラーを処理します
  }

  revalidatePath('/posts') // キャッシュされた投稿を更新します
  redirect(`/post/${id}`) // 新しい投稿ページにナビゲートします
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'

export async function createPost(id) {
  try {
    // データベースを呼び出します
  } catch (error) {
    // エラーを処理します
  }

  revalidatePath('/posts') // キャッシュされた投稿を更新します
  redirect(`/post/${id}`) // 新しい投稿ページにナビゲートします
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - `redirect` はデフォルトで307（Temporary Redirect）ステータスコードを返します。Server Actionで使用されると、303（See Other）を返します。これは、POSTリクエストの結果として成功ページにリダイレクトするのによく使われます。
> - `redirect` は内部でエラーをスローするため、`try/catch` ブロックの外で呼び出す必要があります。
> - `redirect` はクライアントコンポーネントのレンダリングプロセス中に呼び出すことができますが、イベントハンドラーでは呼び出すことができません。代わりに [`useRouter` フック](#userouter-hook) を使用してください。
> - `redirect` は絶対URLも受け入れており、外部リンクにリダイレクトするためにも使用できます。
> - レンダリングプロセスの前にリダイレクトしたい場合は、[`next.config.js`](#redirects-in-nextconfigjs) または [Middleware](#nextresponseredirect-in-middleware) を使用してください。

[`redirect` API リファレンス](/docs/app/api-reference/functions/redirect) を参照してください。

## `permanentRedirect` 関数 {#permanentredirect-function}

`permanentRedirect` 関数を使用すると、ユーザーを別のURLに**永続的に**リダイレクトすることができます。`permanentRedirect` を [Server Components](/docs/app/building-your-application/rendering/server-components)、[Route Handlers](/docs/app/building-your-application/routing/route-handlers)、および [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) で呼び出すことができます。

`permanentRedirect` は、エンティティの正規URLが変更された後によく使用されます。たとえば、ユーザーがユーザー名を変更した後にユーザープロファイルURLを更新する場合など：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { permanentRedirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function updateUsername(username: string, formData: FormData) {
  try {
    // データベースを呼び出します
  } catch (error) {
    // エラーを処理します
  }

  revalidateTag('username') // ユーザー名へのすべての参照を更新します
  permanentRedirect(`/profile/${username}`) // 新しいユーザープロファイルにナビゲートします
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { permanentRedirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function updateUsername(username, formData) {
  try {
    // データベースを呼び出します
  } catch (error) {
    // エラーを処理します
  }

  revalidateTag('username') // ユーザー名へのすべての参照を更新します
  permanentRedirect(`/profile/${username}`) // 新しいユーザープロファイルにナビゲートします
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - `permanentRedirect` はデフォルトで308（permanent redirect）ステータスコードを返します。
> - `permanentRedirect` は絶対URLも受け入れており、外部リンクにリダイレクトするためにも使用できます。
> - レンダリングプロセスの前にリダイレクトしたい場合は、[`next.config.js`](#redirects-in-nextconfigjs) または [Middleware](#nextresponseredirect-in-middleware) を使用してください。

[`permanentRedirect` API リファレンス](/docs/app/api-reference/functions/permanentRedirect) を参照してください。

</AppOnly>

## `useRouter()` フック {#userouter-hook}

<AppOnly>

クライアントコンポーネント内のイベントハンドラー内でリダイレクトを行う必要がある場合、`useRouter` フックの `push` メソッドを使用できます。たとえば：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

コンポーネント内でリダイレクトを行う必要がある場合、`useRouter` フックの `push` メソッドを使用できます。たとえば：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { useRouter } from 'next/router'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { useRouter } from 'next/router'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

> **Good to know**:
>
> - プログラムによってナビゲーションを行う必要がない場合は、[`<Link>`](/docs/app/api-reference/components/link) コンポーネントを使用すべきです。

<AppOnly>

[`useRouter` API リファレンス](/docs/app/api-reference/functions/use-router) を参照してください。

</AppOnly>

<PagesOnly>

[`useRouter` API リファレンス](https://nextjs.org/docs/canary/pages/api-reference/functions/use-router) を参照してください。

</PagesOnly>

## `next.config.js` 内の `redirects` {#redirects-in-next-config-js}

`next.config.js` ファイル内の `redirects` オプションを使用すると、受信リクエストのパスを別の移動先のパスにリダイレクトすることができます。これは、ページのURL構造を変更する場合や、事前に知られているリダイレクトのリストがある場合に役立ちます。

`redirects` は、[パス](/docs/app/api-reference/config/next-config-js/redirects#path-matching)、[ヘッダー、クッキー、およびクエリのマッチング](/docs/app/api-reference/config/next-config-js/redirects#header-cookie-and-query-matching)をサポートしており、受信リクエストに基づいてユーザーをリダイレクトする柔軟性を提供します。

`redirects` を使用するには、オプションを `next.config.js` ファイルに追加します：

```js title="next.config.js"
module.exports = {
  async redirects() {
    return [
      // 基本的なリダイレクト
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
      // ワイルドカードパスマッチング
      {
        source: '/blog/:slug',
        destination: '/news/:slug',
        permanent: true,
      },
    ]
  },
}
```

[`redirects` API リファレンス](/docs/app/api-reference/config/next-config-js/redirects) を参照してください。

> **Good to know**:
>
> - `redirects` は `permanent` オプションを使用して307（Temporary Redirect）または308（Permanent Redirect）というステータスコードを返すことができます。
> - `redirects` にはプラットフォームによって制限があります。たとえば、Vercelではリダイレクトが1,024件の制限があります。1,000件以上の大量のリダイレクトを管理するには、[Middleware](/docs/app/building-your-application/routing/middleware) を使用してカスタムソリューションを作成することを検討してみてください。大規模でのリダイレクト管理に関しては、[managing redirects at scale](#managing-redirects-at-scale-advanced)をご覧ください；
> - `redirects` は Middleware の**前に**実行されます。

## Middlewareでの `NextResponse.redirect` {#nextresponse-redirect-in-middleware}

Middlewareを使用すると、リクエストが完了する前にコードを実行できます。その後、受信リクエストに基づいて `NextResponse.redirect` を使用して異なるURLにリダイレクトできます。これはユーザーを特定の条件（たとえば、認証、セッション管理など）に基づいてリダイレクトしたり、[多数のリダイレクト](#managing-redirects-at-scale-advanced)を持っている場合に便利です。

たとえば、ユーザーが認証されていない場合に `/login` ページにリダイレクトするには：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse, NextRequest } from 'next/server'
import { authenticate } from 'auth-provider'

export function middleware(request: NextRequest) {
  const isAuthenticated = authenticate(request)

  // ユーザーが認証されている場合、通常どおり続行します
  if (isAuthenticated) {
    return NextResponse.next()
  }

  // 認証されていない場合はログインページにリダイレクト
  return NextResponse.redirect(new URL('/login', request.url))
}

export const config = {
  matcher: '/dashboard/:path*',
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'
import { authenticate } from 'auth-provider'

export function middleware(request) {
  const isAuthenticated = authenticate(request)

  // ユーザーが認証されている場合、通常どおり続行します
  if (isAuthenticated) {
    return NextResponse.next()
  }

  // 認証されていない場合はログインページにリダイレクト
  return NextResponse.redirect(new URL('/login', request.url))
}

export const config = {
  matcher: '/dashboard/:path*',
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - Middleware は `next.config.js` の `redirects` の**後**に実行され、レンダリングの**前**に実行されます。

[Middleware](/docs/app/building-your-application/routing/middleware) のドキュメントを参照してください；

## 大規模でのリダイレクト管理（上級編）{#managing-redirects-at-scale-advanced}

1,000件以上の大量のリダイレクトを管理するには、Middleware を使用してカスタムソリューションを作成することを検討してみてください。これにより、アプリケーションを再デプロイしなくてもプログラムでリダイレクトを処理できます。

これを行うには、以下を考慮する必要があります：

1. リダイレクトマップの作成と保存
2. データ検索パフォーマンスの最適化

> **Next.js の例**: 以下の推奨事項の実装については、[Middleware with Bloom filter](https://redirects-bloom-filter.vercel.app/) の例をご覧ください。

### 1. リダイレクトマップの作成と保存 {#1-creating-and-storing-a-redirect-map}

リダイレクトマップとは、データベース（通常はキー-バリューストア）またはJSONファイルに保存できるリダイレクトのリストです。

以下のようなデータ構造を考慮してください：

```json
{
  "/old": {
    "destination": "/new",
    "permanent": true
  },
  "/blog/post-old": {
    "destination": "/blog/post-new",
    "permanent": true
  }
}
```

[Middleware](/docs/app/building-your-application/routing/middleware) では、Vercelの [Edge Config](https://vercel.com/docs/storage/edge-config/get-started?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) または [Redis](https://vercel.com/docs/storage/vercel-kv?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) などのデータベースから読み取り、受信リクエストに基づいてユーザーをリダイレクトすることができます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse, NextRequest } from 'next/server'
import { get } from '@vercel/edge-config'

type RedirectEntry = {
  destination: string
  permanent: boolean
}

export async function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname
  const redirectData = await get(pathname)

  if (redirectData && typeof redirectData === 'string') {
    const redirectEntry: RedirectEntry = JSON.parse(redirectData)
    const statusCode = redirectEntry.permanent ? 308 : 307
    return NextResponse.redirect(redirectEntry.destination, statusCode)
  }

  // リダイレクトが見つからない場合は、そのまま続行します
  return NextResponse.next()
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'
import { get } from '@vercel/edge-config'

export async function middleware(request) {
  const pathname = request.nextUrl.pathname
  const redirectData = await get(pathname)

  if (redirectData) {
    const redirectEntry = JSON.parse(redirectData)
    const statusCode = redirectEntry.permanent ? 308 : 307
    return NextResponse.redirect(redirectEntry.destination, statusCode)
  }

  // リダイレクトが見つからない場合は、そのまま続行します
  return NextResponse.next()
}
```

</TabItem>
</Tabs>

### 2. データ検索パフォーマンスの最適化 {#2-optimizing-data-lookup-performance}

すべての受信リクエストに対して大規模なデータセットを読み取ることは、遅くて高コストになる可能性があります。データ検索パフォーマンスを最適化するための2つの方法があります：

- [Vercel Edge Config](https://vercel.com/docs/storage/edge-config/get-started?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) や [Redis](https://vercel.com/docs/storage/vercel-kv?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) など、迅速な読み取りに最適化されたデータベースを使用します；
- [Bloomフィルター](https://ja.wikipedia.org/wiki/Bloomフィルター) のようなデータ検索手法を使用して、大規模なリダイレクトファイルやデータベースを読み取る**前に**、リダイレクトが存在するかどうかを効率よく確認します。

前述の例を考慮すると、生成されたブルームフィルターファイルをMiddlewareにインポートし、受信リクエストパス名がブルームフィルター内に存在するかどうかを確認します。

存在する場合、<AppOnly>それを [Route Handler](/docs/app/building-your-application/routing/route-handlers) に転送します</AppOnly> <PagesOnly>[API Routes](https://nextjs.org/docs/canary/pages/building-your-application/routing/api-routes)</PagesOnly>；そうすると、実際のファイルをチェックし、適切なURLにユーザーをリダイレクトします。これにより、大規模なリダイレクトファイルをMiddlewareにインポートすることが避けられ、すべての受信リクエストが遅くなるのを防ぎます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse, NextRequest } from 'next/server'
import { ScalableBloomFilter } from 'bloom-filters'
import GeneratedBloomFilter from './redirects/bloom-filter.json'

type RedirectEntry = {
  destination: string
  permanent: boolean
}

// 生成されたJSONファイルからブルームフィルターを初期化
const bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any)

export async function middleware(request: NextRequest) {
  // 受信リクエストのパスを取得
  const pathname = request.nextUrl.pathname

  // パスがブルームフィルターに存在するか確認
  if (bloomFilter.has(pathname)) {
    // パス名をルートハンドラーに転送
    const api = new URL(
      `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,
      request.nextUrl.origin
    )

    try {
      // ルートハンドラーからリダイレクトデータを取得
      const redirectData = await fetch(api)

      if (redirectData.ok) {
        const redirectEntry: RedirectEntry | undefined =
          await redirectData.json()

        if (redirectEntry) {
          // ステータスコードを決定
          const statusCode = redirectEntry.permanent ? 308 : 307

          // 宛先にリダイレクト
          return NextResponse.redirect(redirectEntry.destination, statusCode)
        }
      }
    } catch (error) {
      console.error(error)
    }
  }

  // リダイレクトが見つからない場合、そのままリクエストを続行
  return NextResponse.next()
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'
import { ScalableBloomFilter } from 'bloom-filters'
import GeneratedBloomFilter from './redirects/bloom-filter.json'

// 生成されたJSONファイルからブルームフィルターを初期化
const bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter)

export async function middleware(request) {
  // 受信リクエストのパスを取得
  const pathname = request.nextUrl.pathname

  // パスがブルームフィルターに存在するか確認
  if (bloomFilter.has(pathname)) {
    // パス名をルートハンドラーに転送
    const api = new URL(
      `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,
      request.nextUrl.origin
    )

    try {
      // ルートハンドラーからリダイレクトデータを取得
      const redirectData = await fetch(api)

      if (redirectData.ok) {
        const redirectEntry = await redirectData.json()

        if (redirectEntry) {
          // ステータスコードを決定
          const statusCode = redirectEntry.permanent ? 308 : 307

          // 宛先にリダイレクト
          return NextResponse.redirect(redirectEntry.destination, statusCode)
        }
      }
    } catch (error) {
      console.error(error)
    }
  }

  // リダイレクトが見つからない場合、そのままリクエストを続行
  return NextResponse.next()
}
```

</TabItem>
</Tabs>

<AppOnly>

次に、ルートハンドラーで：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/redirects/route.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import redirects from '@/app/redirects/redirects.json'

type RedirectEntry = {
  destination: string
  permanent: boolean
}

export function GET(request: NextRequest) {
  const pathname = request.nextUrl.searchParams.get('pathname')
  if (!pathname) {
    return new Response('Bad Request', { status: 400 })
  }

  // redirects.jsonファイルからリダイレクトエントリを取得
  const redirect = (redirects as Record<string, RedirectEntry>)[pathname]

  // ブルームフィルターの誤検知を考慮
  if (!redirect) {
    return new Response('No redirect', { status: 400 })
  }

  // リダイレクトエントリを返す
  return NextResponse.json(redirect)
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/redirects/route.js" switcher
import { NextResponse } from 'next/server'
import redirects from '@/app/redirects/redirects.json'

export function GET(request) {
  const pathname = request.nextUrl.searchParams.get('pathname')
  if (!pathname) {
    return new Response('Bad Request', { status: 400 })
  }

  // redirects.jsonファイルからリダイレクトエントリを取得
  const redirect = redirects[pathname]

  // ブルームフィルターの誤検知を考慮
  if (!redirect) {
    return new Response('No redirect', { status: 400 })
  }

  // リダイレクトエントリを返す
  return NextResponse.json(redirect)
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

次に、API Routeで：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/redirects.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import redirects from '@/app/redirects/redirects.json'

type RedirectEntry = {
  destination: string
  permanent: boolean
}

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const pathname = req.query.pathname
  if (!pathname) {
    return res.status(400).json({ message: 'Bad Request' })
  }

  // redirects.jsonファイルからリダイレクトエントリを取得
  const redirect = (redirects as Record<string, RedirectEntry>)[pathname]

  // ブルームフィルターの誤検知を考慮
  if (!redirect) {
    return res.status(400).json({ message: 'No redirect' })
  }

  // リダイレクトエントリを返す
  return res.json(redirect)
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/redirects.js" switcher
import redirects from '@/app/redirects/redirects.json'

export default function handler(req, res) {
  const pathname = req.query.pathname
  if (!pathname) {
    return res.status(400).json({ message: 'Bad Request' })
  }

  // redirects.jsonファイルからリダイレクトエントリを取得
  const redirect = redirects[pathname]

  // ブルームフィルターの誤検知を考慮
  if (!redirect) {
    return res.status(400).json({ message: 'No redirect' })
  }

  // リダイレクトエントリを返す
  return res.json(redirect)
}
```

</TabItem>
</Tabs>

</PagesOnly>

> **Good to know**:
>
> - ブルームフィルターを生成するには、[`bloom-filters`](https://www.npmjs.com/package/bloom-filters) のようなライブラリを使用できます；
> - ルートハンドラーへのリクエストを検証し、悪意のあるリクエストを防ぐべきです。
