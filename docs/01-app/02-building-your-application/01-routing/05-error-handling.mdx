---
title: 'エラーハンドリング'
description: '予想されるエラーを表示し、捕捉されない例外を処理する方法を学びます。'
related:
  links:
    - app/api-reference/file-conventions/error
---

エラーは2つのカテゴリに分けられます：**予想されるエラー**と**捕捉されない例外**です；

- **予想されるエラーは戻り値としてモデリングする**：Server Actions では予想されるエラーに `try`/`catch` を使用することは避けます。これらのエラーを管理し、クライアントに返すために [`useActionState`](https://react.dev/reference/react/useActionState) を使用します。
- **予期しないエラーにはエラーボーダリーを使用する**：予期しないエラーを処理し、フォールバック UI を提供するために、`error.tsx` および `global-error.tsx` ファイルを使用してエラーボーダリーを実装します。

## 予想されるエラーの処理 {#handling-expected-errors}

予想されるエラーは、通常のアプリケーション操作中に発生する可能性のあるエラーです。たとえば、[サーバーサイドのフォームバリデーション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-form-validation) や失敗したリクエストなどです。これらのエラーは明示的に処理され、クライアントに返されるべきです。

### Server Actions からの予想されるエラーの処理 {#handling-expected-errors-from-server-actions}

`useActionState` フックを使用して、サーバーアクションの状態を管理します。これにはエラー処理も含まれます。このアプローチでは、予想されるエラーに対し `try`/`catch` ブロックを使用せず、それらを例外としてスローするのではなく、戻り値としてモデリングします。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState: any, formData: FormData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '有効なメールアドレスを入力してください' }
  }

  redirect('/dashboard')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState, formData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '有効なメールアドレスを入力してください' }
  }

  redirect('/dashboard')
}
```

</TabItem>
</Tabs>

次に、アクションを `useActionState` フックに渡し、返された `state` を使用してエラーメッセージを表示します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup.tsx" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>Sign up</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup.js" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>Sign up</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

返された状態を使用して、クライアントコンポーネントからトーストメッセージを表示することもできます。

### サーバーコンポーネントからの予想されるエラーの処理 {#handling-expected-errors-from-server-components}

Server Component 内でデータをフェッチする際には、レスポンスを利用してエラーメッセージを条件付きでレンダリングするか、[`redirect`](/docs/app/building-your-application/routing/redirecting#redirect-function) することができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  const res = await fetch(`https://...`)
  const data = await res.json()

  if (!res.ok) {
    return 'エラーが発生しました。'
  }

  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  const res = await fetch(`https://...`)
  const data = await res.json()

  if (!res.ok) {
    return 'エラーが発生しました。'
  }

  return '...'
}
```

</TabItem>
</Tabs>

## 捕捉されない例外 {#uncaught-exceptions}

捕捉されない例外は、アプリケーションの通常の流れの中で発生することが予期されないバグや問題を示すエラーです。これらはエラーとしてスローされ、エラーボーダリーによって捕捉されるべきです。

- **一般的な処理**: root レイアウト以下で、`error.js` で捕捉されなかったエラーを処理します。
- **オプショナル**: ネストされた `error.js` ファイルで細かく捕捉されなかったエラーを処理します（例：`app/dashboard/error.js`）。
- **非一般的な処理**: root レイアウト内で捕捉されなかったエラーを `global-error.js` で処理します。

### エラーボーダリーの使用 {#using-error-boundaries}

Next.js はエラーボーダリーを使用して捕捉されない例外を処理します。エラーボーダリーは、その子コンポーネント内のエラーをキャッチし、クラッシュしたコンポーネントツリーの代わりにフォールバック UI を表示します。

ルートセグメント内に `error.tsx` ファイルを追加し、React コンポーネントをエクスポートしてエラーボーダリーを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/error.tsx" switcher
'use client' // エラーボーダリーはクライアントコンポーネントである必要があります

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // エラーをエラーレポーティングサービスにログします
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>問題が発生しました！</h2>
      <button
        onClick={
          // セグメントを再レンダリングして回復を試みます
          () => reset()
        }
      >
        再試行
      </button>
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/error.js" switcher
'use client' // エラーボーダリーはクライアントコンポーネントである必要があります

import { useEffect } from 'react'

export default function Error({ error, reset }) {
  useEffect(() => {
    // エラーをエラーレポーティングサービスにログします
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>問題が発生しました！</h2>
      <button
        onClick={
          // セグメントを再レンダリングして回復を試みます
          () => reset()
        }
      >
        再試行
      </button>
    </div>
  )
}
```

</TabItem>
</Tabs>

親エラーボーダリーにエラーをバブルアップさせたい場合は、`error` コンポーネントをレンダリングする際に `throw` できます。

### ネストされたルート内のエラー処理 {#handling-errors-in-nested-routes}

エラーは最も近い親エラーボーダリーまでバブルアップします。これにより、[ルート階層](/docs/app/building-your-application/routing#component-hierarchy)の異なるレベルに `error.tsx` ファイルを配置することで、細かいエラーハンドリングが可能になります。

<Image
  alt="ネストされたエラーコンポーネントの階層"
  srcLight="/docs/light/nested-error-component-hierarchy.png"
  srcDark="/docs/dark/nested-error-component-hierarchy.png"
  width="1600"
  height="687"
/>

### グローバルエラーの処理 {#handling-global-errors}

非一般的ですが、root アプリディレクトリにある `app/global-error.js` を使用して、root レイアウトでエラーを処理できます。これは、[国際化](/docs/app/building-your-application/routing/internationalization) を活用している場合でもです。グローバルエラー UI は独自の `<html>` および `<body>` タグを定義する必要があります。アクティブなとき、root レイアウトまたはテンプレートを置き換えるためです。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/global-error.tsx" switcher
'use client' // エラーボーダリーはクライアントコンポーネントである必要があります

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    // global-error はhtmlとbodyタグを含む必要があります
    <html>
      <body>
        <h2>問題が発生しました！</h2>
        <button onClick={() => reset()}>再試行</button>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/global-error.js" switcher
'use client' // エラーボーダリーはクライアントコンポーネントである必要があります

export default function GlobalError({ error, reset }) {
  return (
    // global-error はhtmlとbodyタグを含む必要があります
    <html>
      <body>
        <h2>問題が発生しました！</h2>
        <button onClick={() => reset()}>再試行</button>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>
