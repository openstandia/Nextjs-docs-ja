---
title: 'リンクとナビゲーション'
description: 'Next.jsでのナビゲーションの仕組みと、Linkコンポーネントや `useRouter` フックの使い方を学びましょう。'
related:
  links:
    - 'app/building-your-application/caching'
    - 'app/api-reference/config/typescript'
---

Next.jsでルート間をナビゲートする方法は4つあります：

- [`<Link>`コンポーネント](#link-component)を使う
- [`useRouter` フック](#userouter-hook)を使う（[Client Components](/docs/app/building-your-application/rendering/client-components)）
- [`redirect` 関数](#redirect-function)を使う（[Server Components](/docs/app/building-your-application/rendering/server-components)）
- ネイティブの[History API](#using-the-native-history-api)を使う

このページでは、それぞれの方法の使い方を紹介し、ナビゲーションの仕組みを詳しく説明します。

## `<Link>` コンポーネント {#link-component}

`<Link>` はHTMLの `<a>` タグを拡張し、[プリフェッチ](#2-prefetching)とクライアントサイドのルート間ナビゲーションを提供する組み込みコンポーネントです。これはNext.jsでルート間を移動するための主要でお勧めの方法です。

`next/link` からインポートし、コンポーネントに `href` prop を渡すことで使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

`<Link>`に渡すことができる他のオプションの`props`については、[APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()` フック {#userouter-hook}

`useRouter` フックを使用すると、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラムでルートを変更できます。

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

`useRouter` メソッドの全リストは、[APIリファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **推奨：** `useRouter` を使用する特定の要件がない限り、ルート間を移動するには `<Link>` コンポーネントを使用してください。

## `redirect` 関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)には、代わりに `redirect` 関数を使用します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **参考情報**:
>
> - `redirect` はデフォルトで307（Temporary Redirect）ステータスコードを返します。Server Actionで使用されると、POSTリクエストの結果として成功ページへのリダイレクトによく使われる303（See Other）を返します。
> - `redirect` は内部的にエラーを投げるため、`try/catch` ブロックの外で呼び出す必要があります。
> - `redirect` は描画処理中のClient Componentsで呼び出すことができますが、イベントハンドラーではできません。代わりに[`useRouter` フック](#userouter-hook)を使用できます。
> - `redirect` は絶対URLを受け入れるので、外部リンクへのリダイレクトに使用できます。
> - 描画プロセスの前にリダイレクトしたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs)または[Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)を使用してください。

詳細は[`redirect` APIリファレンス](/docs/app/api-reference/functions/redirect)を参照してください。

## ネイティブのHistory APIを使う {#using-the-native-history-api}

Next.jsはネイティブの[`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)と[`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState)メソッドを使用して、ページを再読み込みせずにブラウザの履歴スタックを更新できます。

`pushState`と`replaceState`の呼び出しはNext.js Routerに統合され、[`usePathname`](/docs/app/api-reference/functions/use-pathname)や[`useSearchParams`](/docs/app/api-reference/functions/use-search-params)と同期することができます。

### `window.history.pushState` {#window-history-pushstate}

ブラウザの履歴スタックに新しいエントリを追加するために使用します。ユーザーは以前の状態に戻ることができます。例えば、製品リストを並べ替える場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

ブラウザの履歴スタックの現在のエントリを置き換えるために使用します。ユーザーは以前の状態に戻ることはできません。例えば、アプリケーションのロケールを切り替える場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // e.g. '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // e.g. '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの仕組み {#how-routing-and-navigation-works}

App Routerは、ルーティングとナビゲーションにおいてハイブリッドアプローチを使用しています。サーバーでは、アプリケーションコードが自動的にルートセグメントごとに[コードスプリット](#1-code-splitting)されます。そしてクライアントでは、Next.jsはルートセグメントを[プリフェッチ](#2-prefetching)し、[キャッシュ](#3-caching)します。これにより、ユーザーが新しいルートに移動したとき、ブラウザはページを再読み込みせず、変更されたルートセグメントのみが再レンダリングされるため、ナビゲーションの体験とパフォーマンスが向上します。

### 1. コードスプリッティング {#1-code-splitting}

コードスプリッティングは、アプリケーションコードをブラウザによってダウンロードおよび実行される小さなバンドルに分割できるようにします。これにより、各リクエストで転送されるデータ量と実行時間が削減され、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components)は、アプリケーションコードを自動的にルートセグメントごとにコードスプリットできるようにします。これにより、ナビゲーション時に現在のルートに必要なコードのみがロードされます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチは、ユーザーがそのルートを訪れる前にバックグラウンドでルートを事前にロードする方法です。

Next.jsでルートがプリフェッチされる方法は2つあります：

- **`<Link>`コンポーネント**：ルートはユーザーのビューポートに表示されると自動的にプリフェッチされます。ページが最初にロードされたとき、またはスクロールを通じてビューに入ったときにプリフェッチが行われます。
- **`router.prefetch()`**：`useRouter` フックを使用してプログラムでルートをプリフェッチできます。

`<Link>` のデフォルトのプリフェッチ動作（つまり、`prefetch` prop が指定されていないか `null` に設定されている場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用に依存して異なります。共有レイアウトのみがプリフェッチおよび`30秒`キャッシュされ、その下にあるコンポーネントのレンダリングされた"tree"までは、`loading.js`ファイルまでです。これにより、完全な動的ルートのフェッチのコストが削減され、ユーザーにより良い視覚的フィードバックを与えるために[瞬時のロード状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示できます。

`prefetch` prop を `false` に設定してプリフェッチを無効にすることができます。あるいは、`prefetch` prop を `true` に設定して、ローディング境界を超えて完全なページデータをプリフェッチできます。

詳細は[`<Link>` APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

> **参考情報**:
>
> - プリフェッチは、開発環境では有効ではなく、本番環境でのみ有効です。

### 3. キャッシング {#3-caching}

Next.jsは、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)と呼ばれる**インメモリーのクライアントサイドキャッシュ**を持っています。ユーザーがアプリをナビゲートするにつれて、[プリフェッチ](#2-prefetching)されたルートセグメントと訪問したルートのReact Server Componentペイロードがキャッシュに保存されます。

これにより、ナビゲーション時にキャッシュができる限り再利用され、新しいリクエストをサーバーに送信する代わりに、パフォーマンスが向上し、要求と転送されるデータの数が削減されます。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の働きや設定の方法について、詳細を学びましょう。

### 4. 部分レンダリング {#4-partial-rendering}

部分レンダリングとは、ナビゲーション時に変更されたルートセグメントのみがクライアントで再レンダリングされ、共有セグメントが保持されることを意味します。

たとえば、2つの兄弟ルート、`/dashboard/settings` と `/dashboard/analytics` との間を移動する場合、`settings` ページがアンマウントされ、`analytics` ページが新しい状態でマウントされ、共有された`dashboard` レイアウトが保持されます。この動作は同じ動的セグメント上の2つのルートでも存在します。たとえば、`/blog/[slug]/page` から `/blog/first` から `/blog/second` へのナビゲーションの場合です。

<Image
  alt="部分レンダリングの仕組み"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

部分レンダリングがない場合、各ナビゲーションがクライアントでページ全体を再レンダリングすることになります。変更されるセグメントのみをレンダリングすることで、転送されるデータ量と実行時間が削減され、パフォーマンスが向上します。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザはページ間の移動時に「ハードナビゲーション」を行います。Next.jsのApp Routerはページ間の「ソフトナビゲーション」を可能にし、変更されたルートセグメントのみが再レンダリング（部分レンダリング）されるようにします。これにより、ナビゲーション中のクライアントのReactの状態が保持されます。

### 6. 戻ると進むナビゲーション {#6-back-and-forward-navigation}

デフォルトで、Next.jsは戻ると進むナビゲーションのためにスクロール位置を保持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)でルートセグメントを再利用します。

### 7. `pages/` と `app/` の間のルーティング {#7-routing-between-pages-and-app}

`pages/` から `app/` への段階的な移行中、Next.jsルーターは自動的に両者間のハードナビゲーションを処理します。`pages/` から `app/` への移行を検出するために、アプリルートの確率的チェックを活用するクライアントルーターフィルターがあり、まれに誤検知が発生することがあります。デフォルトでは、そのような誤検知は非常にまれであるはずです。私たちは、誤検知の可能性を 0.01% に設定しています。この可能性は `next.config.js` の `experimental.clientRouterFilterAllowedRate` オプションでカスタマイズできます。誤検知率を下げることを主張すると、クライアントバンドルで生成されるフィルターのサイズが増加します。

また、自分で `pages/` と `app/` 間のルーティングを完全に管理したい場合は、`next.config.js` にて、`experimental.clientRouterFilter` をfalseに設定することでこの処理を無効化できます。この機能が無効になっている場合、アプリルートと重複するページ内の動的ルートは、デフォルトでは正しくナビゲートされません。
