---
title: 'リンクとナビゲーション'
description: 'Next.jsでのナビゲーション方法、Linkコンポーネントと`useRouter`フックの使用方法を学びます。'
related:
  links:
    - 'app/building-your-application/caching'
    - 'app/api-reference/config/typescript'
---

Next.jsでは、ルート間を移動する方法が4つあります；

- [`<Link>`コンポーネント](#link-component)を使用
- [`useRouter`フック](#userouter-hook)を使用（[Client Components](/docs/app/building-your-application/rendering/client-components)）
- [`redirect`関数](#redirect-function)を使用（[Server Components](/docs/app/building-your-application/rendering/server-components)）
- ネイティブの[History API](#using-the-native-history-api)を使用

このページでは、これらの各オプションの使い方を説明し、ナビゲーションがどのように機能するかをさらに詳しく説明します。

## `<Link>`コンポーネント {#link-component}

`<Link>`は組み込みコンポーネントで、HTML `<a>`タグを拡張して、[プレフェッチ](#2-prefetching)とクライアントサイドのルート間ナビゲーションを提供します。Next.jsでルート間を移動するための主要かつ推奨される方法です。

`next/link`からインポートし、コンポーネントに`href`プロップを渡すことで使用できます；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

`<Link>`に渡せる他のオプションのプロップもあります。詳細は[APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()`フック {#userouter-hook}

`useRouter`フックは、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラムでルートを変更することができます；

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

`useRouter`メソッドの完全なリストは、[APIリファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **推奨事項**: 特別な要件がない限り、ルート間を移動するには`<Link>`コンポーネントを使用してください。

## `redirect`関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)では、代わりに`redirect`関数を使用します；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **知っておくと良いこと**:
>
> - `redirect`はデフォルトで307（Temporary Redirect）のステータスコードを返します。Server Actionで使用される場合、POSTリクエストの結果として成功ページにリダイレクトする際によく使用される303（See Other）を返します；
> - `redirect`は内部でエラーをスローするため、`try/catch`ブロックの外で呼び出す必要があります；
> - `redirect`はRenderingプロセス中にClient Componentsで呼び出すことができますが、イベントハンドラーではできません；その場合は[`useRouter`フック](#userouter-hook)を使用してください；
> - `redirect`は絶対的なURLも受け入れ、外部リンクへのリダイレクトに使用できます；
> - Renderingプロセスの前にリダイレクトを行いたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs)または[Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)を使用してください；

詳細は[`redirect` APIリファレンス](/docs/app/api-reference/functions/redirect)を参照してください。

## ネイティブHistory APIの使用 {#using-the-native-history-api}

Next.jsではネイティブの[`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)と[`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState)メソッドを使用して、ページを再読み込みせずにブラウザの履歴スタックを更新することができます。

`pushState`と`replaceState`の呼び出しはNext.js Routerに統合され、[`usePathname`](/docs/app/api-reference/functions/use-pathname)や[`useSearchParams`](/docs/app/api-reference/functions/use-search-params)と同期することができます。

### `window.history.pushState` {#window-history-pushstate}

ブラウザの履歴スタックに新しいエントリを追加します。ユーザーは前の状態に戻ることができます。例として、製品リストのソートをするには；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

ブラウザの履歴スタックの現在のエントリを置き換えます。ユーザーは前の状態に戻ることはできません。例として、アプリケーションのロケールを切り替えるには；

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // 例: '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // 例: '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの仕組み {#how-routing-and-navigation-works}

App Routerはルーティングとナビゲーションのためにハイブリッドなアプローチを採用しています。サーバー上で、アプリケーションコードはルートセグメントによって自動的に[コード分割](#1-code-splitting)されます。そして、クライアント上で、Next.jsはルートセグメントを[プレフェッチ](#2-prefetching)し、[キャッシュ](#3-caching)します。これにより、ユーザーが新しいルートに移動するとき、ブラウザはページを再読み込みせず、変更があるルートセグメントのみが再レンダリングされるため、ナビゲーション体験とパフォーマンスが向上します；

### 1. コード分割 {#1-code-splitting}

コード分割により、アプリケーションコードをより小さなバンドルに分割し、ブラウザがダウンロードして実行することができます。これにより、転送されるデータとリクエストごとの実行時間が減少し、パフォーマンスが向上します；

[Server Components](/docs/app/building-your-application/rendering/server-components)により、アプリケーションコードはルートセグメントごとに自動的にコード分割されます。これにより、ナビゲーション時には現在のルートに必要なコードのみが読み込まれます；

### 2. プレフェッチ {#2-prefetching}

プレフェッチは、ユーザーが訪れる前にバックグラウンドでルートを事前に読み込みする方法です。

Next.jsではルートがプレフェッチされる方法は2つあります；

- **`<Link>`コンポーネント**: ユーザーのビューポートに表示されるとルートが自動的にプレフェッチされます。ページの最初のロード時またはスクロールによってビューポートに表示されるときにプレフェッチが行われます。
- **`router.prefetch()`**: `useRouter`フックを使用してプログラムでルートをプレフェッチすることができます。

`<Link>`のデフォルトのプレフェッチ動作（`prefetch`プロップが指定されていないか`null`に設定されている場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用によって異なります。root レイアウトから最初の`loading.js`ファイルまでのレンダリングされた "tree"の共有レイアウトのみが、プレフェッチされキャッシュされます；これは、動的ルートを完全にフェッチするコストを削減し、ユーザーにより良いビジュアルフィードバックを提供するための[即時ロード状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示できることを意味します；

プレフェッチを無効にするには`prefetch`プロップを`false`に設定します。代わりに`prefetch`プロップを`true`に設定することで、loading境界を超えた完全なページデータをプレフェッチすることができます；

詳細は[`<Link>` APIリファレンス](/docs/app/api-reference/components/link)を参照してください；

> **知っておくと良いこと**:
>
> - プレフェッチは開発時に無効で、本番環境でのみ有効になります；

### 3. キャッシング {#3-caching}

Next.jsは、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)と呼ばれる**クライアントサイドのメモリ内キャッシュ**を持っています。ユーザーがアプリ内をナビゲーションする際、[プレフェッチ](#2-prefetching)されたルートセグメントと訪問したルートのReact Server Component Payloadはキャッシュ内に保存されます。

これにより、ナビゲーション時には新たなサーバーへのリクエストを行う代わりにキャッシュができる限り再利用され、リクエスト数と転送データ量を減少させることでパフォーマンスが向上します。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の動作と設定方法について詳しく学んでください；

### 4. 部分的レンダリング {#4-partial-rendering}

部分的レンダリングでは、ナビゲーション時に変更のあるルートセグメントだけがクライアント上で再レンダリングされ、共有されたセグメントは保持されます；

例えば、2つの兄弟ルート`/dashboard/settings`から`/dashboard/analytics`にナビゲーションすると、`settings`ページがアンマウントされ、`analytics`ページが新しい状態でマウントされ、共有された`dashboard`レイアウトは保持されます。この動作は2つのルートが同じdynamic route segmentにある場合でも見られます；例えば、`/blog/[slug]/page`から`/blog/first`から`/blog/second`へのナビゲーションです。

<Image
  alt="部分的レンダリングの動作"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

部分的レンダリングがない場合、各ナビゲーションはクライアント上でページ全体の再レンダリングを引き起こします。変更部分だけをレンダリングすることでデータ転送量と実行時間を減少させ、パフォーマンスの向上につながります；

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザはページ間のナビゲーションを「ハードナビゲーション」として実行します。Next.js App Routerはルートセグメントの変更だけを再レンダリング（部分的レンダリング）する「ソフトナビゲーション」を有効にすることで、ナビゲーション中のクライアントのReact状態を保持します；

### 6. 戻ると進むナビゲーション {#6-back-and-forward-navigation}

デフォルトで、Next.jsは前後のナビゲーション時にスクロール位置を維持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)内のルートセグメントを再利用します；

### 7. `pages/` と `app/` 間のルーティング {#7-routing-between-pages-and-app}

`pages/`から`app/`への段階的な移行中、Next.js routerは2つの間のハードナビゲーションを自動的に処理します。`pages/`から`app/`への遷移を検出するため、クライアントルーターがアプリルートの確率的検査を利用して検出するフィルタを使用します；これには誤検知が発生することもあります。デフォルトでは、そのような発生は非常に稀であるべきです；誤検知の発生確率を0.01%に設定しているためです。この確率は`next.config.js`内の`experimental.clientRouterFilterAllowedRate`オプションを通じてカスタマイズできます。誤検知率を下げると生成されるクライアントバンドル内のフィルタサイズが大きくなることを覚えておいてください。

また、`experimental.clientRouterFilter`を`false`に設定してこの処理を完全に無効にし、`pages/`と`app/`間のルーティングを手動で管理することもできます；この機能が無効になっている場合、`pages`内で`app`ルートとオーバーラップする動的ルートがある場合、それらはデフォルトでは正しくナビゲートされません。
