---
title: 'リンクとナビゲーション'
description: 'Next.jsでのナビゲーションの仕組み、およびLinkコンポーネントと`useRouter`フックの使用方法を学びましょう。'
related:
  links:
    - 'app/building-your-application/caching'
    - 'app/api-reference/config/typescript'
---

Next.jsでルート間をナビゲートする方法は4つあります：

- [`<Link>` コンポーネントを使用する](#link-component)
- [`useRouter`フックを使用する](#userouter-hook) ([Client Components](/docs/app/building-your-application/rendering/client-components))
- [`redirect` 関数を使用する](#redirect-function) ([Server Components](/docs/app/building-your-application/rendering/server-components))
- ネイティブの[History APIを使用する](#using-the-native-history-api)

このページでは、これらの方法を使う方法について説明し、ナビゲーションの仕組みを深く掘り下げます。

## `<Link>` コンポーネント {#link-component}

`<Link>` は、HTML `<a>` タグを拡張して[プリフェッチ](#2-prefetching)とクライアントサイドのルート間のナビゲーションを提供する組み込みコンポーネントです。Next.jsでルート間をナビゲートするための主要で推奨される方法です。

`next/link` からインポートし、コンポーネントに `href` prop を渡して使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">ダッシュボード</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">ダッシュボード</Link>
}
```

</TabItem>
</Tabs>

他のオプションのpropsも`<Link>`に渡すことができます。詳細は[API リファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()` フック {#userouter-hook}

`useRouter` フックを使用すると、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラム的にルートを変更できます。

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      ダッシュボード
    </button>
  )
}
```

`useRouter` メソッドの完全なリストは、[API リファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **推奨事項：** ルート間のナビゲーションには、特定の要件がない限り、`useRouter` を使用するよりも`<Link>`コンポーネントを使用してください。

## `redirect` 関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)では、代わりに`redirect`関数を使用します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **知っておくと便利**:
>
> - `redirect` はデフォルトで307 (一時的リダイレクト) ステータスコードを返します。Server Actionで使用されると、POSTリクエストの結果としてよく使用される303 (他を参照) を返します。
> - `redirect` は内部でエラーをスローするため、`try/catch` ブロックの外で呼び出す必要があります。
> - `redirect` はクライアントコンポーネントのレンダリング時に呼び出すことができますが、イベントハンドラ内では使用できません。代わりに[`useRouter`フック](#userouter-hook)を使用できます。
> - `redirect` は絶対URLも受け入れることができ、外部リンクへのリダイレクトに使用できます。
> - レンダリングプロセスの前にリダイレクトしたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs) または [Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)を使用してください。

[`redirect` API リファレンス](/docs/app/api-reference/functions/redirect)で詳細情報を参照してください。

## ネイティブの History API を使用する {#using-the-native-history-api}

Next.jsでは、ページをリロードせずにブラウザの履歴スタックを更新するために、ネイティブの [`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) 及び [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) メソッドを使用できます。

`pushState` と `replaceState` の呼び出しはNext.js Routerに統合され、[`usePathname`](/docs/app/api-reference/functions/use-pathname)や[`useSearchParams`](/docs/app/api-reference/functions/use-search-params)と同期が取れます。

### `window.history.pushState` {#window-history-pushstate}

ブラウザの履歴スタックに新しいエントリを追加するために使用します。ユーザーは前の状態に戻ることができます。例えば、製品を並べ替える場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>昇順で並べ替え</button>
      <button onClick={() => updateSorting('desc')}>降順で並べ替え</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>昇順で並べ替え</button>
      <button onClick={() => updateSorting('desc')}>降順で並べ替え</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

ブラウザの履歴スタックの現在のエントリを置き換えるために使用します。ユーザーは前の状態に戻ることができません。例えば、アプリケーションの言語を切り替える場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // 例: '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>英語</button>
      <button onClick={() => switchLocale('fr')}>フランス語</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // 例: '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>英語</button>
      <button onClick={() => switchLocale('fr')}>フランス語</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの仕組み {#how-routing-and-navigation-works}

App Routerは、ルーティングとナビゲーションにハイブリッドアプローチを使用しています。サーバー上で、アプリケーションコードはルートセグメントによって自動的に[コード分割](#1-code-splitting)されています。そして、クライアント上で、Next.jsはルートセグメントを[プリフェッチ](#2-prefetching)し[キャッシュ](#3-caching)します。これにより、ユーザーが新しいルートへナビゲートする際、ブラウザはページをリロードせず、変更されたルートセグメントのみが再レンダリングされるため、ナビゲーションの体験とパフォーマンスを向上させます。

### 1. コード分割 {#1-code-splitting}

コード分割により、アプリケーションコードを小さなバンドルに分割して、ブラウザがダウンロードおよび実行できるようにします。これにより、各リクエストのデータ転送量と実行時間が削減され、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components) を使用すると、アプリケーションコードはルートセグメントによって自動的にコード分割されます。これにより、ナビゲーション時には現在のルートに必要なコードのみが読み込まれます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチは、ユーザーがルートを訪れる前にバックグラウンドでルートを事前に読み込む方法です。

Next.jsでは、以下の2つの方法でルートがプリフェッチされます：

- **`<Link>` コンポーネント**：ルートはユーザーのビューポートに表示されると自動的にプリフェッチされます。プリフェッチはページが最初に読み込まれたとき、またはスクロールによって表示されたときに行われます。
- **`router.prefetch()`**： `useRouter` フックを使用してプログラム的にルートをプリフェッチできます。

`<Link>` のデフォルトのプリフェッチ動作（つまり、`prefetch` プロップが指定されていないか `null` に設定されている場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用状況に応じて異なります。共有レイアウトのみがプリフェッチされ、キャッシュされ、`30秒`間`読み取り専用`です。これは動的ルート全体のフェッチコストを削減し、ユーザーにより良いビジュアルフィードバックを提供するために[インスタントのロード状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示できることを意味します。

プリフェッチを無効にするには、`prefetch` プロップを `false` に設定します。また、特定のロード境界を超えた完全なページデータをプリフェッチするには、`prefetch` プロップを `true` に設定します。

[`<Link>` API リファレンス](/docs/app/api-reference/components/link)で詳細情報を参照してください。

> **知っておくと便利**:
>
> - プリフェッチは開発環境では有効にされず、本番環境でのみ有効です。

### 3. キャッシュ {#3-caching}

Next.jsには、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)と呼ばれる**クライアント側のメモリ内キャッシュ**があります。ユーザーがアプリ内をナビゲートすると、[プリフェッチ](#2-prefetching)されたルートセグメントと訪れたルートのサーバーコンポーネントペイロードがキャッシュに保存されます。

これにより、ナビゲーション時には可能な限りキャッシュを再利用して、新しいリクエストをサーバーに送信する必要がなくなるため、要求とデータ転送の数が削減され、パフォーマンスが向上します。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の動作方法と設定方法について詳細情報を学びましょう。

### 4. パーシャルレンダリング {#4-partial-rendering}

パーシャルレンダリングは、ナビゲーション時に変更されたルートセグメントのみがクライアント上で再レンダリングされ、共有されたセグメントは保持されることを意味します。

例えば、`/dashboard/settings` と `/dashboard/analytics` という2つの兄弟ルート間をナビゲートする場合、`settings` ページはアンマウントされ、`analytics` ページは新しい状態でマウントされ、共有された `dashboard` レイアウトは維持されます。この動作は、`/blog/[slug]/page` と `/blog/first` から `/blog/second` にナビゲートするときの同じ動的セグメントの2つのルート間でも表示されます。

<Image
  alt="パーシャルレンダリングの仕組み"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

パーシャルレンダリングなしでは、各ナビゲーションでクライアント上のページ全体が再レンダリングされてしまいます。変更されたセグメントのみをレンダリングすることで、データの転送量と実行時間が削減され、パフォーマンスが向上します。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザはページ間のナビゲーション時に「ハードナビゲーション」を実行します。Next.js App Router は、ページ間で「ソフトナビゲーション」を有効にし、変更されたルートセグメントのみが再レンダリングされる（パーシャルレンダリング）ことを保証します。これにより、ナビゲーション中にクライアントのReactの状態が保持されます。

### 6. 押戻しナビゲーション {#6-back-and-forward-navigation}

デフォルトでは、Next.jsは押し戻しナビゲーションにスクロール位置を保持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)内のルートセグメントを再利用します。

### 7. `pages/` と `app/` のルート間のルーティング {#7-routing-between-pages-and-app}

`pages/` から `app/` への漸進的な移行時に、Next.js Router は両者間のハードナビゲーションを自動的に処理します。`pages/` から `app/` への遷移を検出するために、クライアントルーターフィルターが app ルートの確率的なチェックを利用し、場合によっては誤検知が発生する可能性があります。デフォルトではこのような誤検知は非常に稀であるべきですが、0.01% の誤検知率が設定されています。この確率は、`next.config.js` の `experimental.clientRouterFilterAllowedRate` オプションを使用してカスタマイズできます。誤検知率を下げるとクライアントバンドルで生成されるフィルターのサイズが増えます。

あるいは、この処理を完全に無効にし、`pages/` と `app/` のルーティングを手動で管理したい場合は、`next.config.js` 内で `experimental.clientRouterFilter` を false に設定できます。この機能が無効の場合、app ルートと重複するページ内の動的ルートはデフォルトでは正しくナビゲートされません。
