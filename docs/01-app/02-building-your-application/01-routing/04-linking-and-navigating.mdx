---
title: 'リンクとナビゲーション'
description: 'Next.jsにおけるナビゲーションの仕組みと、Linkコンポーネントや`useRouter`フックの使い方について学びます；'
related:
  links:
    - app/building-your-application/caching
    - app/api-reference/config/typescript
---

Next.jsでは、ルート間を移動するための方法が4つあります：

- [`<Link>`コンポーネント](#link-component)を使用する
- [`useRouter`フック](#userouter-hook)を使用する（[Client Components](/docs/app/building-your-application/rendering/client-components)）
- [`redirect`関数](#redirect-function)を使用する（[Server Components](/docs/app/building-your-application/rendering/server-components)）
- ネイティブの[History API](#using-the-native-history-api)を使用する

このページでは、それぞれのオプションの使用方法と、ナビゲーションがどのように機能するかについて詳しく説明します。

## `<Link>`コンポーネント {#link-component}

`<Link>`は、HTMLの`<a>`タグを拡張して[プリフェッチ](#2-prefetching)とクライアントサイドのナビゲーションを提供する組み込みのコンポーネントです。Next.jsでルート間を移動する際の主要で推奨される方法です。

`next/link`からインポートして、コンポーネントに`href`プロップを渡して使用します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

`<Link>`に渡すことができる他のオプションのプロップもあります。詳しくは[APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()`フック {#userouter-hook}

`useRouter`フックを使うと、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラムでルートを変更できます。

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

`useRouter`のメソッドの完全なリストについては、[APIリファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **推奨事項:** 特定の要件がない限り、ルート間を移動するためには`<Link>`コンポーネントを使用してください。

## `redirect`関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)の場合は、代わりに`redirect`関数を使用します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }: { params: { id: string } }) {
  const team = await fetchTeam(params.id)
  if (!team) {
    redirect('/login')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const team = await fetchTeam(params.id)
  if (!team) {
    redirect('/login')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - `redirect`はデフォルトで307（Temporary Redirect）ステータスコードを返します。Server Actionで使用すると、303（See Other）を返し、これはPOSTリクエストの結果として成功ページにリダイレクトするために一般的に使用されます；
> - `redirect`は内部でエラーをスローするため、`try/catch`ブロックの外で呼び出す必要があります；
> - `redirect`はClient Componentsのレンダリングプロセス中に呼び出すことができますが、イベントハンドラでは呼び出せません。代わりに[`useRouter`フック](#userouter-hook)を使用できます；
> - `redirect`は絶対URLも受け入れ、外部リンクへのリダイレクトにも使用できます；
> - レンダリングプロセスの前にリダイレクトを行いたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs)または[Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)を使用してください；

詳細については、[`redirect` APIリファレンス](/docs/app/api-reference/functions/redirect)を参照してください。

## ネイティブHistory APIの使用 {#using-the-native-history-api}

Next.jsでは、ネイティブの[`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)と[`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState)メソッドを使用して、ページをリロードせずにブラウザの履歴スタックを更新できます。

`pushState`と`replaceState`の呼び出しはNext.js Routerに統合され、[`usePathname`](/docs/app/api-reference/functions/use-pathname)や[`useSearchParams`](/docs/app/api-reference/functions/use-search-params)と同期を取れるようにします。

### `window.history.pushState` {#window-history-pushstate}

ブラウザの履歴スタックに新しいエントリを追加するために使用します。ユーザーは前の状態に戻ることができます。例えば、商品のリストを並べ替える場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

ブラウザの履歴スタックの現在のエントリを置き換えるために使用します。ユーザーは前の状態に戻ることができません。例えば、アプリケーションのロケールを切り替える場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // 例: '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // 例: '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの仕組み {#how-routing-and-navigation-works}

App Routerは、ルーティングとナビゲーションにハイブリッドアプローチを使用します。サーバー上では、アプリケーションコードがルートセグメントごとに自動的に[コードスプリット](#1-code-splitting)されます。クライアント側では、Next.jsがルートセグメントを[プリフェッチ](#2-prefetching)し、[キャッシュ](#3-caching)します。これにより、ユーザーが新しいルートに移動するときにブラウザはページをリロードせず、変更されたルートセグメントのみが再レンダーされ、ナビゲーション体験とパフォーマンスが向上します。

### 1. コードスプリッティング {#1-code-splitting}

コードスプリッティングにより、アプリケーションコードを小さなバンドルに分割し、ブラウザによってダウンロードと実行が行われます。これにより、データ転送量とリクエストごとの実行時間が短縮され、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components)は、アプリケーションコードをルートセグメントごとに自動的にコードスプリットされるようにします。これにより、ナビゲーション時に必要なコードだけが読み込まれます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチは、ユーザーが訪問する前にバックグラウンドでルートを事前に読み込む方法です。

Next.jsでは、ルートがプリフェッチされる方法が2つあります：

- **`<Link>`コンポーネント**：ルートはユーザーのビューポートに表示されたときに自動的にプリフェッチされます。ページの初回読み込み時やスクロールで表示されるときにプリフェッチが行われます。
- **`router.prefetch()`**：`useRouter`フックを使用してルートをプログラム的にプリフェッチすることができます；

`<Link>`のデフォルトのプリフェッチ動作（`prefetch`プロップを指定しないか`null`に設定した場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用方法によって異なります。共有レイアウトのみがプリフェッチされ、"tree"のレンダリングされたコンポーネントまで第1の`loading.js`ファイルがキャッシュされ、30秒間保存されます。これにより、ダイナミックルート全体を取得するコストが削減され、ユーザーに対するビジュアルフィードバックを改善するために[即時ロード状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示することができます；

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定します。あるいは`prefetch`プロップを`true`に設定して、ロードする境界を超えて完全なページデータをプリフェッチすることもできます；

詳しくは、[`<Link>` APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

> **Good to know**:
>
> - プリフェッチは開発環境では有効になっておらず、本番環境でのみ有効です；

### 3. キャッシュ {#3-caching}

Next.jsには、**インメモリクライアントサイドキャッシュ**である[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)が備わっています。アプリケーション内を移動するにつれて、[プリフェッチ](#2-prefetching)されたルートセグメントと訪問したルートのReactサーバーコンポーネントペイロードがキャッシュに保存されます。

これにより、ナビゲーション時にできるだけキャッシュが再利用され、新たにサーバーへのリクエストを行う代わりに必要となるリクエストと転送されるデータ量が削減されることで、パフォーマンスが向上します；

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の仕組みについての詳細やその設定方法について学んでください；

### 4. パーシャルレンダリング {#4-partial-rendering}

パーシャルレンダリングは、ナビゲーションの際に変更されたルートセグメントのみがクライアントで再レンダリングされ、共有されたセグメントが保持されることを意味します。

たとえば、2つの兄弟ルート`/dashboard/settings`と`/dashboard/analytics`間で移動する場合、`settings`ページがアンマウントされ`analytics`ページが新たな状態でマウントされ、共有されている`dashboard`レイアウトは保持されます。この動作は、`/blog/[slug]/page`と`/blog/first`から`/blog/second`へのナビゲーションを含む同じダイナミックセグメント上の2つのルートの間でも存在します。

<Image
  alt="パーシャルレンダリングのしくみ"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

パーシャルレンダリングがなければ、各ナビゲーションごとに、クライアント側でページ全体が再レンダリングされることになります。変化したセグメントだけをレンダリングすることで、転送されるデータの量と実行時間が短縮され、パフォーマンスが向上します。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザはページ間のナビゲーションを「ハードナビゲーション」として扱います。Next.jsのApp Routerは、ページ間の「ソフトナビゲーション」を有効にし、変化したルートセグメントのみを再レンダリング（パーシャルレンダリング）することを保証します。これにより、ナビゲーション時にクライアントのReact stateを保持することができます。

### 6. 戻ると進むのナビゲーション {#6-back-and-forward-navigation}

デフォルトでは、Next.jsは戻ると進むのナビゲーションの際にスクロール位置を維持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)内のルートセグメントを再利用します。

### 7. `pages/`と`app/`間のルーティング {#7-routing-between-pages-and-app}

`pages/`から`app/`への段階的な移行の際に、Next.jsルーターは自動的に2つの間のハードナビゲーションを処理します。`pages/`から`app/`への移行を検出するために、クライアントルーターフィルターがアプローチに依存してアプリルートを確率的に検査しますが、これはまれに誤検知を招くことがあります。通常、このような状況は非常にまれで、誤検知の可能性を0.01％に設定しています。クライアントバンドルで生成されるフィルターのサイズを増加させることに注意しながら、この頻度は`next.config.js`で`experimental.clientRouterFilterAllowedRate`オプションを使用してカスタマイズできます。

あるいは、この処理を完全に無効にして、手動で`pages/`と`app/`間のルーティングを管理したい場合は、`next.config.js`で`experimental.clientRouterFilter`をfalseに設定できます。この機能を無効にすると、appルートと重なるpages内のダイナミックルートはデフォルトで正しくナビゲートされません。
