---
title: 'リンクとナビゲーション'
description: 'Next.jsでのナビゲーションの動作、およびLinkコンポーネントと`useRouter`フックの使用方法を学びます。'
related:
  links:
    - 'app/building-your-application/caching'
    - 'app/api-reference/config/typescript'
---

Next.jsでは、ルート間をナビゲートするための4つの方法があります：

- [`<Link>`コンポーネント](#link-component)を使用する
- [`useRouter`フック](#userouter-hook)を使用する（[Client Components](/docs/app/building-your-application/rendering/client-components)）
- [`redirect`関数](#redirect-function)を使用する（[Server Components](/docs/app/building-your-application/rendering/server-components)）
- ネイティブの[History API](#using-the-native-history-api)を使用する

このページでは、これらの各オプションの使用方法について説明し、ナビゲーションの動作をより深く探っていきます。

## `<Link>`コンポーネント {#link-component}

`<Link>`は、HTMLの`<a>`タグを拡張し、[プリフェッチ](#2-prefetching)とクライアントサイドでのルート間ナビゲーションを提供する組み込みコンポーネントです。Next.jsではルート間をナビゲートする主な推奨方法です。

`next/link`からインポートし、コンポーネントに`href`propsを渡して使用します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

`<Link>`には他にもオプションのpropsを渡すことができます。詳細は[APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()` フック {#userouter-hook}

`useRouter`フックを使用すると、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラム的にルートを変更できます。

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

`useRouter`メソッドの完全なリストについては、[APIリファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **おすすめ：** 特別な理由がない限り、ルート間のナビゲーションには`useRouter`ではなく`<Link>`コンポーネントを使用してください。

## `redirect`関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)では、`redirect`関数を使用します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **知っておくと良いこと**:
>
> - `redirect`はデフォルトで307（Temporary Redirect）ステータスコードを返します。Server Action内で使用されると、POSTリクエストの結果として、303（See Other）を返すことが一般的です。
> - `redirect`は内部的にエラーをスローするため、`try/catch`ブロックの外で呼び出すべきです。
> - `redirect`は、Client Components内でレンダリングプロセス中に呼び出すことができますが、イベントハンドラ内ではできません。代わりに[`useRouter`フック](#userouter-hook)を使うことができます。
> - `redirect`は絶対URLを受け入れ、外部リンクへのリダイレクトに使用できます。
> - レンダリングプロセスの前にリダイレクトしたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs)や[ミドルウェア](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)を使用してください。

詳細は、[`redirect`APIリファレンス](/docs/app/api-reference/functions/redirect)を参照してください。

## ネイティブのHistory APIを使用する {#using-the-native-history-api}

Next.jsは、ページをリロードせずにブラウザの履歴スタックを更新するためのネイティブの[`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)と[`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState)メソッドを使用することを許可します。

`pushState`と`replaceState`の呼び出しは、Next.js Routerに統合され、[`usePathname`](/docs/app/api-reference/functions/use-pathname)や[`useSearchParams`](/docs/app/api-reference/functions/use-search-params)と同期を取ることができます。

### `window.history.pushState` {#window-history-pushstate}

ブラウザの履歴スタックに新しいエントリを追加するために使用します。ユーザーは以前の状態に戻ることができます。例えば、製品のリストをソートする場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

ブラウザの履歴スタックの現在のエントリを置き換えるために使用します。ユーザーは以前の状態に戻ることができません。例えば、アプリケーションのロケールを切り替える場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // e.g. '/en/about' or '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // e.g. '/en/about' or '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの動作 {#how-routing-and-navigation-works}

App Routerはルーティングとナビゲーションにハイブリッドアプローチを採用しています。サーバー上では、アプリケーションコードは自動的にルートセグメントによって[コードスプリット](#1-code-splitting)され、クライアントでは、Next.jsがルートセグメントを[プリフェッチ](#2-prefetching)して[キャッシュ](#3-caching)します。これにより、ユーザーが新しいルートにナビゲートした際にページのリロードが発生せず、変更されたルートセグメントのみが再レンダリングされるため、ナビゲーション体験とパフォーマンスが向上します。

### 1. コードスプリッティング {#1-code-splitting}

コードスプリッティングは、アプリケーションコードをより小さなバンドルに分割して、ブラウザにダウンロードして実行させることを可能にします。これにより、各リクエストのデータ転送量と実行時間が減少し、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components)は、アプリケーションコードを自動的にルートセグメントに基づいてコードスプリットすることを可能にします。これにより、ナビゲーション時に必要なコードのみが読み込まれます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチは、ユーザーが訪れる前にバックグラウンドでルートを事前に読み込む方法です。

Next.jsでは次の2つの方法でルートがプリフェッチされます：

- **`<Link>`コンポーネント**：ルートはユーザーのビューポートに表示されると自動的にプリフェッチされます。プリフェッチはページが最初に読み込まれたときやスクロールにより表示されたときに行われます。
- **`router.prefetch()`**：`useRouter`フックを使ってプログラム的にルートをプリフェッチできます。

`<Link>`のデフォルトのプリフェッチ動作（つまり、`prefetch`propsが指定されていない場合や`null`に設定されている場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用状況に応じて異なります。共有レイアウトが、表示されるコンポーネントの"tree"の中の最初の`loading.js`ファイルまでをプリフェッチして`30秒`間キャッシュします。これにより、動的なルート全体をフェッチするコストが削減され、ユーザーに対して[瞬時の読み込み状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示するためにより良いビジュアルフィードバックが提供できます。

プリフェッチを無効にするには、`prefetch`propsを`false`に設定します。あるいは、`prefetch`propsを`true`に設定してロードバウンダリーを超えたページデータ全体をプリフェッチできます。

詳細は、[`<Link>`APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

> **知っておくと良いこと**:
>
> - プリフェッチは開発時には有効化されておらず、本番環境でのみ有効化されます。

### 3. キャッシング {#3-caching}

Next.jsには、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)と呼ばれる**クライアントサイドのメモリ内キャッシュ**があります。ユーザーがアプリをナビゲートする際に、[プリフェッチされた](#2-prefetching)ルートセグメントおよび訪れたルートのReact Server Component Payloadがキャッシュに保存されます。

これにより、ナビゲーション時にキャッシュが可能な限り再利用され、新しいサーバーへのリクエストを減らすことでパフォーマンスが向上します。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の動作と設定方法について、詳しく学びましょう。

### 4. 部分的描画 {#4-partial-rendering}

部分的描画とは、ナビゲーション時に変更されるルートセグメントのみがクライアントで再レンダリングされ、共有されるセグメントが保存されることを意味します。

例えば、兄弟ルート`/dashboard/settings`と`/dashboard/analytics`間をナビゲートした場合、`settings`ページはアンマウントされ、`analytics`ページは新しい状態でマウントされ、共有`dashboard`レイアウトは保存されます。同様の挙動は、同じ動的セグメント上の2つのルート間でも見られます。例として`/blog/[slug]/ページ`とナビゲーションが`/blog/first`から`/blog/second`に変わるケースがあります。

<Image
  alt="部分的描画の仕組み"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

部分的描画がない場合、各ナビゲーションはクライアント上でページ全体を再描画します。変更されるセグメントのみをレンダリングすることで、データ転送量と実行時間が削減され、パフォーマンスが向上します。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザはページ間をナビゲートする際に"ハードナビゲーション"を行います。Next.js App Routerは、ルートセグメントが変更された場合のみ再描画される（部分的描画）"ソフトナビゲーション"を可能にし、ナビゲーション中にクライアントのReact状態が保存されることを保証します。

### 6. 戻るおよび進むナビゲーション {#6-back-and-forward-navigation}

デフォルトで、Next.jsは戻るおよび進むナビゲーションのためにスクロール位置を保持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)内のルートセグメントを再利用します。

### 7. `pages/`と`app/`間でのルーティング {#7-routing-between-pages-and-app}

`pages/`から`app/`に増分移行する際、Next.js Routerは両者間のハードナビゲーションを自動で処理します。`pages/`から`app/`への遷移を検出するために、Client Routerフィルターがアプリルートの確率的チェックを利用していますが、これは稀に誤検出することがあります。通常、 false positiveの発生は非常に稀であるべきで、我々はfalse positiveの発生率を0.01%に設定しています。この発生率は、`next.config.js`の`experimental.clientRouterFilterAllowedRate`オプションを使ってカスタマイズできます。注意すべき点として、 false positiveの発生率を低下させると、クライアントバンドル内で生成されるフィルタのサイズが増大します。

あるいは、`pages/`と`app/`間のルーティングを完全に無効化し、その管理を手動で行いたい場合は、`next.config.js`で`experimental.clientRouterFilter`をfalseに設定できます。この機能を無効にすると、 appルートと重複するpages内の動的ルートはデフォルトで正しくナビゲートされません。
