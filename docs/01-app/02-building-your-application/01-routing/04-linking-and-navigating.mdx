---
title: 'リンクとナビゲーション'
description: 'Next.jsにおけるナビゲーションの仕組みと、Linkコンポーネントと`useRouter`フックの使い方を学びます。'
related:
  links:
    - 'app/building-your-application/caching'
    - 'app/api-reference/config/typescript'
---

Next.jsでは、ルート間をナビゲートする方法が4つあります。

- [`<Link>` Component](#link-component) を使う
- [`useRouter` hook](#userouter-hook) を使う （[Client Components](/docs/app/building-your-application/rendering/client-components)）
- [`redirect` function](#redirect-function) を使う （[Server Components](/docs/app/building-your-application/rendering/server-components)）
- ネイティブな[History API](#using-the-native-history-api)を使う

このページではこれらそれぞれのオプションの使い方と、ナビゲーションの仕組みについて詳しく説明します。

## `<Link>` コンポーネント {#link-component}

`<Link>`は、HTMLの`<a>`タグを拡張して、[prefetching](#2-prefetching) とクライアントサイドでのルート間ナビゲーションを提供する組み込みコンポーネントです。Next.jsでルート間を移動するための主要で推奨される方法です。

`next/link`からインポートして、コンポーネントに`href`プロップを渡して使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

`<Link>`に渡すことができるその他の任意のプロップもあります。詳細は[AAPI リファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()` フック {#userouter-hook}

`useRouter`フックは、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラムでルートを変更することを可能にします。

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

`useRouter`メソッドの完全なリストについては、[API リファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **おすすめ:** 特定の要求がない限り、ルート間のナビゲーションには`<Link>`コンポーネントを使用してください。

## `redirect` 関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)では、`redirect`関数を使用します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **知っておくと良い点**:
>
> - `redirect`はデフォルトで307（Temporary Redirect）ステータスコードを返します。Server Actionで使用する場合、303（See Other）を返します。これはPOSTリクエストの結果として成功ページにリダイレクトする際によく使用されます。
> - `redirect`は内部でエラーを投げるため、`try/catch`ブロックの外で呼び出すべきです。
> - `redirect`はクライアントコンポーネントのレンダリングプロセス中に呼び出せますが、イベントハンドラ内では呼び出せません。代わりに[`useRouter` hook](#userouter-hook)を使用できます。
> - `redirect`は絶対URLも受け入れ、外部リンクへのリダイレクトにも使用できます。
> - レンダリング前にリダイレクトしたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs) もしくは [Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware) を使用します。

`redirect`の詳細については、[`redirect` API リファレンス](/docs/app/api-reference/functions/redirect)を参照してください。

## ネイティブ History API を使う {#using-the-native-history-api}

Next.jsでは、ネイティブの[`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) と [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState)メソッドを使って、ページをリロードすることなくブラウザの履歴スタックを更新できます。

`pushState`と`replaceState`の呼び出しは、Next.js Routerに統合されており、[`usePathname`](/docs/app/api-reference/functions/use-pathname)や[`useSearchParams`](/docs/app/api-reference/functions/use-search-params)と同期することができます。

### `window.history.pushState` {#window-history-pushstate}

`pushState`を使用して、ブラウザの履歴スタックに新しいエントリを追加します。ユーザーは前の状態に戻ることができます。たとえば、製品のリストを並べ替える場合:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

`replaceState`を使用して、ブラウザの履歴スタックの現在のエントリを置き換えます。ユーザーは前の状態に戻ることはできません。たとえば、アプリケーションのロケールを切り替える場合:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // 例えば '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // 例えば '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの仕組み {#how-routing-and-navigation-works}

App Routerは、ルーティングとナビゲーションにハイブリッドアプローチを採用しています。サーバーでは、アプリケーションコードがルートセグメントによって自動的にコードスプリットされます。クライアントでは、Next.jsがルートセグメントを[prefetch](#2-prefetching)し、キャッシュします。これにより、ユーザーが新しいルートにナビゲートするとき、ブラウザはページをリロードせず、変更されるルートセグメントのみが再レンダリングされ、ナビゲーション体験とパフォーマンスが向上します。

### 1. コードスプリット {#1-code-splitting}

コードスプリットとは、アプリケーションコードを小さなバンドルに分割し、ブラウザがダウンロードして実行できるようにすることを指します。これにより、データ転送量と各リクエストの実行時間が削減され、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components)により、アプリケーションコードはルートセグメントによって自動的にコードスプリットされます。したがって、ナビゲーション時に必要なコードのみが読み込まれます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチとは、ユーザーが訪れる前にバックグラウンドでルートを事前読み込みする方法です。

Next.jsではルートがプリフェッチされる方法は2つあります。

- **`<Link>` コンポーネント**: ルートはユーザーのビューポートで見えるようになると自動的にプリフェッチされます。プリフェッチはページが最初に読み込まれるときまたはスクロールによってビューに入るときに行われます。
- **`router.prefetch()`**: `useRouter`フックを使用してプログラム的にルートをプリフェッチできます。

`<Link>`のデフォルトのプリフェッチ動作（つまり、`prefetch`プロップが未指定または`null`に設定されている場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用によって異なります。共有レイアウトのみがプリフェッチおよび`30秒`間キャッシュされます。これにより、動的ルート全体をフェッチするコストが削減され、ユーザーに優れた視覚フィードバックを提供するために[インスタントのローディング状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示することができます。

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定します。あるいは`prefetch`プロップを`true`に設定して、ローディング境界を超えてページデータ全体をプリフェッチすることもできます。

詳細については、[`<Link>` APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

> **知っておくと良い点**:
>
> - プリフェッチは開発時には有効になっておらず、本番環境でのみ有効です。

### 3. キャッシュ {#3-caching}

Next.jsには**メモリ内クライアントサイドキャッシュ**という名の[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)があります。ユーザーがアプリをナビゲートすると、[prefetch](#2-prefetching)されたルートセグメントおよび訪問したルートの React Server Component Payload がキャッシュに保存されます。

これにより、ナビゲーション時には可能な限りキャッシュが再利用され、サーバーへの新たなリクエストが不要となり、リクエスト数およびデータ転送量が削減されパフォーマンスが向上します。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の動作とその設定方法について詳しくは、こちらを参照してください。

### 4. 部分レンダリング {#4-partial-rendering}

部分レンダリングとは、ナビゲーション時にクライアント上で変更されたルートセグメントのみが再レンダリングされ、共通のセグメントが保持されることを指します。

例えば、2つの兄弟ルート (`/dashboard/settings` と `/dashboard/analytics`) をナビゲートすると、`settings`ページがアンマウントされ、`analytics`ページが新しい状態でマウントされ、共通の`dashboard`レイアウトが保持されます。この動作は、同じ動的セグメント内の2つのルートの場合、例えば`/blog/[slug]/page`と、`/blog/first` から `/blog/second` へのナビゲーションでも同じです。

<Image
  alt="部分レンダリングの仕組み"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

部分レンダリングがなければ、ナビゲーションごとにクライアント上のページ全体が再レンダリングされます。変更されたセグメントのみをレンダリングすることで、データ転送量と実行時間が削減され、パフォーマンスが向上します。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザは、ページ間のナビゲーションで「ハードナビゲーション」を行います。Next.js App Routerは「ソフトナビゲーション」を可能にし、変更されたルートセグメントのみが再レンダリングされるようにします（部分レンダリング）。これにより、クライアントのReact状態がナビゲーション中に保持されます。

### 6. 前後のナビゲーション {#6-back-and-forward-navigation}

デフォルトで、Next.jsは後方および前方のナビゲーションのためのスクロール位置を維持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)内のルートセグメントを再利用します。

### 7. `pages/` と `app/` 間のルーティング {#7-routing-between-pages-and-app}

`pages/`から`app/`へ段階的に移行する場合、Next.jsルーターは`pages/` と `app/` 間でのハードナビゲーションを自動的に処理します。`pages/`から`app/`への遷移を検出するために、確率的に app ルートをチェックするクライアントルーターフィルターがありますが、時折誤検出（false positives）が発生することがあります。デフォルトでは、これらの発生は非常に稀であるべきで、誤検出の可能性を0.01%に設定しています。この可能性は、`next.config.js`で`experimental.clientRouterFilterAllowedRate`オプションを使用してカスタマイズできます。誤検出率を下げると、クライアントバンドル内で生成されるフィルターのサイズが増加します。

また、このハンドリングを完全に無効にし、`pages/` と `app/` 間のルーティングを手動で管理したい場合は、`next.config.js`で`experimental.clientRouterFilter`を false に設定できます。この機能が無効化されると、app ルートと重なる pages 内の動的ルートはデフォルトで適切にナビゲートされません。
