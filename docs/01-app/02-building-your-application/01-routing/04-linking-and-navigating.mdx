---
title: 'リンクとナビゲーション'
description: 'Next.jsでのナビゲーションの仕組みと、Link コンポーネントと useRouter フックの使い方を学ぶ'
related:
  links:
    - 'app/building-your-application/caching'
    - 'app/api-reference/config/typescript'
---

Next.jsでルート間を移動する方法は4つあります：

- [`<Link>` コンポーネントを使用する](#link-component)
- [`useRouter` フックを使用する](#userouter-hook) ([Client Components](/docs/app/building-your-application/rendering/client-components))
- [`redirect` 関数を使用する](#redirect-function) ([Server Components](/docs/app/building-your-application/rendering/server-components))
- ネイティブの[History APIを使用する](#using-the-native-history-api)

このページでは、これら各オプションの使用方法を説明し、ナビゲーションの仕組みについてより深く掘り下げます。

## `<Link>` コンポーネント {#link-component}

`<Link>`は、HTMLの`<a>`タグを拡張して、[プリフェッチ](#2-prefetching)とクライアントサイドのルート間ナビゲーションを提供する組み込みのコンポーネントです。Next.jsでルート間を移動する主要で推奨される方法です。

`next/link`からインポートして、そのコンポーネントに`href`プロップを渡すことで使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

`<Link>`には他にもオプションのプロップを渡すことができます。他の詳細は[APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()` フック {#userouter-hook}

`useRouter`フックを使用すると[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラム的にルートを変更できます：

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

`useRouter`メソッドの全一覧については[APIリファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **推奨事項**: `useRouter`を使用する特定の要件がない限り、ルート間を移動するには`<Link>`コンポーネントを使用してください。

## `redirect` 関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)には`redirect`関数を使用します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - `redirect`はデフォルトで307 (一時リダイレクト)ステータスコードを返します。Server Actionで使用した場合は、POSTリクエストの結果としての成功ページへのリダイレクトによく使われる303 (他を参照)を返します。
> - `redirect`は内部的にエラーをスローするため、`try/catch`ブロックの外で呼び出すべきです。
> - `redirect`はClient Componentsのレンダリングプロセス中に使用できますが、イベントハンドラ内では使用できません。その場合は[`useRouter`フック](#userouter-hook)を使用できます。
> - `redirect`は絶対URLも受け付け、外部リンクにリダイレクトできます。
> - レンダリングプロセスの前にリダイレクトしたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs) または [Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)を使用してください。

より詳しい情報は[`redirect` APIリファレンス](/docs/app/api-reference/functions/redirect)を参照してください。

## ネイティブのHistory APIを使用する {#using-the-native-history-api}

Next.jsは、ネイティブの[`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) および [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) メソッドを使用してページをリロードせずにブラウザの履歴スタックを更新できます。

`pushState`と`replaceState`の呼び出しはNext.js Routerに統合されており、[`usePathname`](/docs/app/api-reference/functions/use-pathname) および [`useSearchParams`](/docs/app/api-reference/functions/use-search-params) と同期することができます。

### `window.history.pushState` {#window-history-pushstate}

ブラウザの履歴スタックに新しいエントリを追加するために使用します。ユーザーは前の状態に戻ることができます。たとえば、製品のリストを並べ替えるには：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

ブラウザの履歴スタック上の現在のエントリを置き換えるために使用します。ユーザーは前の状態に戻ることはできません。たとえば、アプリケーションの言語を切り替えるには：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // e.g. '/en/about' or '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // e.g. '/en/about' or '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの仕組み {#how-routing-and-navigation-works}

App Routerはルーティングとナビゲーションのためのハイブリッドアプローチを使用します。サーバー上では、アプリケーションコードが自動的にルートセグメントごとに[コード分割](#1-code-splitting)されます。クライアント側では、Next.jsがルートセグメントを[プリフェッチ](#2-prefetching)し、[キャッシュ](#3-caching)します。これにより、ユーザーが新しいルートに移動した際にブラウザがページをリロードせず、変更されたルートセグメントのみが再レンダリングされ、ナビゲーション体験とパフォーマンスが向上します。

### 1. コード分割 {#1-code-splitting}

コード分割は、アプリケーションコードをより小さいバンドルに分割し、ブラウザによってダウンロードされ実行されるようにすることです。これにより、転送されるデータ量と各リクエストの実行時間が削減され、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components)はアプリケーションコードを自動的にルートセグメントごとにコード分割することを可能にします。これにより、ナビゲーション時には現在のルートに必要なコードだけが読み込まれます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチは、ユーザーがルートを訪れる前にバックグラウンドでそのルートを事前に読み込む方法です。

Next.jsでは2つの方法でルートがプリフェッチされます：

- **`<Link>` コンポーネント**: ルートはユーザーのビューポート内に入ると自動的にプリフェッチされます。プリフェッチはページが最初に読み込まれる時や、スクロールで視界に入った時に行われます。
- **`router.prefetch()`**: `useRouter`フックを使用してルートをプログラム的にプリフェッチできます。

`<Link>`のデフォルトのプリフェッチ動作（`prefetch`プロップが指定されていない場合や`null`に設定されている場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用状況に応じて異なります。レンダリングされたコンポーネントの"tree"の、最初の`loading.js`ファイルまでの共有されているレイアウトのみがプリフェッチされ、`30s`間キャッシュされます。これにより、ダイナミックルート全体をフェッチするコストが削減され、ユーザーには[即時のローディング状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示でき、視覚的なフィードバックが向上します。

プリフェッチを無効にする場合は、`prefetch`プロップを`false`に設定します。あるいは、プリフェッチを`true`に設定することで、ローディング境界を超えて完全なページデータをプリフェッチできます。

詳細は[`<Link>` APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

> **Good to know**:
>
> - プリフェッチは開発環境では有効になっておらず、本番環境のみで有効です。

### 3. キャッシング {#3-caching}

Next.jsは[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)と呼ばれる**インメモリーのクライアントサイドキャッシュ**を持っています。ユーザーがアプリ内を移動する際、[プリフェッチ](#2-prefetching)されたルートセグメントと訪問したルートのReact Server Component Payloadがキャッシュに保存されます。

これにより、ナビゲーション時にキャッシュが可能な限り再利用され、新しいサーバーへのリクエストを行う必要がなくなります。これにより、リクエスト数と転送するデータが減少し、パフォーマンスが向上します。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の作動方法および設定方法についての詳細を学んでください。

### 4. 部分レンダリング {#4-partial-rendering}

部分レンダリングは、ナビゲーション時に変更されたルートセグメントのみがクライアントで再レンダリングされ、共有されたセグメントが保持されることを意味します。

たとえば、2つの兄弟ルート`/dashboard/settings`と`/dashboard/analytics`の間を移動する場合、`settings`ページはアンマウントされ、`analytics`ページは新しい状態でマウントされ、共有された`dashboard`レイアウトは保持されます。同様に、2つの動的セグメント上のルート間でもこの動作が見られます。例：`/blog/[slug]/page`から`/blog/first`への移動から`/blog/second`への移動。

<Image
  alt="部分レンダリングの仕組み"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

部分レンダリングがなければ、各ナビゲーションはクライアントでページ全体を再レンダリングします。変更されるセグメントのみをレンダリングすることにより、転送データと実行時間が削減され、パフォーマンスが向上します。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザは、ページ間のナビゲーション時に「ハードナビゲーション」を行います。Next.jsのApp Routerは、ページ間の「ソフトナビゲーション」を可能にし、変更されたルートセグメントのみが再レンダリングされるようにします（部分レンダリング）。これにより、ナビゲーション中にクライアントのReact状態が保持されます。

### 6. バックナビゲーションとフォワードナビゲーション {#6-back-and-forward-navigation}

デフォルトでは、Next.jsはバックワードとフォワードナビゲーションのためにスクロール位置を維持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)内のルートセグメントを再利用します。

### 7. `pages/` と `app/` 間のルーティング {#7-routing-between-pages-and-app}

`pages/`から`app/`への漸進的な移行時には、Next.jsのルーターが自動的に両者の間のハードナビゲーションを処理します。`pages/`から`app/`への遷移を検出するには、アプリのルートの確率的チェックを利用するクライアントルーターフィルターがありますが、これにより時折誤検出が発生することがあります。デフォルトでは、その発生は非常にまれであるべきで、この誤検出の確率を0.01%に設定しています。この確率は`next.config.js`の`experimental.clientRouterFilterAllowedRate`オプションを通じてカスタマイズできます。誤検出率を低下させると、クライアントバンドル内の生成されたフィルターのサイズが増加することに注意してください。

代替として、この処理を完全に無効にし、`pages/`と`app/`間のルーティングを手動で管理したい場合は、`experimental.clientRouterFilter`を`false`に設定できます。この機能が無効になっている場合、アプリルートと重複するページ内のダイナミックルートにはデフォルト設定では正しくナビゲートされません。
