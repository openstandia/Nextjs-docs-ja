---
title: 'リンクとナビゲーション'
description: 'Next.js におけるナビゲーションの仕組み、Link コンポーネントおよび `useRouter` フックの使用方法を学びます。'
related:
  links:
    - 'app/building-your-application/caching'
    - 'app/api-reference/config/typescript'
---

Next.js では、ルート間をナビゲートする方法が4つあります：

- [`<Link>` コンポーネント](#link-component)を使用する
- [`useRouter` フック](#userouter-hook)を使用する（[Client Components](/docs/app/building-your-application/rendering/client-components)）
- [`redirect` 関数](#redirect-function)を使用する（[Server Components](/docs/app/building-your-application/rendering/server-components)）
- ネイティブの[History API](#using-the-native-history-api)を使用する

このページでは、それぞれの方法の使い方について説明し、ナビゲーションの仕組みを詳しく掘り下げます。

## `<Link>` コンポーネント {#link-component}

`<Link>` は、HTML `<a>` タグを拡張して、[プリフェッチ](#2-prefetching)やクライアント側のルート間ナビゲーションを提供する組み込みコンポーネントです。Next.js でルート間をナビゲートするための主要かつ推奨される方法です。

これを使用するには、`next/link` からインポートし、`href` プロップをコンポーネントに渡します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">ダッシュボード</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">ダッシュボード</Link>
}
```

</TabItem>
</Tabs>

その他のオプションプロップを `<Link>` に渡すこともできます。詳細は [APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()` フック {#userouter-hook}

`useRouter` フックを使うことで、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラム的にルートを変更できます。

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      ダッシュボード
    </button>
  )
}
```

`useRouter` メソッドの完全なリストは、[APIリファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **推奨事項:** `<Link>` コンポーネントを使用してルート間をナビゲートすることをお勧めします。`useRouter` を使用する特定の要件がある場合を除きます。

## `redirect` 関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)の場合は、代わりに `redirect` 関数を使用します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - `redirect` はデフォルトで 307 (Temporary Redirect) ステータスコードを返します。Server Action で使用するときは、303 (See Other) を返します。これは、POST リクエストの結果として成功ページにリダイレクトするためによく使われます。
> - `redirect` は内部でエラーをスローするため、`try/catch` ブロックの外で呼び出す必要があります。
> - `redirect` は、Client Components のレンダリングプロセス中に呼び出せますが、イベントハンドラでは呼び出せません。代わりに[`useRouter` フック](#userouter-hook)を使用できます。
> - `redirect` は絶対 URL も受け入れることができ、外部リンクへのリダイレクトにも使用できます。
> - レンダリングプロセスの前にリダイレクトしたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs) または [Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)を使用してください。

[`redirect` APIリファレンス](/docs/app/api-reference/functions/redirect)を参照してください。

## ネイティブの History API を使用する {#using-the-native-history-api}

Next.js では、ネイティブの [`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) および [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) メソッドを使用して、ページを再読み込みせずにブラウザの履歴スタックを更新できます。

`pushState` および `replaceState` 呼び出しは Next.js Router に統合されているため、[`usePathname`](/docs/app/api-reference/functions/use-pathname)および [`useSearchParams`](/docs/app/api-reference/functions/use-search-params)と同期できます。

### `window.history.pushState` {#window-history-pushstate}

ブラウザの履歴スタックに新しいエントリを追加するために使用します。たとえば、製品リストを並べ替えるには：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>昇順で並べ替え</button>
      <button onClick={() => updateSorting('desc')}>降順で並べ替え</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>昇順で並べ替え</button>
      <button onClick={() => updateSorting('desc')}>降順で並べ替え</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

ブラウザの履歴スタックの現在のエントリを置き換えるために使用します。たとえば、アプリケーションのロケールを切り替えるには：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // 例: '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // 例: '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの仕組み {#how-routing-and-navigation-works}

App Router はルーティングとナビゲーションにハイブリッドアプローチを採用しています。サーバー側では、アプリケーションコードがルートセグメントごとに自動的に[コード分割](#1-code-splitting)されます。そして、クライアント側では、Next.js がルートセグメントを[プリフェッチ](#2-prefetching)および[キャッシュ](#3-caching)します。これにより、ユーザーが新しいルートにナビゲートするときにブラウザがページを再読み込みせず、変更するルートセグメントのみが再レンダリングされるため、ナビゲーションの体験とパフォーマンスが向上します。

### 1. コード分割 {#1-code-splitting}

コード分割により、アプリケーションコードを小さなバンドルに分割し、ブラウザによってダウンロードおよび実行されます。これにより、転送されるデータ量と各リクエストの実行時間が削減され、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components) を使用して、アプリケーションコードがルートセグメントごとに自動的にコード分割されます。これにより、ナビゲーション時に現在のルートに必要なコードのみがロードされます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチは、ユーザーが訪れる前にルートをバックグラウンドで事前にロードする方法です。

Next.js では、プリフェッチされる方法が2つあります：

- **`<Link>` コンポーネント**： ルートはユーザーのビューポートに可視化されると自動的にプリフェッチされます。プリフェッチは、ページが最初にロードされるときやスクロールによってビューに入るときに行われます。
- **`router.prefetch()`**： `useRouter` フックを使用してルートをプログラム的にプリフェッチできます。

`<Link>` のデフォルトのプリフェッチ動作（つまり、`prefetch` プロップが指定されていないか `null` に設定されてる場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用法によって異なります。`loading.js` ファイルに至るまでの描画された"ツリー"の下位を共通レイアウトとしてプリフェッチし、`30s`の間キャッシュします。これにより、動的ルート全体を取得するコストが削減され、ユーザーには[即時のローディング状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を示すことができ、視覚的なフィードバックが向上します。

`prefetch` プロップを `false` に設定することでプリフェッチを無効にできます。あるいは、プリフェッチの枠を超えてフルページデータを取得するために `prefetch` プロップを `true` に設定することもできます。

詳細については、[`<Link>` APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

> **Good to know**:
>
> - プリフェッチは、開発環境では有効ではなく、本番環境でのみ有効です。

### 3. キャッシング {#3-caching}

Next.js には **メモリ内のクライアントサイドキャッシュ** である [Router Cache](/docs/app/building-your-application/caching#client-side-router-cache) が存在します。ユーザーがアプリをナビゲートすることで、[プリフェッチ](#2-prefetching)されたルートセグメントおよび訪問したルートの React Server Component ペイロードがキャッシュに保存されます。

これにより、ナビゲーション時には新しいリクエストをサーバーに行う代わりに、キャッシュをできる限り再利用することで、パフォーマンスを向上させ、リクエスト数および転送されるデータ量を削減します。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache) の仕組みや設定方法について詳しく学びましょう。

### 4. 部分的レンダリング {#4-partial-rendering}

部分的レンダリングは、ナビゲーション時に変更されるルートセグメントのみがクライアント側で再レンダリングされ、共通セグメントはそのまま保持されることを意味します。

たとえば、2つの兄弟ルート `/dashboard/settings` と `/dashboard/analytics` 間をナビゲーションするとき、`settings` ページはアンマウントされ、`analytics` ページは新しい状態でマウントされ、共通の `dashboard` レイアウトが保持されます。この動作は、同じ動的セグメント上の2つのルート間でも同様です。たとえば、`/blog/[slug]/page` で `/blog/first` から `/blog/second` へのナビゲーションです。

<Image
  alt="How partial rendering works"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

部分的レンダリングがなければ、ナビゲーションごとにクライアント側でページ全体が再レンダリングされるでしょう。変更されるセグメントのみをレンダリングすることで、転送されるデータ量と実行時間を削減し、パフォーマンスを向上させます。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザはページ間をナビゲートするときに「ハードナビゲーション」を行います。Next.js の App Router はページ間の「ソフトナビゲーション」を可能にし、変更されたルートセグメントのみが再レンダリングされることを保証します（部分的レンダリング）。これにより、ナビゲーション中にクライアントの React 状態が保持されます。

### 6. 戻ると進むナビゲーション {#6-back-and-forward-navigation}

デフォルトで、Next.js は後退および前進ナビゲーションの際にスクロール位置を維持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache) のルートセグメントを再利用します。

### 7. `pages/` と `app/` 間のルーティング {#7-routing-between-pages-and-app}

`pages/` から `app/` への漸進的な移行時、Next.js ルーターは 2 つの間のハードナビゲーションを自動的に処理します。`pages/` から `app/` への移行を検出するために、クライアントルーターはアプリルートの確率的なチェックを活用し、時折偽陽性を引き起こすことがあります。デフォルトでは、そのような発生は非常にまれです。偽陽性の可能性を 0.01% に設定しています。この可能性は、`next.config.js` の `experimental.clientRouterFilterAllowedRate` オプションでカスタマイズできます。偽陽性率を下げると、クライアントバンドルに生成されるフィルターのサイズが増加することに注意してください。

あるいは、この処理を完全に無効にし、`pages/` と `app/` 間のルーティングを手動で管理したい場合は、`next.config.js` で `experimental.clientRouterFilter` を false に設定できます。この機能が無効化されている場合、`app` ルートと重なる `pages` の動的ルートはデフォルトで適切にナビゲートされなくなります。
