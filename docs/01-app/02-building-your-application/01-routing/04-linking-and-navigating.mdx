---
title: 'リンクとナビゲーション'
description: 'Next.js でのナビゲーションの仕組みと、Link コンポーネントや `useRouter` フックの使い方を学びます。'
related:
  links:
    - app/building-your-application/caching
    - app/api-reference/config/typescript
---

Next.js でルート間のナビゲーションを行う方法は次の4つです：

- [`<Link>` コンポーネント](#link-component)を使う
- [`useRouter` フック](#userouter-hook)を使う（[Client Components](/docs/app/building-your-application/rendering/client-components)）
- [`redirect` 関数](#redirect-function)を使う（[Server Components](/docs/app/building-your-application/rendering/server-components)）
- ネイティブな [History API](#using-the-native-history-api)を使う

このページでは、これらの各オプションの使い方を説明し、ナビゲーション機能の仕組みを深く掘り下げます。

## `<Link>` コンポーネント {#link-component}

`<Link>` は、HTML の `<a>` タグを拡張して[プリフェッチ](#2-prefetching)やクライアントサイドのルート間ナビゲーションを提供する組み込みのコンポーネントです。Next.js でルート間のナビゲーションを行うために推奨される主な方法です。

`next/link` からインポートし、コンポーネントに `href` prop を渡して使用します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

`<Link>` に渡せる他のオプションの props については、[API リファレンス](/docs/app/api-reference/components/link)をご覧ください。

## `useRouter()` フック {#userouter-hook}

`useRouter` フックを使用すると、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラム的にルートを変更することができます。

```jsx title="app/page.js"
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

`useRouter` メソッドの全一覧は、[API リファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **推奨:** 特定の `useRouter` 使用要件がない限り、ルート間のナビゲーションには `<Link>` コンポーネントを使用してください。

## `redirect` 関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)には、代わりに `redirect` 関数を使用します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - `redirect` はデフォルトで 307（Temporary Redirect）ステータスコードを返します。Server Action で使用された場合、POST リクエストの結果として成功ページへのリダイレクトに一般的に使用される 303（See Other）を返します。
> - `redirect` は内部でエラーをスローするため、`try/catch` ブロックの外部で呼び出す必要があります。
> - `redirect` は、Client Components のレンダリング処理中に呼び出すことができますが、イベントハンドラ内では呼び出せません。代わりに [`useRouter` フック](#userouter-hook)を使用できます。
> - `redirect` は絶対 URL も受け入れることができ、外部リンクへのリダイレクトに使用できます。
> - レンダリングプロセスの前にリダイレクトしたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs) または [Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware) を使用します。

詳しくは [`redirect` API リファレンス](/docs/app/api-reference/functions/redirect)をご覧ください。

## ネイティブな History API の使用 {#using-the-native-history-api}

Next.js では、ページをリロードせずにブラウザの履歴スタックを更新するために、ネイティブな [`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) と [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) メソッドを使用することができます。

`pushState` と `replaceState` の呼び出しは Next.js Router に統合されており、[`usePathname`](/docs/app/api-reference/functions/use-pathname) や [`useSearchParams`](/docs/app/api-reference/functions/use-search-params) と同期できます。

### `window.history.pushState` {#window-history-pushstate}

ブラウザの履歴スタックに新しいエントリを追加するために使用します。ユーザーは前の状態に戻ることができます。たとえば、製品リストをソートする：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

ブラウザの履歴スタックの現在のエントリを置き換えるために使用します。ユーザーは前の状態に戻ることができません。たとえば、アプリケーションのロケールを切り替える：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // 例：'/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // 例：'/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの仕組み {#how-routing-and-navigation-works}

App Router は、ルーティングとナビゲーションにハイブリッドアプローチを採用しています。サーバーでは、アプリケーションコードがルートセグメントごとに自動的に[コード分割](#1-code-splitting)されます。そしてクライアントでは、Next.js がルートセグメントを[プリフェッチ](#2-prefetching)し、[キャッシュ](#3-caching)します。これにより、ユーザーが新しいルートにナビゲートするときにブラウザはページをリロードせず、変更されたルートセグメントだけが再レンダリングされます。これによりナビゲーション体験とパフォーマンスが向上します。

### 1. コード分割 {#1-code-splitting}

コード分割を使用すると、アプリケーションコードをより小さなバンドルに分割し、ブラウザによってダウンロードおよび実行されるようにできます。これにより、各リクエストのデータ転送量と実行時間が削減され、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components)は、アプリケーションコードをルートセグメントごとに自動的にコード分割することができます。これにより、ナビゲーション時にそのルートに必要なコードだけがロードされます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチは、ユーザーが訪れる前にバックグラウンドでルートをプレロードする方法です。

Next.js では2つの方法でプリフェッチが行われます：

- **`<Link>` コンポーネント**: ルートはユーザーのビューポートに表示されたときに自動的にプリフェッチされます。プリフェッチは、ページが最初に読み込まれたときやスクロールして表示されるときに行われます。
- **`router.prefetch()`**: `useRouter` フックを使用してプログラム的にルートをプリフェッチできます。

`<Link>` のデフォルトのプリフェッチ動作（`prefetch` prop が未指定または `null` に設定されている場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading) の使用方法によって異なります。プリフェッチされ、キャッシュされるのは、最初の `loading.js` ファイルまでのレンダリングされた "tree" の共有レイアウトだけで `30秒` の間キャッシュされます。この方法は、動的ルート全体をフェッチするコストを削減し、ユーザーにより良い視覚的フィードバックを与えるための[即時のローディング状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示することができます。

プリフェッチを無効にするには、`prefetch` prop を `false` に設定します。また、`prefetch` prop を `true` に設定することで、ローディング境界を超えて完全なページデータをプリフェッチすることもできます。

詳しくは [`<Link>` API リファレンス](/docs/app/api-reference/components/link)をご覧ください。

> **Good to know**:
>
> - 開発環境ではプリフェッチは有効ではなく、本番環境でのみ有効です。

### 3. キャッシング {#3-caching}

Next.js には、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache) と呼ばれる**インメモリのクライアントサイドキャッシュ**があります。ユーザーがアプリをナビゲートする際、[プリフェッチされた](#2-prefetching)ルートセグメントと訪問したルートの React Server Component Payload がキャッシュに格納されます。

これにより、ナビゲーション時に新たなサーバーリクエストを減らし、キャッシュをできる限り再利用することが可能です。これはリクエストとデータ転送量を削減し、パフォーマンスの向上につながります。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の仕組みと設定方法について詳しく学びましょう。

### 4. 部分レンダリング {#4-partial-rendering}

部分レンダリングとは、ナビゲーション時に変更があったルートセグメントのみをクライアントで再レンダリングし、共有されているセグメントを保持することを意味します。

たとえば、2つの兄弟ルート `/dashboard/settings` と `/dashboard/analytics` の間を移動する際、`settings` ページはアンマウントされ、`analytics` ページが新しい状態でマウントされ、共有された `dashboard` レイアウトは保持されます。この動作は、同じ動的セグメント上の2つのルート間、例として `/blog/[slug]/page` から `/blog/first` から `/blog/second` にナビゲートする場合でも存在します。

<Image
  alt="部分レンダリング機能動作図"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

部分レンダリングがなければ、各ナビゲーションでクライアント上でフルページを再レンダリングすることになります。変更があったセグメントだけをレンダリングすることで、データ転送量と実行時間を削減し、パフォーマンス向上に寄与します。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザは、ページ間のナビゲーション時に「ハードナビゲーション」を行います。Next.js の App Router は、ページ間で「ソフトナビゲーション」を可能にし、変更されたルートセグメントのみを再レンダリング（部分レンダリング）します。これにより、ナビゲーション中にクライアントの React 状態を保持できます。

### 6. 前進および後進ナビゲーション {#6-back-and-forward-navigation}

デフォルトで、Next.js は前進および後進ナビゲーション用のスクロール位置を保持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache) でルートセグメントを再利用します。

### 7. `pages/` と `app/` 間でのルーティング {#7-routing-between-pages-and-app}

`pages/` から `app/` への増分移行時、Next.js の router はこの2つの間でのハードナビゲーションを自動的に処理します。クライアントルーターのフィルタのアプリルートの確率的チェックを活用し、`pages/` から `app/` への遷移を検出します。これにより稀に誤検知が発生します。デフォルトでこの発生は非常に稀で、誤検知の確率を 0.01% に設定しています。この確率は、`next.config.js` の `experimental.clientRouterFilterAllowedRate` オプションでカスタマイズできます。誤検知率を下げると、クライアントバンドル内で生成されたフィルタサイズが増加することに注意が必要です。

また、`experimental.clientRouterFilter` を `false` に設定すると、この処理を完全に無効にして、`pages/` と `app/` 間のルーティングを手動で管理することもできます。これにより、デフォルトでは app ルートと重複する `pages/` 内の動的ルートには、適切なナビゲーションが行われません。
