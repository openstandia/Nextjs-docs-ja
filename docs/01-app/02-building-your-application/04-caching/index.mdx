---
title: 'Next.jsにおけるキャッシング'
nav_title: 'キャッシング'
description: 'Next.jsのキャッシングメカニズムの概要。'
---

Next.jsは、レンダリング作業とデータリクエストをキャッシュすることで、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシングメカニズム、設定するためのAPI、およびそれらの相互作用について詳しく説明します。

> **Good to know**: このページは、Next.jsの内部動作を理解するためのものであり、Next.jsを使って生産的に作業するために必須の知識では**ありません**。ほとんどのNext.jsのキャッシングヒューリスティックは、APIの使用方法によって決定され、ゼロまたは最小限の設定で最高のパフォーマンスを発揮するためのデフォルトがあります。代わりに例を見たい場合は、[こちらから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

次に、異なるキャッシングメカニズムとその目的の概要を示します：

| メカニズム                                  | 内容                | 所在地       | 目的                                             | 期間                               |
| ------------------------------------------- | ------------------- | ------------ | ------------------------------------------------ | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の戻り値        | サーバ       | React Component tree内でのデータ再利用           | リクエストライフサイクルごと       |
| [Data Cache](#data-cache)                   | データ              | サーバ       | ユーザーリクエストとデプロイメント間のデータ保存 | 永続的（再検証可能）               |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバ       | レンダリングコスト削減とパフォーマンス向上       | 永続的（再検証可能）               |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時のサーバリクエスト削減           | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsはできるだけ多くのキャッシュを行い、パフォーマンスを向上させ、コストを削減します。つまり、ルートは**静的にレンダリング**され、データリクエストは**キャッシュ**されますが、あなたがオプトアウトしない限りです。以下の図では、ビルド時や静的ルートが初めて訪問されたときに、ルートが静的にレンダリングされるデフォルトのキャッシング動作が示されています。

<Image
  alt="Next.jsにおける4つのメカニズムにおけるデフォルトのキャッシング動作を示す図。ビルド時およびルートが最初に訪問されたときのHIT、MISS、SET。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシング動作は、ルートが静的または動的にレンダリングされているか、データがキャッシュされているかキャッシュされていないか、およびリクエストが最初の訪問の一部か、その後のナビゲーションの一部かに応じて変化します。使用ケースに応じて、個々のルートとデータリクエストのキャッシング動作を設定できます。

## Request Memoization {#request-memoization}

Reactは、同じURLとオプションを持つリクエストを自動で**メモ化**するために、[`fetch` API](#fetch)を拡張しています。これにより、同じデータに対するfetch関数をReact component tree内の複数の場所で呼び出しても、それを1回だけ実行することができます。

<Image
  alt="重複しないフェッチリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

例えば、ルート全体で同じデータを使用する必要がある場合（例：Layout、Page、複数のコンポーネント内）、ツリーのトップでデータを取得してからプロップをコンポーネント間で渡す必要はありません。代わりに、必要なデータを持つコンポーネント内でデータをフェッチし、ネットワーク全体で同じデータに対して複数回リクエストを送ることのパフォーマンスへの影響を心配することなく、データを使うことができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、その結果がキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しは、ルート内のどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、その結果がキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しは、ルート内のどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoizationの仕組み**

<Image
  alt="Reactレンダリング中にfetchメモ化がどのように機能するかを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングする際、特定のリクエストが初めて呼び出されたとき、その結果はメモリに存在せず、キャッシュ`MISS`となります；
- そのため、関数は実行され、データは外部ソースから取得され、結果はメモリに格納されます；
- 同じレンダリングパス内でのリクエストの後続の関数呼び出しはキャッシュ`HIT`となり、関数を実行せずにメモリからデータが返されます；
- ルートがレンダリングされ、レンダリングパスが完了すると、メモリは「リセット」され、すべてのリクエストメモ化エントリがクリアされます；

> **Good to know**:
>
> - リクエストメモ化はReactの機能であり、Next.jsの機能ではありません。他のキャッシングメカニズムとの相互作用を示すためにここに含まれています；
> - メモ化は`fetch`リクエストの`GET`メソッドにのみ適用されます；
> - メモ化はReact Component treeにのみ適用されます。つまり：
>   - `fetch`リクエストは、`generateMetadata`、`generateStaticParams`、Layouts、Pages、その他のServer Componentsで適用されます；
>   - Route Handlers内の`fetch`リクエストには適用されません。なぜなら、それらはReact component treeの一部ではないからです；
> - `fetch`が適切でない場合（例：いくつかのデータベースクライアント、CMSクライアント、またはGraphQLクライアント）、[Reactの`cache`関数](#react-cache-function)を使用して関数をメモ化することができます；

### 期間 {#duration}

キャッシュはサーバリクエストのライフタイムの間持続し、React component treeのレンダリングが完了するまで持続します；

### 再検証 {#revalidating}

メモ化はサーバリクエスト間で共有されず、レンダリング中にのみ適用されるため、再検証の必要はありません；

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、`POST`や`DELETE`などの他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、これからオプトアウトすることは推奨されません；

個々のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)からの[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これによりリクエストはメモ化からオプトアウトするのではなく、処理中のリクエストを中止します；

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには組み込みのData Cacheがあり、データフェッチの結果を**サーバリクエスト**および**デプロイメント**間で**永続化**します。これは、Next.jsがネイティブの`fetch`APIを拡張して、サーバ上の各リクエストが自身の永続的なキャッシングセマンティクスを設定できるようにすることで可能になります；

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、`cache`オプションはサーバサイドリクエストがサーバのData Cacheとどのように相互作用するかを示します；

キャッシング動作を設定するには、`fetch`の[`cache`](#fetch-optionscache)および[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用できます；

**Data Cacheの仕組み**

<Image
  alt="Data Cacheとメモ化されていないfetchリクエストがData Cacheとどのように相互作用するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化され、キャッシュされていないリクエストはデータソースから取得され、Data Cacheに保存されず、メモ化される。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- 初めて`'force-cache'`オプションを持つ`fetch`リクエストがレンダリング中に呼び出されたとき、Next.jsはData Cacheでキャッシュされたレスポンスを確認します；
- キャッシュされたレスポンスが見つかった場合、それは即座に返され、[メモ化](#request-memoization)されます；
- キャッシュされたレスポンスが見つからない場合、データソースに対してリクエストが行われ、その結果がData Cacheに格納され、メモ化されます；
- キャッシュされていないデータ（例：キャッシュオプションが定義されていない、または`{ cache: 'no-store' }`を使用している場合）、したがってリクエストは常にデータソースから取得され、メモ化されます；
- データがキャッシュされているかキャッシュされていないかにかかわらず、リクエストは常にメモ化されて、Reactレンダリングパス中の同じデータに対する重複リクエストを防ぎます；

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシングメカニズムはキャッシュされたデータを再利用することによってパフォーマンスを向上させるのに役立ちますが、Data Cacheは入ってくるリクエストとデプロイメント間で永続的であるのに対し、メモ化はリクエストの寿命のみ持続です。

### 期間 {#duration}

Data Cacheは、再検証またはオプトアウトしない限り、入ってくるリクエストとデプロイメント間で永続です；

### 再検証 {#revalidating}

キャッシュされたデータは次の2つの方法で再検証できます：

- **時間ベースの再検証**：一定時間が経過し、新しいリクエストが行われるとデータを再検証します。これは、変化が少なく、鮮度がそれほど重要でないデータに便利です；
- **オンデマンド再検証**：イベントに基づいてデータを再検証します（例：フォームの送信）。オンデマンド再検証では、タグベースまたはパスベースのアプローチを使用してデータのグループを一度に再検証できます。これは、（例：ヘッドレスCMSからコンテンツが更新されたときなど）できるだけ迅速に最新データを表示したい場合に便利です；

#### 時間ベースの再検証 {#time-based-revalidation}

データを一定間隔で再検証するには、`fetch`の`next.revalidate`オプションを使用して、リソースのキャッシュ寿命を設定します（秒単位）；

```js
// 最長で毎時再検証
fetch('https://...', { next: { revalidate: 3600 } })
```

または、[route segment configオプション](#segment-config-options)を使用して、セグメント内のすべての`fetch`リクエストを設定するか、`fetch`を使用できない場合（例：データベースクライアントやサードパーティのライブラリを使用する場合）に設定できます；

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証がどのように機能するかを示す図。再検証期間後、最初のリクエストで古いデータが返され、その後データが再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`を持つfetchリクエストが初めて呼び出されたとき、データが外部データソースからフェッチされ、Data Cacheに格納されます；
- 指定された時間枠（例：60 seconds）内に呼び出されたリクエストはキャッシュされたデータを返します；
- 時間枠が経過した後、次のリクエストはキャッシュされた（現在古くなった）データを返します；
  - Next.jsはバックグラウンドでデータの再検証をトリガーします；
  - データが正常にフェッチされた場合、Next.jsはData Cacheを新鮮なデータで更新します；
  - バックグラウンドの再検証が失敗した場合、以前のデータが変更されずに保持されます；

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)の動作に似ています；

#### オンデマンド再検証 {#on-demand-revalidation}

データはパスごとにオンデマンドで再検証できます（[`revalidatePath`](#revalidatepath)）またはキャッシュタグごとに（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）；

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証がどのように機能するかを示す図。再検証リクエスト後、Data Cacheは新鮮なデータで更新されます。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼び出されると、データが外部データソースからフェッチされ、Data Cacheに格納されます；
- オンデマンド再検証がトリガーされると、適切なキャッシュエントリがキャッシュからパージされます；
  - これは、古いデータをキャッシュしておく時間ベースの再検証とは異なります；
- 次のリクエストが行われると、再びキャッシュ`MISS`となり、データが外部データソースから取得され、Data Cacheに格納されます；

### オプトアウト {#opting-out}

`fetch`からのレスポンスを**キャッシュしたくない**場合、以下のようにすることができます：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**：
>
> **Automatic Static Optimization**、**Static Site Generation**、または**Static Rendering**は、アプリケーションのルートをビルド時にレンダリングおよびキャッシュするプロセスを指すために互換的に使用される場合があります。

Next.jsはビルド時にルートを自動的にレンダリングし、キャッシュします。これは、各リクエストでサーバーでレンダリングする代わりにキャッシュされたルートを提供できる最適化であり、ページの読み込みを速くすることができます。

Full Route Cacheの仕組みを理解するためには、Reactがレンダリングをどのように処理するかと、Next.jsがその結果をどのようにキャッシュするかを見てみると役立ちます：

### 1. サーバーでのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングをオーケストレートします。レンダリング作業は次のように分割されます：個々のルートセグメントおよびSuspense境界により。

各チャンクは2つのステップでレンダリングされます：

1. ReactはServer Componentsをストリーミング用に最適化された特別なデータ形式、通称**React Server Component Payload**にレンダリングします；
2. Next.jsはReact Server Component PayloadとClient Component JavaScriptの命令を使用して、サーバーで**HTML**をレンダリングします；

これにより、すべてがレンダリングされるのを待つ必要がなく、作業をキャッシュしたり、レスポンスを送信したりすることができます。代わりに、作業が完了するときにレスポンスをストリーム送信することができます；

> **React Server Component Payloadとは？**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。このバイナリ表現は、クライアント側のReactがブラウザのDOMを更新するために使用します。React Server Component Payloadには次の内容が含まれます：
>
> - Sever Componentsのレンダリングされた結果
> - Client Componentsがレンダリングされるべき場所のプレースホルダーとそれらのJavaScriptファイルの参照
> - Server ComponentからClient Componentに渡されたプロップ
>
> 詳しくは、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください；

### 2. サーバーでのNext.jsキャッシング（Full Route Cache） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="Full Route Cacheのデフォルト動作、静的にレンダリングされたルートのサーバーでのReact Server Component PayloadとHTMLがキャッシュされる様子を示す。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルト動作は、ルートのレンダリングされた結果（React Server Component PayloadとHTML）をサーバ上でキャッシュすることです。これは、スタティックにレンダリングされたルートに対して、ビルド時、または再検証時に適用されます；

### 3. クライアントでのReactのハイドレーションとリコンシリエーション {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時に、クライアント上で：

1. HTMLは、ClientおよびServer Componentsの非インタラクティブな初期プレビューをすぐに表示するために使用されます；
2. React Server Components Payloadは、ClientおよびレンダリングされたServer Component treeを調整し、DOMを更新するために使用されます；
3. JavaScript命令は、アプリケーションをインタラクトにするための[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)Client Componentsに使用されます；

### 4. クライアントでのNext.jsキャッシング（Router Cache） {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadは、クライアント側の[Router Cache](#client-side-router-cache)に保存されます。これは、個々のルートセグメントごとに分割された別のインメモリキャッシュです。このRouter Cacheは、以前に訪問されたルートを保存し、将来訪れる可能性があるルートをプリフェッチすることによって、ナビゲーション体験を向上させます；

### 5. 後続のナビゲーション {#5-subsequent-navigations}

後続のナビゲーションやプリフェッチ中に、Next.jsはReact Server Components PayloadがRouter Cacheに格納されているかどうかを確認します。それが存在する場合、新しいサーバへのリクエストをスキップします；

ルートセグメントがキャッシュされていない場合、Next.jsはサーバからReact Server Componentsペイロードをフェッチし、クライアントでRouter Cacheを更新します；

### スタティックレンダリングと動的レンダリング {#static-and-dynamic-rendering}

ルートがビルド時にキャッシュされるかどうかは、静的にレンダリングされるか動的にレンダリングされるかによって決まります。静的ルートはデフォルトでキャッシュされますが、動的ルートはリクエスト時にレンダリングされ、キャッシュされません；

この図は、キャッシュされたデータおよびキャッシュされていないデータを使用した静的レンダリングおよび動的レンダリングの違いを示しています：

<Image
  alt="静的レンダリングと動的レンダリングがFull Route Cacheにどのように影響を与えるか。静的ルートはビルド時またはデータ再検証後にキャッシュされるが、動的ルートは決してキャッシュされない。"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的レンダリングと動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学んでください；

### 期間 {#duration}

デフォルトで、Full Route Cacheは永続的です。これは、レンダリングの出力がユーザーのリクエストにわたってキャッシュされることを意味します；

### 無効化 {#invalidation}

Full Route Cacheを無効にする2つの方法があります：

- **[Revalidating Data](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)を再検証することで、Router Cacheを無効にし、サーバでコンポーネントを再レンダリングし、新しいレンダリング結果をキャッシュします；
- **再デプロイ**: 入ってくるリクエストとデプロイメント間で永続的なData Cacheとは異なり、Full Route Cacheは新しいデプロイメントでクリアされます；

### オプトアウト {#opting-out}

Full Route Cacheからオプトアウトする、つまり各着信リクエストごとにコンポーネントを動的にレンダリングするには、以下の方法があります：

- **[Dynamic API](#dynamic-apis)を使用する**：これはFull Route Cacheからルートをオプトアウトし、リクエスト時に動的にレンダリングします。Data Cacheはまだ使用できます；
- **`dynamic = 'force-dynamic'`または`revalidate = 0`ルートセグメント設定オプションを使用する**：Full Route CacheとData Cacheをスキップします。つまり、サーバーへのすべてのリクエストごとにコンポーネントをレンダリングし、データを取得します。Router Cacheはクライアントサイドのキャッシュであるため、まだ適用されます；
- **[Data Cache](#data-cache)からオプトアウトする**：キャッシュされていない`fetch`リクエストを持つルートがある場合、これはルートをFull Route Cacheからオプトアウトします。特定の`fetch`リクエストのデータはすべてのリクエストごとにフェッチされます。キャッシュからオプトアウトしない他のリクエストはData Cacheにキャッシュされ続けます。これにより、キャッシュされたデータとキャッシュされていないデータのハイブリッドを作成できます；

## クライアントサイドRouter Cache {#client-side-router-cache}

Next.jsには、ルートセグメントのRSCペイロードをレイアウト、ローディング状態、ページに分割してキャッシュするインメモリのクライアントサイドルータキャッシュがあります；

ユーザーがルート間を移動すると、Next.jsは訪れたルートセグメントをキャッシュし、ユーザーが次に移動する可能性が高いルートを[prefetch](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、前後のナビゲーションが即座に行われ、ナビゲーション間での全ページの再読み込みがなく、Reactステートとブラウザステートが維持されます；

Router Cacheを使用することで：

- **レイアウト**はキャッシュされ、ナビゲーション時に再利用されます（[partial rendering](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）；
- **ローディング状態**はナビゲーション時にキャッシュされ、[インスタントナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)に再利用されます；
- **ページ**はデフォルトではキャッシュされませんが、ブラウザの後ろ向きおよび前向きナビゲーション中に再利用されます。実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用してページセグメントのキャッシュを有効にできます；

{/* TODO: v15の動作に合わせて図を更新 */}

> **Good to know:** このキャッシュは特にNext.jsおよびServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、同様の結果を持っています；

### 期間 {#duration}

キャッシュはブラウザの一時メモリに保存されます。2つの要素がルータキャッシュの持続時間を決定します：

- **セッション**：キャッシュはナビゲーション中に永続します。ただし、ページの更新時にはクリアされます；
- **自動無効化期間**：レイアウトとローディング状態のキャッシュは指定された時間が経過すると自動的に無効化されます。この期間はリソースが[prefetch](/docs/app/api-reference/components/link#prefetch)された方法やリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかどうかによって異なります：
  - **デフォルトプリフェッチ** (`prefetch={null}`または指定なし)：動的ページのためにはキャッシュされず、静的ページのためには5分間；
  - **フルプリフェッチ** (`prefetch={true}`または`router.prefetch`)：静的および動的ページの両方が5分間；

ページ更新時には**すべて**キャッシュされたセグメントがクリアされますが、自動無効化期間はプリフェッチされた時からの個々のセグメントにのみ影響します；

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用して上記の自動無効化時間を調整できます；

### 無効化 {#invalidation}

Router Cacheを無効にする2つの方法があります：

- **Server Action**内で：
  - パスでのオンデマンドデータ再検証（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)）またはキャッシュタグでの（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）；
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用すると、ルートが古くならないようにするためにRouter Cacheが無効化されます（例：認証）；
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すとRouter Cacheが無効化され、現在のルートに対してサーバーへの新しいリクエストが行われます；

### オプトアウト {#opting-out}

Next.js 15以降、ページセグメントはデフォルトでオプトアウトされています；

> **Good to know:** `<Link>`コンポーネントの`prefetch`プロップを`false`に設定することで[prefetch](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)もオプトアウトできます。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシングメカニズムを設定する際に、それらがどのように相互作用するかを理解することが重要です：

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheを再検証またはオプトアウトすると、レンダリングの出力がデータに依存しているため、Full Route Cacheが無効になります；
- Full Route Cacheを無効化またはオプトアウトしても、Data Cacheには影響しません。キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングすることができます。これは、ページのほとんどがキャッシュされたデータを使用しており、リクエスト時にフェッチする必要があるデータを使用しているコンポーネントがいくつかある場合に便利です。すべてのデータを再フェッチするパフォーマンス影響を心配せずに動的にレンダリングできます；

### Data CacheとClient-side Router cache {#data-cache-and-client-side-router-cache}

- Data CacheとRouter cacheを即座に無効にするには、[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用します；
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でのData Cacheの再検証は、Router Handlerが特定のルートに関連付けられていないため、Router Cacheを即座に無効に**しません**。これにより、Router Cacheはハードリフレッシュまたは自動無効化期間が経過するまで前のペイロードを提供し続けます；

## API {#apis}

以下の表は、さまざまなNext.jsのAPIがキャッシングにどのように影響するかの概要を示します：

| API                                                                     | ルーターキャッシュ      | Full Route Cache             | Data Cache                   | React Cache |
| ----------------------------------------------------------------------- | ----------------------- | ---------------------------- | ---------------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | キャッシュ              |                              |                              |             |
| [`router.prefetch`](#routerprefetch)                                    | キャッシュ              |                              |                              |             |
| [`router.refresh`](#routerrefresh)                                      | 再検証                  |                              |                              |             |
| [`fetch`](#fetch)                                                       |                         |                              | キャッシュ                   | キャッシュ  |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                         |                              | キャッシュまたはオプトアウト |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                         | 再検証                       | 再検証                       |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                         | キャッシュ                   | キャッシュ                   |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | 再検証（Server Action） | 再検証                       | 再検証                       |             |
| [`revalidatePath`](#revalidatepath)                                     | 再検証（Server Action） | 再検証                       | 再検証                       |             |
| [`const revalidate`](#segment-config-options)                           |                         | 再検証またはオプトアウト     | 再検証またはオプトアウト     |             |
| [`const dynamic`](#segment-config-options)                              |                         | キャッシュまたはオプトアウト | キャッシュまたはオプトアウト |             |
| [`cookies`](#cookies)                                                   | 再検証（Server Action） | オプトアウト                 |                              |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                         | オプトアウト                 |                              |             |
| [`generateStaticParams`](#generatestaticparams)                         |                         | キャッシュ                   |                              |             |
| [`React.cache`](#react-cache-function)                                  |                         |                              |                              | キャッシュ  |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                         |                              | キャッシュ                   |             |

### `<Link>` {#link}

デフォルトで、`<Link>`コンポーネントはFull Route Cacheからルートを自動的にプリフェッチし、React Server Component PayloadをRouter Cacheに追加します；

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定します。しかし、これはキャッシュを永続的にスキップすることはありません。ユーザーがルートを訪れると、ルートセグメントはクライアントサイドでキャッシュされます；

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しく学びましょう；

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使用して、手動でルートをプリフェッチできます。これにより、React Server Component PayloadがRouter Cacheに追加されます；

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPI参照を参照してください；

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使用して、手動でルートをリフレッシュできます。これにより、Router Cacheが完全にクリアされ、現在のルートに対してサーバーに新しいリクエストが行われます。`refresh`はDataまたはFull Route Cacheには影響しません；

レンダリングされた結果はReact状態とブラウザ状態を保持しながらクライアント上で調整されます；

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPI参照を参照してください；

### `fetch` {#fetch}

`fetch`から返されるデータは、Data Cacheに自動的にキャッシュ**されません**；

`fetch`のデフォルトのキャッシング動作（例：`cache`オプションが指定されていない場合）は、次のコードにおいて`cache`オプションが`no-store`に設定されているのと同等です：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` API Reference](/docs/app/api-reference/functions/fetch)で他のオプションを参照してください；

### `fetch options.cache` {#fetch-options-cache}

個々の`fetch`をキャッシュするためには、`cache`オプションを`force-cache`に設定します：

```jsx
// キャッシュへオプトインする
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` API Reference](/docs/app/api-reference/functions/fetch)で他のオプションを参照してください；

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

`fetch`の`next.revalidate`オプションを使用して、個々の`fetch`リクエストの再検証期間（秒単位）を設定できます。これによりData Cacheが再検証され、その結果Full Route Cacheも再検証されます。新鮮なデータがフェッチされ、コンポーネントがサーバーで再レンダリングされます；

```jsx
// 最長で1時間後に再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` API reference](/docs/app/api-reference/functions/fetch)で他のオプションを参照してください；

### `fetch options.next.tags`と`revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには細かいデータキャッシングと再検証のためのキャッシュタグシステムがあります；

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用すると、キャッシュエントリに1つまたは複数のタグを設定するオプションがあります；
2. 次に、特定のタグに関連するキャッシュエントリをパージするために`revalidateTag`を呼び出すことができます；

例えば、データをフェッチする際にタグを設定することができます：

```jsx
// タグでデータをキャッシュ
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

次に、タグでキャッシュエントリをパージするために`revalidateTag`を呼び出します：

```jsx
// 特定のタグを持つエントリを再検証
revalidateTag('a')
```

次の2つの場所で、目的に応じて`revalidateTag`を使用できます：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：Webhook）に応じてデータを再検証するため。これによりRouter Cacheが即座には無効化されません。Router Handlerが特定のルートに関連付けられていないためです；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション（例：フォーム送信）後にデータを再検証するため。これにより対応するルートに対するRouter Cacheが無効化されます；

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、データの再検証を手動で行い、特定のパスの下のルートセグメントを単一の操作で再レンダリングできます。`revalidatePath`メソッドを呼び出すと、データキャッシュが再検証され、その結果Full Route Cacheが無効化されます；

```jsx
revalidatePath('/')
```

次の2つの場所で、目的に応じて`revalidatePath`を使用できます：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：Webhook）に応じてデータを再検証するため；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション（例：フォーム送信、ボタンのクリック）後にデータを再検証するため；

[`revalidatePath` API参照](/docs/app/api-reference/functions/revalidatePath)で詳しい情報をご確認ください；

> **`revalidatePath`** vs. **`router.refresh`**：
>
> `router.refresh`を呼び出すとRouter cacheがクリアされ、データキャッシュやFull Route Cacheを無効にせずにサーバーでルートセグメントが再レンダリングされます；
>
> 違いは、`revalidatePath`はデータキャッシュとFull Route Cacheをパージする一方、`router.refresh()`はデータキャッシュとFull Route Cacheを変更しないクライアントサイドAPIであるということです；

### Dynamic API {#dynamic-apis}

`cookies`や`headers`のようなDynamic API、またPagesにおける`searchParams`プロップは、実行時の受信リクエスト情報に依存しています。それらを使用すると、ルートはFull Route Cacheからオプトアウトされ、動的にレンダリングされます；

#### `cookies` {#cookies}

Server Action内で`cookies.set`または`cookies.delete`を使用すると、認証の変更を反映するため（例：認証の変更）にRouter Cacheが無効化されます；

[`cookies`](/docs/app/api-reference/functions/cookies) API参照を参照してください；

### Segment Config Options {#segment-config-options}

Route Segment Configオプションは、ルートセグメントのデフォルトをオーバーライドするため、または`fetch` APIを使用できない場合（例：データベースクライアントや3rdパーティのライブラリ）に使用できます；

次のRoute Segment Configオプションは、Full Route Cacheからオプトアウトします：

- `const dynamic = 'force-dynamic'`

この設定オプションは、すべてのフェッチをData Cacheからオプトアウトします（例：`no-store`）：

- `const fetchCache = 'default-no-store'`

[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)でより詳細なオプションをご覧ください；

[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントで他のオプションをご覧ください；

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）の場合、`generateStaticParams`によって提供されるパスはビルド時にFull Route Cacheにキャッシュされます。リクエスト時には、ビルド時に不明だったパスも最初に訪問されたときにキャッシュされます；

ビルド時にすべてのパスを静的にレンダリングするには、`generateStaticParams`に完全なパスリストを提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスのサブセットを静的にレンダリングし、その後のパスを実行時に初めて訪問されたときにレンダリングするには、部分的なパスリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10件の投稿をビルド時にレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

最初に訪問されたときにすべてのパスを静的にレンダリングするには、空の配列を返す（ビルド時にはパスがレンダリングされない）か、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`では、たとえ空でも配列を返す必要があります。そうしないと、ルートは動的にレンダリングされます；

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時のキャッシングを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。この設定オプションが使用されると、`generateStaticParams`で提供されたパスのみが提供され、他のルートは404を返します（[catch-all ルート](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)）に一致する場合があります；

### React `cache`関数 {#react-cache-function}

Reactの`cache`関数を使用すると、関数の戻り値をメモ化することができ、同じ関数を複数回呼び出しても1回だけ実行されます；

`fetch`リクエストは自動的にメモ化されるため、React `cache`でラップする必要はありません。ただし、`fetch` APIが適さないユースケースの場合に、データリクエストを手動でメモ化するために`cache`を使用できます。例えば、いくつかのデータベースクライアント、CMSクライアント、またはGraphQLクライアントです；

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
