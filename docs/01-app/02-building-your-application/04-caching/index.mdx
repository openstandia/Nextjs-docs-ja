---
title: 'Next.jsにおけるキャッシュ'
nav_title: 'キャッシュ'
description: 'Next.jsのキャッシュメカニズムの概要。'
---

Next.jsはレンダリング作業とデータリクエストをキャッシュすることで、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシュメカニズム、設定に使用できるAPI、およびそれらがどのように相互作用するかについて詳しく説明します。

> **Good to know**: このページはNext.jsの内部がどのように機能しているかを理解するのに役立ちますが、Next.jsで生産的に稼働するために必ずしも必要な知識ではありません。Next.jsのキャッシュアルゴリズムの多くは、APIの使用方法に基づいて決定され、そのほとんどの場合はゼロまたは最小限の設定で最高のパフォーマンスのためのデフォルトが用意されています。代わりに、例をすぐに見たい場合は、[こちらから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

次に、さまざまなキャッシュメカニズムとその目的の概要を示します:

| メカニズム                                  | 内容                | 場所         | 目的                                                   | 期間                               |
| ------------------------------------------- | ------------------- | ------------ | ------------------------------------------------------ | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の戻り値        | サーバー     | React Component tree内でデータを再利用する             | リクエストライフサイクルごと       |
| [Data Cache](#data-cache)                   | データ              | サーバー     | ユーザーリクエストとデプロイメント間でデータを保存する | 永続的（再検証可能）               |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバー     | レンダリングコストを削減し、パフォーマンスを向上させる | 永続的（再検証可能）               |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時のサーバーリクエストを削減する         | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsはパフォーマンスを向上させ、コストを削減するために可能な限り多くのキャッシュを行います。つまり、ルートは**静的にレンダリングされ**、データリクエストは**キャッシュされ**ますが、これをオプトアウトすることもできます。以下の図は、ビルド時と静的なルートが初めて訪問されたときにルートが静的にレンダリングされるときのデフォルトのキャッシュ動作を示しています：

<Image
  alt="Next.jsにおける4つのメカニズムのデフォルトのキャッシュ動作を示す図、ビルド時とルートが初めて訪問されたときのHIT、MISS、SET。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシュ動作は、ルートが静的にレンダリングされるか動的にレンダリングされるか、データがキャッシュされているかされていないか、リクエストが初めての訪問か後続のナビゲーションの一部であるかによって変わります。ユースケースに応じて、個々のルートやデータリクエストのキャッシュ動作を設定することができます。

## Request Memoization {#request-memoization}

Reactは同じURLとオプションのリクエストを自動的に**メモ化**するために、[`fetch` API](#fetch)を拡張しています。これにより、Reactコンポーネントツリーの複数の場所で同じデータを取得するためのfetch関数を呼び出すことができますが、実行されるのは1回だけです。

<Image
  alt="重複を排除されたFetch Requests"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

たとえば、ルート全体で同じデータを使用する必要がある場合（例：レイアウト、ページ、および複数のコンポーネント）、ツリーの最上位でデータをフェッチし、それをコンポーネント間でpropsとして渡す必要はありません。代わりに、それを必要とするコンポーネントでデータをフェッチすることができ、同じデータに対してネットワークを介して複数のリクエストを行うことによるパフォーマンスへの影響を心配する必要はありません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれるが、最初に実行されたときだけ実行されます
const item = await getItem() // cache MISS

// 2番目の呼び出しはルート内のどこにでも配置できます
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれるが、最初に実行されたときだけ実行されます
const item = await getItem() // cache MISS

// 2番目の呼び出しはルート内のどこにでも配置できます
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoizationの仕組み**

<Image
  alt="Reactレンダリング中にfetchメモ化がどのように機能するかを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリング中、特定のリクエストが最初に呼び出されたとき、その結果はメモリに存在せず、キャッシュ`MISS`になります。
- そのため、関数が実行され、外部ソースからデータが取得され、その結果がメモリに保存されます。
- 同じレンダリングパス内でのリクエストの後続の関数呼び出しはキャッシュ`HIT`となり、関数を実行せずにメモリからデータが返されます。
- ルートがレンダリングされ、レンダリングパスが完了すると、メモリは「リセット」され、すべてのrequest memoizationエントリがクリアされます。

> **Good to know**:
>
> - Request memoizationはReactの機能であり、Next.jsの機能ではありません。ここに含めたのは、他のキャッシュメカニズムとの相互作用を示すためです。
> - メモ化は、`fetch`リクエストの`GET`メソッドにのみ適用されます。
> - メモ化は、React Component treeにのみ適用されます。つまり:
>   - `generateMetadata`、`generateStaticParams`、レイアウト、ページ、およびその他のServer Componentsでの`fetch`リクエストに適用されます。
>   - Route Handlersでの`fetch`リクエストには適用されません。これらはReact component treeの一部ではないためです。
> - `fetch`が適していない場合（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）、[React `cache`関数](#react-cache-function)を使用して関数をメモ化することができます。

### 期間 {#duration}

キャッシュはサーバーリクエストのライフタイムの間に存在し、React component treeのレンダリングが完了するまで続きます。

### 再検証 {#revalidating}

メモ化はサーバーリクエスト間で共有されず、レンダリング中にのみ適用されるので、再検証の必要はありません。

### オプトアウト {#opting-out}

メモ化は、`fetch`リクエストの`GET`メソッドにのみ適用され、`POST`や`DELETE`などの他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、それをオプトアウトすることは推奨しません。

個々のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)の[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。しかし、これはメモ化からリクエストをオプトアウトするのではなく、実行中のリクエストを中止します。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには、**サーバーリクエスト**および**デプロイ**間でデータフェッチの結果を**永続**するための組み込みData Cacheがあります。これは、Next.jsがネイティブの`fetch`APIを拡張して、サーバー上の各リクエストで独自の永続的なキャッシュセマンティクスを設定できるようにすることで実現可能です。

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、`cache`オプションはサーバー側リクエストがサーバーのData Cacheとどのように相互作用するかを示します。

`fetch`の[`cache`](#fetch-optionscache)および[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシュの動作を設定できます。

**Data Cacheの仕組み**

<Image
  alt="キャッシュされたリクエストとキャッシュされていないリクエストがData Cacheとどのように相互作用するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化され、キャッシュされていないリクエストはデータソースからフェッチされ、Data Cacheに保存されず、メモ化されます。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- レンダリング中に`fetch`リクエストが`'force-cache'`オプションで初めて呼び出されると、Next.jsはData Cacheにキャッシュされたレスポンスがあるかどうかを確認します。
- キャッシュされたレスポンスが見つかると、それはすぐに返され、[メモ化](#request-memoization)されます。
- キャッシュされたレスポンスが見つからない場合、リクエストはデータソースに対して行われ、結果がData Cacheに保存され、メモ化されます。
- キャッシュされないデータの場合（例：`cache`オプションが定義されていない場合、または `{ cache: 'no-store' }`を使用している場合）、結果は常にデータソースからフェッチされ、メモ化されます。
- データがキャッシュされているかされていないかに関わらず、リクエストは常にメモ化され、Reactレンダーパス中に同じデータの重複リクエストを行わないようにします。

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシュメカニズムがキャッシュされたデータを再利用することでパフォーマンスを向上させるのに役立ちますが、Data Cacheは受信リクエストとデプロイメントを通じて永続的であるのに対し、メモ化はリクエストの寿命のみ持続します。

### 期間 {#duration}

Data Cacheは再検証またはオプトアウトしない限り、受信リクエストとデプロイメントを通じて永続的です。

### 再検証 {#revalidating}

キャッシュされたデータは次の2つの方法で再検証できます：

- **時間ベースの再検証**：一定時間が経過した後、リクエストが新たに行われたときにデータを再検証します。これは変更が少なく、最新であることが重要でないデータに役立ちます。
- **オンデマンド再検証：** イベントに基づいてデータを再検証します（例：フォーム送信時）。オンデマンド再検証は、タグベースまたはパスベースのアプローチを使用して、データのグループを一括で再検証できます。これは、コンテンツの最新状態をできるだけ早く表示したい場合に役立ちます（例：ヘッドレスCMSのコンテンツが更新された場合）。

#### 時間ベースの再検証 {#time-based-revalidation}

特定の間隔でデータを再検証するには、`fetch`の`next.revalidate`オプションを使用してリソースのキャッシュ期間（秒単位）を設定できます。

```js
// 最大1時間ごとに再検証します
fetch('https://...', { next: { revalidate: 3600 } })
```

または、[Route Segment Configオプション](#segment-config-options)を使用して、セグメント内のすべての`fetch`リクエストを設定するか、`fetch`を使用できない場合にそれを使用できます。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証がどのように機能するかを示す図、再検証期間の後、最初のリクエストでは古いデータが返され、次にデータが再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`付きのfetchリクエストが初めて呼び出されると、データが外部データソースからフェッチされ、Data Cacheに保存されます。
- 指定された時間枠内で呼び出されるリクエストはキャッシュされたデータを返します。
- この時間枠が経過すると、次回のリクエストは依然としてキャッシュされた（古い）データを返します。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データが正常にフェッチされると、Next.jsは新鮮なデータでData Cacheを更新します。
  - バックグラウンド再検証が失敗した場合、以前のデータは変更されずに保持されます。

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)の動作に似ています。

#### オンデマンド再検証 {#on-demand-revalidation}

データは、パス（[`revalidatePath`](#revalidatepath)）またはキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）でオンデマンドで再検証できます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証がどのように機能するかを示す図、再検証リクエスト後にData Cacheが新しいデータで更新されます。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼び出されると、データが外部データソースからフェッチされ、Data Cacheに保存されます。
- オンデマンド再検証がトリガーされた場合、適切なキャッシュエントリはキャッシュから削除されます。
  - これは、古いデータをフェッチするまでキャッシュに保持する時間ベースの再検証とは異なります。
- 次にリクエストが行われたとき、再びキャッシュ`MISS`となり、データが外部データソースからフェッチされ、Data Cacheに保存されます。

### オプトアウト {#opting-out}

`fetch`からのレスポンスをキャッシュしたくない場合は、次のように設定できます：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**:
>
> アプリケーションのルートをビルド時にレンダリングおよびキャッシュするプロセスを指して、**Automatic Static Optimization**、**Static Site Generation**、または**Static Rendering**という用語を使用することがあります。

Next.jsはビルド時にルートを自動的にレンダリングし、キャッシュします。これにより、すべてのリクエストに対してサーバーでレンダリングする代わりに、キャッシュされたルートを提供することができ、高速なページロードを実現します。

Full Route Cacheの仕組みを理解するには、Reactがレンダリングをどのように処理し、Next.jsがその結果をどのようにキャッシュするかを見ることが役立ちます：

### 1. サーバーでのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントやSuspense境界によって分割されます。

各チャンクは2つのステップでレンダリングされます：

1. Reactはサーバーコンポーネントをストリーミングに最適化された特別なデータ形式である**Reactサーバーコンポーネントペイロード**にレンダリングします。
2. Next.jsはReactサーバーコンポーネントペイロードとクライアントコンポーネントJavaScript命令を使用して、**HTML**をサーバーでレンダリングします。

これにより、すべてをレンダリングし終えるまで作業をキャッシュしたり、レスポンスを送信したりする必要がなくなります。代わりに、作業が完了すると、レスポンスをストリーミングできます。

> **Reactサーバーコンポーネントペイロードとは？**
>
> Reactサーバーコンポーネントペイロードは、レンダリングされたReactサーバーコンポーネントツリーのコンパクトなバイナリ表現です。クライアントのReactによってブラウザのDOMを更新するために使用されます。このペイロードには次が含まれます：
>
> - サーバーコンポーネントのレンダリング結果
> - クライアントコンポーネントのレンダリング場所とそのJavaScriptファイルへの参照
> - サーバーコンポーネントからクライアントコンポーネントに渡されるany props
>
> 詳しくは、[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)ドキュメントをご覧ください。

### 2. サーバーでのNext.jsキャッシュ（Full Route Cache） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="静的にレンダリングされたルートに対して、サーバーにReactサーバーコンポーネントペイロードとHTMLがキャッシュされるFull Route Cacheのデフォルト動作を示す図。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルト動作は、サーバーでルートのレンダリング結果（ReactサーバーコンポーネントペイロードとHTML）をキャッシュすることです。これは、ビルド時または再検証時に静的にレンダリングされたルートに適用されます。

### 3. クライアントでのReactのハイドレーションと調整 {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時、クライアント側では：

1. HTMLを使用して、クライアントおよびサーバーコンポーネントのインタラクティブでない初期プレビューを即座に表示します。
2. Reactサーバーコンポーネントペイロードを使用して、クライアントとレンダリングされたサーバーコンポーネントツリーを調整し、DOMを更新します。
3. JavaScript命令を使用して[クライアントコンポーネントをハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにします。

### 4. クライアントでのNext.jsキャッシュ（Router Cache） {#4-next-js-caching-on-the-client-router-cache}

Reactサーバーコンポーネントペイロードは、クライアント側の[Router Cache](#client-side-router-cache)に保存されます。これは、個々のルートセグメントによって分割されたメモリキャッシュです。このRouter Cacheは、以前訪れたルートを保存し、将来のルートを事前フェッチすることで、ナビゲーション経験を向上させるために使用されます。

### 5. 後続のナビゲーション {#5-subsequent-navigations}

後続のナビゲーションや事前フェッチ中、Next.jsはRouter CacheにReactサーバーコンポーネントペイロードが保存されているかどうかを確認します。そうであれば、新たにサーバーにリクエストを送信することをスキップします。

ルートセグメントがキャッシュにない場合、Next.jsはサーバーからReactサーバーコンポーネントペイロードをフェッチし、クライアントのRouter Cacheに置きます。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ルートがビルド時にキャッシュされるかどうかは、そのルートが静的レンダリングか動的レンダリングかによります。静的ルートはデフォルトでキャッシュされますが、動的ルートはリクエスト時にレンダリングされ、キャッシュされません。

この図は、静的および動的にレンダリングされたルートと、キャッシュされたデータとキャッシュされていないデータとの違いを示しています：

<Image
  alt="静的および動的レンダリングがFull Route Cacheにどのように影響するかを示す図。静的ルートはビルド時またはデータ再検証後にキャッシュされ、動的ルートは決してキャッシュされません"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学ぶ。

### 期間 {#duration}

デフォルトでは、Full Route Cacheは永続的です。これは、レンダリング結果がユーザーリクエストを通じてキャッシュされるという意味です。

### 無効化 {#invalidation}

Full Route Cacheを無効化する方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)を再検証することで、Router Cacheを再レンダリングすることにより、サーバーでコンポーネントを再レンダリングし、新しいレンダリング結果をキャッシュします。
- **再デプロイ**: データキャッシュとは異なり、新しいデプロイメント時にFull Route Cacheはクリアされます。

### オプトアウト {#opting-out}

Full Route Cacheをオプトアウトする、つまり、各受信リクエストごとにコンポーネントを動的にレンダリングするには、以下の手法があります：

- **[Dynamic API](#dynamic-apis)を使用する**: これにより、ルートがFull Route Cacheからオプトアウトされ、リクエスト時に動的にレンダリングされます。Data Cacheは引き続き使用できます。
- **`dynamic = 'force-dynamic'`または`revalidate = 0`ルートセグメント設定オプションを使用**: これにより、Full Route CacheおよびData Cacheをスキップします。つまり、サーバーへのすべての受信リクエストでコンポーネントがレンダリングされ、データがフェッチされます。Router Cacheはクライアントサイドのキャッシュなので引き続き適用されます。
- **[Data Cache](#data-cache)のオプトアウト**: キャッシュされていない`fetch`リクエストが存在するルートは、Full Route Cacheからオプトアウトされます。特定の`fetch`リクエストのデータがすべての受信リクエストでフェッチされます。キャッシュのオプトアウトをしない他の`fetch`リクエストはData Cacheにキャッシュされ続けます。これは、キャッシュされたデータとキャッシュされていないデータのハイブリッドを可能にします。

## クライアントサイドRouter Cache {#client-side-router-cache}

Next.jsには、レイアウト、読み込み状態、およびページによって分割されたルートセグメントのRSCペイロードを保存するメモリ内クライアントサイドのrouterのキャッシュがあります。

ユーザーがルート間をナビゲートする場合、Next.jsは訪問したルートセグメントをキャッシュし、ユーザーがナビゲートする可能性が高いルートを[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、瞬時の戻る/進むナビゲーションが可能になり、ナビゲーション間でのフルページのリロードがなくなり、Reactの状態とブラウザーの状態が維持されます。

Router Cacheを使用すると：

- **レイアウト**はキャッシュされ、ナビゲーション時に再利用される（[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）。
- **ロード状態**はキャッシュされ、[インスタントナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のためにナビゲーション時に再利用されます。
- **ページ**はデフォルトではキャッシュされませんが、ブラウザーの戻るおよび進むナビゲーション中に再利用されます。ページセグメントのキャッシュを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用できます。

{/* TODO: v15の動作に合わせて図を更新 */}

> **Good to know:** このキャッシュは特にNext.jsおよびサーバーコンポーネントに適用され、ブラウザーの[bfcache](https://web.dev/bfcache/)とは異なりますが、結果は似ています。

### 期間 {#duration}

キャッシュはブラウザーの一時メモリに保存されます。2つの要因がrouter cacheの持続期間を決定します：

- **セッション**: キャッシュはナビゲーション中に持続しますが、ページをリフレッシュするとクリアされます。
- **自動無効化期間**: レイアウトとロード状態のキャッシュは、特定の時間が経過すると自動的に無効化されます。この期間は、リソースが[プリフェッチされた](/docs/app/api-reference/components/link#prefetch)方法と、リソースが[静的に生成された](/docs/app/building-your-application/rendering/server-components#static-rendering-default)かどうかによって異なります：
  - **デフォルトのプリフェッチング**（`prefetch={null}`または指定されていない）：動的ページの場合はキャッシュされず、静的ページの場合は5分。
  - **フルプリフェッチング**（`prefetch={true}`または`router.prefetch`）：静的ページと動的ページの両方の場合は5分。

ページをリフレッシュすると、**すべて**のキャッシュされたセグメントがクリアされますが、自動無効化期間はプリフェッチされた時点から個々のセグメントにだけ影響します。

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用して、上記の自動無効化時間を調整できます。

### 無効化 {#invalidation}

Router Cacheを無効化する方法は2つあります：

- **Server Action**で：
  - （[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)）または（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）を使用してパスによるオンデマンド再検証。
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用することで、クッキーを使用するルートが古くならないようにRouter Cacheを無効にします（例：認証）。
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すことで、Router Cacheを無効化し、現在のルートに対して新しいリクエストをサーバーに送信します。

### オプトアウト {#opting-out}

Next.js 15以降では、ページセグメントはデフォルトでオプトアウトされています。

> **Good to know:** `<Link>`コンポーネントの`prefetch` propを`false`に設定することで、[プリフェッチング](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)をオプトアウトすることもできます。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシュメカニズムを設定するとき、それらがどのように相互作用するかを理解することが重要です：

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheを再検証またはオプトアウトすると、Full Route Cacheは**無効化**されます。なぜなら、レンダリングの結果はデータに依存するからです。
- Full Route Cacheを無効化またはオプトアウトしても、Data Cacheは影響を受けません。キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングすることができます。これは、ページのほとんどがキャッシュされたデータを使用しているが、いくつかのコンポーネントがリクエスト時にフェッチする必要があるデータに依存している場合に便利です。すべてのデータを再フェッチするパフォーマンスへの影響を心配することなく、動的にレンダリング可能です。

### Data CacheとクライアントサイドRouter Cache {#data-cache-and-client-side-router-cache}

- Data CacheとRouter Cacheを即時に無効化するには、[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます。
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証しても、Router Cacheは即時に無効化されません。なぜなら、Route Handlerは特定のルートに結びついていないからです。つまり、Router Cacheはハードリフレッシュが行われるまで、または自動無効化期間が経過するまで、前のペイロードを配信し続けます。

## API {#apis}

以下の表は、さまざまなNext.js APIがキャッシュにどのように影響するかの概要を示しています：

| API                                                                     | Router Cache               | Full Route Cache      | Data Cache            | React Cache |
| ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | Cache                      |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                    | Cache                      |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                      | Revalidate                 |                       |                       |             |
| [`fetch`](#fetch)                                                       |                            |                       | Cache                 | Cache       |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                       | Cache or Opt out      |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Revalidate            | Revalidate            |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Cache                 | Cache                 |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`revalidatePath`](#revalidatepath)                                     | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`const revalidate`](#segment-config-options)                           |                            | Revalidate or Opt out | Revalidate or Opt out |             |
| [`const dynamic`](#segment-config-options)                              |                            | Cache or Opt out      | Cache or Opt out      |             |
| [`cookies`](#cookies)                                                   | Revalidate (Server Action) | Opt out               |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Opt out               |                       |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Cache                 |                       |             |
| [`React.cache`](#react-cache-function)                                  |                            |                       |                       | Cache       |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                       | Cache                 |             |

### `<Link>` {#link}

デフォルトでは、`<Link>`コンポーネントはFull Route Cacheからルートを自動的にプリフェッチし、Router CacheにReactサーバーコンポーネントペイロードを追加します。

プリフェッチを無効にするには、`prefetch` propを`false`に設定できます。しかし、これによりキャッシュが恒久的にスキップされることはなく、ユーザーがルートを訪問したときにルートセグメントはクライアント側でまだキャッシュされます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しく学ぶ。

### `router.prefetch` {#router-prefetch}

`router.prefetch`オプションを使用して手動でルートをプリフェッチできます。これにより、ReactサーバーコンポーネントペイロードがRouter Cacheに追加されます。

[`useRouter` hook](/docs/app/api-reference/functions/use-router)のAPIリファレンスをご覧ください。

### `router.refresh` {#router-refresh}

`refresh`オプションを使用することで、ルートを手動でリフレッシュできます。これにより、Router Cacheが完全にクリアされ、現在のルートに対して新しいリクエストがサーバーに送信されます。`refresh`はDataまたはFull Route Cacheには影響しません。

レンダリングされた結果は、Reactの状態とブラウザーの状態を保持しながらクライアント側で調整されます。

[`useRouter` hook](/docs/app/api-reference/functions/use-router)のAPIリファレンスをご覧ください。

### `fetch` {#fetch}

`fetch`から返されるデータは、Data Cacheに自動的にキャッシュされません。

`fetch`のデフォルトのキャッシュ動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定した場合と同等です：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で他のオプションを確認してください。

### `fetch options.cache` {#fetch-options-cache}

個々の`fetch`をキャッシュにオプトインするには、`cache`オプションを`force-cache`に設定します：

```jsx
// キャッシュにオプトイン
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で他のオプションを確認してください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

`fetch`の`next.revalidate`オプションを使用して、個々の`fetch`リクエストの再検証期間（秒単位）を設定できます。これによりData Cacheが再検証され、結果としてFull Route Cacheも再検証されます。新鮮なデータがフェッチされ、コンポーネントがサーバーで再レンダリングされます。

```jsx
// 最大1時間ごとに再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で他のオプションを確認してください。

### `fetch options.next.tags`および`revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、細かいデータキャッシングと再検証のためのキャッシュタグシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用する場合、1つ以上のタグをキャッシュエントリに付けるオプションがあります。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリをパージできます。

たとえば、データをフェッチするときにタグを設定できます：

```jsx
// キャッシュデータにタグを付ける
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

次に、特定のタグでキャッシュエントリをパージするために`revalidateTag`を呼び出します：

```jsx
// 特定のタグを持つエントリを再検証
revalidateTag('a')
```

どちらのケースも、あなたが達成しようとしていることに応じて、`revalidateTag`を使用できる場所が2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：Webhook）の応答でデータを再検証します。Router Cacheはすぐには無効化されません。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション（例：フォーム送信）後にデータを再検証します。関連するルートのRouter Cacheは無効化されます。

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、データを手動で再検証し、特定のパス以下のルートセグメントを単一の操作で再レンダリングできます。`revalidatePath`メソッドを呼び出すとData Cacheが再検証され、この結果としてFull Route Cacheが無効化されます。

```jsx
revalidatePath('/')
```

どちらのケースも、あなたが達成しようとしていることに応じて、`revalidatePath`を使用できる場所が2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：Webhook）の応答でデータを再検証します。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション（例：フォーム送信、ボタンクリック）後にデータを再検証します。

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)で詳細を確認してください。

> **`revalidatePath`** vs. **`router.refresh`**:
>
> `router.refresh`を呼び出すと、Router Cacheがクリアされ、Data CacheまたはFull Route Cacheを無効化せずにサーバーでルートセグメントが再レンダリングされます。
>
> 違いは、`revalidatePath`がData CacheとFull Route Cacheをパージするのに対し、`router.refresh()`はData CacheとFull Route Cacheに影響しない点です。なぜなら、これはクライアントサイドAPIだからです。

### Dynamic API {#dynamic-apis}

`cookies`や`headers`などのDynamic API、Pagesでの`searchParams` propは、ランタイムの受信リクエスト情報に依存します。それらを使用することで、ルートはFull Route Cacheからオプトアウトされ、動的にレンダリングされます。

#### `cookies` {#cookies}

`cookies.set`や`cookies.delete`をServer Action内で使用すると、Router Cacheが無効化され、クッキーを使用するルートが古くならないようにします（例：認証の変更を反映するため）。

[`cookies`](/docs/app/api-reference/functions/cookies)APIリファレンスをご覧ください。

### Route Segment Configオプション {#segment-config-options}

Route Segment Configオプションは、ルートセグメントのデフォルトを上書きするか、`fetch` APIが使用できない場合（例：データベースクライアントまたはサードパーティライブラリ）に使用できます。

次のRoute Segment Configオプションは、Full Route Cacheのオプトアウトに使用できます：

- `const dynamic = 'force-dynamic'`

この設定オプションを使用すると、すべてのfetchがData Cacheからオプトアウトされます（つまり、`no-store`）：

- `const fetchCache = 'default-no-store'`

[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)で高度なオプションを確認してください。

[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)のドキュメントで他のオプションを確認してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）の場合、`generateStaticParams`が提供するパスはビルド時にFull Route Cacheにキャッシュされます。リクエスト時、Next.jsは知られていないパスもキャッシュし、最初にそれらが訪問されたときにキャッシュされます。

すべてのパスをビルド時に静的にレンダリングするには、`generateStaticParams`にパスの完全なリストを提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時に一部のパスだけを静的にレンダリングし、残りをランタイムで最初に訪問されたときにレンダリングするには、部分的なリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10件の投稿をビルド時にレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

訪問された最初の時点でパスをすべて静的にレンダリングするには、空の配列を返すか（ビルド時にはパスがレンダリングされません）、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`からは必ず配列を返す必要があります。たとえそれが空であっても。そうしないと、ルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時にキャッシュを無効にするには、ルートセグメント内に`export const dynamicParams = false`オプションを追加します。この設定オプションが使用されている場合、`generateStaticParams`で提供されたパスのみが提供され、他のルートは404になるか（[catch-allルート](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)のケース）一致します。

### React `cache`関数 {#react-cache-function}

Reactの`cache`関数を使用すると、関数の戻り値をメモ化することができ、同じ関数を複数回呼び出しながら、1回だけ実行することができます。

`fetch`リクエストは自動的にメモ化されるため、Reactの`cache`でラップする必要はありませんが、`fetch` APIが適していないユースケースのためにデータリクエストを手動でメモ化するために`cache`を使用できます。たとえば、一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアントです。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
