---
title: 'Next.jsでのキャッシング'
nav_title: 'キャッシング'
description: 'Next.jsにおけるキャッシングメカニズムの概要。'
---

Next.jsは、レンダリング作業とデータリクエストをキャッシュすることでアプリケーションのパフォーマンスを向上し、コストを削減します。このページでは、Next.jsのキャッシングメカニズム、設定するために使用できるAPI、およびそれらがどのように相互作用するかについて詳しく説明します。

> **Good to know**: このページは、Next.jsの内部構造を理解するのに役立ちますが、Next.jsを使って生産的に作業するために必須の知識では**ありません**。Next.jsのキャッシングのヒューリスティックスの多くは、APIの使用によって決定されており、デフォルト設定でベストパフォーマンスを発揮します。具体例に飛びたい場合は、[ここから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

以下に、さまざまなキャッシングメカニズムとその目的についての概要を示します：

| メカニズム                                  | 何が                | どこで       | 目的                                             | 期間                               |
| ------------------------------------------- | ------------------- | ------------ | ------------------------------------------------ | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の戻り値        | サーバー     | React Componentツリーのデータ再利用              | リクエストライフサイクルごと       |
| [Data Cache](#data-cache)                   | データ              | サーバー     | ユーザーリクエストとデプロイメント間のデータ保存 | 永続的（再検証可能）               |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバー     | レンダリングコスト削減とパフォーマンス向上       | 永続的（再検証可能）               |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時のサーバーリクエスト削減         | ユーザーセッションまたは期間による |

デフォルトでは、Next.jsは性能を高め、コストを削減するためにキャッシュ可能なものをできる限りキャッシュします。これは、ルートが**静的にレンダリング**され、データリクエストが**キャッシュ**されることを意味しますが、これをオプトアウトすることも可能です。以下の図は、ルートがビルド時に静的にレンダリングされたときと、静的ルートが最初に訪問されたときのデフォルトのキャッシング動作を示しています。

<Image
  alt="Next.jsでのデフォルトのキャッシング動作を示す図。4つのメカニズムでビルド時と初回訪問時のHIT、MISS、SETを示す。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシング動作は、ルートが静的または動的にレンダリングされるか、データがキャッシュされるかされないか、リクエストが初回訪問またはその後のナビゲーションの一部であるかによって変わります。用途に応じて、個々のルートとデータリクエストのキャッシング動作を設定できます。

## Request Memoization {#request-memoization}

Reactは、同じURLとオプションを持つリクエストを自動で**メモ化**するために[`fetch` API](#fetch)を拡張しています。これにより、React component treeの複数の場所で同じデータのfetch関数を呼び出しても、それが実行されるのは最初の一度だけです。

<Image
  alt="重複しないfetchリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

例えば、ルート全体で同じデータを使用する必要がある場合（例：Layout、Page、複数のコンポーネントで）、ツリーの最上位でデータを取得して、propsをコンポーネント間で渡す必要はありません。代わりに、必要なコンポーネントでデータを取得できます。同じデータに対して複数のリクエストをネットワーク越しに行うことのパフォーマンスへの影響を心配する必要はありません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、その結果は
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されていますが、最初の一度だけ実行されます
const item = await getItem() // cache MISS

// 2度目の呼び出しはルート内のどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、その結果は
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されていますが、最初の一度だけ実行されます
const item = await getItem() // cache MISS

// 2度目の呼び出しはルート内のどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoization の仕組み**

<Image
  alt="Reactレンダリング中にfetchメモ化がどのように機能するかを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングする際、特定のリクエストが呼び出された初めての時、その結果はメモリ内に存在せず、cache `MISS` となります；
- そのため、関数が実行され、外部ソースからデータが取得され、結果がメモリに保存されます；
- 同じレンダリングパス内でのリクエストの後続の関数呼び出しはcache `HIT`となり、関数を実行せずにメモリからデータが返されます；
- ルートのレンダリングが終わり、レンダリングパスが完了すると、メモリは「リセット」され、すべてのrequest memoizationエントリがクリアされます；

> **Good to know**:
>
> - Request memoizationはReactの機能であり、Next.jsの機能ではありません。他のキャッシングメカニズムとの相互作用を示すためにここに含められています。
> - メモ化は`GET`メソッドの`fetch`リクエストにのみ適用されます；
> - メモ化はReact Componentツリーにのみ適用されます。つまり：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、その他のServer Componentsの `fetch`リクエストに適用されます。
>   - Route Handlersの`fetch`リクエストには適用されません。これらはReact komponent treeの一部ではないためです。
> - `fetch`が適さない場合（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）では、Reactの[`cache`関数](#react-cache-function)を使用して関数をメモ化できます。

### 期間 {#duration}

キャッシュは、サーバーリクエストのライフタイムで、React component treeがレンダリングを完了するまで持続します。

### 再検証 {#revalidating}

メモ化はサーバーリクエストをまたいで共有されず、レンダリング中にのみ適用されるため、それを再検証する必要はありません。

### オプトアウト {#opting-out}

メモ化は`GET`メソッドの`fetch`リクエストにのみ適用され、`POST`や`DELETE`など他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、これからオプトアウトすることはお勧めしません。

個々のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)の[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用することができます。ただし、これはリクエストをメモ化からオプトアウトするのではなく、進行中のリクエストを中止するものです。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには組み込みのData Cacheがあり、**データフェッチの結果を** **サーバーリクエスト**と**デプロイメント**の間に**永続化**します。これは、Next.jsがネイティブの`fetch` APIを拡張し、サーバー上の各リクエストに独自の永続的なキャッシングセマンティクスを設定できるようにしているからです。

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは`cache`オプションはサーバーサイドリクエストがサーバーのData Cacheとどのように相互作用するかを示します。

`fetch`の[`cache`](#fetch-optionscache)と[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシング動作を設定できます。

**Data Cache の仕組み**

<Image
  alt="Data Cacheとキャッシュされていないfetchリクエストの相互作用を示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化される。キャッシュされていないリクエストはデータソースから取得され、Data Cacheには保存されず、メモ化される。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- レンダリング中に`'force-cache'`オプションを持つ`fetch`リクエストが初めて呼び出されたとき、Next.jsはData Cacheをチェックしてキャッシュされたレスポンスを探します；
- キャッシュされたレスポンスが見つかった場合、それは即座に返され、[memoize](#request-memoization)されます；
- キャッシュされたレスポンスが見つからない場合、リクエストはデータソースに送信され、結果はData Cacheに保存され、メモ化されます；
- キャッシュされていないデータ（例：`cache`オプションが定義されていない場合や`{ cache: 'no-store' }`を使用している場合）は、結果が常にデータソースからフェッチされ、メモ化されます；
- データがキャッシュされているかされていないかに関わらず、リクエストは常にメモ化され、Reactレンダリングパス中に同じデータに対する重複リクエストを避けることができます。

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシングメカニズムはキャッシュされたデータを再利用することでパフォーマンスを向上させますが、Data Cacheはリクエストやデプロイメントにまたがって永続化されるのに対し、メモ化はリクエストのライフタイムでのみ持続します。

### 期間 {#duration}

Data Cacheは、再検証またはオプトアウトしない限り、リクエストやデプロイメントをまたいで永続的です。

### 再検証 {#revalidating}

キャッシュされたデータは、次の2つの方法で再検証できます：

- **時間ベースの再検証**：一定時間が経過し、新しいリクエストが行われたときにデータを再検証する。これは、頻繁に変更されるわけではなく、新鮮さがそれほど重要ではないデータに有用です。
- **オンデマンド再検証**：イベント（例：フォーム送信）に基づいてデータを再検証する。オンデマンド再検証は、タグベースまたはパスベースのアプローチを使用してデータのグループを一度に再検証できます。これは、（例えば、ヘッドレスCMSからコンテンツが更新されたときなどに）できる限り最新のデータを表示したい場合に役立ちます。

#### 時間ベースの再検証 {#time-based-revalidation}

時間間隔でデータを再検証するには、`fetch`の`next.revalidate`オプションを使用して、リソースのキャッシュ有効期間（秒単位）を設定できます。

```js
// 最大で毎時間の再検証
fetch('https://...', { next: { revalidate: 3600 } })
```

あるいは、セグメントや`fetch`を使用できない場合には、[Route Segment Configオプション](#segment-config-options)を使用して、すべての`fetch`リクエストを設定することもできます。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証の仕組みを示す図。再検証期間後、最初のリクエストでは古いデータが返され、続いてデータが再検証される。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`付きの`fetch`リクエストが初めて呼び出されたとき、データは外部データソースから取得され、Data Cacheに保存されます；
- 指定された期間内（例: 60秒）に呼び出されるリクエストは、キャッシュされたデータを返します；
- 期間が経過した後、次のリクエストは引き続きキャッシュされた（いまや古くなった）データを返します；
  - Next.jsはバックグラウンドでデータを再検証します；
  - データが正常にフェッチされると、Next.jsは新鮮なデータでData Cacheを更新します；
  - バックグラウンド再検証に失敗した場合、前のデータは変更されずに残ります；

これは、[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)の動作に似ています。

#### オンデマンド再検証 {#on-demand-revalidation}

データは、パス（[`revalidatePath`](#revalidatepath)）またはキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）によってオンデマンドで再検証できます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証の仕組みを示す図。再検証リクエスト後にData Cacheが新鮮なデータで更新される。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼び出されたとき、データは外部データソースから取得され、Data Cacheに保存されます；
- オンデマンド再検証がトリガーされると、適切なキャッシュエントリーはキャッシュからパージされます；
  - これは、古いデータのパージが行われずにデータが取得されるのを待つ時間ベースの再検証とは異なります；
- 次回リクエストが行われた時、再びキャッシュ`MISS`となり、データは外部データソースからフェッチされてData Cacheに保存されます；

### オプトアウト {#opting-out}

`fetch`のレスポンスをキャッシュしたくない場合は、次のようにします：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**: **Automatic Static Optimization**、**Static Site Generation**、または**Static Rendering**という用語は、アプリケーションのルートがビルド時にレンダリングおよびキャッシュされるプロセスを指すために交換可能に使用されることがあります。

Next.jsはビルド時に自動でルートをレンダリングおよびキャッシュします。これは、各リクエストに対してサーバーでレンダリングするのではなく、キャッシュされたルートを提供することを可能にする最適化であり、ページの読み込み速度を向上させます。

Full Route Cacheがどのように機能するかを理解するには、Reactがレンダリングをどのように処理するか、そしてNext.jsが結果をどのようにキャッシュするかを見ると役立ちます：

### 1. サーバーでのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上では、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントやSuspense boundaryごとに分割されます。

各チャンクは2つの段階でレンダリングされます：

1. Reactが、ストリーミングに最適化された特殊なデータ形式でServer Componentsをレンダリングします。これを**React Server Component Payload**と呼びます。
2. Next.jsは、React Server Component PayloadとClient ComponentのJavaScript命令を使用して、サーバー上で**HTML**をレンダリングします。

これにより、すべてがレンダリングされるのを待ってから作業をキャッシュしたり、レスポンスを送信する必要はありません。代わりに、作業が完了するごとに応じてストリームレスポンスを送信できます。

> **React Server Component Payloadとは何か？**
>
> React Server Component Payloadは、レンダリングされたReact Server Componentツリーのコンパクトなバイナリ表現です。これは、クライアント側のReactによってブラウザのDOMを更新するために使用されます。React Server Component Payloadには以下が含まれています：
>
> - Server Componentsのレンダリング結果
> - Client Componentsがレンダリングされるべき場所のプレースホルダーおよびそれらのJavaScriptファイルへの参照
> - Server ComponentsからClient Componentsに渡された任意のprops
>
> 詳しくは、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください。

### 2. サーバーでのNext.jsのキャッシング (Full Route Cache) {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="Full Route Cacheのデフォルトの動作、静的にレンダリングされたルートのReact Server ComponentペイロードとHTMLがサーバーにキャッシュされる過程を示す図。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの動作は、ルートのレンダリングされた結果（React Server Component PayloadとHTML）をサーバーにキャッシュするものです。これは、ビルド時に静的にレンダリングされたルートや、再検証時に適用されます。

### 3. クライアントでのReact HydrationとReconciliation {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時に、クライアント側で：

1. HTMLを使用してClientとServer Componentの速い非インタラクティブな初期プレビューを即座に表示します；
2. React Server Componentsペイロードを使用してClientとレンダリングされたServer Componentツリーを調整し、DOMを更新します；
3. JavaScript命令を使用してClient Componentsを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにします；

### 4. クライアントでのNext.jsのキャッシング (Router Cache) {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadは、クライアント側のRouter Cacheに保存されます。これはレイアウト、ローディング状態、ページごとに分割された個別のメモリキャッシュです。このRouter Cacheは、以前訪問したルートを保存し、将来のルートをプリフェッチすることで、ナビゲーション体験を向上させます。

### 5. 後続のナビゲーション {#5-subsequent-navigations}

後続のナビゲーションやプリフェッチ中に、Next.jsはRouter CacheにReact Server Components Payloadがあるかどうかをチェックします。もし存在する場合、新しいサーバーへのリクエストを送信することをスキップします。

ルートセグメントがキャッシュにない場合、Next.jsはサーバーからReact Server Components Payloadを取得し、クライアントでRouter Cacheを埋めます。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ビルド時にルートがキャッシュされるかどうかは、それが静的にまたは動的にレンダリングされるかによって異なります。静的ルートはデフォルトでキャッシュされ、動的ルートはリクエスト時にレンダリングされ、キャッシュされません。

この図は、静的および動的にレンダリングされたルートの違いと、データがキャッシュされているかいないかを示しています：

<Image
  alt="静的および動的レンダリングがFull Route Cacheにどのように影響を与えるかを示す図。静的ルートはキャッシュされ、動的ルートは決してキャッシュされない。"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学ぶ。

### 期間 {#duration}

デフォルトでは、Full Route Cacheは永続的です。これは、レンダリング出力がユーザーリクエストをまたいでキャッシュされることを意味します。

### 無効化 {#invalidation}

Full Route Cacheを無効化する方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**：Data Cacheを再検証すると、サーバー上でコンポーネントを再レンダリングし、新しいレンダリング出力をキャッシュすることでRouter Cacheが無効になります。
- **再デプロイ**：データキャッシュとは異なり、デプロイメントごとに永続するのはData Cacheのみで、Full Route Cacheは新しいデプロイメント時にクリアされます。

### オプトアウト {#opting-out}

Full Route Cacheからオプトアウトする、つまり、すべての受信リクエストに対して動的にコンポーネントをレンダリングするための方法は次の通りです：

- **[Dynamic API](#dynamic-apis)を使用する**: これにより、ルートはFull Route Cacheからオプトアウトされ、リクエスト時に動的にレンダリングされます。Data Cacheは引き続き使用することができます；
- **`dynamic = 'force-dynamic'` または `revalidate = 0` route segment configオプションを使用する**：これにより、Full Route CacheとData Cacheがスキップされます。つまり、コンポーネントはサーバーへのすべての受信リクエストごとにレンダリングされ、データがフェッチされます。Router Cacheはクライアントサイドキャッシュとして適用され続けます；
- **[データキャッシュ](#data-cache)からオプトアウトする**：ルートにキャッシュされない`fetch`リクエストがある場合、このルートはFull Route Cacheからオプトアウトされます。特定の`fetch`リクエストに関するデータはすべての受信リクエストに対してフェッチされます。キャッシュからオプトアウトしない他の`fetch`リクエストは、引き続きData Cacheにキャッシュされます。これにより、キャッシュされたデータとキャッシュされていないデータのハイブリッドが可能になります。

## クライアント側Router Cache {#client-side-router-cache}

Next.jsには、ルートセグメントのRSCペイロードをレイアウト、読み込み状態、ページごとに分割して保存するメモリ内クライアントサイドrouter cacheがあります。

ユーザーがルート間を移動すると、Next.jsは訪問したルートセグメントをキャッシュし、ユーザーが移動しそうなルートを[prefetch](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、即座に戻る/進むナビゲーション、ナビゲーション間でのフルページリロードがなく、React状態とブラウザ状態の保持が実現します。

Router Cacheを使用すると：

- **レイアウト**はキャッシュされ、ナビゲーション時に再利用されます（[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）；
- **読み込み状態**はキャッシュされてナビゲーション時に再利用され、[即座のナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)が可能になります；
- **ページ**はデフォルトではキャッシュされませんが、ブラウザの後退および前進ナビゲーション中に再利用されます。ページセグメントのキャッシングを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)構成オプションを使用できます；

{/* TODO: Update diagram to match v15 behavior */}

> **Good to know:**このキャッシュは特にNext.jsとServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、類似した結果を持ちます。

### 期間 {#duration}

キャッシュはブラウザの一時メモリに保存されます。Router Cacheの持続期間は以下の2つの要因で決まります：

- **セッション**：キャッシュはナビゲーション内で保持されます。ただし、ページのリフレッシュ時にクリアされます；
- **自動無効化期間**：レイアウトと読み込み状態のキャッシュは、特定期間後に自動的に無効化されます。無効期間は、リソースが[prefetch](/docs/app/api-reference/components/link#prefetch)された方法、およびリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかどうかに依存します：
  - **デフォルトプリフェッチング**（`prefetch={null}`または指定なし）：動的ページにはキャッシュされず、静的ページには5分キャッシュされます；
  - **フルプリフェッチング**（`prefetch={true}` または `router.prefetch`）：静的および動的ページの両方で5分間キャッシュされます；

ページのリフレッシュはすべてのキャッシュセグメントをクリアしますが、自動無効化期間は、プリフェッチされた時から個々のセグメントにのみ影響します。

> **Good to know**: [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)構成オプションを使用して、上記の自動無効化時間を調整できます。

### 無効化 {#invalidation}

Router Cacheを無効化する方法は2つあります：

- **サーバーアクション**内で：
  - パスでデータをオンデマンドで再検証する（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)）またはキャッシュタグで（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie) または [`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies) を使用することで、cookieを使用しているルートが古くならないようにRouter Cacheが無効化されます（例：認証）
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すと、Router Cacheが無効化され、現在のルートに対してサーバーへの新しいリクエストが行われます。

### オプトアウト {#opting-out}

Next.js 15以降では、ページセグメントはデフォルトでオプトアウトされています。

> **Good to know:** [`prefetch`](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)からオプトアウトするには、 `<Link>` コンポーネントの`prefetch`プロップを`false`に設定することもできます。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシングメカニズムを設定する際に、相互にどのように作用するかを理解することが重要です：

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheを再検証するか、データキャッシュからオプトアウトするとFull Route Cacheは無効化されます。これは、レンダリング出力がデータによって決まるためです；
- Full Route Cacheを無効化するか、キャッシュからオプトアウトすると、Data Cacheには影響しません。キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングすることができます。これは、ページのほとんどがキャッシュされたデータを使用しなければならないときに役立ちますが、一部のコンポーネントがリクエスト時にフェッチされる必要があるデータに依存する場合もあります。すべてのデータを再フェッチするパフォーマンスの影響を気にせずに、動的にレンダリングできます。

### Data CacheとクライアントサイドRouter cache {#data-cache-and-client-side-router-cache}

- Data CacheとRouter Cacheを即座に無効化するには、[サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で[`revalidatePath`](#revalidatepath)や[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用することができます；
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証してもRouter Cacheは直ちには無効化されません。Route Handlerが特定のルートに結びついていないためです。このため、Router Cacheはハードリフレッシュ、または自動無効化期間が経過するまで以前のペイロードを提供し続けます。

## API {#apis}

次の表は、さまざまなNext.js APIがキャッシングにどのように影響するかの概要を示しています：

| API                                                                     | Router Cache                 | Full Route Cache             | Data Cache                   | React Cache |
| ----------------------------------------------------------------------- | ---------------------------- | ---------------------------- | ---------------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | キャッシュ                   |                              |                              |             |
| [`router.prefetch`](#routerprefetch)                                    | キャッシュ                   |                              |                              |             |
| [`router.refresh`](#routerrefresh)                                      | 再検証                       |                              |                              |             |
| [`fetch`](#fetch)                                                       |                              |                              | キャッシュ                   | キャッシュ  |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                              |                              | キャッシュまたはオプトアウト |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                              | 再検証                       | 再検証                       |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                              | キャッシュ                   | キャッシュ                   |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | 再検証（サーバーアクション） | 再検証                       | 再検証                       |             |
| [`revalidatePath`](#revalidatepath)                                     | 再検証（サーバーアクション） | 再検証                       | 再検証                       |             |
| [`const revalidate`](#segment-config-options)                           |                              | 再検証またはオプトアウト     | 再検証またはオプトアウト     |             |
| [`const dynamic`](#segment-config-options)                              |                              | キャッシュまたはオプトアウト | キャッシュまたはオプトアウト |             |
| [`cookies`](#cookies)                                                   | 再検証（サーバーアクション） | オプトアウト                 |                              |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                              | オプトアウト                 |                              |             |
| [`generateStaticParams`](#generatestaticparams)                         |                              | キャッシュ                   |                              |             |
| [`React.cache`](#react-cache-function)                                  |                              |                              |                              | キャッシュ  |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                              |                              | キャッシュ                   |             |

### `<Link>` {#link}

デフォルトで、`<Link>`コンポーネントはFull Route Cacheからルートを自動的にprefetchし、React Server Component PayloadをRouter Cacheに追加します。

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定できます。ただし、これはキャッシュを永続的にスキップするわけではありません；ユーザーがルートを訪れたとき、ルートセグメントはクライアント側で引き続きキャッシュされます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しく学ぶ。

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使用してルートを手動でプリフェッチできます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)APIリファレンスを参照。

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使用してルートを手動でリフレッシュできます。これにより、Router Cacheが完全にクリアされ、現在のルートに対するサーバーへの新しいリクエストが行われます。`refresh`はDataやFull Route Cacheに影響を与えません。

レンダリング結果はクライアントで調整され、React状態とブラウザ状態を保持します。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)APIリファレンスを参照。

### `fetch` {#fetch}

`fetch`から返されるデータは、Data Cacheに自動的にキャッシュされ**ません**。

`fetch`のデフォルトのキャッシュ動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定するのと同じです：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で他のオプションを確認します。

### `fetch options.cache` {#fetch-options-cache}

個々の`fetch`リクエストをキャッシュにオプトインするには、`cache`オプションを`force-cache`に設定します：

```jsx
// キャッシュにオプトイン
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で他のオプションを確認します。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

`fetch`の`next.revalidate`オプションを使用して、個々の`fetch`リクエストの再検証期間（秒単位）を設定できます。これはData Cacheを再検証し、それがFull Route Cacheを再検証します。新鮮なデータがフェッチされ、コンポーネントがサーバー上で再レンダリングされます。

```jsx
// 最大で毎時間の再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で他のオプションを確認します。

### `fetch options.next.tags` and `revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、細かいデータキャッシングと再検証のためのキャッシュタグ付けシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用するとき、一つ以上のタグでキャッシュエントリーをタグ付けするオプションがあります；
2. その後、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリーをパージできます；

たとえば、データをフェッチするときにタグを設定できます：

```jsx
// キャッシュデータにタグを付ける
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

次に、特定のタグでキャッシュエントリーをパージするために`revalidateTag`を呼び出します：

```jsx
// 特定のタグでエントリーを再検証
revalidateTag('a')
```

`revalidateTag`を使用できる場所は、目的に応じて2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベントに応じたデータを再検証（例：ウェブフック）。これはRoute Handlerが特定のルートに結びついていないため、Router Cacheを直ちに無効にはしません；
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション後にデータを再検証（例：フォーム送信）。これにより、関連するルートのRouter Cacheが無効化されます；

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、特定のパスの下のルートセグメントを手動で再検証し、再レンダリングすることができます。`revalidatePath`メソッドの呼び出しはData Cacheを再検証し、それによりFull Route Cacheを無効化します。

```jsx
revalidatePath('/')
```

`revalidatePath`を使用できる場所は、目的に応じて2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベントに応じたデータを再検証（例：ウェブフック）；
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション後にデータを再検証（例：フォーム送信、ボタンクリック）；

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)で詳細をご覧ください。

> **`revalidatePath`** vs. **`router.refresh`**:
>
> `router.refresh`を呼び出すと、Router Cacheがクリアされ、サーバー上でルートセグメントが再レンダリングされますが、Data CacheまたはFull Route Cacheの無効化は行われません；
>
> 違いは、`revalidatePath`はData CacheとFull Route Cacheをパージし、`router.refresh()`はData CacheとFull Route Cacheを変更しません。`router.refresh`はクライアントサイドAPIです。

### Dynamic APIs {#dynamic-apis}

`cookies`や`headers`などの動的API、およびPagesの`searchParams`プロップは、ランタイムの受信リクエスト情報に依存しています。それらを使用することで、ルートはFull Route Cacheからオプトアウトされ、動的にレンダリングされます。

#### `cookies` {#cookies}

`cookies.set`または`cookies.delete`をサーバーアクションで使用すると、Router Cacheが無効化され、クッキーを使用するルートが古くならないようになります（例：認証の反映）。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスをご覧ください。

### Segment Configオプション {#segment-config-options}

Route Segment Configオプションは、ルートセグメントのデフォルトをオーバーライドするか、`fetch` APIを使用できない場合（例：データベースクライアントやサードパーティライブラリ）に使用できます。

次のRoute Segment Configオプションにより、Full Route Cacheからオプトアウトされます：

- `const dynamic = 'force-dynamic'`

この設定オプションにより、すべてのフェッチがData Cacheからオプトアウトされます（つまり、`no-store`）：

- `const fetchCache = 'default-no-store'`

より高度なオプションを確認するには、[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)を参照してください。

詳しくは、[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントをご覧ください。

### `generateStaticParams` {#generatestaticparams}

[ダイナミックセグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）のために、`generateStaticParams`によって提供されたパスはビルド時にFull Route Cacheにキャッシュされます。リクエスト時には、Next.jsはビルド時に知られていなかったパスも最初に訪れたときにキャッシュします。

ビルド時にすべてのパスを静的にレンダリングするには、パスの完全なリストを`generateStaticParams`に提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスのサブセットを静的にレンダリングし、他の部分はランタイムで初めて訪れたときに静的にレンダリングするには、一部のパスのリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // ビルド時に最初の10投稿をレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

最初の訪問時にすべてのパスを静的にレンダリングするために、空の配列を返す（ビルド時にはパスはレンダリングされません）か、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を使用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`からは必ず配列を返す必要があります、たとえそれが空でも。そうでなければルートは動的にレンダリングされます；

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時のキャッシングを無効にするには、ルートセグメントで`export const dynamicParams = false`オプションを追加します。この設定オプションが使用される場合、`generateStaticParams`によって提供されたパスのみが提供され、その他のルートは404または一致します（[catch-allルート](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）。

### React `cache` 関数 {#react-cache-function}

Reactの`cache`関数を使用すると、関数の戻り値をメモ化し、同じ関数を複数回呼び出しても1回だけ実行することができます。

`fetch`リクエストは自動的にメモ化されるため、Reactの`cache`でラップする必要はありません。ただし、`fetch` APIが適していない場合（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）には、手動でデータリクエストをメモ化するために`cache`を使用することができます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
