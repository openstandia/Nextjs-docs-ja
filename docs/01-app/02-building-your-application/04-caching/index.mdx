---
title: 'Next.jsにおけるキャッシング'
nav_title: 'キャッシング'
description: 'Next.jsにおけるキャッシングメカニズムの概要。'
---

Next.jsは、アプリケーションのパフォーマンスを向上させ、コストを削減するために、レンダリング作業やデータリクエストをキャッシュします。このページでは、Next.jsのキャッシングメカニズム、設定に使えるAPI、それらがどのように相互作用するかの詳細な説明を提供します。

> **Good to know**: このページはNext.jsの内部動作を理解するのに役立ちますが、Next.jsで生産的に作業するために必須の知識ではありません。ほとんどのNext.jsのキャッシングヒューリスティックは、APIの使用に基づいて決定され、ゼロまたは最小限の設定で最高のパフォーマンスを発揮するようにデフォルト設定されています。代わりに例にジャンプしたい場合は、[ここから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

以下は、さまざまなキャッシングメカニズムとその目的の概要です：

| メカニズム                                  | What                | Where        | 目的                                                   | 期間                               |
| ------------------------------------------- | ------------------- | ------------ | ------------------------------------------------------ | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の戻り値        | サーバー     | React Component treeでデータを再利用する               | リクエストのライフサイクルごと     |
| [Data Cache](#data-cache)                   | データ              | サーバー     | ユーザーリクエストやデプロイメント間でデータを保存する | 永続的（再検証可能）               |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバー     | レンダリングコストを削減し、パフォーマンスを向上する   | 永続的（再検証可能）               |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時のサーバーリクエストを削減する         | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsは可能な限り多くのものをキャッシュして、パフォーマンスを向上させ、コストを削減します。これは、ルートが**静的にレンダリング**され、データリクエストが**キャッシュ**されることを意味します。ただし、オプトアウトしない限りこの状態が続きます。以下の図は、ビルド時および静的ルートが初めて訪れたときのデフォルトのキャッシングの動作を示しています。

<Image
  alt="Next.jsにおける4つのメカニズムでのデフォルトのキャッシング動作を示す図、ビルド時およびルートが初めて訪れたときのHIT, MISS, SETが記されています。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシングの動作は、ルートが静的または動的にレンダリングされるか、データがキャッシュされるかされないか、リクエストが初回訪問かその後のナビゲーションの一部であるかによって変わります。使用例に応じて、個々のルートやデータリクエストのキャッシング動作を設定できます。

## Request Memoization {#request-memoization}

Reactは[`fetch` API](#fetch)を拡張して、同じURLやオプションを持つリクエストを自動的に**メモ化**します。これにより、React component treeの複数箇所で同じデータへfetch関数を呼び出しても、一度の実行で済みます。

<Image
  alt="重複排除されたフェッチリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

例えば、ルート全体で同じデータを使う必要がある場合（例：Layout、Page、および複数のコンポーネントで）、ツリーの上位でデータを取得し、コンポーネント間でpropを転送する必要はありません。代わりに、必要とするコンポーネントでデータをフェッチし、ネットワーク上で同じデータに対する複数のリクエストのパフォーマンスへの影響を気にすることなく実行できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこにでも置けます
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこにでも置けます
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoizationの仕組み**

<Image
  alt="Reactレンダリング中にfetchメモ化がどのように機能するかを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングしている間、特定のリクエストが最初に呼ばれると、その結果はメモリに存在せず、キャッシュ`MISS`になります。
- そのため、関数が実行され、データが外部ソースから取得され、その結果がメモリに保存されます。
- 同じレンダリングパスでのリクエストの後続の関数呼び出しはキャッシュ`HIT`となり、関数を実行せずにメモリからデータが返されます。
- ルートのレンダリングが完了し、レンダリングパスが完了すると、メモリは"リセット"され、すべてのリクエストメモ化エントリがクリアされます。

> **Good to know**:
>
> - Request MemoizationはReactの機能であって、Next.jsの機能ではありません。ここに含めたのは、他のキャッシングメカニズムとどのように相互作用するかを示すためです。
> - メモ化は`fetch`リクエストの`GET`メソッドにのみ適用されます。
> - メモ化はReact Component treeにのみ適用されます。これはつまり：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、およびその他のServer Components内の`fetch`リクエストに適用されます。
>   - Route Handlers内の`fetch`リクエストには適用されません。これらはReact component treeの一部ではないからです。
> - `fetch`が適していない場合（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）、関数をメモ化するために[React `cache`関数](#react-cache-function)を使用できます。

### 期間 {#duration}

キャッシュは、サーバーリクエストのライフタイムまで、React component treeのレンダリングが完了するまで持続します。

### 再検証 {#revalidating}

メモ化はサーバーリクエスト間で共有されず、レンダリング中にのみ適用されるため、再検証の必要はありません。

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、他のメソッド、例えば`POST`や`DELETE`はメモ化されません。このデフォルトの動作はReactの最適化であり、それをオプトアウトすることは推奨しません。

個々のリクエストを管理するために、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)の[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これにより要求をメモ化の外に出すのではなく、進行中のリクエストを中断します。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには、**サーバーリクエスト**と**デプロイメント**の間でデータフェッチの結果を**永続化**する組み込みのData Cacheがあります。これは、Next.jsがネイティブの`fetch`APIを拡張し、サーバーの各リクエストで独自の永続的なキャッシングセマンティックを設定できるようにすることで可能にしています。

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションは、リクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、`cache`オプションはサーバーサイドリクエストがサーバーのData Cacheとどのように相互作用するかを示します。

`fetch`の[`cache`](#fetch-optionscache)および[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシング動作を設定できます。

**Data Cacheの仕組み**

<Image
  alt="Data Cacheとのキャッシュ済みおよび非キャッシュ済みのfetchリクエストの相互作用を示す図。キャッシュ済みリクエストはData Cacheに保存され、非キャッシュ済みリクエストはデータソースからフェッチされ、Data Cacheに保存されず、メモ化される。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- `'force-cache'`オプションを持つ`fetch`リクエストがレンダリング中に初めて呼ばれた場合、Next.jsはData Cacheでキャッシュされた応答を確認します。
- キャッシュされた応答が見つかるとすぐに返され、[メモ化](#request-memoization)されます。
- キャッシュされた応答が見つからない場合は、リクエストがデータソースに送信され、結果がData Cacheに保存され、メモ化されます。
- 非キャッシュデータ（例：`cache`オプションが定義されていない、または`{ cache: 'no-store' }`を使用している）に対しては、結果は常にデータソースからフェッチされ、メモ化されます。
- データがキャッシュされているかされていないかにかかわらず、リクエストは常にメモ化され、Reactレンダリングパス中に同じデータに対する重複リクエストの発生を防ぎます。

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシングメカニズムは、キャッシュされたデータを再利用してパフォーマンスを向上させるのに役立ちますが、Data Cacheはサーバーリクエスト間およびデプロイメントをまたいでの永続性があるのに対し、メモ化はリクエストのライフタイムのみ続きます。

### 期間 {#duration}

Data Cacheは、再検証またはオプトアウトしない限り、サーバーリクエスト間およびデプロイメントをまたいで永続的です。

### 再検証 {#revalidating}

キャッシュされたデータは、次の方法で再検証できます：

- **時間ベースの再検証**：一定の時間が経過し、新しいリクエストが行われた後にデータを再検証します。これは、頻繁に変更されず、新鮮さがそれほど重要でないデータにとって有用です。
- **オンデマンド再検証**：イベントに基づいてデータを再検証します（例：フォーム送信）。タグベースまたはパスベースのアプローチを使用して、データのグループを一度に再検証できます。これは、（例：ヘッドレスCMSのコンテンツが更新された場合など）可能な限り速やかに最新のデータを表示したい場合に有用です。

#### 時間ベースの再検証 {#time-based-revalidation}

リソースのキャッシュライフタイム（秒単位）を設定するために、`fetch`の`next.revalidate`オプションを使ってデータを時間制限付きで再検証できます。

```js
// 最長1時間ごとに再検証します
fetch('https://...', { next: { revalidate: 3600 } })
```

または、すべての`fetch`リクエストをセグメント内で設定したり、`fetch`を使用できない場合に[Route Segment Config options](#segment-config-options)を使用できます。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証がどのように機能するかを示した図、再検証期間後、最初のリクエストでは古いデータが返され、その後データが再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- 再検証付きのフェッチリクエストが初めて呼ばれると、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- 指定された時間枠内（例：60秒）に呼ばれたリクエストは、キャッシュされたデータを返します。
- 時間枠が過ぎると、次のリクエストは依然としてキャッシュされた（現在は古い）データを返します。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データが正常にフェッチされた後、Next.jsは新鮮なデータでData Cacheを更新します。
  - バックグラウンドの再検証が失敗する場合、以前のデータは変更されずに保持されます。

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)の動作に似ています。

#### オンデマンド再検証 {#on-demand-revalidation}

データは、パス（[`revalidatePath`](#revalidatepath)）またはキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）でオンデマンドに再検証できます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証がどのように機能するかを示した図、再検証リクエスト後に新しいデータでData Cacheが更新されます。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼ばれると、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- オンデマンド再検証がトリガーされると、関連するキャッシュエントリはキャッシュから消去されます。
  - これは時間ベースの再検証とは異なり、新しいデータがフェッチされるまで古いデータをキャッシュに保持します。
- 次回リクエストが行われると、再びキャッシュ`MISS`になり、データは外部データソースからフェッチされ、Data Cacheに保存されます。

### オプトアウト {#opting-out}

`fetch`からの応答をキャッシュしたくない場合、次のようにします：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**：
>
> **自動静的最適化**、**静的サイト生成**、または**静的レンダリング**という用語が、ビルド時にアプリケーションのルートをレンダリングしキャッシュするプロセスを指すために使われることがあります。

Next.jsは自動的にビルド時にルートをレンダリングし、キャッシュします。これは、各リクエストに対してサーバーでレンダリングする代わりにキャッシュされたルートを提供することで、ページの読み込みを高速化する最適化です。

Full Route Cacheの動作を理解するためには、Reactがレンダリングをどのように扱うか、Next.jsがその結果をどのようにキャッシュするかを見ておくと役立ちます：

### 1. サーバーでのReactによるレンダリング {#1-react-rendering-on-the-server}

サーバーでは、Next.jsはReactのAPIを使用してレンダリングをオーケストレーションします。レンダリング作業はチャンクに分割されます：個々のroute segment およびsuspense boundaryによって分割されます。

各チャンクは2つのステップでレンダリングされます：

1. ReactはServer Componentsをストリーミングに最適化された特別なデータフォーマットである**React Server Component Payload**にレンダリングします。
2. Next.jsはReact Server Component PayloadとClient ComponentのJavaScript指示を使用して**HTML**をサーバーでレンダリングします。

これにより、レンダリングをすべて待たずに作業をキャッシュしたり、応答を送信したりすることが可能になります。その代わりに、作業が完了するにつれて応答をストリームで送信できます。

> **React Server Component Payloadとは？**
>
> React Server Component Payloadは、レンダリングされたReact Server Component treeのコンパクトなバイナリ表現です。ReactがクライアントでブラウザのDOMを更新するために使用されます。React Server Component Payloadには以下が含まれます：
>
> - Server Componentのレンダリング結果
> - Client Componentがレンダリングされるべき箇所とそれらのJavaScriptファイルへの参照のプレースホルダー
> - Server ComponentからClient Componentに渡された任意のprops
>
> 詳しくは、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください。

### 2. サーバーでのNext.jsのキャッシング (Full Route Cache) {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="静的にレンダリングされたルートのためのReact Server Component PayloadとHTMLがサーバー上でキャッシュされるFull Route Cacheのデフォルトの動作を示す図。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの動作は、ルートのレンダリング結果（React Server Component PayloadとHTML）をサーバーでキャッシュすることです。これは、ビルド時または再検証中に静的にレンダリングされたルートに適用されます。

### 3. クライアントでのReactのハイドレーションと調整 {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時、クライアントでは：

1. HTMLは、クライアントおよびServer Componentsの非インタラクティブな初期プレビューをすぐに表示するために使用されます。
2. React Server Components Payloadは、クライアントおよびレンダリングされたServer Component treeを調整し、DOMを更新するために使用されます。
3. JavaScriptの指示は、[ハイドレーション](https://react.dev/reference/react-dom/client/hydrateRoot)してクライアントコンポーネントをインタラクティブにします。

### 4. クライアントでのNext.jsのキャッシング (Router Cache) {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadはクライアントサイドの[Router Cache](#client-side-router-cache)に保存されます - 個別のルートセグメントで分割されたインメモリキャッシュです。このRouter Cacheは、ナビゲーション体験を改善するために、以前訪れたルートを保存し、将来のルートをプリフェッチするために使用されます。

### 5. 後続のナビゲーション {#5-subsequent-navigations}

後続のナビゲーションまたはプリフェッチ時に、Next.jsはReact Server Components PayloadがRouter Cacheに保存されているかどうかを確認します。そうであれば、新しいリクエストをサーバーに送信することをスキップします。

ルートセグメントがキャッシュにない場合、Next.jsはReact Server Components Payloadをサーバーからフェッチし、クライアントのRouter Cacheに格納します。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ルートがビルド時にキャッシュされるかどうかは、それが静的にレンダリングされるか動的にレンダリングされるかによります。静的なルートはデフォルトでキャッシュされ、動的なルートはリクエスト時にレンダリングされ、キャッシュされません。

この図は、静的にレンダリングされるルートと動的にレンダリングされるルートの違いを、キャッシュされたデータとキャッシュされていないデータで示しています：

<Image
  alt="静的および動的レンダリングがFull Route Cacheにどのように影響するか。静的ルートはビルド時またはデータの再検証後にキャッシュされ、動的ルートは決してキャッシュされない。"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)の詳細を確認してください。

### 期間 {#duration}

デフォルトでは、Full Route Cacheは永続的です。これはレンダリングされた出力がユーザーリクエスト間でキャッシュされることを意味します。

### 無効化 {#invalidation}

Full Route Cacheを無効にする方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: Data Cacheを再検証することで、Router CacheもRender時にコンポーネントをサーバーで再レンダリングし、新しいレンダー出力をキャッシュすることによって無効化されます。
- **リデプロイ**: Data Cacheはデプロイメント間で持続しますが、Full Route Cacheは新しいデプロイメントでクリアされます。

### オプトアウト {#opting-out}

Full Route Cacheをオプトアウトする、つまり、すべての着信リクエストに対して動的にコンポーネントをレンダリングするためには：

- **[Dynamic API](#dynamic-apis)を使う**: これにより、ルートをFull Route Cacheからオプトアウトし、リクエスト時に動的にレンダリングします。Data Cacheはまだ使用可能です。
- **`dynamic = 'force-dynamic'`または`revalidate = 0`のroute segment configオプションを使う**: これにより、Full Route CacheとData Cacheもスキップします。これは、コンポーネントがサーバーの各着信リクエストでレンダリングされ、データがフェッチされることを意味します。Router Cacheはクライアントサイドキャッシュとして引き続き適用されます。
- **[Data Cache](#data-cache)をオプトアウトする**: ルートにキャッシュされていない`fetch`リクエストがある場合、これはFull Route Cacheからルートをオプトアウトします。その特定の`fetch`リクエストのデータは、各着信リクエストでフェッチされます。キャッシュのオプトアウトをしない他の`fetch`リクエストはData Cacheに引き続きキャッシュされます。これにより、キャッシュされたデータとキャッシュされていないデータのハイブリッドが可能になります。

## クライアントサイドRouter Cache {#client-side-router-cache}

Next.jsはインメモリのクライアントサイドrouter cacheを持ち、route segmentのRSCペイロードをレイアウト、読み込みステート、およびページごとに分割して保存します。

ユーザーがルート間をナビゲートすると、Next.jsは訪れたルートセグメントをキャッシュし、ユーザーがナビゲートする可能性が高いルートを[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、瞬時のバック/フォワードナビゲーション、ナビゲーション間の全ページリロードの排除、Reactステートおよびブラウザーステートの保持が実現します。

Router Cacheでは：

- **レイアウト**はナビゲーション時にキャッシュされ再利用されます（[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）。
- **読み込みステート**は[瞬時のナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のためにナビゲーション時にキャッシュされ再利用されます。
- **ページ**はデフォルトでキャッシュされませんが、ブラウザの前後のナビゲーション中は再利用されます。ページセグメントのキャッシュを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用できます。

{/* TODO: v15の動作に一致するように図を更新します */}

> **Good to know:** このキャッシュは特にNext.jsとServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、類似の結果をもたらします。

### 期間 {#duration}

キャッシュはブラウザの一時メモリに保存されます。router cache の持続期間は次の2つの要因によって決定されます：

- **セッション**：キャッシュはナビゲーション全体で持続します。ただし、ページリフレッシュ時にクリアされます。
- **自動無効化期間**：レイアウトや読み込みステートのキャッシュは特定の時間後に自動的に無効化されます。この期間は、リソースがどのように[プリフェッチされ](/docs/app/api-reference/components/link#prefetch)、リソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかに応じて変わります：
  - **デフォルトのプリフェッチ** (`prefetch={null}`または指定なし): 動的ページについてはキャッシュされず、静的ページについては5分間。
  - **完全なプリフェッチ** (`prefetch={true}`または`router.prefetch`): 静的および動的ページの両方で5分間。

ページのリフレッシュは**すべての**キャッシュされたセグメントをクリアしますが、自動無効化期間はプリフェッチされた個々のセグメントにのみ影響を与えます。

> **Good to know**: 実験的な [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes) 設定オプションを使用して、上記の自動無効化時間を調整できます。

### 無効化 {#invalidation}

Router Cache を無効化する方法は2つあります：

- **Server Action**内で：
  - ([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath))によるパス別でのリクエストオンデマンド再検証、または([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag))によるキャッシュタグ別での再検証
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie) または [`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies) を使うと、cookieを使用するルートの陳腐化を防ぐためにRouter Cacheが無効化されます（例：認証時など）。
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すと、Router Cacheを無効化し、現在のルートに対してサーバーへ新しいリクエストを行います。

### オプトアウト {#opting-out}

Next.js 15から、ページセグメントはデフォルトでオプトアウトされています。

> **Good to know:** `<Link>`コンポーネントの`prefetch`propを`false`に設定することで、[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)のオプトアウトも可能です。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシングメカニズムを設定する際には、それがどのように相互作用するかを理解することが重要です：

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheの再検証またはオプトアウトは、フルルートキャッシュを無効にします。なぜなら、レンダー出力がデータに依存しているからです。
- Full Route Cacheを無効化またはオプトアウトしてもData Cacheには影響しません。キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングできます これは、ほとんどのページでキャッシュされたデータを使用しながら、一部のコンポーネントでリクエスト時にフェッチが必要なデータに依存する場合に便利です 全データを再フェッチする必要性のパフォーマンスへの影響を心配せずに、動的にレンダリングできます。

### Data Cacheとクライアントサイドルーターキャッシュ {#data-cache-and-client-side-router-cache}

- Data CacheとRouter Cacheを即座に無効にするには、[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)内で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます。
- [ルートハンドラー](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証してもRouter Cacheは即座には無効化されません なぜならRoute Handlerは特定のルートに紐づいていないからです。 このためRouter Cacheは以前のペイロードを提供し続け、ハードリフレッシュまたは自動無効化期間が経過するまで続きます。

## API {#apis}

次の表は、さまざまなNext.jsのAPIがキャッシュにどのように影響を与えるかの概要を示しています：

| API                                                                     | Router Cache            | Full Route Cache             | Data Cache                   | React Cache |
| ----------------------------------------------------------------------- | ----------------------- | ---------------------------- | ---------------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | キャッシュ              |                              |                              |             |
| [`router.prefetch`](#routerprefetch)                                    | キャッシュ              |                              |                              |             |
| [`router.refresh`](#routerrefresh)                                      | 再検証                  |                              |                              |             |
| [`fetch`](#fetch)                                                       |                         |                              | キャッシュ                   | キャッシュ  |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                         |                              | キャッシュまたはオプトアウト |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                         | 再検証                       | 再検証                       |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                         | キャッシュ                   | キャッシュ                   |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | 再検証（Server Action） | 再検証                       | 再検証                       |             |
| [`revalidatePath`](#revalidatepath)                                     | 再検証（Server Action） | 再検証                       | 再検証                       |             |
| [`const revalidate`](#segment-config-options)                           |                         | 再検証またはオプトアウト     | 再検証またはオプトアウト     |             |
| [`const dynamic`](#segment-config-options)                              |                         | キャッシュまたはオプトアウト | キャッシュまたはオプトアウト |             |
| [`cookies`](#cookies)                                                   | 再検証（Server Action） | オプトアウト                 |                              |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                         | オプトアウト                 |                              |             |
| [`generateStaticParams`](#generatestaticparams)                         |                         | キャッシュ                   |                              |             |
| [`React.cache`](#react-cache-function)                                  |                         |                              |                              | キャッシュ  |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                         |                              | キャッシュ                   |             |

### `<Link>` {#link}

デフォルトでは、`<Link>`コンポーネントは自動的にFull Route Cacheからルートをプリフェッチし、React Server Component PayloadをRouter Cacheに追加します。

プリフェッチを無効にするには、`prefetch`プロパティを`false`に設定できます。ただし、これによってクライアントサイドのキャッシュが永久にスキップされるわけではなく、ユーザーがルートを訪れた際にセグメントは依然としてキャッシュされます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)の詳細を確認してください。

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使って、ルートを手動でプリフェッチできます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを確認してください。

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使って、ルートを手動で更新できます。これにより、Router Cacheが完全にクリアされ、現在のルートのためにサーバーに新しいリクエストが行われます。`refresh`はData CacheまたはFull Route Cacheには影響しません。

レンダリングされた結果は、Reactステートとブラウザステートを保持しながらクライアントで調整されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを確認してください。

### `fetch` {#fetch}

`fetch`から返されるデータはData Cacheに自動的にキャッシュされません。

`fetch`のデフォルトのキャッシング動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定することと同等です：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` API Reference](/docs/app/api-reference/functions/fetch)で他のオプションを確認してください。

### `fetch options.cache` {#fetch-options-cache}

`cache`オプションを`force-cache`に設定することで、個々の`fetch`をキャッシュにオプトインできます：

```jsx
// キャッシングをオプトイン
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` API Reference](/docs/app/api-reference/functions/fetch)で他のオプションを確認してください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

`fetch`の`next.revalidate`オプションを使って、個々の`fetch`リクエストの再検証期間（秒単位）を設定できます。これにより、Data Cacheが再検証され、それがFull Route Cacheを再検証します。新鮮なデータがフェッチされ、コンポーネントはサーバーで再レンダリングされます。

```jsx
// 最長1時間ごとに再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` API reference](/docs/app/api-reference/functions/fetch)で他のオプションを確認してください。

### `fetch options.next.tags`と`revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsは、細かいデータキャッシングや再検証のためのキャッシュタグシステムを持っています。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用する際に、キャッシュエントリを1つ以上のタグでタグ付けするオプションがあります。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリをパージできます。

例えば、データがフェッチされる際にタグを設定できます：

```jsx
// データをタグでキャッシュ
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

その後、特定のタグで`revalidateTag`を呼び出してキャッシュエントリをパージします：

```jsx
// 特定のタグでエントリーを再検証
revalidateTag('a')
```

`revalidateTag`を使用する場所は目的に応じて2つあります：

1. [ルートハンドラー](/docs/app/building-your-application/routing/route-handlers) - サードパーティのイベント（例：Webhook）に応じてデータを再検証します。ただし、Router Cacheが即座に無効化されることはありません。なぜなら、Router Handlerは特定のルートに紐づいていないためです。
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション（例：フォーム送信）後にデータを再検証します。これにより、関連するルートのRouter Cacheが無効化されます。

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、データを手動で再検証し、特定のパス以下のルートセグメントを1つの操作で再レンダリングします。`revalidatePath`メソッドを呼び出すことで、Data Cacheが再検証され、それによりFull Route Cacheが無効化されます。

```jsx
revalidatePath('/')
```

`revalidatePath`を使用する場所は目的に応じて2つあります：

1. [ルートハンドラー](/docs/app/building-your-application/routing/route-handlers) - サードパーティのイベント（例：Webhook）に応じてデータを再検証します。
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション（例：フォーム送信、ボタンのクリック）後にデータを再検証します。

[`revalidatePath` API reference](/docs/app/api-reference/functions/revalidatePath)で詳細を確認してください。

> **`revalidatePath`**対**`router.refresh`**:
>
> `router.refresh` は Router Cache をクリアし、Data Cache または Full Route Cache を無効化せずにサーバーでルートセグメントを再レンダリングします。
>
> 違いは、`revalidatePath`がData CacheとFull Route Cacheをパージするのに対し、`router.refresh()`はData CacheとFull Route Cacheを変更せず、クライアントサイドAPIです。

### Dynamic API {#dynamic-apis}

Dynamic APIには`cookies`や`headers`、およびPagesの`searchParams`があり、実行時の着信リクエスト情報に依存します。これらを使用すると、ルートがFull Route Cacheからオプトアウトされ、動的にレンダリングされます。

#### `cookies` {#cookies}

Server Action内で`cookies.set`または`cookies.delete`を使用すると、Router Cacheが無効化され、cookieを使用するルートが陳腐化しないようにします（例：認証の変更を反映）。

[`cookies`](/docs/app/api-reference/functions/cookies) API referenceを確認してください。

### Segment Config Options {#segment-config-options}

Route Segment Configオプションは、ルートセグメントのデフォルトを上書きするために使用されるか、`fetch` APIを使用できない場合に使用されます（例：データベースクライアント、サードパーティライブラリ）。

以下のRoute Segment Configオプションは、Full Route Cacheからのオプトアウトとなります：

- `const dynamic = 'force-dynamic'`

この設定オプションは、Data Cacheからすべてのフェッチをオプトアウトします（例：`no-store`）：

- `const fetchCache = 'default-no-store'`

[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)でさらに高度なオプションを確認してください。

[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントで他のオプションを確認してください。

### `generateStaticParams` {#generatestaticparams}

[dynamic segments](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）に対しては、`generateStaticParams`によって提供されたパスがビルド時にFull Route Cacheにキャッシュされます。リクエスト時、Next.jsはビルド時に知られていなかったパスも最初に訪れた際にキャッシュします。

すべてのパスをビルド時に静的にレンダリングするには、`generateStaticParams`に完全なパスリストを提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

一部のパスをビルド時に静的にレンダリングし、残りをランタイムで最初に訪れた際に静的にレンダリングするには、部分的なパスリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10件の投稿をビルド時にレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

すべてのパスを最初に訪れた際に静的にレンダリングするには、空の配列を返す（ビルド時にパスがレンダリングされない）か、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`からは、空の場合でも配列を返す必要があります。そうしないと、ルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時のキャッシュを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。この設定オプションが使用されると、`generateStaticParams`によって提供されたパスのみが提供され、他のルートは404となるか、に一致します（[catch-allルート](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）。

### React `cache`関数 {#react-cache-function}

Reactの`cache`関数は関数の戻り値をメモ化するために使い、同じ関数を複数回呼び出しても一度だけ実行されます。

`fetch`リクエストは自動的にメモ化されるため、Reactの`cache`にラップする必要はありません。ただし、`fetch`APIが適切でないユースケースの場合、データリクエストを手動でメモ化するのに`cache`を使えます。例えば、一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアントには`cache`が有用です。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
