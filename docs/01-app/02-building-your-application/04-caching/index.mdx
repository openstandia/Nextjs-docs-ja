---
title: 'Next.jsのキャッシング'
nav_title: 'キャッシング'
description: 'Next.jsのキャッシングメカニズムの概要。'
---

Next.jsは、レンダリングの作業やデータ要求をキャッシュすることで、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシングメカニズムについて詳しく説明し、それらを構成するために使用できるAPIと、これらのAPIがどのように相互作用するかを説明します。

> **Good to know**: このページは、Next.jsが内部でどのように機能するかを理解するのに役立ちますが、Next.jsを効率的に使用するために必ずしも必要な知識ではありません。Next.jsのほとんどのキャッシング推測は、あなたのAPI使用法に基づいており、ゼロまたは最小限の構成で最高のパフォーマンスを得るためのデフォルトが設定されています。代わりに例に飛びたい場合は、[こちらから始めてください](/docs/app/building-your-application/data-fetching/fetching).

## 概要 {#overview}

次は、さまざまなキャッシングメカニズムとその目的の概要です：

| メカニズム                                  | 内容                    | 場所         | 目的                                                   | 期間                               |
| ------------------------------------------- | ----------------------- | ------------ | ------------------------------------------------------ | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の戻り値            | サーバー     | React Component tree内でのデータ再利用                 | リクエストライフサイクルごと       |
| [Data Cache](#data-cache)                   | データ                  | サーバー     | ユーザーリクエストとデプロイメントを超えてデータを保存 | 永続的（検証可能）                 |
| [Full Route Cache](#full-route-cache)       | HTMLおよびRSCペイロード | サーバー     | レンダリングコストの削減とパフォーマンスの向上         | 永続的（検証可能）                 |
| [Router Cache](#client-side-router-cache)   | RSCペイロード           | クライアント | ナビゲーション時のサーバーリクエストの削減　　　　     | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsはパフォーマンスを向上させ、コストを削減するために可能な限りキャッシュします。これは、ルートが**静的にレンダリング**され、データ要求が**キャッシュ**されることを意味します。以下の図は、ビルド時および静的ルートが初めて訪問されたときの、デフォルトのキャッシング動作を示しています。

<Image
  alt="Next.jsにおける4つのメカニズムに対するデフォルトのキャッシング動作を示した図。ビルド時とルートが初めて訪問されるときにHIT、MISS、SETが発生。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシング動作は、ルートが静的にレンダリングされるか動的にレンダリングされるか、データがキャッシュされるかキャッシュされないか、リクエストが初回訪問の一部か、後のナビゲーションの一部かによって変わります。用途に応じて、個々のルートやデータ要求のキャッシング動作を構成できます。

## Request Memoization {#request-memoization}

Reactは[`fetch` API](#fetch)を拡張して、同じURLとオプションを持つリクエストを自動的に**メモ化**します。つまり、React component treeの複数の箇所で同じデータを取得するためにフェッチ関数を呼び出しても、１回だけ実行されます。

<Image
  alt="重複除去されたフェッチリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

たとえば、ルート全体で同じデータを使用する必要がある場合（たとえば、Layout、Page、複数のコンポーネントで）、ツリーの一番上でデータをフェッチしてコンポーネント間でpropsを伝播する必要はありません。代わりに、データが必要なコンポーネントでデータをフェッチし、ネットワーク経由で同じデータの複数の要求を行うことによるパフォーマンスの影響を心配することなくデータを活用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初の1回だけ実行されます
const item = await getItem() // キャッシュ MISS

// 2回目の呼び出しはルートのどこにでもあります
const item = await getItem() // キャッシュ HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初の1回だけ実行されます
const item = await getItem() // キャッシュ MISS

// 2回目の呼び出しはルートのどこにでもあります
const item = await getItem() // キャッシュ HIT
```

</TabItem>
</Tabs>

**Request Memoizationの仕組み**

<Image
  alt="Reactレンダリング中のfetchメモ化の仕組みを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングする際、特定のリクエストが初めて呼び出されたとき、その結果はメモリにありません。そしてキャッシュは`MISS`となります。
- そのため、関数が実行され、データが外部ソースから取得され、その結果がメモリに保存されます。
- 同じレンダリングパスでリクエストの後続の関数呼び出しは、キャッシュ`HIT`となり、データは関数を実行することなくメモリから返されます。
- ルートがレンダリングされレンダリングパスが完了すると、メモリは「リセット」され、すべてのリクエストメモ化エントリがクリアされます。

> **Good to know**:
>
> - Request MemoizationはReactの機能であり、Next.jsの機能ではありません。ここでは、他のキャッシングメカニズムとどのように相互作用するかを示しています。
> - メモ化は`fetch`リクエストの`GET`メソッドにのみ適用されます。
> - メモ化はReact Component treeのみに適用されます。つまり：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、その他のServer Componentsの`fetch`リクエストに適用されます。
>   - Route Handlersの`fetch`リクエストには適用されません。これらはReact component treeの一部ではないためです。
> - `fetch`が適していない場合（たとえば、データベースクライアント、CMSクライアント、GraphQLクライアントなど）、関数をメモ化するために[Reactの`cache`関数](#react-cache-function)を使用することができます。

### 期間 {#duration}

キャッシュはサーバーリクエストのライフタイム、つまりReact component treeのレンダリングが終了するまで続きます。

### 再検証 {#revalidating}

メモ化はサーバーリクエストごとに共有されておらず、レンダリング中のみ適用されるため、再検証する必要はありません。

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、`POST`や`DELETE`などの他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、オプトアウトを推奨しません。

個々のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)から[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これはリクエストをメモ化から完全にオプトアウトするものではなく、フライト中のリクエストを中断します。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには組み込みのData Cacheがあり、データフェッチの結果が着信する**サーバーリクエスト**や**デプロイ**を超えて**永続**します。これは、Next.jsがネイティブの`fetch` APIを拡張して、サーバー上の各リクエストがその永続的なキャッシングセマンティクスを設定できるようにしているためです。

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのようにやり取りするかを示します。一方、Next.jsでは、`cache`オプションはサーバーサイドリクエストがサーバーのData Cacheとどのようにやり取りするかを示します。

`fetch`の[`cache`](#fetch-optionscache)および[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシング動作を設定できます。

**Data Cacheの仕組み**

<Image
  alt="キャッシュされたリクエストとキャッシュされていないリクエストがData Cacheとどのように対話するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化されています。キャッシュされないリクエストはデータソースからフェッチされ、Data Cacheには保存されず、メモ化されています。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- レンダリング中に`'force-cache'`オプションを持つ`fetch`リクエストが初めて呼び出されるとき、Next.jsはData Cacheにキャッシュされたレスポンスがあるか確認します。
- キャッシュされたレスポンスが見つかれば、それは即座に返され、[メモ化](#request-memoization)されます。
- キャッシュされたレスポンスが見つからなければ、リクエストがデータソースに対して行われ、結果がData Cacheに保存され、メモ化されます。
- 未キャッシュのデータの場合（例えば、キャッシュオプションが定義されていないか、`{ cache: 'no-store' }`を使用）、結果は常にデータソースからフェッチされ、メモ化されます。
- データがキャッシュされているかいないかに関わらず、リクエストは常にメモ化され、Reactのレンダー中に同じデータの重複リクエストが行われるのを避けます。

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシングメカニズムは、キャッシュされたデータを再利用することでパフォーマンスを向上させますが、Data Cacheは要求とデプロイメントを超えて永続的であるのに対し、メモ化はリクエストのライフタイムを超えて持続しません。

### 期間 {#duration}

Data Cacheは、再検証またはオプトアウトしない限り、着信リクエストおよびデプロイメントを超えて永続的です。

### 再検証 {#revalidating}

キャッシュされたデータは、以下の2つの方法で再検証できます：

- **時間ベースの再検証**：一定の時間が経過し、新しいリクエストが来た場合にデータを再検証します。これは、めったに変更されないデータで、新鮮さがそれほど重要でない場合に役立ちます。
- **オンデマンド再検証**：イベントに基づいてデータを再検証します（例：フォーム送信）。オンデマンド再検証は、タグベースまたはパスベースのアプローチを使用して一度にデータのグループを再検証できます。これは、ヘッドレスCMSからコンテンツが更新されたときなど、できるだけ早く最新のデータを表示したい場合に便利です。

#### 時間ベースの再検証 {#time-based-revalidation}

指定された間隔でデータを再検証するには、`fetch`の`next.revalidate`オプションを使用してリソースのキャッシュの寿命（秒数）を設定します。

```js
// 1時間ごとに再検証します
fetch('https://...', { next: { revalidate: 3600 } })
```

または、セグメントまたは`fetch`を使用できないケースでのすべての`fetch`リクエストを構成するために[Route Segment Configオプション](#segment-config-options)を使用できます。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証がどのように機能するかを示す図。再検証期間後、最初のリクエスト時には古いデータが戻され、その後データが再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`付きのフェッチリクエストが初めて呼び出されたとき、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- 指定された時間（例：60秒）内で呼び出されたリクエストは、キャッシュされたデータを返します。
- 指定された時間が経過した後、次のリクエストは依然としてキャッシュされた（現在は古い）データを返します。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データが正常にフェッチされると、Next.jsはData Cacheを新鮮なデータで更新します。
  - バックグラウンドの再検証が失敗した場合、以前のデータは変更されずに保持されます。

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)動作に似ています。

#### オンデマンド再検証 {#on-demand-revalidation}

データは、パス（[`revalidatePath`](#revalidatepath)）またはキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）でオンデマンドで再検証できます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証の動作を示す図。再検証リクエスト後、Data Cacheが新しいデータで更新されます。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼び出されたとき、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- オンデマンド再検証がトリガーされた場合、対応するキャッシュエントリがキャッシュから削除されます。
  - これは時間ベースの再検証とは異なり、データの取得が完了するまで古いデータをキャッシュ内に保持します。
- 次にリクエストが行われたときに、再びキャッシュ`MISS`となり、データは外部データソースからフェッチされてData Cacheに格納されます。

### オプトアウト {#opting-out}

`fetch`の応答をキャッシュしたくない場合は、次のようにします：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**：
>
> 自動静的最適化、静的サイト生成または静的レンダリングは、アプリケーションのルートをビルド時にレンダリングしてキャッシュするプロセスを指すために、同義語として使われることがあります。

Next.jsは、自動的にルートをビルド時にレンダリングし、キャッシュします。これは、リクエストごとにサーバーでレンダリングする代わりにキャッシュされたルートを提供することを可能にする最適化であり、ページ読み込み速度を向上させます。

Full Route Cacheがどのように機能するかを理解するためには、Reactがレンダリングをどのように処理するか、Next.jsが結果をどのようにキャッシュするかを見てみると役立ちます：

### 1.サーバー上でのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントとSuspense境界ごとにチャンクに分割されます。

各チャンクは2段階でレンダリングされます：

1. ReactはServer Componentsをストリーミングに最適化された特別なデータ形式、つまり**React Server Component Payload**にレンダリングします。
2. Next.jsは、React Server Component PayloadとClient Component JavaScriptの命令を使用して、**HTML**をサーバーにレンダリングします。

これにより、レンダリングすべてが完了するのを待つことなく、作業をキャッシュしたり、レスポンスを送信したりできます。その代わりに、作業が完了したらストリームでレスポンスを送信できます。

> **React Server Component Payloadとは？**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。クライアント上のReactがブラウザのDOMを更新するために使用されます。React Server Component Payloadには以下が含まれます：
>
> - Server Componentsのレンダリング結果
> - Client Componentsをレンダリングすべき場所のプレースホルダーとそのJavaScriptファイルへの参照
> - Server ComponentからClient Componentに渡されるプロパティ
>
> 詳しくは、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください。

### 2.サーバー上でのNext.jsのキャッシング（Full Route Cache） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="スタティックにレンダリングされたルートのためにサーバー上でReact Server Component PayloadとHTMLがキャッシュされるFull Route Cacheのデフォルトの動作を示しています。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルト動作は、ルートのレンダリング結果（React Server Component PayloadおよびHTML）をサーバーにキャッシュすることです。これはビルド時または再検証時のスタティックレンダリングされたルートに適用されます。

### 3.クライアントでのReact Hydrationと一致化 {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時に、クライアントで：

1. HTMLは、クライアントとServer Componentsの対話不可な初期プレビューを即座に表示するために使用されます。
2. React Server Component Payloadは、クライアントとレンダリングされたServer Component treeを一致させたり、DOMを更新するために使用されます。
3. JavaScriptの命令は、Client Componentsを水和し、アプリケーションを対話型にするために使用されます。

### 4.クライアントでのNext.jsのキャッシング（Router Cache） {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadは、クライアント側[Router Cache](#client-side-router-cache)に保存されます。これらのRouter Cacheは、以前に訪れたルートを保存し、将来訪れる可能性が高いルートを事前フェッチすることにより、ナビゲーション体験を向上させるために使用されます。

### 5.後続のナビゲーション {#5-subsequent-navigations}

その後のナビゲーションや事前フェッチ時に、Next.jsはRouter CacheにReact Server Components Payloadが格納されているかどうかを確認します。格納されている場合、新しいリクエストをサーバーに送信することはありません。

ルートセグメントがキャッシュにない場合、Next.jsはサーバーからReact Server Components Payloadをフェッチし、クライアント上のRouter Cacheを更新します。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ルートがビルド時にキャッシュされているかどうかは、静的か動的レンダリングされているかによります。静的ルートはデフォルトでキャッシュされますが、動的ルートはリクエスト時にレンダリングされ、キャッシュされません。

この図は、静的および動的にレンダリングされたルートにおける、キャッシュデータと非キャッシュデータの違いを示しています：

<Image
  alt="静的レンダリングと動的レンダリングがFull Route Cacheにどのように影響を与えるかを示す図。静的ルートはビルド時またはデータ再検証後にキャッシュされるのに対し、動的ルートは決してキャッシュされません"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学ぶ。

### 期間 {#duration}

デフォルトでは、Full Route Cacheは永続的です。これは、レンダリング出力がユーザーリクエスト間でキャッシュされることを意味します。

### 無効化 {#invalidation}

Full Route Cacheを無効化する方法は2つあります：

- **[データを再検証する](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)を再検証することで、サーバーでコンポーネントを再レンダリングし、新しいレンダー出力をキャッシュすることでRouter Cacheを無効にします。
- **再デプロイ**: デプロイメントを超えて永続するData Cacheとは異なり、Full Route Cacheは新しいデプロイメント時にクリアされます。

### オプトアウト {#opting-out}

Full Route Cacheからオプトアウトする、または、他の言い方をすれば、すべての着信リクエストに対してコンポーネントを動的にレンダリングするには：

- **[Dynamic API](#dynamic-apis)を使用**: これにより、Full Route Cacheからルートがオプトアウトされ、リクエスト時に動的にレンダリングされます。Data Cacheは引き続き使用できます。
- **`dynamic = 'force-dynamic'`または`revalidate = 0`ルートセグメント構成オプションを使用**:これにより、Full Route CacheとData Cacheがスキップされます。つまり、着信リクエストのたびにサーバーでコンポーネントがレンダリングされ、データが取得されます。Router Cacheはクライアントサイドキャッシュとして引き続き適用されます。
- **[Data Cache](#data-cache)からオプトアウト**: キャッシュされていない`fetch`リクエストを持つルートでは、Full Route Cacheからオプトアウトされます。特定の`fetch`リクエストのデータは、着信リクエストのたびに取得されます。他のキャッシュからオプトアウトしない`fetch`リクエストは引き続きData Cacheでキャッシュされます。これにより、キャッシュデータと非キャッシュデータのハイブリッドが可能になります。

## クライアントサイドRouter Cache {#client-side-router-cache}

Next.jsには、ルートセグメントのRSCペイロードを格納するインメモリのクライアントサイドrouter cacheがあり、レイアウト、ロード状態、およびページごとに分割されます。

ユーザーがルート間をナビゲートする際、Next.jsは訪れたルートセグメントをキャッシュし、ユーザーがナビゲートする可能性のあるルートを[事前フェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、ナビゲーション間の完全なページリロードがなくなり、Reactとブラウザの状態が保持され、即座に前進/後退ナビゲーションが実現します。

Router Cacheを使用すると：

- **レイアウト**はキャッシュされ、ナビゲーション時に再利用されます（[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）。
- **ロード状態**はキャッシュされ、[即時ナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)用にナビゲーション時に再利用されます。
- **ページ**はデフォルトではキャッシュされませんが、ブラウザの前進・後退ナビゲーション時に再利用されます。ページセグメントのキャッシングを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)構成オプションを使用できます。

{/* TODO: Update diagram to match v15 behavior */}

> **Good to know:** このキャッシュは特にNext.jsとServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、似たような結果をもたらします。

### 期間 {#duration}

キャッシュはブラウザの一時メモリに格納されます。router cacheがどれだけ持続するかには、2つの要因があります：

- **セッション**: キャッシュはナビゲーション間で持続します。ただし、ページを更新するとクリアされます。
- **自動無効化期間**: レイアウトとロード状態のキャッシュは、特定の時間後に自動的に無効化されます。継続時間は、リソースがどのように[P prefetched](/docs/app/api-reference/components/link#prefetch)されていたか、およびリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されていたかによって異なります。
  - **デフォルトの事前フェッチ**（`prefetch={null}`または指定なし）：動的ページの場合はキャッシュされず、静的ページの場合は5分間。
  - **完全な事前フェッチ**（`prefetch={true}`または`router.prefetch`）：静的および動的ページの両方で5分間。

ページをリフレッシュすると**すべての**キャッシュされたセグメントがクリアされる一方で、自動無効化期間は事前フェッチされた時点からの個別のセグメントにのみ影響を与えます。

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)構成オプションを使用して、上記の自動無効化時間を調整できます。

### 無効化 {#invalidation}

Router Cacheを無効にする方法は2つあります：

- **サーバーアクション**内で：
  - パスやキャッシュタグでデータをオンデマンドで再検証し、Router Cacheを無効することができます。例：(サーバーアクションで`revalidatePath`または`revalidateTag`を使用した場合)。
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)はRouter Cacheを無効化して、cookieを使用するルートが古くなるのを防ぎます（例：認証）。
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すと、Router Cacheが無効化され、現在のルートのためにサーバーに新しいリクエストが送信されます。

### オプトアウト {#opting-out}

Next.js 15以降、ページセグメントはデフォルトでオプトアウトされます。

> **Good to know:** `<Link>`コンポーネントの`prefetch`プロップを`false`に設定することで、[事前フェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)からもオプトアウトできます。

## キャッシュ相互作用 {#cache-interactions}

異なるキャッシングメカニズムを構成する際には、それらがどのように相互作用するかを理解することが重要です：

### Data CacheとFull Route Cacheの関係 {#data-cache-and-full-route-cache}

- Data Cacheを再検証またはオプトアウトすると、レンダー出力がデータに依存するため、Full Route Cacheが無効化されます。
- Full Route Cacheを無効化したりオプトアウトすることは、Data Cacheには影響しません。両方のキャッシュされたデータとノンキャッシュされたデータを持つルートを動的にレンダリングすることができます。ページのほとんどがキャッシュされたデータを使用する場合でも、リクエスト時に取得する必要のあるデータに依存するコンポーネントがいくつかある場合には役立ちます。すべてのデータを再取得することによるパフォーマンスへの影響を心配することなく、動的にレンダリングできます。

### Data CacheとクライアントサイドRouter Cacheの関係 {#data-cache-and-client-side-router-cache}

- Data CacheとRouter Cacheを即時に無効化するには、[サーバーアクション](#revalidatepath)で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます。
- [ルートハンドラ](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証しても、Router Cacheは即時には無効化されません。なぜなら、ルートハンドラは特定のルートに結びつけられていないためです。したがって、Router Cacheはハードリフレッシュや自動無効化期間が経過するまで以前のペイロードを提供し続けます。

## API {#apis}

次の表は、異なるNext.js APIがキャッシングにどのように影響するかの概要を示しています：

| API                                                                     | Router Cache                 | Full Route Cache             | Data Cache                   | React Cache |
| ----------------------------------------------------------------------- | ---------------------------- | ---------------------------- | ---------------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | キャッシュ                   |                              |                              |             |
| [`router.prefetch`](#routerprefetch)                                    | キャッシュ                   |                              |                              |             |
| [`router.refresh`](#routerrefresh)                                      | 再検証                       |                              |                              |             |
| [`fetch`](#fetch)                                                       |                              |                              | キャッシュ                   | キャッシュ  |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                              |                              | キャッシュまたはオプトアウト |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                              | 再検証                       | 再検証                       |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                              | キャッシュ                   | キャッシュ                   |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | 再検証（サーバーアクション） | 再検証                       | 再検証                       |             |
| [`revalidatePath`](#revalidatepath)                                     | 再検証（サーバーアクション） | 再検証                       | 再検証                       |             |
| [`const revalidate`](#segment-config-options)                           |                              | 再検証またはオプトアウト     | 再検証またはオプトアウト     |             |
| [`const dynamic`](#segment-config-options)                              |                              | キャッシュまたはオプトアウト | キャッシュまたはオプトアウト |             |
| [`cookies`](#cookies)                                                   | 再検証（サーバーアクション） | オプトアウト                 |                              |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                              | オプトアウト                 |                              |             |
| [`generateStaticParams`](#generatestaticparams)                         |                              | キャッシュ                   |                              |             |
| [`React.cache`](#react-cache-function)                                  |                              |                              |                              | キャッシュ  |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                              |                              | キャッシュ                   |             |

### `<Link>` {#link}

デフォルトで、`<Link>`コンポーネントは、Full Route Cacheからルートを自動的にプリフェッチし、Router CacheにReact Server Component Payloadを追加します。

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定できます。ただし、これにより、ルートセグメントがクライアントサイドで永続的にキャッシュされないだけでなく、ユーザーがルートを訪れるとキャッシュされることもあります。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しく学ぶ。

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使用して、ルートを手動でプリフェッチできます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`](#routerprefetch)フックの詳細については、[`useRouter` API リファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使用して、ルートを手動でリフレッシュできます。これにより、Router Cacheが完全にクリアされ、現在のルートのためにサーバーに新しいリクエストが送信されます。`refresh`は、Data Cache または Full Route Cache には影響しません。

レンダリングされた結果は、Reactの状態とブラウザの状態を保持しながら、クライアント側で一致化されます。

[`useRouter` API リファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

### `fetch` {#fetch}

`fetch`から返されるデータは、データキャッシュに自動的にキャッシュされません。

`fetch`のデフォルトのキャッシング動作（例えば、`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`として設定することと同等です：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

他のオプションについては、[`fetch` API リファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.cache` {#fetch-options-cache}

個別の`fetch`をキャッシングにオプトインするには、`cache`オプションを`force-cache`に設定します：

```jsx
// キャッシュにオプトイン
fetch(`https://...`, { cache: 'force-cache' })
```

他のオプションについては、[`fetch` API リファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

`fetch`の`next.revalidate`オプションを使用して、個別の`fetch`リクエストの再検証期間（秒単位）を設定できます。これにより、Data Cacheが再検証され、Full Route Cacheも再検証されます。新鮮なデータがフェッチされ、コンポーネントはサーバーで再レンダリングされます。

```jsx
// 最長1時間後に再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

他のオプションについては、[`fetch` API リファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.next.tags`と `revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、詳細なデータキャッシングと再検証のためのキャッシュタグシステムがあります。

1. `fetch`や[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用している場合、1つ以上のタグでキャッシュエントリをタグ付けするオプションがあります。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリをクリアできます。

例えば、データをフェッチするときにタグを設定できます：

```jsx
// タグ付きでデータをキャッシュ
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

その後、特定のタグで`revalidateTag`を呼び出してキャッシュエントリをクリアします：

```jsx
// 特定のタグでエントリを再検証する
revalidateTag('a')
```

達成しようとしている目的に基づいて、`revalidateTag`を使用できる場所は2つあります：

1. [ルートハンドラ](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベントに応じてデータを再検証するため（例：webhook）。Router Cacheは即時には無効化されません。なぜなら、Router Handlerは特定のルートに結びつけられていないためです。
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション後にデータを再検証するため（例：フォーム送信）。関連するルートのRouter Cacheが無効化されます。

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、特定のパス以下のルートセグメントでデータを手動で再検証し、再レンダリングすることができます。`revalidatePath`メソッドを呼び出すことで、Data Cacheが再検証され、Full Route Cacheが無効化されます。

```jsx
revalidatePath('/')
```

達成したいことに応じて、`revalidatePath`を使用できる場所は2つあります：

1. [ルートハンドラ](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベントに応じてデータを再検証するため（例：webhook）。
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション後にデータを再検証するため（例：フォーム送信、ボタンクリック）。

[`revalidatePath` API リファレンス](/docs/app/api-reference/functions/revalidatePath)を参照してください。

> **`revalidatePath`**と**`router.refresh`**の違い：
>
> `router.refresh`を呼び出すと、Router Cacheがクリアされ、Data CacheまたはFull Route Cacheを無効化せずにサーバーでルートセグメントが再レンダリングされます。
>
> `revalidatePath`はData CacheおよびFull Route Cacheをクリアしますが、`router.refresh()`はData CacheおよびFull Route
> Cacheを変更しません。これはクライアントサイドのAPIだからです。

### 動的API {#dynamic-apis}

動的API、例えば`cookies`や`headers`、Pagesの`searchParams` propはランタイムの着信リクエスト情報に依存します。これを使用すると、Full Route Cacheからルートがオプトアウトされ、ルートが動的にレンダリングされます。

#### `cookies` {#cookies}

サーバーアクションで`cookies.set`や`cookies.delete`を使用することで、cookieを使用するルートが古くなるのを防ぐためにRouter Cacheが無効化されます（例：認証の変化を反映するため）。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照してください。

### セグメント構成オプション {#segment-config-options}

Route Segment Configオプションは、ルートセグメントのデフォルトを上書きするため、または`fetch` APIを使用できない場合（例：データベースクライアントやサードパーティのライブラリ）などに使用できます。

次のRoute Segment Configオプションは、Full Route Cacheからオプトアウトします：

- `const dynamic = 'force-dynamic'`

この構成オプションは、すべてのフェッチをData Cacheからオプトアウトします（例えば、`no-store`）：

- `const fetchCache = 'default-no-store'`

より詳細なオプションについては、[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)を参照してください。

その他のオプションには、[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントを参照してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）の場合、`generateStaticParams`で提供されるパスは、ビルド時にFull Route Cacheにキャッシュされます。リクエスト時に、Next.jsはビルド時に知られていなかったパスも初めて訪れた際にキャッシュします。

すべてのパスをビルド時に静的にレンダリングするには、`generateStaticParams`にパスの完全なリストを供給します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時に一部のパスのみを静的にレンダリングし、残りのパスは実行時に初めて訪れた時にレンダリングするには、部分的なリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10件の投稿をビルド時にレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

すべてのパスを初めて訪れた際に静的にレンダリングするには、空の配列を返します（ビルド時にはどのパスもレンダリングされません）。もしくは、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`からは必ず配列を返す必要があります、たとえそれが空だとしても。そうでないと、ルートが動的にレンダリングされることになります。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時のキャッシュを無効にするには、ルートセグメントで`export const dynamicParams = false`オプションを追加します。この構成オプションが使用される場合、`generateStaticParams`で提供されたパスのみがサーブされ、その他のルートは404またはマッチ（[catch-allルート](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）されます。

### React `cache` 関数 {#react-cache-function}

Reactの`cache`関数を使用すると関数の戻り値をメモ化でき、同じ関数を複数回呼び出しながら、一度だけ実行されます。

`fetch`リクエストは自動的にメモ化されるため、React `cache`でラップする必要はありません。しかし、`fetch` APIが適していない場合のデータリクエストを手動でメモ化するためには、`cache`を使用できます。たとえば、データベースクライアント、CMSクライアント、またはGraphQLクライアントの場合です。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
