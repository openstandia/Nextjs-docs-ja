---
title: 'Next.jsにおけるキャッシュ'
nav_title: 'キャッシュ'
description: 'Next.jsにおけるキャッシュ機構の概要。'
---

Next.jsは、レンダリング作業やデータリクエストをキャッシュすることで、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシュ機構、設定に使用できるAPI、およびそれらがどのように互いに連携するかについて詳しく説明します。

> **Good to know**: このページは、Next.jsがどのように内部で動作するかを理解するための助けにはなりますが、Next.jsを使いこなすために必須の知識ではありません。Next.jsのほとんどのキャッシュ推論は、APIの使用状況によって決定され、ゼロまたは最小限の設定で最高のパフォーマンスを得るためのデフォルトが設けられています。代わりに例を試したい場合は、[こちらから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

これが、異なるキャッシュ機構とその目的の大まかな概要です：

| 機構                                        | 内容                | 所在地       | 目的                                             | 継続時間                             |
| ------------------------------------------- | ------------------- | ------------ | ------------------------------------------------ | ------------------------------------ |
| [Request Memoization](#request-memoization) | 関数の返り値        | サーバー     | React Component tree 内のデータ再利用            | リクエスト毎のライフサイクル         |
| [Data Cache](#data-cache)                   | データ              | サーバー     | ユーザーリクエストとデプロイ間でデータを保存     | 永続的（再検証可能）                 |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバー     | レンダリングコストを削減し、パフォーマンスを向上 | 永続的（再検証可能）                 |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時のサーバーリクエストを削減       | ユーザーセッションまたは時間に基づく |

デフォルトでは、Next.jsは可能な限り多くのキャッシュを行い、パフォーマンスを向上させ、コストを削減します。これは、ルートが**静的にレンダリングされ**、データリクエストが**キャッシュされる**ことを意味します。ただし、オプトアウトすることも可能です。以下の図は、ビルド時および静的ルートが初めて訪問されたときのデフォルトのキャッシュ動作を示しています：

<Image
  alt="Next.jsにおける4つの機構でのデフォルトのキャッシュ動作を示す図。ビルド時とルートが初めて訪問されたときのHIT、MISS、SET。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシングの動作はルートが静的か動的か、データがキャッシュされているかキャッシュされていないか、またリクエストが初回訪問かその後のナビゲーションかによって変わります。あなたのユースケースによって、個々のルートとデータリクエストのキャッシング動作を設定できます。

## Request Memoization {#request-memoization}

Reactは[`fetch` API](#fetch)を拡張して、同じURLとオプションを持つリクエストを自動的に**メモ化**します。これにより、Reactコンポーネントツリーの複数の場所で同じデータに対してフェッチ関数を呼び出しても、実行は1回のみとなります。

<Image
  alt="重複フェッチリクエストの排除"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

例えば、ルート全体で同じデータを使用する必要がある場合（例：レイアウト・ページ・複数のコンポーネント）には、ツリーの上部でデータをフェッチし、コンポーネント間でpropsを転送する必要はありません。代わりに、必要なコンポーネントでデータをフェッチし、同じデータに対する複数のネットワークリクエストを行うことによるパフォーマンスへの影響を考慮する必要はありません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch` 関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch` 関数は自動的にメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoization の仕組み**

<Image
  alt="Reactレンダリング中のfetchメモ化の仕組みを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートのレンダリング中に、特定のリクエストが初めて呼び出されると、その結果はメモリには存在しないため、キャッシュ`MISS`となります。
- したがって、関数が実行され、外部ソースからデータがフェッチされ、結果がメモリに保存されます。
- 同じレンダーパス内のそのリクエストの後続の関数呼び出しではキャッシュ`HIT`となり、関数を実行することなくメモリからデータが返されます。
- ルートがレンダリングされ、レンダリングパスが完了すると、メモリは「リセット」され、すべてのリクエストメモ化エントリがクリアされます。

> **Good to know**:
>
> - Request MemoizationはReactの機能であり、Next.jsの機能ではありません。他のキャッシュ機構との相互作用を示すためにここに含まれています。
> - メモ化は`fetch`リクエストにおける`GET`メソッドにのみ適用されます。
> - メモ化はReact Component treeのみに適用されるため：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、および他のServer Components内の`fetch`リクエストに適用されます。
>   - React component treeの一部でないため、Route Handlersでの`fetch`リクエストには適用されません。
> - `fetch`が適していないケース（例：いくつかのデータベースクライアント、CMSクライアント、またはGraphQLクライアント）では、Reactの`cache`関数を使用して関数をメモ化できます。

### 継続時間 {#duration}

キャッシュは、サーバーリクエストのライフサイクルが終了し、React component treeのレンダリングが完了するまで続きます。

### 再検証 {#revalidating}

メモ化はサーバーリクエスト間で共有されず、レンダリング中にのみ適用されるため、再検証の必要はありません。

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、`POST`や`DELETE`など他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、オプトアウトは推奨されません。

個々のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) の [`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal) プロパティを使用できます。ただし、これは要求をメモ化から外すのではなく、進行中のリクエストを中止するものです。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには、リクエスト毎の**サーバーリクエスト**や**デプロイ**間でデータフェッチの結果を**永続**させる組み込みのData Cacheがあります。これは、Next.jsがネイティブ`fetch` APIを拡張し、各リクエストが自身の永続的キャッシュ言語を設定できるようにすることで可能となりました。

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションは、リクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、サーバーサイドのリクエストがサーバーのData Cacheとどのように相互作用するかを示します。

[`cache`](#fetch-optionscache) と [`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシュ動作を設定できます。

**Data Cache の仕組み**

<Image
  alt="Data Cacheとキャッシュされていないフェッチリクエストがどのように相互作用するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化され、キャッシュされていないリクエストはデータソースから取得され、Data Cacheには保存されず、メモ化されます。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- レンダリング中に`'force-cache'`オプション付きの`fetch`リクエストが初めて呼び出された場合、Next.jsはData Cacheを確認し、キャッシュされたレスポンスがあるかどうかを確認します。
- キャッシュされたレスポンスが見つかれば、それが即座に返され、[メモ化](#request-memoization)されます。
- キャッシュされたレスポンスが見つからない場合、データソースへのリクエストが行われ、その結果がData Cacheに保存され、メモ化されます。
- キャッシュされていないデータの場合（例：`cache`オプションが定義されていない、または`{ cache: 'no-store' }`を使用した場合）、結果は常にデータソースからフェッチされ、メモ化されます。
- データがキャッシュされているかキャッシュされていないかにかかわらず、リクエストは常にメモ化され、Reactレンダリングパス中に同じデータに対する重複リクエストが行われないようにします。

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシュ機構は、キャッシュされたデータを再利用することでパフォーマンスを向上させますが、Data Cacheはリクエストとデプロイをまたいで永続化されるのに対し、メモ化はリクエストのライフタイム内でのみ続きます。

### 継続時間 {#duration}

デフォルトでは、Data Cacheはリクエストとデプロイをまたいで永続化されますが、再検証またはオプトアウトすることで変更可能です。

### 再検証 {#revalidating}

キャッシュされたデータは以下の2つの方法で再検証可能です：

- **時間ベースの再検証**：一定の時間が経過した後に再検証を行います。これは変更が頻繁でないデータにとって便利で、更新の迅速さがそれほど重要でない場面に適しています。
- **オンデマンドの再検証**：イベントに基づいてデータを再検証します（例：フォーム送信時）。オンデマンドの再検証では、タグベースまたはパスベースのアプローチを使用して、一度にデータのグループを再検証します。これは、ヘッドレスCMSからのコンテンツが更新されている場合など、できるだけ早く最新データを示したい場合に便利です。

#### 時間ベースの再検証 {#time-based-revalidation}

タイムドインターバルでデータを再検証するには、`fetch`の`next.revalidate`オプションを使用してリソースのキャッシュライフタイム（秒単位）を設定します。

```js
// 最長で毎時間再検証
fetch('https://...', { next: { revalidate: 3600 } })
```

また、[Route Segment Configオプション](#segment-config-options) を使用して、セグメント内のすべての`fetch`リクエストを設定したり、`fetch`が使用できない場合に設定することもできます。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証がどのように機能するかを示す図。再検証期間後、最初のリクエストに対して古いデータが返され、その後データが再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`付きの`fetch`リクエストが初めて呼び出されたとき、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- 指定された時間枠（例：60秒）内に呼び出された任意のリクエストはキャッシュされたデータを返します。
- 時間枠が過ぎた後、次のリクエストはキャッシュされた（現在のところ古い）データを返します。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データが正常にフェッチされると、Next.jsはData Cacheに新しいデータを更新します。
  - バックグラウンド再検証が失敗した場合、以前のデータは変更されずに保存されます。

これは、[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)の動作に似ています。

#### オンデマンドの再検証 {#on-demand-revalidation}

データは、パス（[`revalidatePath`](#revalidatepath)）またはキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）によってオンデマンドで再検証されます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンドの再検証がどのように機能するかを示す図。再検証リクエスト後、Data Cacheは新しいデータで更新されます。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- 初めて`fetch`リクエストが呼び出されたとき、データは外部データソースから取得され、Data Cacheに保存されます。
- オンデマンドの再検証がトリガーされたとき、適切なキャッシュエントリがキャッシュからパージされます。
  - これは、バックグラウンド再検証が、フェッチした新しいデータが取得されるまでキャッシュ内の古いデータを保持するのとは異なります。
- 次のリクエストが行われたとき、それは再びキャッシュ`MISS`となり、データは外部データソースから取得され、Data Cacheに保存されます。

### オプトアウト {#opting-out}

`fetch`のレスポンスをキャッシュ**しない**場合、以下のようにします：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**：
>
> 自動静的最適化（Automatic Static Optimization）、静的サイト生成（Static Site Generation）、または静的レンダリング（Static Rendering）という用語が、ビルド時にアプリケーションのルートをレンダリングしキャッシュするプロセスを指すために交換可能に使われる場合があります。

Next.jsはビルド時に自動的にルートをレンダリングしてキャッシュします。これは、毎回のリクエストごとにサーバーでレンダリングするのではなく、キャッシュされたルートを提供することで、ページの読み込みをより迅速にするための最適化です。

Full Route Cacheの仕組みを理解するためには、Reactがレンダリングをどのように処理し、Next.jsがその結果をどのようにキャッシュするかを見ると役に立ちます：

### 1. サーバー上でのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上では、Next.jsはReactのAPIを利用してレンダリングを調整します。レンダリング作業はチャンクに分けられます：個々のルートセグメントとサスペンス境界によって分割されます。

各チャンクは2つのステップでレンダリングされます：

1. Reactはサーバーコンポーネントをストリーミング用に最適化された特別なデータ形式にレンダリングします。これを**React Server Component Payload**と呼びます。
2. Next.jsはReact Server Component PayloadとクライアントコンポーネントのJavaScript命令を使用して、サーバー上で**HTML**をレンダリングします。

これにより、すべてがレンダリング完成するまで待たずに作業をキャッシュしたり、レスポンスを送信したりすることが可能になります。代わりに、作業が完了するたびにレスポンスをストリーミングできます。

> **React Server Component Payloadとは？**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。クライアント上のReactを使用して、ブラウザのDOMを更新するために使用されます。React Server Component Payloadには以下が含まれます：
>
> - サーバーコンポーネントのレンダリング結果
> - クライアントコンポーネントがレンダリングされる場所のプレースホルダーと、それらのJavaScriptファイルへの参照
> - サーバーコンポーネントからクライアントコンポーネントに渡された任意のprops
>
> 詳細は、[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください。

### 2. サーバー上のNext.jsキャッシュ (Full Route Cache) {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="静的にレンダリングされたルートのためにサーバー上でReact Server Component PayloadとHTMLがキャッシュされるFull Route Cacheのデフォルト動作を示す図。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルト動作は、ルートのレンダリングされた結果（React Server Component PayloadとHTML）をサーバー上でキャッシュすることです。これはビルド時または再検証中に静的にレンダリングされたルートに適用されます。

### 3. クライアント上でのReactの復水と調整 {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時には、クライアント側で：

1. HTMLはクライアントとサーバーコンポーネントの即時に非インタラクティブな初期プレビューを表示するために使用されます。
2. React Server Components Payloadは、クライアントとレンダリングされたサーバーコンポーネントのツリーを調整し、DOMを更新するために使用されます。
3. JavaScript命令は[復水](https://react.dev/reference/react-dom/client/hydrateRoot)してクライアントコンポーネントをインタラクティブにするために使用されます。

### 4. クライアントでのNext.jsキャッシュ (Router Cache) {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadは、クライアント側の[Router Cache](#client-side-router-cache)に保存されます。これは個々のルートセグメントによって分割された別のインメモリキャッシュです。このRouter Cacheはナビゲーション体験を改善するために使用され、以前に訪問したルートを保存し、将来のルートを先読み（プリフェッチ）します。

### 5. その後のナビゲーション {#5-subsequent-navigations}

その後のナビゲーションまたはプリフェッチ中に、Next.jsはReact Server Components PayloadがRouter Cacheに保存されているかどうかを確認します。保存されていれば、サーバーに新しいリクエストを送信せずに済みます。

ルートセグメントがキャッシュにない場合、Next.jsはサーバーからReact Server Components Payloadをフェッチし、クライアント上のRouter Cacheを更新します。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ビルド時にルートがキャッシュされるかどうかは、そのルートが静的にレンダリングされるか動的にレンダリングされるかによります。静的ルートはデフォルトでキャッシュされますが、動的ルートはリクエスト時にレンダリングされ、キャッシュされません。

この図は、静的にレンダリングされたルートと動的にレンダリングされたルートの違いをキャッシュおよびキャッシュされていないデータとともに示しています：

<Image
  alt="静的および動的レンダリングがFull Route Cacheにどのように影響を与えるかを示す。静的ルートはビルド時またはデータ再検証後にキャッシュされる一方、動的ルートはキャッシュされない"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学んでください。

### 継続時間 {#duration}

デフォルトでは、Full Route Cacheは永続的です。これはレンダリング出力がユーザーリクエストに渡ってキャッシュされていることを意味します。

### 無効化 {#invalidation}

Full Route Cacheを無効化する方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**：Data Cacheの再検証は、Router Cacheを無効化し、サーバー上でコンポーネントを再レンダリングして新しいレンダリング出力をキャッシュします。
- **再デプロイ**：データキャッシュがデプロイに渡って永続化されるのに対し、新しいデプロイではFull Route Cacheはクリアされます。

### オプトアウト {#opting-out}

Full Route Cacheからオプトアウト、つまりすべての新しい受信リクエストに対して動的にコンポーネントをレンダリングしたい場合は、以下の方法があります：

- **[動的API](#dynamic-apis)を使用する**：これにより、Full Route Cacheからのルートがオプトアウトされ、リクエスト時に動的にレンダリングされます。Data Cacheは依然として使用できます。
- **`dynamic = 'force-dynamic'`または`revalidate = 0`のルートセグメント設定オプションを使用する**：これにより、Full Route CacheおよびData Cacheがスキップされます。つまり、サーバーへのすべての受信リクエストに対してコンポーネントがレンダリングされ、データがフェッチされます。Router Cacheはクライアント側のキャッシュであるため依然として適用されます。
- **[Data Cache](#data-cache)からのオプトアウト**：`fetch`リクエストがキャッシュされていないルートの場合、これによりルートはFull Route Cacheからオプトアウトされます。特定の`fetch`リクエスト用のデータは、すべての新しい受信リクエストごとにフェッチされます。他のキャッシュからオプトアウトしない`fetch`リクエストはData Cacheに依然としてキャッシュされます。これにより、キャッシュとキャッシュされていないデータのハイブリッドを可能にします。

## クライアントサイドのRouter Cache {#client-side-router-cache}

Next.jsには、ルートセグメントのRSCペイロードをレイアウト、ロード状態、ページごとに分割して保存するインメモリのクライアントサイドRouter Cacheがあります。

ユーザーがルートを移動すると、Next.jsは訪問したルートセグメントをキャッシュし、ユーザーがナビゲートすると予想されるルートを[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、バック/フォワードナビゲーションが即時に行われ、ナビゲーション間でページ全体のリロードがなく、Reactの状態とブラウザの状態が保たれます。

Router Cacheを使用すると：

- **レイアウト**はキャッシュされ、ナビゲーションで再利用されます（[部分的レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）。
- **ロード状態**はキャッシュされ、即時ナビゲーションのためにナビゲーションで再利用されます（[即時ロード状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)）。
- **ページ**はデフォルトではキャッシュされませんが、ブラウザのバックワードおよびフォワードナビゲーション中に再利用されます。[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes) 設定オプションを使用して、ページセグメントのキャッシュを有効にできます。

{/* TODO: v15動作に合うように図を更新 */}

> **Good to know**: このキャッシュは特にNext.jsおよびサーバーコンポーネントに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、同様の結果をもたらします。

### 継続時間 {#duration}

キャッシュはブラウザの一時メモリに保存されます。Router Cacheがどれだけ長く続くかは、次の2つの要因によって決まります：

- **セッション**：キャッシュはナビゲーション間で持続します。ただし、ページを更新するとキャッシュはクリアされます。
- **自動無効化期間**：レイアウトとロード状態のキャッシュは、特定の時間後に自動的に無効化されます。この期間は、リソースがどのように[プリフェッチ](/docs/app/api-reference/components/link#prefetch)されたか、およびリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかどうかに依存します：
  - **デフォルトプリフェッチ** (`prefetch={null}` または未指定)：動的ページの場合キャッシュされず、静的ページの場合5分間。
  - **フルプリフェッチ** (`prefetch={true}` または`router.prefetch`)：静的および動的ページの両方で5分間。

ページのリフレッシュで**すべて**のキャッシュされたセグメントがクリアされますが、自動無効化期間はプリフェッチされた時点から個々のセグメントにのみ影響します。

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用して、上記の自動無効化時間を調整できます。

### 無効化 {#invalidation}

Router Cacheを無効化する方法は2つあります：

- **Server Action**で：
  - パスでオンデマンドでデータを再検証し、([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath))またはキャッシュタグで([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag))により
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用すると、クッキーを使用するルートが古くならないようにRouter Cacheが無効化されます（例：認証）。
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すことは、Router Cacheを無効化し、現在のルートのためにサーバーに新しいリクエストを行います。

### オプトアウト {#opting-out}

Next.js 15以降では、ページセグメントはデフォルトでオプトアウトされています。

> **Good to know**: フェッチのプリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)を辞退することもできます。`<Link>`コンポーネントの`prefetch` propを`false`に設定してください。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシュ機構を構成する際には、互いにどのように相互作用するかを理解することが重要です：

### Data Cache と Full Route Cache {#data-cache-and-full-route-cache}

- Data Cacheの再検証またはオプトアウトは、データがレンダリング出力に依存しているため、Full Route Cacheを無効にします。
- Full Route Cacheの無効化またはオプトアウトはData Cacheに影響を与えません。キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングできます。このパターンは、ページのほとんどがキャッシュされたデータを使用している場合に便利ですが、一部のコンポーネントはリクエスト時に取得する必要があるデータに依存しています。すべてのデータを再取得することによるパフォーマンスへの影響を考慮せずに、動的にレンダリングできます。

### Data CacheとクライアントサイドのRouter Cache {#data-cache-and-client-side-router-cache}

- Data CacheとRouter Cacheを即時に無効化するには、[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)内で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます。
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)においてData Cacheを再検証することは、Router Cacheを即時に無効化しません。これは、Route Handlerが特定のルートに紐付けられていないためです。つまり、Router Cacheはハードリフレッシュか自動無効化期間が経過するまで以前のペイロードを提供し続けます。

## APIs {#apis}

以下の表は、異なるNext.js APIがキャッシュにどのように影響するかを示します：

| API                                                                     | Router Cache               | Full Route Cache      | Data Cache            | React Cache |
| ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | Cache                      |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                    | Cache                      |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                      | Revalidate                 |                       |                       |             |
| [`fetch`](#fetch)                                                       |                            |                       | Cache                 | Cache       |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                       | Cache or Opt out      |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Revalidate            | Revalidate            |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Cache                 | Cache                 |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`revalidatePath`](#revalidatepath)                                     | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`const revalidate`](#segment-config-options)                           |                            | Revalidate or Opt out | Revalidate or Opt out |             |
| [`const dynamic`](#segment-config-options)                              |                            | Cache or Opt out      | Cache or Opt out      |             |
| [`cookies`](#cookies)                                                   | Revalidate (Server Action) | Opt out               |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Opt out               |                       |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Cache                 |                       |             |
| [`React.cache`](#react-cache-function)                                  |                            |                       |                       | Cache       |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                       | Cache                 |             |

### `<Link>` {#link}

デフォルトで、`<Link>` コンポーネントはFull Route Cacheからルートを自動的にプリフェッチし、Router CacheにReact Server Component Payloadを追加します。

プリフェッチを無効にするには、`prefetch` propを`false`に設定できます。しかし、これはキャッシュを永続的にスキップするものではなく、ルートセグメントはユーザーがルートを訪れるとクライアント側で依然としてキャッシュされます。

[`<Link>` コンポーネント](/docs/app/api-reference/components/link)の詳細を学ぶ。

### `router.prefetch` {#router-prefetch}

`useRouter` フックの`prefetch`オプションを使用して手動でルートをプリフェッチできます。これにより、Router CacheにReact Server Component Payloadが追加されます。

[`useRouter` フック](/docs/app/api-reference/functions/use-router) APIリファレンスを参照。

### `router.refresh` {#router-refresh}

`useRouter` フックの`refresh`オプションを使用して手動でルートをリフレッシュできます。これにより、Router Cacheが完全にクリアされ、サーバーに新しいリクエストが行われます。`refresh`はDataまたはFull Route Cacheには影響を与えません。

レンダリングされた結果は、React状態とブラウザ状態を保持しながらクライアントで調整されます。

[`useRouter` フック](/docs/app/api-reference/functions/use-router) APIリファレンスを参照。

### `fetch` {#fetch}

`fetch`から返されるデータは自動的にData Cacheにキャッシュされるわけではありません。

`fetch`のデフォルトのキャッシュ動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定することと同じです：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

その他のオプションについては、[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.cache` {#fetch-options-cache}

個々の`fetch`をキャッシュにオプトインするには、`cache`オプションを`force-cache`に設定します：

```jsx
// キャッシュにオプトイン
fetch(`https://...`, { cache: 'force-cache' })
```

その他のオプションについては、[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

`next.revalidate`オプションを使用して、個々の`fetch`リクエストの再検証期間（秒単位）を設定できます。これはData Cacheを再検証し、結果としてFull Route Cacheを再検証します。新しいデータがフェッチされ、サーバー上でコンポーネントが再レンダリングされます。

```jsx
// 最長で1時間後に再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

その他のオプションについては、[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.next.tags` と `revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、細かくデータをキャッシュし、再検証するためのキャッシュタグシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)使用時に、キャッシュエントリに1つ以上のタグを設定できます。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリをパージできます。

例えば、データをフェッチした際にタグを設定できます：

```jsx
// タグ付きでデータをキャッシュ
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

その後、特定のタグでキャッシュエントリをパージするために`revalidateTag`を呼び出します：

```jsx
// 特定のタグのエントリを再検証
revalidateTag('a')
```

目的に応じて、`revalidateTag`を使用できる場所は2つあります：

1. [Route Handler](/docs/app/building-your-application/routing/route-handlers) - サードパーティのイベント（例：Webhook）の結果としてデータを再検証します。これは、Router Cacheをすぐには無効にしません。なぜなら、Router Handlerが特定のルートに結びつけられていないためです。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション（例：フォーム送信）後にデータを再検証します。これは、関連するルートに対してRouter Cacheを無効にします。

### `revalidatePath` {#revalidatepath}

`revalidatePath`は、特定のパス以下のルートセグメントを単一の操作で手動でデータを再検証し、再レンダリングできるようにします。`revalidatePath`メソッドを呼び出すとData Cacheが再検証され、Full Route Cacheが無効化されます。

```jsx
revalidatePath('/')
```

目的に応じて、2つの場所で`revalidatePath`を使用できます：

1. [Route Handler](/docs/app/building-your-application/routing/route-handlers) - サードパーティのイベント（例：Webhook）に対応してデータを再検証します。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザー操作（例：フォーム送信、ボタンのクリック）後にデータを再検証します。

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)で詳しく学べます。

> **`revalidatePath`**と **`router.refresh`**：
>
> `router.refresh`を呼び出すとRouter cacheがクリアされ、Data CacheまたはFull Route Cacheを変更せずにサーバー上でルートセグメントを再レンダリングします。
>
> 違いは、`revalidatePath`がData CacheとFull Route Cacheをパージするのに対し、`router.refresh()`はData CacheとFull Route Cacheを変更せず、クライアントサイドAPIです。

### 動的API {#dynamic-apis}

`cookies` や `headers`などの動的API、およびPagesの`searchParams` propは実行時の受信リクエスト情報に依存します。これらを使用すると、Full Route Cacheからルートが自動でオプトアウトされ、動的にレンダリングされます。

#### `cookies` {#cookies}

Server Actionで`cookies.set`または`cookies.delete`を使用すると、クッキーを使用するルートが古くならないようにRouter Cacheが無効化されます（例：認証の変更を反映するため）。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照。

### セグメント設定オプション {#segment-config-options}

Route Segment Configオプションを使用して、ルートセグメントのデフォルトをオーバーライドしたり、`fetch` APIが使用できない場合（例：データベースクライアントやサードパーティのライブラリ）に設定できます。

以下のRoute Segment Configオプションは、Full Route Cacheからオプトアウトします：

- `const dynamic = 'force-dynamic'`

この設定オプションは、Data Cacheからすべてのフェッチをオプトアウトします（つまり`no-store`）：

- `const fetchCache = 'default-no-store'`

詳細なオプションを確認するには、[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)を参照してください。

その他のオプションについては、[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントを参照してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)の場合（例：`app/blog/[slug]/page.js`）、`generateStaticParams`で提供されたパスはビルド時にFull Route Cacheにキャッシュされます。リクエスト時には、Next.jsはビルド時に知られていなかったパスを初めて訪れた際にもキャッシュします。

ビルド時にすべてのパスを静的にレンダリングするには、パスのフルリストを`generateStaticParams`に提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスのサブセットを静的にレンダリングし、残りの部分を実行時に初めて訪れたときにレンダリングするには、パスの部分的なリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // ビルド時に最初の10記事をレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

最初の訪問時にすべてのパスを静的にレンダリングするには、空の配列を返す（ビルド時にパスはレンダリングされません）か、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を使用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know**: `generateStaticParams`から配列を返さなければなりません（たとえ空でも）。そうしないとルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時のキャッシュを無効にするには、ルートセグメント内の`export const dynamicParams = false`オプションを追加します。この設定オプションが使用されると、`generateStaticParams`で提供されたパスのみが提供され、それ以外のルートは404または一致します（[catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）。

### React `cache` 関数 {#react-cache-function}

React `cache` 関数は、関数の返り値をメモ化することを可能にし、同じ関数を複数回呼び出しても、1回だけ実行されます。

`fetch` リクエストは自動的にメモ化されるため、React `cache` に包む必要はありません。しかし、`fetch` APIが適さない場合に備えて、手動でデータリクエストをメモ化するために`cache`を利用できます。例：いくつかのデータベースクライアント、CMSクライアント、またはGraphQLクライアント。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
