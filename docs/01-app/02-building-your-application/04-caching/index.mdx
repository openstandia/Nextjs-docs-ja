---
title: 'Next.jsのキャッシュ'
nav_title: 'キャッシュ'
description: 'Next.jsのキャッシュ機構の概要です。'
---

Next.jsは、レンダリング作業やデータリクエストをキャッシュすることで、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシュ機構、これらを設定するためのAPI、そしてそれらがどのように相互に作用するかを詳しく説明します。

> **Good to know**: このページは、Next.jsが内部でどのように動作しているかを理解するのに役立ちますが、Next.jsを使って生産的に作業するために必須の知識では**ありません**。Next.jsのキャッシュヒューリスティックの大半は、APIの使用法によって決定され、最小限の設定で最高のパフォーマンスを発揮するデフォルトが設定されています。例をすぐに見たい場合は、[こちらから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

以下は、さまざまなキャッシュ機構とその目的のハイレベルな概要です：

| 機構                                        | 何を                | どこ         | 目的                                           | 期間                                 |
| ------------------------------------------- | ------------------- | ------------ | ---------------------------------------------- | ------------------------------------ |
| [Request Memoization](#request-memoization) | 関数の戻り値        | サーバ       | Reactコンポーネントツリーでデータを再利用      | リクエストごと                       |
| [Data Cache](#data-cache)                   | データ              | サーバ       | ユーザーリクエストとデプロイ間でデータを保存   | 永続的（再検証可能）                 |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバ       | レンダリングコストを削減しパフォーマンスを向上 | 永続的（再検証可能）                 |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時のサーバリクエストを削減       | ユーザーセッションまたは時間に基づく |

デフォルトでは、Next.jsは可能な限りキャッシュしてパフォーマンスを向上させ、コストを削減します。つまり、ルートは**静的にレンダリング**され、データリクエストは**キャッシュ**されますが、オプトアウトしない限りです。以下の図は、ビルド時と静的ルートが初めて訪問されたときに、ルートが静的にレンダリングされるデフォルトのキャッシュ動作を示しています。

<Image
  alt="Next.jsのデフォルトのキャッシュ動作を示す図。ビルド時とルートが初めて訪問されたときのHIT、MISS、SETを含む4つのメカニズム。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシュ動作は、ルートが静的または動的にレンダリングされるかどうか、データがキャッシュされているかどうか、リクエストが初訪問またはナビゲーションの一部であるかどうかに応じて変わります。ユースケースに応じて、個々のルートとデータリクエストのキャッシュ動作を設定することができます。

## リクエストメモ化 {#request-memoization}

Reactは[`fetch` API](#fetch)を拡張して、同じURLとオプションを持つリクエストを自動で**メモ化**します。これにより、Reactコンポーネントツリーの複数の場所で同じデータのfetch関数を呼び出しても、実行は1回だけになります。

<Image
  alt="メモ化されたFetchリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

例えば、ルート全体で同じデータを使用する必要がある場合（例：Layout、Page、複数のコンポーネント）、ツリーの上部でデータをフェッチし、コンポーネント間でpropsを渡す必要はありません。代わりに、必要なコンポーネントでデータをフェッチし、同じデータに対してネットワーク上で複数のリクエストを行うことによるパフォーマンスへの影響を心配する必要はありません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動でメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、初回のみ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動でメモ化され、結果はキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、初回のみ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**リクエストメモ化の仕組み**

<Image
  alt="Reactレンダリング中にfetchのメモ化がどのように機能するかを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングする際、特定のリクエストを初めて呼び出すとき、その結果はメモリに存在せず、キャッシュ `MISS` になります。
- したがって、関数は実行され、外部ソースからデータがフェッチされ、結果がメモリに保存されます。
- 同じレンダリングパス内でそのリクエストの後続の関数呼び出しはキャッシュ `HIT` となり、データは関数を実行せずにメモリから返されます。
- ルートがレンダリングされてレンダリングパスが完了すると、メモリは「リセット」され、すべてのリクエストメモ化エントリーがクリアされます。

> **Good to know**:
>
> - リクエストメモ化はReactの機能であり、Next.jsの機能ではありません。ここで他のキャッシュメカニズムとどのように相互作用するかを示すために含まれています。
> - メモ化は`fetch`リクエストの`GET`メソッドにのみ適用されます。
> - メモ化はReactコンポーネントツリーにのみ適用されます。つまり：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、その他のServer Componentsでの`fetch`リクエストに適用されます。
>   - Route Handlersでの`fetch`リクエストには適用されません。これらはReactコンポーネントツリーの一部ではないためです。
> - `fetch`が適さないケース（例：いくつかのデータベースクライアント、CMSクライアント、GraphQLクライアント）では、[Reactの`cache`関数](#react-cache-function)を使って関数をメモ化することができます。

### 期間 {#duration}

キャッシュはサーバリクエストのライフタイムの間持続し、Reactコンポーネントツリーのレンダリングが完了するまで続きます。

### 再検証 {#revalidating}

メモ化はサーバリクエスト間で共有されず、レンダリング中にのみ適用されるため、再検証する必要はありません。

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、他のメソッド（例：`POST`や`DELETE`）はメモ化されません。このデフォルトの動作はReactの最適化であり、これをオプトアウトすることは推奨されません。

個々のリクエストを管理するために[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)の[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用することができます。ただし、これはメモ化からリクエストをオプトアウトするのではなく、進行中のリクエストを中止します。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには、**永続的に**データフェッチの結果を保存するための組み込みのData Cacheがあります。これは、Next.jsがネイティブの`fetch` APIを拡張し、サーバー側のリクエストごとに独自の永続的なキャッシングセマンティクスを設定できるようにしているため可能です。

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、`cache`オプションはサーバー側のリクエストがサーバーのData Cacheとどのように相互作用するかを示します。

`fetch`の[`cache`](#fetch-optionscache)オプションと[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシング動作を設定できます。

**Data Cacheの仕組み**

<Image
  alt="キャッシュされたfetchリクエストとキャッシュされていないfetchリクエストがData Cacheとどのように相互作用するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化され、キャッシュされていないリクエストはデータソースからフェッチされ、Data Cacheには保存されず、メモ化されます。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- `fetch`リクエストに`'force-cache'`オプションが指定されていて、レンダリング中に初めて呼び出されたとき、Next.jsはData Cacheにキャッシュされた応答があるかどうかを確認します。
- キャッシュされた応答が見つかると、即座に返され、[メモ化](#request-memoization)されます。
- キャッシュされた応答が見つからない場合、リクエストはデータソースに対して行われ、その結果がData Cacheに保存され、メモ化されます。
- キャッシュされていないデータ（例：`cache`オプションが定義されていない、または`{ cache: 'no-store' }`を使用している場合）については、結果は常にデータソースからフェッチされ、メモ化されます。
- データがキャッシュされているかどうかにかかわらず、リクエストは常にメモ化され、Reactレンダー中に重複したリクエストを避けるために同じデータが再リクエストされることはありません。

> **Data Cacheとリクエストメモ化の違い**
>
> 両方のキャッシュ機構は、キャッシュされたデータを再利用することでパフォーマンスを向上させますが、Data Cacheはサーバリクエストとデプロイ間で永続的であるのに対し、メモ化はリクエストの寿命だけ持続します。

### 持続期間 {#duration}

Data Cacheは、再検証したりオプトアウトしたりしない限り、サーバリクエストとデプロイ間で永続します。

### 再検証 {#revalidating}

キャッシュされたデータは次の方法で再検証できます：

- **時間ベースの再検証**：一定期間経過後、新しいリクエストが行われたときにデータを再検証します。これは、データがあまり頻繁に変更されず、新鮮さがそれほど重要でない場合に便利です。
- **オンデマンドの再検証**：イベント（例：フォーム送信）に基づいてデータを再検証します。オンデマンドの再検証は、タグベースまたはパスベースのアプローチを使用してデータのグループを一度に再検証できます。これは、ヘッドレスCMSからコンテンツが更新された場合などに、最新版のデータをできるだけ早く表示する必要があるときに便利です。

#### 時間ベースの再検証 {#time-based-revalidation}

リソースのキャッシュライフタイム（秒単位）を設定するために、`fetch`の`next.revalidate`オプションを使用して、一定の間隔でデータを再検証できます。

```js
// 最大1時間ごとに再検証する
fetch('https://...', { next: { revalidate: 3600 } })
```

または、Route Segment Configオプションを使用してセグメントのすべての`fetch`リクエストを設定するか、`fetch`を使用できない場合にセグメント全体に適用することができます。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証の仕組みを示す図。再検証期間後、最初のリクエストでは古いデータが返され、その後データが再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`付きのfetchリクエストが最初に呼び出されると、外部データソースからデータがフェッチされ、Data Cacheに保存されます。
- 指定された時間枠内（例：60秒）に行われたリクエストは、キャッシュされたデータを返します。
- 時間枠が終了すると、次のリクエストはキャッシュされた（現在は古い）データを返したままです。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データが正常にフェッチされると、Next.jsは新しいデータでData Cacheを更新します。
  - バックグラウンド再検証が失敗した場合、前のデータは保持され変更されません。

これは、[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)動作に似ています。

#### オンデマンドの再検証 {#on-demand-revalidation}

データは、パスごとに([`revalidatePath`](#revalidatepath))またはキャッシュタグによって([`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag))、オンデマンドで再検証できます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証の仕組みを示す図。再検証リクエスト後、Data Cacheが新しいデータで更新される。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼び出されると、外部データソースからデータがフェッチされ、Data Cacheに保存されます。
- オンデマンド再検証がトリガーされると、適切なキャッシュエントリがキャッシュから削除されます。
  - これは、古いデータが新しいデータがフェッチされるまでキャッシュに保持される時間ベースの再検証とは異なります。
- 次にリクエストが行われると、再びキャッシュ`MISS`となり、外部データソースからデータがフェッチされ、Data Cacheに保存されます。

### オプトアウト {#opting-out}

`fetch`からの応答をキャッシュしたくない場合は、次のようにします：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**：
>
> **Automatic Static Optimization**、**Static Site Generation**、または**Static Rendering**という用語が、アプリケーションのルートをビルド時にレンダリングしキャッシュするプロセスを指すために使われることがあります。

Next.jsはビルド時にルートを自動的にレンダリングし、キャッシュします。これは、すべてのリクエストに対してサーバーでレンダリングする代わりに、キャッシュされたルートを提供することを可能にする最適化であり、その結果、ページの読み込みが速くなります。

Full Route Cacheの仕組みを理解するためには、Reactがレンダリングをどのように処理しているか、そしてNext.jsがその結果をどのようにキャッシュしているかを見ることが役立ちます：

### 1. サーバーでのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は個々のルートセグメントとsuspense boundaryによるチャンクに分割されます。

各チャンクは2つのステップでレンダリングされます：

1. Reactはサーバコンポーネントをストリーミングに最適化された特別なデータフォーマット、**Reactサーバコンポーネントペイロード**にレンダリングします。
2. Next.jsはReactサーバコンポーネントペイロードとクライアントコンポーネントJavaScript命令を使用して、サーバー上で**HTML**をレンダリングします。

これにより、すべてがレンダリングされるのを待たずに作業をキャッシュまたは応答を送信できます。代わりに、作業が完了するにつれて応答をストリーミングできます。

> **Reactサーバコンポーネントペイロードとは何ですか？**
>
> Reactサーバコンポーネントペイロードは、レンダリングされたReact server component treeのコンパクトなバイナリ表現です。これはReactによってクライアント上でブラウザのDOMを更新するために使用されます。Reactサーバコンポーネントペイロードには以下が含まれます：
>
> - サーバコンポーネントのレンダリング結果
> - クライアントコンポーネントがレンダリングされるべき場所のプレースホルダーと、それらのJavaScriptファイルへの参照
> - サーバコンポーネントからクライアントコンポーネントに渡されたprops
>
> 詳細については、[Server Components](/docs/app/building-your-application/rendering/server-components)ドキュメントを参照してください。

### 2. サーバーでのNext.jsキャッシュ（フルルートキャッシュ） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="Next.jsのデフォルトのフルルートキャッシュの動作を示し、サーバー上で静的にレンダリングされたルートのためにReactサーバコンポーネントペイロードとHTMLがキャッシュされていることを示す図。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの動作は、サーバー上でルートのレンダリング結果（ReactサーバコンポーネントペイロードとHTML）をキャッシュすることです。これは静的にレンダリングされたルートと関係していて、ビルド時や再検証中に適用されます。

### 3. ClientでのReactハイドレーションと調和 {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時に、クライアント上で：

1. HTMLはクライアントとサーバコンポーネントの非インタラクティブな初期プレビューを即座に表示するために使用されます。
2. Reactサーバコンポーネントペイロードはクライアントとレンダリングされたサーバコンポーネントツリーを調和させ、DOMを更新するために使用されます。
3. JavaScript命令はクライアントコンポーネントを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにするために使用されます。

### 4. クライアント上でのNext.jsキャッシュ（ルーターキャッシュ） {#4-next-js-caching-on-the-client-router-cache}

Reactサーバコンポーネントペイロードはクライアントサイドの[Router Cache](#client-side-router-cache)に保存されます。これは個々のルートセグメントで分割された別のインメモリキャッシュです。このRouter Cacheは、以前に訪れたルートを保存し、将来訪れる可能性のあるルートをプレフェッチすることでナビゲーション体験を向上させるために使用されます。

### 5. その後のナビゲーション {#5-subsequent-navigations}

その後のナビゲーションやプレフェッチ中に、Next.jsはReactサーバコンポーネントペイロードがRouter Cacheに保存されているかどうかを確認します。保存されている場合、新しいリクエストをサーバーに送信することをスキップします。

ルートセグメントがキャッシュされていない場合、Next.jsはサーバーからReactサーバコンポーネントペイロードをフェッチし、クライアントのRouter Cacheに保存します。

### 静的レンダリングと動的レンダリング {#static-and-dynamic-rendering}

ルートがビルド時にキャッシュされるかどうかは、それが静的または動的にレンダリングされるかどうかによります。静的ルートはデフォルトでキャッシュされますが、動的ルートはリクエスト時にレ renderされ、キャッシュされません。

この図は、静的レンダリングと動的レンダリングの違いを、キャッシュされたデータとキャッシュされていないデータで示しています：

<Image
  alt="静的レンダリングと動的レンダリングがフルルートキャッシュにどのように影響するかを示す図。静的ルートはビルド時やデータ再検証後にキャッシュされるが、動的ルートはキャッシュされない。"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的レンダリングと動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学ぶ。

### 持続期間 {#duration}

デフォルトでは、フルルートキャッシュは永続的です。これは、レンダリングの出力がユーザーリクエストを超えてキャッシュされることを意味します。

### 無効化 {#invalidation}

フルルートキャッシュを無効化する方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)を再検証することで、Router Cacheを無効化し、サーバー上でコンポーネントを再レンダリングし、新しいレンダリング出力をキャッシュします。
- **再デプロイ**: Data Cacheとは異なり、フルルートキャッシュは新しいデプロイメントでクリアされます。

### オプトアウト {#opting-out}

フルルートキャッシュをオプトアウトするか、言い換えれば、すべてのインカミングリクエストに対してコンポーネントを動的にレンダリングするには：

- **[Dynamic API](#dynamic-apis)を使うこと**: これにより、ルートはフルルートキャッシュからオプトアウトし、リクエスト時に動的にレンダリングされます。Data Cacheはまだ使用できます。
- **`dynamic = 'force-dynamic'` または `revalidate = 0`のルートセグメントコンフィグオプションを使用すること**: これにより、フルルートキャッシュとData Cacheをスキップします。つまり、コンポーネントはサーバへのすべてのインカミングリクエストに対してレンダリングされ、データがフェッチされます。Router Cacheは、クライアントサイドのキャッシュであるため、依然として適用されます。
- **[Data Cache](#data-cache)からオプトアウトすること**: ルートがキャッシュされていない`fetch`リクエストを持っている場合、これはフルルートキャッシュからルートをオプトアウトします。特定の`fetch`リクエストのデータは、すべてのインカミングリクエストに対してフェッチされます。他のキャッシュをオプトアウトしていない`fetch`リクエストは、まだData Cacheにキャッシュされます。これにより、キャッシュされたデータとキャッシュされていないデータのハイブリッドが可能になります。

## クライアントサイドRouter Cache {#client-side-router-cache}

Next.jsは、レイアウト、ローディング状態、およびページで分割されたルートセグメントのRSCペイロードを保存するメモリ内のクライアントサイドルータキャッシュを持っています。

ユーザーがルート間をナビゲートするとき、Next.jsは訪れたルートのセグメントをキャッシュし、ユーザーがナビゲートする可能性が高いルートを[プレフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、インスタントのバック/フォワードナビゲーションが可能になり、ナビゲーション間でのフルページのリロードがなく、React状態とブラウザ状態が保持されます。

Router Cacheでは：

- **レイアウト**は再利用され、新しいナビゲーションで使用されます（[部分的レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）。
- **ローディング状態**は、[インスタントナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のために、新しいナビゲーションでキャッシュされ、再利用されます。
- **ページ**はデフォルトではキャッシュされませんが、ブラウザの後退および前進ナビゲーション中は再利用されます。ページセグメントのキャッシュを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)コンフィグオプションを使用できます。

{/* TODO: Update diagram to match v15 behavior */}

> **Good to know**: このキャッシュはNext.jsとサーバコンポーネントに専用のものであり、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、同様の結果をもたらします。

### 持続期間 {#duration}

キャッシュはブラウザの一時メモリに保存されます。ルータキャッシュの期間を決定する要素は2つあります：

- **セッション**：キャッシュはナビゲーション中に持続します。ただし、ページをリフレッシュするとクリアされます。
- **自動無効化期間**：レイアウトとローディング状態のキャッシュは、特定の時間が経過すると自動的に無効化されます。この期間は、リソースがどのように[プレフェッチ](/docs/app/api-reference/components/link#prefetch)されたか、またリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されていたかによって異なります：
  - **デフォルトのプレフェッチ**（`prefetch={null}`または指定なし）：動的ページにはキャッシュされず、静的ページには5分間。
  - **完全なプレフェッチ**（`prefetch={true}`または`router.prefetch`）：静的＆動的ページの両方で5分間。

ページリフレッシュで**すべての**キャッシュされたセグメントがクリアされますが、自動無効化期間はプレフェッチされた時点から個々のセグメントにのみ影響します。

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用して、上記の自動無効化時間を調整することができます。

### 無効化 {#invalidation}

Router Cacheを無効化する方法は2つあります：

- **Server Action**内で：
  - パスでデータをオンデマンドで再検証することで（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)）またはキャッシュタグで（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用すると、クッキーを使用するルートが古くならないようにRouter Cacheが無効化されます（例：認証）。
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すことでRouter Cacheを無効化し、現在のルートのためにサーバに新しいリクエストを作成します。

### オプトアウト {#opting-out}

Next.js 15以降、ページセグメントはデフォルトでオプトアウトされています。

> **Good to know**: `<Link>`コンポーネントの`prefetch`プロパティを`false`に設定することで、[プレフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)をオプトアウトすることもできます。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシュメカニズムを設定するとき、それらがどのように相互作用するかを理解することが重要です：

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheを再検証するかオプトアウトすることは、Full Route Cacheを無効化します。これは、レンダリング結果がデータに依存するためです。
- Full Route Cacheを無効化またはオプトアウトすることは、Data Cacheには影響しません。キャッシュされたデータとキャッシュされていないデータを持つルートを動的にレンダリングできます。これは、ページのほとんどがキャッシュされたデータを使用しているが、一部のコンポーネントがリクエスト時にフェッチする必要のあるデータに依存している場合に便利です。すべてのデータを再フェッチするパフォーマンスへの影響を心配せずに動的にレンダリングできます。

### Data CacheとClient-side Router Cache {#data-cache-and-client-side-router-cache}

- データキャッシュとルータキャッシュを即座に無効化するには、[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で`revalidatePath`または`revalidateTag`を使用できます。
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証することは、Route Handlerが特定のルートに結びついていないため、Router Cacheを即座に無効化すること**はありません**。つまり、Router Cacheは、ハードリフレッシュまたは自動無効化期間が経過するまで、以前のペイロードを提供し続けます。

## API {#apis}

次の表は、異なるNext.js APIがキャッシュにどのように影響するかの概要を示しています：

| API                                                                     | Router Cache           | Full Route Cache             | Data Cache                   | React Cache |
| ----------------------------------------------------------------------- | ---------------------- | ---------------------------- | ---------------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | キャッシュ             |                              |                              |             |
| [`router.prefetch`](#routerprefetch)                                    | キャッシュ             |                              |                              |             |
| [`router.refresh`](#routerrefresh)                                      | 再検証                 |                              |                              |             |
| [`fetch`](#fetch)                                                       |                        |                              | キャッシュ                   | キャッシュ  |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                        |                              | キャッシュまたはオプトアウト |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                        | 再検証                       | 再検証                       |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                        | キャッシュ                   | キャッシュ                   |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | 再検証 (Server Action) | 再検証                       | 再検証                       |             |
| [`revalidatePath`](#revalidatepath)                                     | 再検証 (Server Action) | 再検証                       | 再検証                       |             |
| [`const revalidate`](#segment-config-options)                           |                        | 再検証またはオプトアウト     | 再検証またはオプトアウト     |             |
| [`const dynamic`](#segment-config-options)                              |                        | キャッシュまたはオプトアウト | キャッシュまたはオプトアウト |             |
| [`cookies`](#cookies)                                                   | 再検証 (Server Action) | オプトアウト                 |                              |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                        | オプトアウト                 |                              |             |
| [`generateStaticParams`](#generatestaticparams)                         |                        | キャッシュ                   |                              |             |
| [`React.cache`](#react-cache-function)                                  |                        |                              |                              | キャッシュ  |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                        |                              | キャッシュ                   |             |

### `<Link>` {#link}

デフォルトでは、`<Link>`コンポーネントはルートをフルルートキャッシュから自動的にプレフェッチし、Reactサーバコンポーネントペイロードをルータキャッシュに追加します。

プレフェッチを無効にするには、`prefetch`プロパティを`false`に設定します。ただし、これによりルートは永久にキャッシュされないわけではありません。ルートセグメントはユーザーがルートを訪れるとクライアントサイドでキャッシュされ続けます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しく学ぶ。

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使用して、ルートを手動でプレフェッチできます。これにより、Reactサーバコンポーネントペイロードがルータキャッシュに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを参照してください。

### `router.refresh` {#router-refresh}

`refresh`のオプションは、`useRouter`フックを使用してルートを手動で更新するために使用できます。これにより、Router Cacheが完全にクリアされ、現在のルートに対してサーバーに新しいリクエストが作成されます。`refresh`はData CacheまたはFull Route Cacheに影響を与えません。

レンダリングされた結果は、React状態とブラウザ状態を保持しながらクライアントで調和されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを参照してください。

### `fetch` {#fetch}

`fetch`から返されたデータはData Cacheに自動的にキャッシュされ**ません**。

`fetch`のデフォルトのキャッシング動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定したときと同じです：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` API Reference](/docs/app/api-reference/functions/fetch)のその他のオプションを参照してください。

### `fetch options.cache` {#fetch-options-cache}

個々の`fetch`をキャッシュにオプトインするには、`cache`オプションを`force-cache`に設定します：

```jsx
// キャッシュにオプトインします。
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` API Reference](/docs/app/api-reference/functions/fetch)のその他のオプションを参照してください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

個々の`fetch`リクエストの再検証期間（秒単位）を設定するには、`fetch`の`next.revalidate`オプションを使用できます。これによりData Cacheが再検証され、結果としてフルルートキャッシュが再検証されます。新鮮なデータがフェッチされ、コンポーネントがサーバー上で再レンダリングされます。

```jsx
// 最大1時間ごとに再検証します。
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` API reference](/docs/app/api-reference/functions/fetch)のその他のオプションを参照してください。

### `fetch options.next.tags` and `revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsは、きめ細かいデータキャッシングおよび再検証のためのキャッシュタグシステムを持っています。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用するとき、キャッシュエントリを1つ以上のタグでタグ付けするオプションがあります。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられているキャッシュエントリを削除できます。

例えば、データをフェッチする際にタグを設定します：

```jsx
// データをタグでキャッシュします。
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

その後、タグを使用して`revalidateTag`を呼び出してキャッシュエントリを削除します：

```jsx
// 特定のタグでエントリを再検証します。
revalidateTag('a')
```

`revalidateTag`を使用できる場所は次の2箇所で、達成しようとしているものによります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：ウェブフック）に応答してデータを再検証します。これは、Router Handlerが特定のルートに結びついていないため、即座にRouter Cacheを無効にすることはありません。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション（例：フォーム送信）後のデータを再検証します。これは、関連するルートのRouter Cacheを無効にします。

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、単一の操作で特定のパス以下のルートセグメントを**再レンダリング**し、データを手動で再検証できます。`revalidatePath`メソッドを呼び出すことで、Data Cacheが再検証され、フルルートキャッシュが無効になります。

```jsx
revalidatePath('/')
```

`revalidatePath`を使用できる場所は次の2箇所で、達成しようとしているものによります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：ウェブフック）に応答してデータを再検証します。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション（例：フォーム送信、ボタンをクリック）後のデータを再検証します。

[`revalidatePath` API reference](/docs/app/api-reference/functions/revalidatePath)を参照して詳細を確認してください。

> **`revalidatePath`** 対 **`router.refresh`**:
>
> `router.refresh`を呼び出すと、Routerキャッシュがクリアされ、データキャッシュやフルルートキャッシュを無効にすることなくサーバー上でルートセグメントが再レンダリングされます。
>
> 違いは、`revalidatePath`がData Cacheとフルルートキャッシュを削除するのに対し、`router.refresh()`はData Cacheとフルルートキャッシュを変更しないことです。これはクライアントサイドのAPIであるためです。

### Dynamic APIs {#dynamic-apis}

`cookies`や`headers`、Pagesの`searchParams`プロップを持つ動的APIは、ランタイムのインカミングリクエスト情報に依存します。これらを使用すると、ルートはフルルートキャッシュからオプトアウトされ、動的にレンダリングされます。

#### `cookies` {#cookies}

Server Action内で`cookies.set`や`cookies.delete`を使用することで、クッキーを反映するためにルートが古くなるのを防ぐためにRouter Cacheが無効化されます（例：認証の変更を反映）。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照してください。

### Segment Config Options {#segment-config-options}

Route Segment Configオプションを使用して、ルートセグメントのデフォルトをオーバーライドするか、`fetch` APIを使用できない場合（例：データベースクライアントやサードパーティライブラリ）に設定します。

次のRoute Segment Configのオプションを使用すると、フルルートキャッシュからオプトアウトします：

- `const dynamic = 'force-dynamic'`

このコンフィグオプションはすべてのフェッチをData Cacheからオプトアウトさせます（つまり、`no-store`）：

- `const fetchCache = 'default-no-store'`

より高度なオプションを参照するには、[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)を参照してください。

詳しいオプションについては、[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントを参照してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）には、`generateStaticParams`で提供されるパスは、ビルド時にフルルートキャッシュにキャッシュされます。リクエスト時に、Next.jsは最初に訪れたときにビルド時に知られていなかったパスもキャッシュします。

すべてのパスをビルド時に静的にレンダリングするには、`generateStaticParams`にパスの完全なリストを提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスのサブセットを静的にレンダリングし、その他のパスをランタイムで最初に訪れたときにレンダリングするには、部分的なリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10件だけをビルド時にレンダリングします
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時に全てのパスをレンダリングしない場合や、最初に訪れたときに全てのパスを静的にレンダリングする場合、空の配列を返す（ビルド時にパスはレンダリングされません）か、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`からは、空であっても必ず配列を返す必要があります。それ以外の場合、ルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時のキャッシングを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。このコンフィグオプションが使用される場合、`generateStaticParams`で提供されたパスのみが提供され、他のルートは404になるか（[catch-allサイト](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合と同様）、一致します。

### React `cache` 関数 {#react-cache-function}

Reactの`cache`関数を使用すると、関数の戻り値をメモ化することができ、同じ関数を複数回呼び出しても、実行は1回だけになります。

`fetch`リクエストは自動的にメモ化されるため、Reactの`cache`でラップする必要はありません。しかし、`fetch` APIが適さないユースケース（例：いくつかのデータベースクライアント、CMSクライアント、GraphQLクライアント）では、データリクエストを手動でメモ化するために`cache`を使用することができます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
