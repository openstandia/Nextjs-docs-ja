---
title: 'Next.jsにおけるキャッシュ'
nav_title: 'キャッシュ'
description: 'Next.jsにおけるキャッシュのメカニズムの概要。'
---

Next.jsは、レンダリング作業やデータリクエストをキャッシュすることで、アプリケーションのパフォーマンスを向上し、コストを削減します。このページでは、Next.jsのキャッシュメカニズム、設定に使用できるAPI、各メカニズムの相互連携について詳しく説明します。

> **知っておくと良いこと**: このページは、Next.jsの内部動作を理解するのに役立ちますが、Next.jsを生産的に使うための必須知識では**ありません**。Next.jsのキャッシュヒューリスティックは、主にAPIの使用方法によって決定され、ほとんどの場合ゼロまたは最小限の設定で最適なパフォーマンスを得られるようになっています。代わりに例を見たい場合は、[こちらから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

以下は、さまざまなキャッシュメカニズムとその目的の概要です。

| メカニズム                                  | 内容                    | 場所         | 目的                                               | 期間                             |
| ------------------------------------------- | ----------------------- | ------------ | -------------------------------------------------- | -------------------------------- |
| [Request Memoization](#request-memoization) | 関数の戻り値            | サーバー     | React Component treeでデータを再利用               | リクエストライフサイクルの間     |
| [Data Cache](#data-cache)                   | データ                  | サーバー     | ユーザーリクエストやデプロイをまたいでデータを保存 | 永続的（再検証可能）             |
| [Full Route Cache](#full-route-cache)       | HTMLおよびRSCペイロード | サーバー     | レンダリングコストの削減とパフォーマンス向上       | 永続的（再検証可能）             |
| [Router Cache](#client-side-router-cache)   | RSCペイロード           | クライアント | ナビゲーション時のサーバーリクエスト削減           | ユーザーセッションまたは時間基準 |

デフォルトで、Next.jsはパフォーマンスを向上し、コストを削減するために可能な限りキャッシュします。つまり、ルートは**静的にレンダリング**され、データリクエストは**キャッシュされます**が、オプトアウトしない限りデフォルトのキャッシュ動作の状態を維持します。下の図は、ビルド時にルートが静的にレンダリングされ、静的ルートが初めてアクセスされたときのデフォルトのキャッシュ動作を示しています。

<Image
  alt="Next.jsでの4つのメカニズムのデフォルトのキャッシュ動作を示す図。ビルド時とルートが初めて訪問された時のHIT、MISS、SET。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシングの動作は、ルートが静的にレンダリングされるか動的にレンダリングされるか、データがキャッシュされているかされていないか、リクエストが初回訪問の一部であるかそれ以降のナビゲーションの一部であるかによって変わります。ケースによっては、個々のルートおよびデータリクエストのキャッシュ動作を構成できます。

## Request Memoization {#request-memoization}

Reactは、URLとオプションが同じリクエストを自動的に**メモ化**するように[`fetch` API](#fetch)を拡張します。これは、React component tree内の複数の場所で同じデータに対してfetch関数を呼び出せる一方で、1度だけ実行されることを意味します。

<Image
  alt="重複除去されたFetchリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

たとえば、ルート全体で同じデータを使用する必要がある場合（例：Layout、Page、および複数のコンポーネント）、ツリーのトップでデータをfetchし、コンポーネント間でpropsを渡す必要はありません。その代わり、必要なコンポーネントでデータをfetchし、同じデータのために複数のネットワークリクエストを作成するパフォーマンスへの影響を考慮する必要はありません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果がキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初にのみ実行されます
const item = await getItem() // cache MISS

// 2番目の呼び出しはルート内のどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果がキャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初にのみ実行されます
const item = await getItem() // cache MISS

// 2番目の呼び出しはルート内のどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoizationの仕組み**

<Image
  alt="Reactレンダリング中のfetchメモ化の仕組みを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングする際、特定のリクエストが初めて呼び出された場合、その結果はメモリに存在せず、キャッシュ`MISS`となります。
- したがって、関数が実行され、データが外部ソースから取得され、その結果はメモリに保存されます。
- 同じレンダーパス内で同じリクエストの後続の関数呼び出しはキャッシュ`HIT`となり、関数を実行することなくメモリからデータが返されます。
- ルートがレンダリングされ、レンダリングパスが完了した後、メモリは「リセット」され、すべてのリクエストメモ化エントリがクリアされます。

> **知っておくと良いこと**:
>
> - Request memoizationはReactの機能であり、Next.jsの機能ではありません。他のキャッシングメカニズムとの相互作用を示すためにここに含まれています。
> - メモ化は`GET`メソッドの`fetch`リクエストにのみ適用されます。
> - メモ化はReact Component treeにのみ適用されます。つまり:
>   - `fetch`リクエストは`generateMetadata`、`generateStaticParams`、Layouts、Pages、およびその他のServer Componentsに適用されます。
>   - Route Handlersの`fetch`リクエストには適用されません。これらはReact component treeの一部ではありません。
> - `fetch`が適さない場合（例: 一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）、[React `cache`関数](#react-cache-function)を使用して関数をメモ化できます。

### 期間 {#duration}

キャッシュは、サーバーリクエストのライフタイム、React componente treeのレンダリングが終了するまで持続します。

### 再検証 {#revalidating}

メモ化はサーバーリクエストをまたいで共有されず、レンダリング中にのみ適用されるため、それを再検証する必要はありません。

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、`POST`や`DELETE`などの他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、これからのオプトアウトを推奨しません。

個々のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)から[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これはリクエストのメモ化をオプトアウトするのではなく、飛行中のリクエストを中止することになります。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには、データフェッチの結果を**保持**する組み込みのData Cacheがあります。**サーバーリクエスト**または**デプロイ**をまたいで保持します。これは、Next.jsがネイティブの`fetch` APIを拡張して、サーバーの各リクエストが独自の永続的なキャッシングセマンティクスを設定できるようにすることによって実現されています。

> **知っておくと良いこと**: ブラウザでは、`fetch`の`cache`オプションがリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、`cache`オプションがサーバー側のリクエストがサーバーのData Cacheとどのように相互作用するかを示します。

`fetch`の[`cache`](#fetch-optionscache)と[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシュ動作を構成できます。

**Data Cacheの仕組み**

<Image
  alt="Data Cacheとキャッシュされていないfetchリクエストがどのように相互作用するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化され、キャッシュされていないリクエストはデータソースから取得され、Data Cacheに保存されず、メモ化されます。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- `'force-cache'`オプション付きの`fetch`リクエストがレンダリング中に初めて呼び出された場合、Next.jsはData Cacheにキャッシュされたレスポンスを探します。
- キャッシュされたレスポンスが見つかった場合、それはすぐに返され、[メモ化されます](#request-memoization)。
- キャッシュされたレスポンスが見つからない場合、リクエストはデータソースに送信され、その結果がData Cacheに保存され、メモ化されます。
- キャッシュされていないデータ（例: `cache`オプションが定義されていない、または`{ cache: 'no-store' }`を使用している場合）、結果は常にデータソースから取得され、メモ化されます。
- データがキャッシュされているかされていないかに関係なく、リクエストは常にメモ化され、Reactのレンダリングパス中に同じデータのための重複リクエストを避けるようにします。

> **Data CacheとRequest Memoizationの違い**
>
> どちらのキャッシングメカニズムもキャッシュされたデータの再利用によってパフォーマンスを向上させるのに役立ちますが、Data Cacheはリクエストやデプロイをまたいで永続的であるのに対し、メモ化はリクエストの期間中のみ持続します。

### 期間 {#duration}

Data Cacheはリクエストをまたいで永続的です。再検証しない限り、またはオプトアウトする限り。

### 再検証 {#revalidating}

キャッシュされたデータは、以下の2つの方法で再検証できます。

- **時間に基づく再検証**：一定の時間が経過した後に新しいリクエストを行う際にデータを再検証します。これは変更が少ないデータや刷新性がそれほど重要でないデータに対して便利です。
- **オンデマンド再検証**：イベントに基づいてデータを再検証します（例：フォーム送信）。オンデマンド再検証は、タグベースまたはパスベースのアプローチを使用してデータのグループを一度に再検証できます。これは、ヘッドレスCMSからのコンテンツが更新されたときに最新のデータを可能な限り早く表示したい場合に便利です。

#### 時間に基づく再検証 {#time-based-revalidation}

定期的にデータを再検証するには、`fetch`の`next.revalidate`オプションを使用して、リソースのキャッシュ寿命（秒）を設定します。

```js
// 最大1時間ごとに再検証
fetch('https://...', { next: { revalidate: 3600 } })
```

または、[Route Segment Configオプション](#segment-config-options)を使用して、セグメント内のすべての`fetch`リクエストを設定するか、`fetch`が使用できない場合に利用可能です。

**時間に基づく再検証の仕組み**

<Image
  alt="時間に基づく再検証の仕組みを示す図。再検証期間後、最初のリクエストでは古いデータが返され、その後データが再検証される。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`を含むfetchリクエストが初めて呼び出されると、データは外部データソースから取得され、Data Cacheに保存されます。
- 指定された期間内（例: 60秒）に呼び出されたリクエストは、キャッシュされたデータを返します。
- 期間が経過した後、次のリクエストは依然として古い（期限切れ）データを返します。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データの取得が成功すると、Next.jsは新しいデータでData Cacheを更新します。
  - バックグラウンドでの再検証に失敗した場合、以前のデータはそのまま保持されます。

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)に似た動作です。

#### オンデマンド再検証 {#on-demand-revalidation}

データは、パス（[`revalidatePath`](#revalidatepath)）またはキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）によってオンデマンドで再検証できます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証の仕組みを示す図。再検証リクエスト後に新しいデータでData Cacheが更新される。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- 初めて`fetch`リクエストが呼び出されると、データは外部データソースから取得され、Data Cacheに保存されます。
- オンデマンド再検証がトリガーされると、適切なキャッシュエントリがキャッシュから削除されます。
  - これは、期間に基づく再検証とは異なり、新しいデータが取得されるまで古いデータをキャッシュに保持する再検証とは異なります。
- 次にリクエストが行われたとき、それは再びキャッシュ`MISS`となり、データは外部データソースから取得され、Data Cacheに保存されます。

### オプトアウト {#opting-out}

`fetch`からのレスポンスをキャッシュしたくない場合は、次のことができます。

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**:
>
> **Automatic Static Optimization**、**Static Site Generation**、および**Static Rendering**の用語が、アプリケーションのルートをビルド時にレンダリングおよびキャッシュするプロセスを指して互換的に使用される場合があります。

Next.jsは、自動的にルートをレンダリングし、ビルド時にキャッシュします。これは最適化であり、各リクエストごとにサーバーでレンダリングする代わりにキャッシュされたルートを提供することで、ページロードを高速化します。

Full Route Cacheの仕組みを理解するためには、Reactがレンダリングをどのように処理するか、およびNext.jsがどのように結果をキャッシュするかを見てみるのが役立ちます。

### 1. サーバーでのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上で、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントやSuspense境界によってチャンクに分割されます。

各チャンクは2つのステップでレンダリングされます。

1. ReactはServer Componentsをストリーミングに最適化された特殊なデータ形式、**React Server Component Payload**にレンダリングします。
2. Next.jsは、React Server Component PayloadおよびClient ComponentのJavaScript命令を使用して、サーバー上で**HTML**をレンダリングします。

これにより、すべてをレンダリングし終わるのを待つことなく作業をキャッシュしたり、レスポンスを送信することが可能になります。代わりに、作業が完了するごとに結果をストリームできます。

> **React Server Component Payloadとは**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。これはクライアントでReactがブラウザのDOMを更新するために使用されます。React Server Component Payloadには次のものが含まれます。
>
> - Server Componentsのレンダリングされた結果
> - Client Componentsがレンダリングされる場所のプレースホルダーとそれらのJavaScriptファイルへの参照
> - Server ComponentからClient Componentに渡されるprops
>
> 詳しくは、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントをご覧ください。

### 2. サーバーでのNext.jsキャッシュ（Full Route Cache） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="静的にレンダリングされたルートのサーバー上でReact Server Component PayloadとHTMLがキャッシュされるFull Route Cacheのデフォルト動作。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの動作は、ルートのレンダリング結果（React Server Component PayloadとHTML）をサーバーにキャッシュすることです。これは、ビルド時または再検証中に静的にレンダリングされるルートに適用されます。

### 3. クライアントでのReactのハイドレーションと和解 {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時、クライアントで次の手順が行われます。

1. HTMLは、クライアントとServer Componentsのインタラクティブではない初期プレビューを高速に表示するために使用されます。
2. React Server Components Payloadは、クライアントとレンダリングされたServer Component treesを調和し、DOMを更新するために使用されます。
3. JavaScript命令は、クライアントコンポーネントを[ハイドレーション](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにします。

### 4. クライアントでのNext.jsキャッシュ（Router Cache） {#4-next-js-caching-on-the-client-router-cache}

React Server Components Payloadは、ルートセグメントごとに分割されたクライアント側の[Router Cache](#client-side-router-cache)に保存されます。このRouter Cacheは、以前に訪問したルートを保存したり、将来のルートをプリフェッチすることで、ナビゲーション体験を向上させるために使用されます。

### 5. 後続のナビゲーション {#5-subsequent-navigations}

後続のナビゲーション時またはプリフェッチ中、Next.jsはReact Server Components PayloadがRouter Cacheに保存されているかを確認します。もしそうなら、新しいリクエストをサーバーに送信するのをスキップします。

ルートセグメントがキャッシュにない場合、Next.jsはReact Server Components Payloadをサーバーからフェッチし、クライアントのRouter Cacheを更新します。

### 静的レンダリングと動的レンダリング {#static-and-dynamic-rendering}

ルートがビルド時にキャッシュされるかどうかは、それが静的にレンダリングされるか動的にレンダリングされるかによります。静的ルートはデフォルトでキャッシュされ、動的ルートはリクエスト時にレンダリングされ、キャッシュされない。

この図は、キャッシュされたデータとキャッシュされていないデータを使用して、静的および動的にレンダリングされたルートの違いを示しています。

<Image
  alt="Full Route Cacheに影響を与える静的および動的レンダリング。静的ルートはビルド時またはデータ再検証後にキャッシュされ、動的ルートはキャッシュされない。"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的レンダリングと動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)の詳細を学びます。

### 期間 {#duration}

デフォルトで、Full Route Cacheは永続的です。つまり、レンダリング出力はユーザーリクエストをまたいでキャッシュされます。

### 無効化 {#invalidation}

Full Route Cacheを無効化する方法は2つあります。

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)を再検証することで、[Router Cache](#client-side-router-cache)を無効化し、サーバーでコンポーネントを再レンダリングし、新しいレンダリング結果をキャッシュします。
- **再デプロイ**: Data Cacheとは異なり、デプロイをまたいで永続するFull Route Cacheは、新しいデプロイ時にクリアされます。

### オプトアウト {#opting-out}

Full Route Cache、または別の言い方をすると、各リクエストごとに動的にコンポーネントをレンダリングすることからオプトアウトすることができます。

- **[Dynamic API](#dynamic-apis)を使用する**: これにより、ルートはFull Route Cacheからオプトアウトされ、リクエスト時に動的にレンダリングされます。Data Cacheは引き続き使用できます。
- **`dynamic = 'force-dynamic'`または`revalidate = 0`ルートセグメント構成オプションを使用する**: これにより、Full Route CacheとData Cacheをスキップします。つまり、すべての受信リクエストでコンポーネントがレンダリングされ、データがフェッチされます。ただし、Router Cacheはクライアント側のキャッシュであるため、依然として適用されます。
- **[Data Cache](#data-cache)からのオプトアウト**: `fetch`リクエストがキャッシュされないルートがある場合、このルートはFull Route Cacheからオプトアウトされます。特定の`fetch`リクエストのデータは、受信リクエストごとにフェッチされます。他のキャッシュからのオプトアウトを選択しない`fetch`リクエストは、Data Cacheにキャッシュされます。これにより、キャッシュされたデータとキャッシュされていないデータのハイブリッドが可能になります。

## クライアント側のRouter Cache {#client-side-router-cache}

Next.jsにはメモリ内のクライアント側ルーターキャッシュがあります。これは、レイアウト、読み込み状態、ページに分割されたルートセグメントのRSCペイロードを保存します。

ユーザーがルート間を移動するとき、Next.jsは訪れたルートセグメントをキャッシュし、ユーザーが移動する可能性のあるルートを[prefetch](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、瞬時の戻る/進むナビゲーションが行われ、ナビゲーション間でのフルページリロードがなく、Reactとブラウザの状態が保持されます。

Router Cacheの利用により:

- **Layouts**はキャッシュされ、[部分的なレンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)でナビゲーション時に再利用されます
- **読み込み状態**はキャッシュされ、ナビゲーション時に[瞬時のナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)用に再利用されます
- **Pages**はデフォルトではキャッシュされませんが、ブラウザの後方および前方のナビゲーション中に再利用されます。ページセグメントのキャッシングを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)構成オプションを使用します

{/* TODO: 図をv15の動作に合わせて更新する */}

> **知っておくと良いこと**: このキャッシュはNext.jsとServer Componentsに特有のものであり、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、類似した結果をもたらします

### 期間 {#duration}

キャッシュはブラウザの一時的なメモリに保存されます。Router Cacheの持続期間を決定する要素は2つあります。

- **セッション**: キャッシュはナビゲーション間で持続しますが、ページのリフレッシュ時にクリアされます
- **自動無効化期間**: レイアウトと読み込み状態のキャッシュは特定の時間の後に自動的に無効化されます。リソースが[プリフェッチ](/docs/app/api-reference/components/link#prefetch)された方法、そのリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかによって期間は決まります。
  - **デフォルトのプリフェッチ**（`prefetch={null}`または未指定）： 動的ページではキャッシュされず、静的ページでは5分間
  - **完全なプリフェッチ**（`prefetch={true}`または`router.prefetch`）： 静的および動的ページのどちらも5分間

ページのリフレッシュによりすべてのキャッシュされたセグメントが消去されますが、自動無効化期間はプリフェッチされたときからの個々のセグメントにのみ影響を与えます。

> **知っておくと良いこと**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)構成オプションを使用して、上記の自動無効化時間を調整できます。

### 無効化 {#invalidation}

Router Cacheを無効化する方法は2つあります。

- **Server Action**で:
  - パスによってオンデマンドでデータを再検証（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)）またはキャッシュタグで（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)の使用により、cookiesを使用するルートが古くならないようにRouter Cacheを無効化（例：認証）
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すことでRouter Cacheを無効化し、現在のルートのサーバーへの新しいリクエストを行います。

### オプトアウト {#opting-out}

Next.js 15以降、ページセグメントはデフォルトでオプトアウトされています。

> **知っておくと良いこと**: また、`prefetch`プロップを`<Link>`コンポーネントに対して`false`に設定することで、[prefetch](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)からもオプトアウトできます。

## キャッシュの相互作用 {#cache-interactions}

さまざまなキャッシュメカニズムを設定する際に、相互作用の仕方を理解することは重要です。

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheの再検証またはオプトアウトにより、レンダリング出力がデータに依存するため、Full Route Cacheを無効化します。
- Full Route Cacheの無効化またはオプトアウトは、Data Cacheには影響しません。キャッシュされたデータとキャッシュされていないデータの両方を持つ動的なルートをレンダリングすることができます。これはページのほとんどがキャッシュされたデータを使用し、一部のコンポーネントがリクエスト時にフェッチするデータに依存する場合に役立ちます。すべてのデータを再フェッチすることによるパフォーマンスの影響を気にせずに動的レンダリングが可能です。

### Data Cacheとクライアント側のRouter cache {#data-cache-and-client-side-router-cache}

- [Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用することでData CacheとRouter cacheをすぐに無効化できます。
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証しても、Router Cacheをすぐに無効化することはありません。Route Handlerは特定のルートに結び付いていません。これはハードリフレッシュまたは自動無効化期間が経過するまではRouter Cacheが以前のペイロードを提供し続けることを意味します。

## API {#apis}

次の表は、さまざまなNext.jsのAPIがキャッシングにどのように影響を与えるかの概要です。

| API                                                                     | Router Cache               | Full Route Cache      | Data Cache            | React Cache |
| ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | Cache                      |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                    | Cache                      |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                      | Revalidate                 |                       |                       |             |
| [`fetch`](#fetch)                                                       |                            |                       | Cache                 | Cache       |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                       | Cache or Opt out      |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Revalidate            | Revalidate            |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Cache                 | Cache                 |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`revalidatePath`](#revalidatepath)                                     | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`const revalidate`](#segment-config-options)                           |                            | Revalidate or Opt out | Revalidate or Opt out |             |
| [`const dynamic`](#segment-config-options)                              |                            | Cache or Opt out      | Cache or Opt out      |             |
| [`cookies`](#cookies)                                                   | Revalidate (Server Action) | Opt out               |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Opt out               |                       |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Cache                 |                       |             |
| [`React.cache`](#react-cache-function)                                  |                            |                       |                       | Cache       |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                       | Cache                 |             |

### `<Link>` {#link}

デフォルトで、`<Link>`コンポーネントはFull Route Cacheからのルートを自動的にプリフェッチし、React Server Component PayloadをRouter Cacheに追加します。

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定します。ただし、これによりキャッシュは恒久的にスキップされるわけではなく、ユーザーがルートを訪れるとクライアント側でルートセグメントがキャッシュされます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳細を学びます。

### `router.prefetch` {#router-prefetch}

`使用Router`フックの`prefetch`オプションは、ルートを手動でプリフェッチするために使用できます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを参照してください。

### `router.refresh` {#router-refresh}

`使用Router`フックの`refresh`オプションを使用して、ルートを手動で更新できます。これにより、Router Cacheが完全にクリアされ、現在のルートのサーバーへの新しいリクエストが行われます。`refresh`はDataまたはFull Route Cacheに影響を与えません。

レンダリングされた結果は、Reactとブラウザの状態を保持しながらクライアントで調和されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを参照してください。

### `fetch` {#fetch}

`fetch`から返されるデータは、Data Cacheに自動的にキャッシュされ**ません**。

`fetch`のデフォルトのキャッシュ動作（例：`cache`オプションが指定されていない場合）は`cache`オプションを`no-store`に設定した場合と等しいです。

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)でより多くのオプションをご覧ください。

### `fetch options.cache` {#fetch-options-cache}

個々の`fetch`を`force-cache`に設定してキャッシュにオプトインできます。

```jsx
// キャッシュにオプトイン
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)でより多くのオプションをご覧ください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

個々の`fetch`リクエストの再検証期間（秒）を設定するために、`fetch`の`next.revalidate`オプションを使用できます。これによりData Cacheが再検証され、同時にFull Route Cacheも再検証されます。新鮮なデータがフェッチされ、サーバーでコンポーネントが再レンダリングされます。

```jsx
// 最大1時間後に再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)でより多くのオプションをご覧ください。

### `fetch options.next.tags`と`revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、細粒度のデータキャッシュと再検証のためのキャッシュタグシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用する場合、キャッシュエントリに1つまたは複数のタグを設定するオプションがあります。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリを削除できます。

たとえば、データをフェッチする際にタグを設定できます。

```jsx
// データをタグでキャッシュ
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

次に、タグを指定してキャッシュエントリを削除するには、`revalidateTag`を呼び出します。

```jsx
// 特定のタグを含むエントリを再検証
revalidateTag('a')
```

`revalidateTag`を使用できる場所は、目的に応じて異なります。

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベントに応答してデータを再検証します（例：webhook）。Router Cacheはすぐに無効化されません。これは、Router Handlerが特定のルートに結びついていないためです。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション後にデータを再検証します（例：フォーム送信）。これにより、関連するルートのRouter Cacheが無効化されます。

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用して、特定のパス以下のルートセグメントを一度に再検証して再レンダリングできます。`revalidatePath`メソッドを呼び出すと、Data Cacheが再検証され、その結果、Full Route Cacheが無効化されます。

```jsx
revalidatePath('/')
```

`revalidatePath`を使用できる場所は、目的に応じて異なります。

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベントに応答してデータを再検証します（例：webhook）。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション後にデータを再検証します（例：フォーム送信、ボタンをクリック）。

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)で詳細をご覧ください。

> **`revalidatePath`** vs. **`router.refresh`**:
>
> `router.refresh`を呼び出すことで、Router cacheをクリアし、Data CacheやFull Route Cacheを無効化せずにサーバーでルートセグメントを再レンダリングできます。
>
> 違いは、`revalidatePath`がData CacheおよびFull Route Cacheを削除するのに対し、`router.refresh()`はData CacheおよびFull Route Cacheを変更しないという点です。これはクライアントサイドのAPIです。

### Dynamic APIs {#dynamic-apis}

`cookies`や`headers`、Pages内の`searchParams` propなどの動的APIは、ランタイムの受信リクエスト情報に依存しています。それらを使用すると、Full Route Cacheからオプトアウトされます。つまり、ルートは動的にレンダリングされます。

#### `cookies` {#cookies}

Server Action内で`cookies.set`または`cookies.delete`を使用すると、Router Cacheを無効化します。これにより、cookiesを使用するルートが古くならないようにします（例：認証の反映）。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照してください。

### Segment Config Options {#segment-config-options}

Route Segment Configオプションは、route segmentのデフォルトをオーバーライドしたり、`fetch` APIを使用できない場合（例: データベースクライアントまたはサードパーティライブラリ）に使用できます。

次のRoute Segment Configオプションは、Full Route Cacheからオプトアウトさせます。

- `const dynamic = 'force-dynamic'`

この設定オプションは、Data Cacheからすべてのフェッチをオプトアウト（例：`no-store`）します。

- `const fetchCache = 'default-no-store'`

到達可能なより高度なオプションについては[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)をご覧ください。

より多くのオプションについては、[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)のドキュメントを参照してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）の場合、`generateStaticParams`によって提供されるパスはビルド時にFull Route Cacheにキャッシュされます。またリクエスト時に、ビルド時に既知でなかったパスも初回アクセス時にキャッシュされます。

すべてのパスをビルド時に静的にレンダリングするには、`generateStaticParams`にフルパスリストを指定します。

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスのサブセットと、残りを実行時に初回アクセス時に静的にレンダリングするには、部分的なパスリストを返します。

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10個の投稿をビルド時にレンダリングします
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

最初の訪問時にすべてのパスを静的にレンダリングするには、空の配列（ビルド時にパスはレンダリングされません）を返すか、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します。

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **知っておくと良いこと**: `generateStaticParams`からは、たとえ空でも配列を返さなければなりません。そうしないと、ルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時にキャッシュを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。この設定オプションが使用されている場合、`generateStaticParams`によって提供されるパスのみが提供され、他のルートは404になったり一致する可能性があります（[catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）。

### React `cache` 関数 {#react-cache-function}

Reactの`cache`関数を使用すると、関数の戻り値をメモ化できます。これにより、同じ関数を複数回呼び出しつつも、1度しか実行されません。

`fetch`リクエストは自動的にメモ化されるため、Reactの`cache`でラップする必要はありません。ただし、`fetch` APIが適していないユースケースの場合、たとえば一部のデータベースクライアント、CMSクライアント、またはGraphQLクライントの場合にデータリクエストを手動でメモ化するために`cache`を使用できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
