---
title: 'Next.jsにおけるキャッシュ'
nav_title: 'キャッシュ'
description: 'Next.jsのキャッシュメカニズムに関する概観。'
---

Next.jsはレンダリング作業とデータ要求をキャッシュすることで、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシュメカニズムの詳細、設定に使用できるAPI、およびそれらの相互作用について説明します。

> **Good to know**: このページは、Next.jsの内部動作を理解するのに役立ちますが、生産的にNext.jsを使用するために必須の知識ではありません。Next.jsのキャッシュヒューリスティクスの大部分はAPIの使用により決定され、ゼロまたは最小限の設定で最高のパフォーマンスを提供するデフォルトを持っています。代わりに例を参照したい場合は、[ここから始めてください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

以下に、さまざまなキャッシュメカニズムとその目的の概要を示します：

| メカニズム                                  | 内容                | 場所         | 目的                                                   | 継続時間                           |
| ------------------------------------------- | ------------------- | ------------ | ------------------------------------------------------ | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の戻り値        | サーバー     | React Component treeでデータを再利用する               | リクエストライフサイクルごとに     |
| [Data Cache](#data-cache)                   | データ              | サーバー     | ユーザーリクエストとデプロイメント間でデータを保存する | 永続的（再検証可能）               |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバー     | レンダリングコストを削減し、パフォーマンスを向上させる | 永続的（再検証可能）               |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時のサーバーリクエストを削減する         | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsはパフォーマンスを向上させ、コストを削減するために可能な限り多くをキャッシュします。つまり、ルートは**静的にレンダリング**され、データリクエストは**キャッシュ**されますが、選択しない限り、選択解除されません。以下の図は、デフォルトのキャッシュ動作を示しています：ルートがビルド時に静的にレンダリングされる場合と、静的ルートが最初に訪問される場合。

<Image
  alt="Next.jsの4つのメカニズムにおけるデフォルトのキャッシュ動作を示す図。ビルド時とルートが最初に訪問されたときのHIT、MISSおよびSET。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシュ動作は、ルートが静的または動的にレンダリングされるかどうか、データがキャッシュされるかどうか、リクエストが初回訪問の一部かどうかによって変化します。ユースケースに応じて、個々のルートやデータリクエストのキャッシュ動作を設定できます。

## Request Memoization {#request-memoization}

Reactは、同じURLとオプションを持つリクエストを自動的に**メモ化**するように`fetch` APIを拡張しています。これにより、同じデータをReact component treeの複数の場所でFETCH関数を呼び出すときに、一度だけ実行されます。

<Image
  alt="重複排除されたFetchリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

例えば、ルート全体に同じデータを使用する必要がある場合（例：Layout、Page、および複数のコンポーネント内）、ツリーのトップでデータを取得し、コンポーネント間でpropsを転送する必要はありません。代わりに、必要なコンポーネントでデータを取得し、ネットワークを介した複数のデータリクエストのパフォーマンスへの影響を心配することなくデータを使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch` 関数は自動的にメモ化され、その結果が
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回のみ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch` 関数は自動的にメモ化され、その結果が
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回のみ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこでも可能です
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoizationの働き**

<Image
  alt="Reactレンダリング中のfetchメモ化の働きを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリング中に、特定のリクエストが最初に呼び出されたとき、その結果はメモリに存在せず、キャッシュ`MISS`となります。
- したがって、関数が実行され、データは外部ソースから取得され、その結果はメモリに保存されます。
- 同じレンダリングパス内でリクエストが呼び出された際の後続の関数呼び出しはキャッシュ`HIT`となり、関数を実行せずにメモリからデータが返されます。
- ルートがレンダリングされ、レンダリングパスが完了すると、メモリが「リセット」され、すべてのリクエストメモ化エントリがクリアされます。

> **Good to know**:
>
> - リクエストメモ化はReactの機能であり、Next.jsの機能ではありません。ここに含まれているのは、他のキャッシュメカニズムとどのように相互作用するかを示すためです。
> - メモ化は、`fetch`リクエストの`GET`メソッドにのみ適用されます。
> - メモ化はReact Component treeのみに適用されます。以下を意味します：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、およびその他のServer Componentsの`fetch`リクエストに適用されます。
>   - Route Handlersの`fetch`リクエストには適用されません。それらはReact component treeの一部ではないためです。
> - `fetch`が適していない場合（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）、[React `cache`関数](#react-cache-function)を使用して関数をメモ化できます。

### 継続時間 {#duration}

キャッシュは、React component treeのレンダリングが完了するまでのサーバーリクエストの寿命にわたって持続します。

### 再検証 {#revalidating}

メモ化はサーバーリクエスト間で共有されず、レンダリング中にのみ適用されるため、再検証する必要はありません。

### 選択解除 {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、`POST`や`DELETE`など他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、選択を解除することはお勧めしません。

個別のリクエストを管理するには、 [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) から[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これはメモ化からリクエストを選択解除するのではなく、フライト中のリクエストを中止します。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには組み込みのData Cacheがあり、データフェッチの結果を**サーバーリクエスト間**および**デプロイメント間**で**持続**させます。これは、Next.jsがネイティブ`fetch` APIを拡張し、サーバーの各リクエストが独自の持続的なキャッシングセマンティクスを設定できるようにするためです。

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、`cache`オプションはサーバー側リクエストがサーバーのData Cacheとどのように相互作用するかを示します。

`fetch`の[`cache`](#fetch-optionscache)と[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、キャッシング動作を設定できます。

**Data Cacheの働き**

<Image
  alt="キャッシュされたfetchリクエストとキャッシュされていないリクエストがData Cacheとどのように相互作用するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化され、キャッシュされていないリクエストはデータソースからフェッチされ、Data Cacheには保存されず、メモ化されます。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- `'force-cache'`オプションを持つ`fetch`リクエストがレンダリング中に最初に呼び出されるとき、Next.jsはData Cacheにキャッシュ済みの応答があるかどうかを確認します。
- キャッシュ済みの応答が見つかった場合、それを即座に返し、[メモ化](#request-memoization)します。
- キャッシュ済みの応答が見つからなかった場合、リクエストはデータソースに送信され、その結果はData Cacheに保存され、メモ化されます。
- キャッシュされていないデータ（例：`cache`オプションが定義されていない、または`{ cache: 'no-store' }`を使用）は、常にデータソースからフェッチされ、メモ化されます。
- データがキャッシュされているかキャッシュされていないかに関わらず、同じデータの重複リクエストを避けるためにリクエストは常にメモ化されます。

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシュメカニズムは、キャッシュされたデータを再利用することでパフォーマンスを向上させますが、Data Cacheはサーバーリクエストとデプロイメント間で持続しますが、メモ化はリクエストの寿命だけ持続します。

### 継続時間 {#duration}

Data Cacheは、再検証または選択解除しない限り、サーバーリクエストおよびデプロイメント間で持続します。

### 再検証 {#revalidating}

キャッシュされたデータは2つの方法で再検証できます：

- **時間ベースの再検証**: 特定の時間が経過し、新しいリクエストがあった後にデータを再検証します。これはデータが頻繁に変わらず、新鮮さがそれほど重要でない場合に役立ちます。
- **オンデマンド再検証**: イベント（例：フォーム送信）に基づいてデータを再検証します。オンデマンドの再検証は、タグベースまたはパスベースのアプローチを使用して、データグループを一度に再検証することができます。これは、ヘッドレスCMSのコンテンツが更新されたときなど、最新のデータをできる限り早く表示したい場合に役立ちます。

#### 時間ベースの再検証 {#time-based-revalidation}

一定の間隔でデータを再検証するには、`fetch`の`next.revalidate`オプションを使用して、リソースのキャッシュ寿命（秒単位）を設定できます。

```js
// 最長1時間ごとに再検証する
fetch('https://...', { next: { revalidate: 3600 } })
```

または、[ルートセグメント設定オプション](#segment-config-options)を使用して、セグメント内のすべての`fetch`リクエストを設定するか、`fetch`を使用できない場合のケースを設定できます。

**時間ベースの再検証の働き**

<Image
  alt="時間ベースの再検証の働きを示す図。再検証期間後、最初のリクエストで古いデータが返され、次にデータが再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`オプションを持つfetchリクエストが最初に呼び出された場合、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- 指定された期間（例：60秒）以内に呼び出されたリクエストはキャッシュデータを返します。
- 期間後、次のリクエストはキャッシュされた（現在古くなった）データを返します。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データが正常にフェッチされると、Next.jsはData Cacheを新しいデータで更新します。
  - バックグラウンド再検証が失敗した場合、以前のデータは変更されずに保持されます。

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)動作に似ています。

#### オンデマンド再検証 {#on-demand-revalidation}

データはパスでのオンデマンドで再検証できます（[`revalidatePath`](#revalidatepath)）またはキャッシュタグで（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）。

**オンデマンド再検証の働き**

<Image
  alt="オンデマンド再検証の働きを示す図。再検証リクエスト後、Data Cacheが新しいデータで更新される。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- fetchリクエストが最初に呼び出された場合、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- オンデマンド再検証がトリガーされると、適切なキャッシュエントリはキャッシュからパージされます。
  - これは、変更をフェッチするまでキャッシュに古いデータを保持する時間ベースの再検証とは異なります。
- 次にリクエストが行われたとき、それは再びキャッシュ`MISS`となり、データは外部データソースからフェッチされ、Data Cacheに保存されます。

### 選択解除 {#opting-out}

`fetch`からの応答をキャッシュしたくない場合、以下のようにします：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**:
>
> 自動静的最適化（Automatic Static Optimization）、静的サイト生成（Static Site Generation）、または静的レンダリング（Static Rendering）という用語が、アプリケーションのルートをビルド時にレンダリングおよびキャッシュするプロセスを指すために相互に用いられることがあります。

Next.jsはビルド時にルートを自動的にレンダリングし、キャッシュします。これは最適化であり、すべてのリクエストに対してサーバーでレンダリングする代わりに、キャッシュされたルートを提供できるため、ページの読み込みが速くなります。

Full Route Cacheの仕組みを理解するには、Reactがレンダリングをどのように処理するか、Next.jsがその結果をどのようにキャッシュするかを見てみると役立ちます：

### 1. サーバーでのReactレンダリング {#1-react-rendering-on-the-server}

サーバーで、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートセグメントとSuspense boundariesによってチャンクに分割されます。

各チャンクは2つのステップでレンダリングされます：

1. ReactはServer Componentsをストリーミングに最適化された特別なデータ形式である**React Server Component Payload**にレンダリングします。
2. Next.jsは、React Server Component PayloadとClient Component JavaScript命令を使用して、サーバー上で**HTML**をレンダリングします。

これにより、すべてをレンダリングするまで待たずに、作業をキャッシュしたり、応答を送信することができます。代わりに、作業が完了したら応答をストリーミングできます。

> **React Server Component Payloadとは?**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。クライアント上のReactによってブラウザのDOMを更新するために使用されます。React Server Component Payloadには以下が含まれます：
>
> - サーバーコンポーネントのレンダリング結果
> - クライアントコンポーネントがレンダリングされるべきプレースホルダと、それらのJavaScriptファイルへの参照
> - サーバーコンポーネントからクライアントコンポーネントに渡されたprops
>
> 詳細については、[Server Components](/docs/app/building-your-application/rendering/server-components)ドキュメントをご覧ください。

### 2. サーバーにおけるNext.jsキャッシュ（Full Route Cache） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="静的にレンダリングされたルートのReact Server Component PayloadとHTMLをサーバーでキャッシュするFull Route Cacheのデフォルト動作。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの動作は、ルートのレンダリング結果（React Server Component PayloadとHTML）をサーバー上でキャッシュすることです。これはビルド時に静的にレンダリングされたルート、または再検証中に適用されます。

### 3. クライアントでのReact Hydrationとリコンシリエーション {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時に、クライアントでは：

1. HTMLはクライアントおよびサーバーコンポーネントの非インタラクティブな初期プレビューを即時に表示するために使用されます。
2. React Server Components Payloadは、クライアントとレンダリングされたサーバーコンポーネント treeをリコンシリエーションし、DOMを更新するために使用されます。
3. JavaScript命令は、クライアントコンポーネントを[hydrate](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにするために使用されます。

### 4. クライアントにおけるNext.jsキャッシュ（Router Cache） {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadはクライアントサイドの[Router Cache](#client-side-router-cache)に保存されます - 個々のルートセグメントごとに分割された別のインメモリキャッシュ。このRouter Cacheは、過去に訪問したルートを保存し、将来のルートをプリフェッチすることにより、ナビゲーション体験を向上させるために使用されます。

### 5. 以降のナビゲーション {#5-subsequent-navigations}

その後のナビゲーションまたはプリフェッチ中に、Next.jsはReact Server Components PayloadがRouter Cacheに保存されているかどうかを確認します。もしあれば、新しいリクエストをサーバーに送信することをスキップします。

ルートセグメントがキャッシュにない場合、Next.jsはReact Server Components Payloadをサーバーからフェッチし、クライアントのRouter Cacheに格納します。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ビルド時にルートがキャッシュされるかどうかは、それが静的または動的にレンダリングされるかによります。静的ルートはデフォルトでキャッシュされますが、動的ルートはリクエスト時にレンダリングされ、キャッシュされません。

この図は、キャッシュされたデータとキャッシュされていないデータとで静的レンダリングと動的レンダリングの違いを示しています：

<Image
  alt="静的および動的レンダリングがFull Route Cacheに与える影響。静的ルートはビルド時またはデータ再検証後にキャッシュされるのに対し、動的ルートは決してキャッシュされません"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学びましょう。

### 継続時間 {#duration}

デフォルトでは、Full Route Cacheは持続的です。つまり、レンダー出力はユーザーリクエスト間でキャッシュされます。

### 無効化 {#invalidation}

Full Route Cacheを無効化するには2つの方法があります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)の再検証は、サーバー上でコンポーネントを再レンダリングし、新しいレンダー出力をキャッシュすることにより、Router Cacheも無効化します。
- **再デプロイ**: デプロイメントを超えて持続するData Cacheとは異なり、Full Route Cacheは新しいデプロイメントでクリアされます。

### 選択解除 {#opting-out}

Full Route Cacheをオプトアウトする、または言い換えると、受信リクエストごとにコンポーネントを動的にレンダリングするには、以下の方法があります：

- **[Dynamic API](#dynamic-apis)を使用する**: これにより、ルートがFull Route Cacheからオプトアウトし、リクエスト時に動的にレンダリングされます。Data Cacheは引き続き使用できます。
- **ルートセグメント設定オプションとして`dynamic = 'force-dynamic'`または`revalidate = 0`を使用する**: これにより、Full Route CacheとData Cacheをスキップします。つまり、すべての受信リクエストでサーバーにコンポーネントをレンダリングし、データをフェッチすることになります。Router Cacheはクライアントサイドキャッシュであるため、引き続き適用されます。
- **[Data Cache](#data-cache)をオプトアウトする**: `fetch`リクエストがキャッシュされていないルートがある場合、これはFull Route Cacheからルートをオプトアウトします。特定の`fetch`リクエストのデータは、すべての受信リクエストでフェッチされます。キャッシュをオプトアウトしない他の`fetch`リクエストは、Data Cacheにキャッシュされ続けます。これにより、キャッシュされたデータとキャッシュされていないデータのハイブリッドが可能になります。

## クライアントサイド Router Cache {#client-side-router-cache}

Next.jsには、ルートセグメントをLayouts、ローディング状態、ページごとに分割してRSCペイロードを保存するインメモリクライアントサイドルーターキャッシュがあります。

ユーザーがルート間をナビゲーションする際、Next.jsは訪れたルートセグメントをキャッシュし、ユーザーがナビゲーションしそうなルートを[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、ナビゲーション間の即時バック/フォワードナビゲーションが可能になり、フルページの再読み込みがなくなり、Reactの状態とブラウザの状態が保持されます。

Router Cacheを使用すると：

- **Layouts**はナビゲーション時にキャッシュされ再利用されます（[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）。
- **ローディング状態**は、ナビゲーション時にキャッシュされ再利用され、[即時ナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を実現します。
- **ページ**はデフォルトではキャッシュされませんが、ブラウザのバックワードおよびフォワードナビゲーション時に再利用されます。実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用してページセグメントのキャッシュを有効にできます。

{/* TODO: v15の動作に合わせた図に更新 */}

> **Good to know:** このキャッシュは特にNext.jsとServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、似たような結果をもたらします。

### 継続時間 {#duration}

キャッシュはブラウザの一時メモリに保存されます。2つの要因がRouter Cacheの持続時間を決定します：

- **セッション**: キャッシュはナビゲーションを越えて持続します。ただし、ページがリフレッシュされるとクリアされます。
- **自動無効化期間**: レイアウトやローディング状態のキャッシュは特定の期間後に自動的に無効化されます。この期間は、リソースが[プリフェッチ](/docs/app/api-reference/components/link#prefetch)された方法や、リソースが[静的に生成された](/docs/app/building-your-application/rendering/server-components#static-rendering-default)かどうかによって異なります：
  - **デフォルトのプリフェッチ**（`prefetch={null}`または未指定）：動的ページではキャッシュされず、静的ページでは5分。
  - **フルプリフェッチ**（`prefetch={true}`または`router.prefetch`）：静的および動的ページの両方で5分。

ページリフレッシュは**すべての**キャッシュされたセグメントをクリアしますが、自動無効化期間はプリフェッチされた時点から個々のセグメントにのみ影響を与えます。

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用して、上記の自動無効化時間を調整できます。

### 無効化 {#invalidation}

Router Cacheを無効化する方法は2つあります：

- **サーバーアクション**:
  - パスを使用したオンデマンドのデータ再検証（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)）またはキャッシュタグを使用（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用すると、クッキーを使用するルートが古くならないようにRouter Cacheが無効になります（例：認証）。
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すことで、Router Cacheを無効にし、現在のルートに対してサーバーに新しいリクエストを送ります。

### 選択解除 {#opting-out}

Next.js 15時点で、ページセグメントはデフォルトで選択解除されています。

> **Good to know:** `<Link>`コンポーネントの`prefetch`プロパティを`false`に設定することで、[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)をオプトアウトすることもできます。

## キャッシュ相互作用 {#cache-interactions}

さまざまなキャッシュメカニズムを設定する際、それらがどのように相互作用するかを理解することが重要です：

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheの再検証またはオプトアウトは、レンダー出力がデータによって異なるため、Full Route Cacheを無効化します。
- Full Route Cacheを無効化またはオプトアウトしてもData Cacheは影響を受けません。キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングできます。これはページのほとんどがキャッシュされたデータを使用しているが、いくつかのコンポーネントがリクエスト時にフェッチする必要があるデータに依存している場合に便利です。すべてのデータを再フェッチすることによるパフォーマンスへの影響を心配することなく、動的にレンダリングできます。

### Data Cacheとクライアントサイドルーターキャッシュ {#data-cache-and-client-side-router-cache}

- データキャッシュとルーターキャッシュを直ちに無効にするには、[サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用します。
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証しても、特定のルートに紐づいていないため、Router Cacheは直ちに無効になりません。これは、ハードリフレッシュか自動無効化期間が経過するまで、Router Cacheが以前のペイロードを提供し続けることを意味します。

## API {#apis}

次の表は、さまざまなNext.js APIがキャッシュにどのように影響するかの概要を示しています：

| API                                                                     | Router Cache               | Full Route Cache        | Data Cache              | React Cache |
| ----------------------------------------------------------------------- | -------------------------- | ----------------------- | ----------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | Cache                      |                         |                         |             |
| [`router.prefetch`](#routerprefetch)                                    | Cache                      |                         |                         |             |
| [`router.refresh`](#routerrefresh)                                      | Revalidate                 |                         |                         |             |
| [`fetch`](#fetch)                                                       |                            |                         | Cache                   | Cache       |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                         | CacheまたはOpt out      |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Revalidate              | Revalidate              |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Cache                   | Cache                   |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate              | Revalidate              |             |
| [`revalidatePath`](#revalidatepath)                                     | Revalidate (Server Action) | Revalidate              | Revalidate              |             |
| [`const revalidate`](#segment-config-options)                           |                            | RevalidateまたはOpt out | RevalidateまたはOpt out |             |
| [`const dynamic`](#segment-config-options)                              |                            | CacheまたはOpt out      | CacheまたはOpt out      |             |
| [`cookies`](#cookies)                                                   | Revalidate (Server Action) | Opt out                 |                         |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Opt out                 |                         |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Cache                   |                         |             |
| [`React.cache`](#react-cache-function)                                  |                            |                         |                         | Cache       |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                         | Cache                   |             |

### `<Link>` {#link}

デフォルトで、`<Link>`コンポーネントはフルルートキャッシュからルートを自動的にプリフェッチし、React Server Component PayloadをRouter Cacheに追加します。

プリフェッチを無効にするには、`prefetch`プロパティを`false`に設定できます。しかし、この選択はキャッシュを恒久的にスキップするわけではなく、ユーザーがルートを訪れた際にはルートセグメントがクライアントサイドでキャッシュされます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しく学びましょう。

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使用して、ルートを手動でプリフェッチできます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router) APIのリファレンスを参照してください。

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使用して、ルートを手動でリフレッシュできます。これにより、Router Cacheが完全にクリアされ、現在のルートに対してサーバーに新しいリクエストを送ります。`refresh`はData CacheまたはFull Route Cacheには影響しません。

レンダー結果は、React状態とブラウザ状態を保持しながらクライアントでリコンシリエーションされます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router) APIのリファレンスを参照してください。

### `fetch` {#fetch}

`fetch`から返されるデータは、Data Cacheに自動的にキャッシュされません。

`fetch`のデフォルトのキャッシング動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定した場合に等しいです：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で詳細なオプションを確認してください。

### `fetch options.cache` {#fetch-options-cache}

`cache`オプションを`force-cache`に設定して、個々の`fetch`をキャッシュにオプトインできます：

```jsx
// キャッシュを選択する
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で詳細なオプションを確認してください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

`fetch`の`next.revalidate`オプションを使用して、個々の`fetch`リクエストの再検証期間（秒単位）を設定できます。これにより、Data Cacheが再検証され、結果としてFull Route Cacheも再検証されます。新鮮なデータがフェッチされ、コンポーネントがサーバーで再レンダリングされます。

```jsx
// 最長1時間後に再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)で詳細なオプションを確認してください。

### `fetch options.next.tags`と`revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、詳細なデータキャッシングと再検証のためのキャッシュタグシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用するとき、1つ以上のタグでキャッシュエントリをタグ付けするオプションがあります。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリをパージできます。

例えば、データをフェッチする際にタグを設定できます：

```jsx
// タグでデータをキャッシュ
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

そして、特定のタグでキャッシュエントリをパージするために`revalidateTag`を呼び出します：

```jsx
// 特定のタグでエントリを再検証
revalidateTag('a')
```

何を達成しようとしているかに応じて、`revalidateTag`を使用できる場所は2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：Webhook）に応じてデータを再検証します。これによりRouter Cacheは直ちに無効になりません。Router Handlerは特定のルートに結び付けられていないためです。
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション後（例：フォーム送信）にデータを再検証します。これにより、関連するルートのRouter Cacheが無効になります。

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、単一の操作で特定のパス以下のデータを手動で再検証し、ルートセグメントを再レンダリングできます。`revalidatePath`メソッドを呼び出すと、Data Cacheが再検証され、結果としてFull Route Cacheが無効化されます。

```jsx
revalidatePath('/')
```

何を達成しようとしているかに応じて、`revalidatePath`を使用できる場所は2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：Webhook）に応じてデータを再検証します。
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション後（例：フォーム送信、ボタンクリック）にデータを再検証します。

詳細については、[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)を参照してください。

> **`revalidatePath`**と**`router.refresh`**:
>
> `router.refresh`を呼び出すと、Router Cacheがクリアされ、Data CacheやFull Route Cacheを無効にすることなく、サーバー上でルートセグメントが再レンダリングされます。
>
> `revalidatePath`はData CacheとFull Route Cacheをパージしますが、`router.refresh()`はData CacheとFull Route Cacheを変更しません。これはクライアントサイドのAPIです。

### Dynamic APIs {#dynamic-apis}

`cookies`や`headers`などのDynamic API、およびPagesの`searchParams` propは、ランタイムの受信リクエスト情報に依存します。これらを使用することで、ルートはFull Route Cacheからオプトアウトされます。つまり、ルートは動的にレンダリングされます。

#### `cookies` {#cookies}

サーバーアクション内で`cookies.set`または`cookies.delete`を使用すると、ルーターキャッシュが無効になり、クッキーを使用するルートが古くならないようにします（例：認証の反映）。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照してください。

### セグメント設定オプション {#segment-config-options}

Route セグメント設定オプションは、`fetch` APIを使用できない場合や（例：データベースクライアントやサードパーティライブラリ）、ルートセグメントのデフォルトを上書きするために使用できます。

以下のRoute セグメント設定オプションは、Full Route Cacheからオプトアウトします：

- `const dynamic = 'force-dynamic'`

この設定オプションはすべてのfetchをData Cacheからオプトアウトします（例：`no-store`）：

- `const fetchCache = 'default-no-store'`

詳細なオプションについては、[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)をご覧ください。

他のオプションについては、[Route Segments 設定](/docs/app/api-reference/file-conventions/route-segment-config) ドキュメントを参照してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）の場合、`generateStaticParams`で提供されるパスは、ビルド時にFull Route Cacheにキャッシュされます。リクエスト時に、Next.jsはフライで訪問された初回のパスもキャッシュします。

すべてのパスをビルド時に静的にレンダリングするには、`generateStaticParams`にパスの完全なリストを提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

一部のパスをビルド時に静的にレンダリングし、残りをランタイムで初回訪問時にレンダリングするには、部分的なパスのリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10件の投稿をビルド時にレンダリングする
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

すべてのパスを初回訪問時に静的にレンダリングするには、空の配列を返す（ビルド時にパスはレンダリングされません）か[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`からは、空であっても配列を返す必要があります。そうでなければ、ルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時にキャッシュを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。この設定オプションが使用されると、`generateStaticParams`で提供されたパスのみが提供され、他のルートは404エラーを返すか、（[catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）一致します。

### React `cache` 関数 {#react-cache-function}

React `cache` 関数を使用すると、関数の戻り値をメモ化し、同じ関数を複数回呼び出し、1回だけ実行することができます。

`fetch`リクエストは自動的にメモ化されるため、React `cache`でラップする必要はありません。ただし、`fetch` APIが適していない場合のデータリクエストを手動でメモ化するには、`cache`を使用できます。例えば、一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアントなどです。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
