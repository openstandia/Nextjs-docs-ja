---
title: 'Next.jsにおけるキャッシュ'
nav_title: 'キャッシュ'
description: 'Next.jsのキャッシュメカニズムの概要。'
---

Next.jsはキャッシュによってレンダリング作業やデータリクエストを効率化し、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシュメカニズム、設定に使えるAPI、およびそれらがどのように相互作用するかについて詳しく説明します。

> **Good to know**: このページはNext.jsの内部動作を理解するのに役立ちますが、Next.jsを生産的に使うために必要な知識ではありません。ほとんどのNext.jsのキャッシュロジックはAPIの使用法によって決定されており、ゼロまたは最小限の設定で最高のパフォーマンスをデフォルトで提供します。例を確認したい場合は、[こちら](/docs/app/building-your-application/data-fetching/fetching)から始めてください。

## 概要 {#overview}

以下は、さまざまなキャッシュメカニズムとその目的の概要です：

| メカニズム                                  | 何                    | どこ         | 目的                                                     | 期間                               |
| ------------------------------------------- | --------------------- | ------------ | -------------------------------------------------------- | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の返り値          | サーバ       | React Component treeのデータを再利用する                 | リクエストライフサイクルごと       |
| [Data Cache](#data-cache)                   | データ                | サーバ       | ユーザーのリクエストとデプロイメント間のデータを保存する | 永続的 (再検証可能)                |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCのペイロード | サーバ       | レンダリングコストを削減し、パフォーマンスを向上させる   | 永続的 (再検証可能)                |
| [Router Cache](#client-side-router-cache)   | RSCペイロード         | クライアント | ナビゲーション時のサーバリクエストを減少させる           | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsはパフォーマンスを向上させ、コストを削減するために可能な限り多くのキャッシュを行います。これには、ルートが**静的にレンダリング**され、データリクエストが**キャッシュ**されることを意味します。以下の図は、ビルド時や静的なルートが最初に訪問されたときに、ルートが静的にレンダリングされるときのデフォルトのキャッシュ動作を示しています。

<Image
  alt="Next.jsのデフォルトのキャッシュ動作を示す図。ビルド時とルートが最初に訪問されたときのHIT、MISSとSET。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシングの動作はルートが静的か動的にレンダリングされているか、データがキャッシュされているかいないか、またリクエストが最初の訪問の一部であるか、またはその後のナビゲーションの一部であるかに応じて変わります。使用状況に応じて、個々のルートやデータリクエストのキャッシング動作を設定できます。

## Request Memoization {#request-memoization}

Reactは[`fetch` API](#fetch)を拡張して、同じURLとオプションを持つリクエストを自動的に**メモ化**します。これにより、Reactコンポーネントtree内で同じデータを複数の場所で扱いながら、実行は1回だけで済みます。

<Image
  alt="重複を排除されたフェッチリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

例として、ルート全体で同じデータを使用する必要がある場合（例：Layout、Page、複数のコンポーネントで）、treeのトップでデータを取得し、propsをコンポーネント間で転送する必要はありません。代わりに、必要なデータを必要とするコンポーネント内で取得することができ、同じデータをネットワークで複数回リクエストすることのパフォーマンスへの影響を心配する必要がありません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、その結果が
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこにでもあります
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、その結果が
  // キャッシュされます
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルートのどこにでもあります
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoizationの動作原理**

<Image
  alt="Reactレンダリング中のfetchメモ化の動作を示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートのレンダリング中、特定のリクエストが初めて呼び出されたときは、その結果はメモリに存在せず、キャッシュ`MISS`となります；
- そのため、関数が実行され、外部ソースからデータが取得され、その結果がメモリに保存されます；
- 同じレンダーパス内でのリクエストのその後の関数呼び出しはキャッシュ`HIT`であり、関数を実行せずにメモリからデータが返されます；
- ルートのレンダリングが完了し、レンダリングパスが終了すると、メモリは「リセット」され、すべてのリクエストメモ化エントリーがクリアされます。

> **Good to know**:
>
> - リクエストメモ化はReactの機能であり、Next.jsの機能ではありません。他のキャッシュメカニズムとの相互作用を示すためにここで取り上げられています。
> - メモ化は`fetch`リクエストの`GET`メソッドにのみ適用されます。
> - メモ化はReact Component treeにのみ適用されます：
>   - `generateMetadata`、`generateStaticParams`、Layout、Page、その他のServer Componentの`fetch`リクエストに適用されます。
>   - リクエストハンドラーでの`fetch`リクエストには適用されません、それらはReact component treeの一部ではないためです。
> - `fetch`が適さない場合（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）、[React `cache`関数](#react-cache-function)を使用して関数をメモ化できます。

### 期間 {#duration}

キャッシュはサーバーリクエストの存続期間中、React component treeがレンダリングを終了するまで持続します。

### 再検証 {#revalidating}

メモ化はサーバーリクエストの間で共有されず、レンダリング中にのみ適用されるため、再検証の必要はありません。

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、`POST`や`DELETE`などの他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、オプトアウトを推奨しません。

個別のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)から[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これによりメモ化が除外されず、リクエストがフライト中に中止されます。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには組み込みのData Cacheがあり、データ取得結果を**サーバリクエスト**や**デプロイメント**間で**永続化**します。これは、Next.jsがネイティブの`fetch` APIを拡張し、各サーバーのリクエストで独自の永続的なキャッシュセマンティクスを設定できるため可能です。

> **Good to know**: ブラウザでの`fetch`の`cache`オプションは、リクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、`cache`オプションはサーバーサイドリクエストがサーバーのData Cacheとどのように相互作用するかを示します。

キャッシュ動作を設定するために、`fetch`の[`cache`](#fetch-optionscache)オプションと[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用できます。

**Data Cacheの動作**

<Image
  alt="Data Cacheとのキャッシュされたリクエストとキャッシュされていないリクエストの相互作用を示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化され、キャッシュされていないリクエストはデータソースから取得され、Data Cacheには保存されず、メモ化される。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- `fetch`リクエストが`'force-cache'`オプションでレンダリング中に初めて呼び出された時、Next.jsはData Cache内のキャッシュされた応答をチェックします；
- キャッシュされた応答が見つかった場合、それは即座に返され、[メモ化](#request-memoization)されます；
- キャッシュされた応答が見つからない場合、リクエストはデータソースに対して行われ、その結果がData Cacheに保存され、メモ化されます；
- キャッシュされていないデータ（例：`cache`オプションが定義されていない、または`{ cache: 'no-store' }`を使用）は常にデータソースから取得され、メモ化されます；
- データがキャッシュされているかキャッシュされていないかにかかわらず、リクエストは常にメモ化され、Reactレンダリングパス中の同じデータに対して重複したリクエストが行われないようにします。

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシュメカニズムは、キャッシュされたデータを再利用してパフォーマンスを向上させますが、Data Cacheはリクエストやデプロイメントをまたいで永続しますが、メモ化はリクエストの存続期間のみ持続します。

### 期間 {#duration}

Data Cacheはリクエストやデプロイメントをまたいで永続します；再検証またはオプトアウトしない限り。

### 再検証 {#revalidating}

キャッシュされたデータは、次の方法で再検証できます：

- **タイムベース再検証 (Time-based Revalidation)**：ある一定の時間が経過し、新しいリクエストが行われた後にデータを再検証します。これは、鮮度がそれほど重要でないインフレクエントに変更されるデータに有用です。
- **オンデマンド再検証 (On-demand Revalidation):** イベントに基づいてデータを再検証します（例：フォーム送信）。タグベースまたはパスベースのアプローチを使用してデータのグループを一度に再検証できます。これは、ヘッドレスCMSからコンテンツが更新された際など、可能な限り迅速に最新のデータを表示させる場合に役立ちます。

#### タイムベース再検証 {#time-based-revalidation}

リソースのキャッシュライフタイム（秒単位）を設定するために、`fetch`の`next.revalidate`オプションを使用してタイムインターバルでデータを再検証できます。

```js
// 最長で1時間ごとに再検証
fetch('https://...', { next: { revalidate: 3600 } })
```

別の方法として、[Route Segment Config options](#segment-config-options)を使用して、セグメント内のすべての`fetch`リクエストを設定するか、`fetch`を使用できない場合などに適用することができます。

**タイムベース再検証の動作**

<Image
  alt="タイムベース再検証の動作を示す図。再検証期間後、最初のリクエストで古いデータが返され、その後データが再検証される。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- 初めて`revalidate`付きのfetchリクエストが呼び出されるとき、データが外部データソースから取得され、Data Cacheに保存されます；
- 指定された時間枠（例：60秒）内に呼び出されるリクエストは、キャッシュされたデータを返します；
- 時間枠を超えた後、次のリクエストは依然としてキャッシュ（現在は古い）データを返します；
  - 背景でのNext.jsがデータの再検証をトリガーします；
  - データが正常に取得されると、Next.jsはData Cacheを新鮮なデータで更新します；
  - 背景再検証が失敗した場合は、以前のデータが変更されずに保持されます；

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)の動作に似ています。

#### オンデマンド再検証 {#on-demand-revalidation}

データはパスでの再検証（[`revalidatePath`](#revalidatepath)）またはキャッシュタグでの再検証（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）によりオンデマンドで再検証できます。

**オンデマンド再検証の動作**

<Image
  alt="オンデマンド再検証の動作を示す図。再検証リクエスト後、Data Cacheはフレッシュデータで更新される。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- 最初に`fetch`リクエストが呼び出されたとき、データは外部データソースから取得され、Data Cacheに保存されます；
- オンデマンド再検証をトリガーすると、該当するキャッシュエントリがキャッシュからパージされます；
  - これは、再検証期間中に古いデータをキャッシュに保持するタイムベース再検証とは異なります；
- 次回リクエストが行われると、再びキャッシュ`MISS`となり、データが外部データソースから取得され、Data Cacheに保存されます；

### オプトアウト {#opting-out}

`fetch`からの応答をキャッシュしたくない場合は、次のように設定できます；

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**:
>
> あなたは、おそらく **Automatic Static Optimization（自動静的最適化）**、 **Static Site Generation（静的サイト生成）**、または **Static Rendering（静的レンダリング）**という用語を、アプリケーションのルートをビルド時にレンダリングしてキャッシュするプロセスを指して使うことを目にするでしょう。

Next.jsは自動的にルートをビルド時にレンダリングし、キャッシュします。これは、リクエストごとにサーバーでレンダリングするのではなく、キャッシュされたルートを提供できるようにすることで、より高速なページ読み込みを実現する最適化です。

Full Route Cacheの動作を理解するためには、Reactがレンダリングをどのように処理し、Next.jsが結果をどのようにキャッシュするかを理解するのが役立ちます；

### 1. サーバでのReactレンダリング {#1-react-rendering-on-the-server}

サーバーでは、Next.jsはReactのAPIを使用してレンダリングを調整します。レンダリングの作業はチャンクに分割されます：個々のルートセグメントとSuspense境界によって。

各チャンクは以下の2ステップでレンダリングされます：

1. ReactはServer Componentを**React Server Component Payload**と呼ばれる、ストリーミングに最適化された特別なデータフォーマットにレンダリングします；
2. Next.jsは、React Server Component PayloadとClient Component JavaScriptインストラクションを使用して**HTML**をサーバでレンダリングします；

これにより、すべてがレンダリングされるのを待つ必要がなく作業をキャッシュしたり応答を送信したりできます。代わりに、作業が完了するごとにストリームとして応答を送信できます。

> **React Server Component Payloadとは何か？**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。クライアントでReactがブラウザのDOMを更新するのに使用されます。React Server Component Payloadには以下が含まれます：
>
> - Server Componentsのレンダリング結果；
> - Client Componentsがレンダリングされる場所のプレースホルダとそれらのJavaScriptファイルへの参照；
> - Server ComponentからClient Componentに渡されるprops；
>
> 詳しくは、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントを参照してください。

### 2. サーバーでのNext.jsのキャッシング（Full Route Cache） {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="Full Route Cacheのデフォルト動作、静的にレンダリングされたルートのためにReact Server ComponentペイロードとHTMLがサーバーでキャッシュされる。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの動作は、ルートのレンダリング結果（React Server ComponentペイロードとHTML）をサーバーにキャッシュすることです。これはビルド時、または再検証中に静的にレンダリングされたルートに適用されます。

### 3. クライアントでのReactハイドレーションと調整 {#3-react-hydration-and-reconciliation-on-the-client}

要求時、クライアント上では：

1. HTMLは、ClientとServer Componentsのインタラクションのない初期プレビューを即座に表示するために使用されます；
2. React Server Components Payloadは、ClientとレンダリングされたServer Component treeを調整し、DOMを更新するのに使用されます；
3. JavaScriptインストラクションは、Client Componentsを[hydrate](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにします；

### 4. クライアントでのNext.jsのキャッシング（Router Cache） {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadはクライアント側の[Router Cache](#client-side-router-cache) - 個々のルートセグメントごとに分割された別のインメモリキャッシュに保存されます。このRouter Cacheは訪問したルートを保存し、将来ナビゲートされる可能性のあるルートをプリフェッチすることによってナビゲーション体験を向上させます。

### 5. その後のナビゲーション {#5-subsequent-navigations}

以降のナビゲーションやプリフェッチ時、Next.jsはReact Server Components PayloadがRouter Cacheに保存されているかどうかを確認します。そうであれば、サーバーに新たなリクエストを送らないこととなります。

ルートセグメントがキャッシュに無い場合、Next.jsはサーバーからReact Server Components Payloadを取得し、クライアントのRouter Cacheを更新します。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ルートがキャッシュされるか否かは、ビルド時に静的にレンダリングされるか動的にレンダリングされるかに依存します。静的ルートはデフォルトでキャッシュされますが、動的ルートは要求時にレンダリングされ、キャッシュされません。

この図は、静的にレンダリングされるルートと動的にレンダリングされるルートの違いを、キャッシュされたデータとキャッシュされていないデータを含めて示しています：

<Image
  alt="静的および動的レンダリングがFull Route Cacheに及ぼす影響。ビルド時またはデータ再検証後に静的ルートはキャッシュされ、動的ルートは決してキャッシュされない"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)についてもっと学びましょう。

### 期間 {#duration}

デフォルトで、Full Route Cacheは永続的です。これはレンダー出力がユーザーリクエストをまたいでキャッシュされることを意味します。

### 失効 {#invalidation}

Full Route Cacheを失効させる方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)の再検証は、サーバーでのコンポーネントの再レンダリングと新しいレンダー出力のキャッシュによってRouter Cacheを失効させます。
- **再デプロイ**：デプロイメントをまたいで永続するData Cacheとは異なり、新しいデプロイメントではFull Route Cacheはクリアされます。

### オプトアウト {#opting-out}

Full Route Cacheからオプトアウトするか、別の方法として、各リクエストのたびに動的にコンポーネントをレンダリングすることができます：

- **[Dynamic API](#dynamic-apis)を使用する**: これにより、ルートがFull Route Cacheから除外され、要求時に動的にレンダリングされます。Data Cacheはまだ使用可能です。
- `dynamic = 'force-dynamic'`または`revalidate = 0`ルートセグメント設定オプションを使用する: Full Route CacheとData Cacheをスキップします。つまり、サーバー上のすべてのリクエストに対してコンポーネントがレンダリングされ、データはフェッチされます。Router Cacheはクライアント側のキャッシュとしてまだ適用されます。
- **[Data Cache](#data-cache)のオプトアウト**: `fetch`リクエストがキャッシュされていないルートがある場合、このルートはFull Route Cacheからオプトアウトされます。特定の`fetch`リクエストのデータは、すべてのリクエストでフェッチされます。キャッシュのオプトアウトをしていない他の`fetch`リクエストはData Cacheにキャッシュされ続けます。これはキャッシュされたデータとキャッシュされていないデータのハイブリッドを可能にします。

## クライアント側Router Cache {#client-side-router-cache}

Next.jsには、レイアウト、読み込み状態、ページごとに分割されたルートセグメントのRSCペイロードを保存するインメモリのクライアント側router cacheがあります。

ユーザーがルートをナビゲートするとき、Next.jsは訪問したルートセグメントをキャッシュし、ユーザーがナビゲートする可能性のあるルートを[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、ナビゲーション間の完全なページのリロードを必要としないインスタントバック/フォワードナビゲーションが実現し、Reactの状態とブラウザの状態が保持されます。

Router Cacheを使用すると：

- **レイアウト**はナビゲーションでキャッシュされ再利用されます（[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）；
- **読み込み状態**は、[インスタントナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のためにナビゲーションでキャッシュされ再利用されます；
- **ページ**はデフォルトでキャッシュされませんが、ブラウザのバックワードおよびフォワードナビゲーション中に再利用されます。ページセグメントのキャッシュを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用します。

{/* TODO: 図をv15の動作に合わせて更新する */}

> **Good to know:** このキャッシュは特にNext.jsとServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、類似の結果をもたらします。

### 期間 {#duration}

キャッシュはブラウザの一時メモリに保存されます。2つの要因がrouter cacheの持続時間を決定します：

- **セッション**: キャッシュはナビゲーションをまたいで持続します。ただし、ページのリフレッシュ時にクリアされます。
- **自動無効期間**: レイアウトと読み込み状態のキャッシュは自動的に特定の時間後に失効します。持続時間は、リソースがどのように[プリフェッチ](/docs/app/api-reference/components/link#prefetch)されたか、およびリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかどうかによって異なります：
  - **デフォルトプリフェッチ** (`prefetch={null}`または指定なし): 動的ページに対してはキャッシュされず、静的ページに対しては5分；
  - **フルプリフェッチ** (`prefetch={true}`または`router.prefetch`): 静的および動的ページの両方に対して5分；

ページのリフレッシュにより**すべて**のキャッシュされたセグメントがクリアされますが、自動失効期間はプリフェッチされた時から個々のセグメントにのみ影響します。

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用して、上記の自動失効時間を調整できます。

### 失効 {#invalidation}

Router Cacheを無効にする方法は2つあります：

- **Server Action**内で：
  - パスによって（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)）またはキャッシュタグによって（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)）データをオンデマンドで再検証します；
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用して、クッキーを使用するルートが古くならないようにRouter Cacheを無効にします（例：認証）；
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すと、Router Cacheが無効になり、現在のルートに対してサーバに新しいリクエストを送信します；

### オプトアウト {#opting-out}

Next.js 15以降、ページセグメントはデフォルトでオプトアウトされます。

> **Good to know:** `<Link>`コンポーネントの`prefetch`プロップを`false`に設定することによって[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)からもオプトアウトできます。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシュメカニズムを設定する際には、それらの相互作用を理解することが重要です；

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheの再検証やオプトアウトは、レンダー出力がデータ依存であるため、Full Route Cacheを失効させます；
- Full Route Cacheを無効にしても、Data Cacheには影響しません。キャッシュされたデータとキャッシュされていないデータの両方を持つルートを動的にレンダリングできます。これは、ページの大部分がキャッシュされたデータを使用しますが、リクエスト時にデータを取得する必要があるいくつかのコンポーネントを持つ場合に便利です。すべてのデータを再フェッチするパフォーマンスへの影響を心配せずに動的にレンダリングできます。

### Data Cacheとクライアント側Router Cache {#data-cache-and-client-side-router-cache}

- Data CacheとRouter Cacheを即座に無効にするには、[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます；
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証するとRouter Cacheは即座には無効になりません。Router Handlerは特定のルートに結びついているわけではないので、ハードリフレッシュや自動無効期間が経過しない限り、Router Cacheは前のペイロードを提供し続けます；

## API {#apis}

次の表は、異なるNext.js APIがキャッシュにどのように影響するかを示しています；

| API                                                                     | Router Cache           | Full Route Cache             | Data Cache                   | React Cache |
| ----------------------------------------------------------------------- | ---------------------- | ---------------------------- | ---------------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | キャッシュ             |                              |                              |             |
| [`router.prefetch`](#routerprefetch)                                    | キャッシュ             |                              |                              |             |
| [`router.refresh`](#routerrefresh)                                      | 再検証                 |                              |                              |             |
| [`fetch`](#fetch)                                                       |                        |                              | キャッシュ                   | キャッシュ  |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                        |                              | キャッシュまたはオプトアウト |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                        | 再検証                       | 再検証                       |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                        | キャッシュ                   | キャッシュ                   |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | 再検証 (Server Action) | 再検証                       | 再検証                       |             |
| [`revalidatePath`](#revalidatepath)                                     | 再検証 (Server Action) | 再検証                       | 再検証                       |             |
| [`const revalidate`](#segment-config-options)                           |                        | 再検証またはオプトアウト     | 再検証またはオプトアウト     |             |
| [`const dynamic`](#segment-config-options)                              |                        | キャッシュまたはオプトアウト | キャッシュまたはオプトアウト |             |
| [`cookies`](#cookies)                                                   | 再検証 (Server Action) | オプトアウト                 |                              |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                        | オプトアウト                 |                              |             |
| [`generateStaticParams`](#generatestaticparams)                         |                        | キャッシュ                   |                              |             |
| [`React.cache`](#react-cache-function)                                  |                        |                              |                              | キャッシュ  |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                        |                              | キャッシュ                   |             |

### `<Link>` {#link}

デフォルトで、`<Link>`コンポーネントはFull Route Cacheからルートを自動でプリフェッチし、React Server Component PayloadをRouter Cacheに追加します。

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定します。しかし、これはキャッシュを恒久的にスキップするわけではなく、ルートがクライアント側でユーザーが訪れたときにキャッシュされ続けます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)について詳しく学びましょう。

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションは、ルートを手動でプリフェッチするのに使用できます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを参照してください。

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションは、ルートを手動でリフレッシュするのに使用できます。これはRouter Cacheを完全にクリアし、現在のルートに対してサーバーに新しいリクエストを行います。`refresh`はDataやFull Route Cacheには影響しません。

レンダリングされた結果は、Reactの状態とブラウザの状態を保存しながらクライアント上で調整されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)のAPIリファレンスを参照してください。

### `fetch` {#fetch}

`fetch`から返されたデータは、自動的にはData Cacheにキャッシュされません。

`fetch`のデフォルトキャッシュ動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定することと同等です；

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

さらに多くのオプションについては[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.cache` {#fetch-options-cache}

個別の`fetch`をキャッシュにオプトインするには、`cache`オプションを`force-cache`に設定します：

```jsx
// キャッシュにオプトインする
fetch(`https://...`, { cache: 'force-cache' })
```

さらに多くのオプションについては[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

個別の`fetch`リクエストの再検証期間（秒単位）を設定するために、`fetch`の`next.revalidate`オプションを使用できます。これにより、Data Cacheが再検証され、その結果Full Route Cacheが再検証されます。新鮮なデータがフェッチされ、コンポーネントがサーバー上で再レンダリングされます。

```jsx
// 最長で1時間ごとに再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

さらに多くのオプションについては[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。

### `fetch options.next.tags` と `revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、データの詳細なキャッシュと再検証のためのキャッシュタグ付けシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用する際、1つ以上のタグでキャッシュエントリをタグ付けするオプションがあります。
2. 次に、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリをパージすることができます。

例えば、データをフェッチする際にタグを設定できます；

```jsx
// タグでデータをキャッシュする
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

次に、特定のタグで`revalidateTag`を呼び出してキャッシュエントリをパージします；

```jsx
// 特定のタグを持つエントリを再検証する
revalidateTag('a')
```

達成しようとしているものに応じて、次の2か所で`revalidateTag`を使用できます：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：Webhook）に応じてデータを再検証します。Router Cacheはすぐには無効にならないので、Router Handlerは特定のルートに結びついていません；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション（例：フォーム送信）後にデータを再検証します。これにより関連するルートのRouter Cacheが無効になります；

### `revalidatePath` {#revalidatepath}

`revalidatePath`では、データを手動で再検証し、特定のパスの下のルートセグメントを単一の操作で再レンダリングできます。`revalidatePath`メソッドを呼び出すと、Data Cacheが再検証され、その結果Full Route Cacheが無効になります；

```jsx
revalidatePath('/')
```

達成しようとしているものに応じて、次の2か所で`revalidatePath`を使用できます；

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティイベント（例：Webhook）に応じてデータを再検証します；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザー操作（例：フォーム送信、ボタンのクリック）後にデータを再検証します；

詳しくは[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)を参照してください。

> **`revalidatePath`** vs. **`router.refresh`**:
>
> `router.refresh`を呼び出すと、Router Cacheがクリアされ、Data CacheやFull Route Cacheを無効にせずにサーバー上でルートセグメントが再レンダリングされます；
>
> 違いは`revalidatePath`がData CacheとFull Route Cacheをパージするのに対して、`router.refresh()`はData CacheとFull Route Cacheを変更しません；

### Dynamic API {#dynamic-apis}

`cookies`や`headers`のような動的API、ページ内の`searchParams`プロップは、実行時のリクエスト情報に依存します。これらを使用すると、ルートはFull Route Cacheからオプトアウトされる、つまり、ルートは動的にレンダリングされます。

#### `cookies` {#cookies}

Server Actionで`cookies.set`または`cookies.delete`を使用すると、クッキーを使用するルートが古くならないようにRouter Cacheを無効にします（例：認証の変更を反映するため）。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照してください。

### Segment Config Options {#segment-config-options}

Route Segment Configオプションは、ルートセグメントのデフォルトを上書きするか、`fetch` APIを使用できない場合などに使用できます（例：データベースおよびサードパーティライブラリ）。

次のルートセグメント設定オプションは、Full Route Cacheからオプトアウトします；

- `const dynamic = 'force-dynamic'`

この設定オプションは、Data Cacheからすべてのフェッチをオプトアウトします（つまり、`no-store`に）；

- `const fetchCache = 'default-no-store'`

詳細なオプションは[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)を参照してください。

さらに、[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)のドキュメントを参照してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）では、`generateStaticParams`によって提供されたパスはビルド時にFull Route Cacheにキャッシュされます。要求時、Next.jsは訪問された初回時にビルド時に知られていなかったパスもキャッシュします。

ビルド時にすべてのパスを静的にレンダリングするには、パスの完全なリストを`generateStaticParams`に提供します；

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスの一部のセットを静的にレンダリングし、残りを実行時に訪問された初回でレンダリングするには、部分的なパスのリストを返します；

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // ビルド時に最初の10件の投稿をレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

すべてのパスを実行時に訪問された初回で静的にレンダリングするには、空の配列を返します（ビルド時にパスはレンダリングされません）または[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を使用します；

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`からは空でも配列を返す必要があります。そうしないとルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

要求時にキャッシュを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。この設定オプションが使用されると、`generateStaticParams`で提供されたパスのみが提供され、他のルートは404になります（ただし、[catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合は例外）。

### React `cache`関数 {#react-cache-function}

React `cache`関数は、関数の戻り値をメモ化し、同じ関数を複数回呼び出しながら1回だけ実行させることを可能にします。

`fetch`リクエストは自動的にメモ化されるため、React `cache`でそれをラップする必要はありません。 ただし、`fetch` APIが適さないユースケース（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）のデータリクエストを手動でメモ化するために`cache`を使用できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
