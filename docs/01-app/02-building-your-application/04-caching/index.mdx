---
title: 'Next.jsにおけるキャッシング'
nav_title: 'キャッシング'
description: 'Next.jsにおけるキャッシングメカニズムの概要。'
---

Next.jsは、レンダリングの作業やデータリクエストをキャッシュすることで、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシングメカニズムについて詳しく説明し、それらを構成するためのAPIと、それらがどのように相互作用するかを解説します。

> **知っておくと良い情報**: このページは、Next.jsの内部動作を理解するのに役立ちますが、Next.jsを効果的に使用するための必須知識ではありません。ほとんどのNext.jsのキャッシングは、使用するAPIによって決定され、最小限の設定で最適なパフォーマンスを得るためのデフォルトが設定されています。例をすぐに見たい場合は[こちらをクリックして開始してください](/docs/app/building-your-application/data-fetching/fetching)。

## 概要 {#overview}

以下は、さまざまなキャッシングメカニズムとその目的の概要です：

| メカニズム                                  | 内容                | 場所         | 目的                                           | 期間                               |
| ------------------------------------------- | ------------------- | ------------ | ---------------------------------------------- | ---------------------------------- |
| [Request Memoization](#request-memoization) | 関数の返り値        | サーバー     | React Component treeでのデータ再利用           | リクエストごとのライフサイクル     |
| [Data Cache](#data-cache)                   | データ              | サーバー     | ユーザーリクエストやデプロイを超えたデータ保持 | 永続的（再検証可能）               |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバー     | レンダリングコスト削減とパフォーマンス向上     | 永続的（再検証可能）               |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時のサーバーリクエスト削減       | ユーザーセッションまたは時間ベース |

デフォルトでは、Next.jsはパフォーマンス向上とコスト削減のために可能な限りキャッシュします。これは、ルートが**静的にレンダリング**され、データリクエストが**キャッシュされる**ことを意味しますが、これを選ばないこともできます。以下の図は、ビルド時にルートが静的にレンダリングされ、静的ルートが最初に訪問されたときの、デフォルトのキャッシング動作を示しています。

<Image
  alt="Next.jsにおける4つのメカニズムに対するデフォルトのキャッシング動作を示す図。ビルド時間とルートが初めて訪問されたときのHIT、MISS、SETを示している。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシング動作は、ルートが静的にレンダリングされるか動的にレンダリングされるか、データがキャッシュされているかキャッシュされていないか、初回訪問かそれ以降のナビゲーションかによって変わります。利用ケースによって、個別のルートやデータリクエストのキャッシング動作を構成できます。

## Request Memoization {#request-memoization}

Reactは、同じURLとオプションを持つリクエストを自動的に**メモ化**するために[`fetch` API](#fetch)を拡張します。つまり、同じデータのfetch関数をReact component treeの複数の場所で呼び出すことが可能であり、それを1回だけ実行します。

<Image
  alt="デデュプリケートされたFetchリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

たとえば、ルート全体（例：Layout、Page、および複数のコンポーネント）で同じデータを使用する必要がある場合、treeのトップでデータをフェッチする必要はなく、コンポーネント間でpropsを転送します。代わりに、必要なコンポーネント内でデータをフェッチし、同じデータをネットワークを超えて複数のリクエストを行うことのパフォーマンスへの影響を心配することなく実行できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果がキャッシュされる
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2番目の呼び出しはルート内のどこでも行うことができます
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch`関数は自動的にメモ化され、結果がキャッシュされる
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼ばれますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2番目の呼び出しはルート内のどこでも行うことができます
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoizationの動作**

<Image
  alt="Reactレンダリング中にfetchのメモ化がどのように機能するかを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングしている間、特定のリクエストが初めて呼び出されたとき、その結果はメモリに存在せず、キャッシュ`MISS`となります；
- したがって、関数が実行され、外部ソースからデータがフェッチされ、その結果がメモリに保存されます；
- 同じレンダリングパス内での後続の呼び出しはキャッシュ`HIT`となり、関数を実行せずにデータをメモリから返します；
- ルートのレンダリングが完了し、レンダリングパスが完了すると、メモリが「リセット」され、すべてのメモ化エントリがクリアされます；

> **知っておくと良い情報**:
>
> - Request MemoizationはReactの機能であり、Next.jsの機能ではありません。ここでは、他のキャッシングメカニズムとの相互作用を示すために含まれています；
> - メモ化は`fetch`リクエストの`GET`メソッドにのみ適用されます；
> - メモ化はReact Component treeにのみ適用されます。つまり：
>   - `fetch` リクエストが`generateMetadata`、`generateStaticParams`、Layouts、Pages、他のServer Componentsでの`fetch`リクエストに適用されます；
>   - Route Handlersでの`fetch`リクエストには適用されません。これらはReact Component treeの一部ではありません；
> - `fetch`が適していない場合（など。一部のデータベースクライアント、CMSクライアント、GraphQLクライアント）では、[React `cache` 関数](#react-cache-function)を使用して関数をメモ化できます；

### 期間 {#duration}

キャッシュはサーバリクエストの期間中、 React component treeのレンダリングが完了するまで持続します；

### 再検証 {#revalidating}

メモ化はサーバリクエスト全体で共有されず、レンダリング中にのみ適用されるため、再検証する必要はありません；

### オプトアウト {#opting-out}

メモ化は `fetch`リクエストの`GET`メソッドにのみ適用され、他のメソッド、例えば`POST`や`DELETE`はメモ化されません。このデフォルトの動作はReact最適化であり、オプトアウトを推奨しません；

個別のリクエストを管理するには、[`AbortController`](https://developer.mozilla.org/ja/docs/Web/API/AbortController)から[`signal`](https://developer.mozilla.org/ja/docs/Web/API/AbortController/signal) プロパティを使用できます。ただし、これはリクエストをメモ化からオプトアウトするものではなく、インフライトリクエストを中止します；

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには、入ってくる**サーバリクエスト**や**デプロイ**を通じてデータフェッチの結果を**永続化**するための組み込みのData Cacheが存在します。これは、Next.jsがネイティブの`fetch`APIを拡張し、サーバーでの各リクエストが独自の永続的なキャッシュセマンティクスを設定できるようにすることで可能になります。

> **知っておくと良い情報**: ブラウザでは`fetch`の`cache`オプションはブラウザのHTTPキャッシュとどのように相互作用するかを示しますが、Next.jsでは、サーバー側のリクエストがサーバーのData Cacheとどのように相互作用するかを示します；

[`cache`](#fetch-optionscache)と[`next.revalidate`](#fetch-optionsnextrevalidate)オプションを使用して、`fetch`のキャッシュ動作を構成できます。

**How the Data Cache Works**

<Image
  alt="キャッシュと未キャッシュのfetchリクエストがData Cacheとどのように相互作用するかを示す図。キャッシュリクエストはData Cacheに保存され、メモ化され、未キャッシュリクエストはデータソースからフェッチされ、Data Cacheに保存されず、メモ化される。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- `fetch`リクエストがレンダリング中に`'force-cache'`オプションを使用して初めて呼ばれたとき、Next.jsはキャッシュされたレスポンスを探すためにData Cacheを確認します；
- キャッシュされたレスポンスが見つかれば、直ちに返され[メモ化](#request-memoization)されます；
- キャッシュされたレスポンスが見つからなければ、リクエストはデータソースに対して行われ、結果はData Cacheに保存され、メモ化されます；
- 未キャッシュデータの場合（例：`cache`オプションが定義されていない、または`{ cache: 'no-store' }`使用）、結果は常にデータソースからフェッチされ、メモ化されます；
- データがキャッシュされているか未キャッシュであれ、リクエストは常にメモ化され、同じデータの重複したリクエストがReactレンダリングパスで行われることを避けます；

> **Data CacheとRequest Memoizationの違い**
>
> 両方のキャッシュメカニズムはキャッシュされたデータを再利用することでパフォーマンスを向上させますが、Data Cacheはリクエスト全体とデプロイを通じて永続的であるのに対して、メモ化はリクエストのライフタイムの間だけ持続します。

### 期間 {#duration}

Data Cacheは、再検証やオプトアウトしない限り、入ってくるリクエストとデプロイを超えて永続的です；

### 再検証 {#revalidating}

キャッシュされたデータは次の2つの方法で再検証できます：

- **時間ベースの再検証**：一定時間が経過し、新たなリクエストが行われた後にデータを再検証します。これは滅多に変更されないデータで、鮮度がそれほど重要でない場合に便利です；
- **オンデマンドの再検証**：イベント（例：フォーム送信）に基づいてデータを再検証します。オンデマンドの再検証は、データのグループを一度に再検証するためのタグベースまたはパスベースのアプローチを使用できます。これは、ヘッドレスCMSからのコンテンツが更新された際に最新のデータをできるだけ早く表示したい場合に役立ちます；

#### 時間ベースの再検証 {#time-based-revalidation}

タイミング間隔でデータを再検証するには、`fetch`の`next.revalidate`オプションを使用してリソースのキャッシュ有効期間（秒単位）を設定できます；

```js
// 最大1時間ごとに再検証
fetch('https://...', { next: { revalidate: 3600 } })
```

また、[Route Segment Config options](#segment-config-options) を使用して、セグメント内の全ての`fetch`リクエストを構成することもできます；

**How Time-based Revalidation Works**

<Image
  alt="時間ベースの再検証が機能する方法を示す図。再検証期間後、最初のリクエストでは古いデータが返され、その後、データが再検証されます。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`付きのfetchリクエストが初めて呼ばれたとき、データは外部データソースからフェッチされ、Data Cacheに保存されます；
- 指定された期間内（例：60秒）のいずれのリクエストもキャッシュされたデータを返します；
- フレームの後に、次のリクエストはまだキャッシュされている（今では古い）データを返します；
  - Next.jsはバックグラウンドでデータの再検証をトリガーします；
  - データが正常にフェッチされると、Next.jsは新しいデータでData Cacheを更新します；
  - バックグラウンド再検証が失敗した場合、前のデータが変更されずに残ります；

これは[**stale-while-revalidate**](https://web.dev/ja/stale-while-revalidate/) 行動に似ています；

#### オンデマンドの再検証 {#on-demand-revalidation}

データは、パス（[`revalidatePath`](#revalidatepath)）またはキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）でオンデマンドに再検証できます；

**How On-Demand Revalidation Works**

<Image
  alt="オンデマンド再検証がどのように機能するかを示す図。再検証リクエスト後、Data Cacheは新しいデータで更新されます。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼ばれたとき、データは外部データソースからフェッチされ、Data Cacheに保存されます；
- オンデマンドの再検証がトリガーされたとき、適切なキャッシュエントリはキャッシュから消去されます；
  - これは時間ベースの再検証とは異なり、新しいデータがフェッチされるまで古いデータをキャッシュに保持します；
- 次にリクエストが行われたとき、それは再びキャッシュ`MISS`となり、データは外部データソースからフェッチされ、Data Cacheに保存されます；

### オプトアウト {#opting-out}

`fetch`からのレスポンスを**キャッシュしたくない場合**、以下のことを行うことができます：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連用語**：
>
> あなたは、**Automatic Static Optimization**、**Static Site Generation**、または**Static Rendering**を、アプリケーションのルートをビルド時にレンダリングしキャッシュするプロセスを指して互換的に使われているのを見るかもしれません。

Next.jsはルートをビルド時に自動的にレンダリングしキャッシュします。これは、ルートをレンダリングすることでなく、キャッシュされたルートを提供することができる最適化であり、これによりより速いページロードを実現できます。

Full Route Cacheがどのように機能するかを理解するには、Reactがレンダリングをどのように処理するか、そしてNext.jsがその結果をどのようにキャッシュするかを考えると役立ちます。

### 1. サーバにおけるReactのレンダリング {#1-react-rendering-on-the-server}

サーバーでは、Next.jsはReactのAPIを使用してレンダリングを管理します。レンダリング作業は、個別のルートセグメントとSuspense boundaryによって分割されます。

各チャンクは次の2ステップでレンダリングされます：

1. Reactがサーバコンポーネントを特別なデータフォーマットにレンダリングし、ストリーミングに最適化された**Reactサーバコンポーネントペイロード**と呼ばれる状態にします。
2. Next.jsはReactサーバコンポーネントペイロードとクライアントコンポーネントのJavaScript指示を使用してサーバー上で**HTML**をレンダリングします。

つまり、作業をキャッシュしたりレスポンスを送信する前にすべてのレンダリングが完了するまで待つ必要はありません。代わりに、作業が完了するにつれてレスポンスをストリームできます。

> **Reactサーバコンポーネントペイロードとは？**
>
> Reactサーバコンポーネントペイロードは、レンダリングされたReactサーバコンポーネントtreeのコンパクトなバイナリ表現です。これは、クライアント上のReactによってブラウザのDOMを更新するために使用されます。Reactサーバコンポーネントペイロードには以下が含まれます：
>
> - サーバコンポーネントのレンダリング結果
> - クライアントコンポーネントがどのようにレンダリングされ参照されるべきかのプレースホルダとJavaScriptファイルへの参照
> - サーバコンポーネントからクライアントコンポーネントに渡されたすべてのprops
>
> 詳しくは、[Server Components](/docs/app/building-your-application/rendering/server-components)ドキュメントを参照してください。

### 2. サーバでのNext.jsキャッシング（Full Route Cache）{#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="完全なルートキャッシュのデフォルトの動作。静的にレンダリングされたルートのサーバーでReactサーバコンポーネントペイロードとHTMLがキャッシュされている様子を示しています。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの動作は、サーバー上のルートのレンダリング結果（ReactサーバコンポーネントペイロードとHTML）をキャッシュすることです。これは、ビルド時や再検証中に静的にレンダリングされたルートに適用されます。

### 3. クライアントでのReactハイドレーションと調整 {#3-react-hydration-and-reconciliation-on-the-client}

リクエスト時に、クライアントで：

1. HTMLは、クライアントおよびサーバコンポーネントのために、インタラクティブでない高速な初期プレビューを即座に表示するために使用されます。
2. Reactサーバコンポーネントペイロードは、クライアントとレンダリングされたサーバコンポーネントtreeを調整し、DOMを更新するために使用されます。
3. JavaScript命令は、クライアントコンポーネントを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにするために使用されます。

### 4. クライアントでのNext.jsキャッシング（Router Cache）{#4-next-js-caching-on-the-client-router-cache}

Reactサーバコンポーネントペイロードは、クライアント側の[Router Cache](#client-side-router-cache)に保存されます。これは、個別のルートセグメントごとに分割された別個のインメモリキャッシュです。このRouter Cacheは、以前に訪問したルートを保存し、将来のルートを事前取得することによって、ナビゲーションエクスペリエンスを向上させるために使用されます。

### 5. 以降のナビゲーション {#5-subsequent-navigations}

以降のナビゲーション時または事前取得時に、Next.jsは、ReactサーバコンポーネントペイロードがRouter Cacheに保存されているかどうかを確認します。保存されている場合は、新しいリクエストをサーバーに送信することを省略します；

もしルートセグメントがキャッシュされていない場合、Next.jsはサーバーからReactサーバコンポーネントペイロードをフェッチし、クライアント上のRouter Cacheを更新します。

### 静的および動的レンダリング {#static-and-dynamic-rendering}

ビルド時にルートがキャッシュされるか否かは、それが静的レンダリングされているか動的レンダリングされているかによります。静的ルートはデフォルトでキャッシュされますが、動的ルートはリクエスト時にレンダリングされ、キャッシュされません。

この図は、静的レンダリングと動的レンダリングされたルートの違いを、キャッシュされたおよびされていないデータと共に示しています：

<Image
  alt="静的および動的レンダリングがFull Route Cacheにどのように影響するかを示す図。静的ルートはビルド時またはデータの再検証後にキャッシュされますが、動的ルートは決してキャッシュされません"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)について詳しく学びましょう。

### 期間 {#duration}

デフォルトでは、Full Route Cacheは永続的です。これは、レンダリング出力がユーザーリクエストを超えてキャッシュされることを意味します；

### 無効化 {#invalidation}

Full Route Cacheを無効にする方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**: [Data Cache](#data-cache)を再検証すると、サーバー上でコンポーネントを再レンダリングし、新しいレンダリング出力をキャッシュすることで、Router Cacheが無効になります；
- **再デプロイ**: Data Cacheとは異なり、新しいデプロイ時にFull Route Cacheはクリアされます；

### オプトアウト {#opting-out}

Full Route Cacheからオプトアウト、または言い換えれば、すべての着信リクエストに対してコンポーネントを動的にレンダリングするには、次のことを行うことができます：

- **[Dynamic API](#dynamic-apis)を使用**: これにより、Full Route Cacheからルートがオプトアウトされ、リクエスト時に動的にレンダリングされます。 Data Cacheはまだ使用できます；
- **`dynamic = 'force-dynamic'`または`revalidate = 0`ルートセグメント構成オプションを使用**: これにより、Full Route CacheおよびData Cacheをスキップします。つまり、コンポーネントはサーバーへの各着信リクエストでレンダリングされ、データがフェッチされます。Router Cacheはまだ適用されますが、これはクライアント側のキャッシュです；
- **[Data Cache](#data-cache)からオプトアウト**: キャッシュされていない`fetch` リクエストを持つルートがある場合、これによりそのルートはFull Route Cacheからオプトアウトされます。 特定の`fetch`リクエストのデータは、着信リクエストごとにフェッチされます。キャッシュオプションをオプトアウトしていない他の`fetch`リクエストは、Data Cacheにキャッシュされ続けます。これにより、キャッシュされたデータと未キャッシュのデータのハイブリッドが可能になります；

## クライアント側のRouter Cache {#client-side-router-cache}

Next.jsには、レイアウト、ロード中の状態、ページごとに分けてルートセグメントのRSCペイロードを格納するインメモリのクライアントサイドルーターキャッシュが存在します。

ユーザーがルートの間をナビゲートする際、Next.jsは訪問したルートセグメントをキャッシュし、ユーザーがナビゲートする可能性が高いルートを[事前取得](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、瞬時のバック/フォワードナビゲーション、ナビゲーション間のフルページリロードなし、React状態とブラウザ状態の保持が可能になります。

Router Cacheを使用すると：

- **レイアウト**はキャッシュされ、ナビゲーションで再利用されます（[部分的レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）；
- **ロード中の状態**はキャッシュされ、[インスタントナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のためにナビゲーション時に再利用されます；
- **ページ**はデフォルトでキャッシュされませんが、ブラウザのバックとフォワードナビゲーション時に再利用されます。ページセグメントのキャッシュを有効にするには、実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)構成オプションを使用できます。

{/* TODO: v15の挙動に一致するように図を更新する */}

> **知っておくと良い情報**: このキャッシュはNext.jsとサーバコンポーネントに特に適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なる結果を持ちますが、似た結果を持ちます。

### 期間 {#duration}

キャッシュはブラウザの一時メモリに保存されます。ルーターキャッシュが持続する時間を決定する要因は2つあります：

- **セッション**: キャッシュはナビゲーション中に持続します。ただし、ページリフレッシュ時にクリアされます；
- **自動無効化期間**: レイアウトやロード中の状態のキャッシュは特定の時間が経過すると自動的に無効になります。この期間は、そのリソースがどのように[事前取得](/docs/app/api-reference/components/link#prefetch)されたか、そしてそのリソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかどうかによって異なります：
  - **デフォルトの事前取得** (`prefetch={null}` または指定しない場合): 動的ページの場合キャッシュされず、静的ページの場合は5分間；
  - **フル事前取得** (`prefetch={true}` または`router.prefetch`): 静的および動的ページの両方で5分間；

ページリフレッシュは**すべての**キャッシュされたセグメントをクリアしますが、自動無効化期間は、事前取得された個別のセグメントのみを影響します。

> **知っておくと良い情報**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)構成オプションを使用して、上記の自動無効化時間を調整することができます。

### 無効化 {#invalidation}

Router Cacheを無効にする方法は2つあります：

- **サーバーアクション**で：
  - パスごとにオンデマンドでデータを再検証する（[`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)を使用）または、キャッシュタグから（[`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)を使用）
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用すると、クッキーを使用するルートが古くならないようにRouter Cacheを無効にします（例：認証の場合）；
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すと、Router Cacheが無効になり、現在のルートに対する新しいリクエストがサーバーに送信されます；

### オプトアウト {#opting-out}

現時点でNext.js 15では、ページセグメントはデフォルトでオプトアウトされています；

> **知っておくと良い情報**: `<Link>`コンポーネントの`prefetch`propを`false`に設定することで、[事前取得](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)をオプトアウトできます。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシングメカニズムを構成する際、相互にどのように影響を受けるかを理解することが重要です。

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheの再検証またはオプトアウトを行うことで、レンダリング出力がデータに依存するため、Full Route Cacheは無効になります；
- Full Route Cacheの無効化またはオプトアウトは、Data Cacheに影響を与えません。キャッシュされたデータと未キャッシュのデータが両方あるルートを動的にレンダリングできます。これにより、ページのほとんどがキャッシュされたデータを使用しているが、一部のコンポーネントがリクエスト時にフェッチする必要があるデータに依存する場合に便利です。すべてのデータを再フェッチするパフォーマンスの影響を気にせずに動的にレンダリングできます；

### Data Cacheとクライアント側Router Cache {#data-cache-and-client-side-router-cache}

- Data CacheとRouter Cacheをすぐに無効化するには、サーバーアクション内で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用します；
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)でData Cacheを再検証するとRouter Cacheは直ちに無効にはなりません。Router Handlerが特定のルートに結びついていないため、Router Cacheはハードリフレッシュまたは自動無効化期間が経過するまで前のペイロードを提供し続けます。

## API {#apis}

次のテーブルは異なるNext.js APIがキャッシュにどのように影響を与えるかの概要を示しています：

| API                                                                       | Router Cache               | Full Route Cache      | Data Cache            | React Cache |
| ------------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                                | Cache                      |                       |                       |             |
| [`router.prefetch`](#router-prefetch)                                     | Cache                      |                       |                       |             |
| [`router.refresh`](#router-refresh)                                       | Revalidate                 |                       |                       |             |
| [`fetch`](#fetch)                                                         |                            |                       | Cache                 | Cache       |
| [`fetch` `options.cache`](#fetch-options-cache)                           |                            |                       | Cache or Opt out      |             |
| [`fetch` `options.next.revalidate`](#fetch-options-next-revalidate)       |                            | Revalidate            | Revalidate            |             |
| [`fetch` `options.next.tags`](#fetch-options-next-tags-and-revalidatetag) |                            | Cache                 | Cache                 |             |
| [`revalidateTag`](#fetch-options-next-tags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`revalidatePath`](#revalidatepath)                                       | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`const revalidate`](#segment-config-options)                             |                            | Revalidate or Opt out | Revalidate or Opt out |             |
| [`const dynamic`](#segment-config-options)                                |                            | Cache or Opt out      | Cache or Opt out      |             |
| [`cookies`](#cookies)                                                     | Revalidate (Server Action) | Opt out               |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                                |                            | Opt out               |                       |             |
| [`generateStaticParams`](#generate-static-params)                         |                            | Cache                 |                       |             |
| [`React.cache`](#react-cache-function)                                    |                            |                       |                       | Cache       |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)      |                            |                       | Cache                 |             |

### `<Link>` {#link}

デフォルトでは、`<Link>`コンポーネントは自動的にFull Route Cacheからのルートを事前取得し、ReactサーバコンポーネントペイロードをRouter Cacheに追加します。

事前取得を無効にするには、`prefetch`propを`false`に設定できます。しかし、これはキャッシュを永続的にスキップするわけではなく、ユーザーがルートを訪問したときにルートセグメントはクライアント側でキャッシュされます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)についてさらに学びましょう。

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションは、ルートを手動で事前取得するために使用でき、これによりReactサーバコンポーネントペイロードがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router) APIリファレンスを参照してください。

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使用すると、ルートを手動で更新することができ、これはRouter Cacheを完全にクリアし、現在のルートのサーバーへの新しいリクエストを行います。`refresh`はData CacheやFull Route Cacheに影響を与えません。

レンダリングされた結果は、React状態やブラウザ状態を保持しながら、クライアント側で調整されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router) APIリファレンスを参照してください。

### `fetch` {#fetch}

`fetch`から戻されたデータはData Cacheに自動的にキャッシュされません。

`fetch`のデフォルトのキャッシュ動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定と同じです：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。他のオプションについても記載されています。

### `fetchの`options.cache` {#fetch-options-cache}

`cache`オプションを`force-cache`に設定することで、個々の`fetch`をキャッシュにオプトインできます：

```jsx
// キャッシュにオプトイン
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。他のオプションについても記載されています。

### `fetchの`options.next.revalidate` {#fetch-options-next-revalidate}

`fetch`の`next.revalidate`オプションを使用して、個々の`fetch`リクエストの再検証期間（秒単位）を設定できます。これにより、Data Cacheが再検証され、それがFull Route Cacheも再検証します。新鮮なデータがフェッチされ、そのコンポーネントがサーバー上で再レンダリングされます。

```jsx
// 最大1時間後に再検証
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)を参照してください。他のオプションについても記載されています。

### `fetchの`options.next.tags`および`revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、細かいデータキャッシュと再検証のためのキャッシュタグシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)内で、キャッシュエントリを一つ以上のタグでタグ付けするオプションがあります。
2. それから、`revalidateTag`を呼び出して、そのタグに関連するキャッシュエントリをパージできます。

例えばデータをフェッチする際にタグを設定できます：

```jsx
// タグ付きでデータをキャッシュ
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

そして特定のタグでキャッシュエントリをパージするために`revalidateTag`を呼び出します：

```jsx
// 特定のタグでエントリを再検証
revalidateTag('a')
```

`revalidateTag`を使用する場所は、達成したい目的に応じて次の2つがあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - 第三者のイベント（例：webhook）の応答でデータを再検証します。これはRouter Cacheを直ちに無効にはしません。ルーターハンドラーが特定のルートに結びついていないためです。
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーのアクション（例：フォーム送信）の後にデータを再検証します。これにより、関連するルートのRouter Cacheが無効になります。

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使うと、特定のパス以下のルートセグメントを再検証し、再レンダリングするように手動でデータを再検証できます。`revalidatePath`メソッドを呼び出すことで、Data Cacheが再検証され、それに伴いFull Route Cacheが無効化されます。

```jsx
revalidatePath('/')
```

`revalidatePath`を使用する場所は、達成したい目的に応じて次の2つがあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - 第三者のイベント（例：webhook）の応答でデータを再検証します；
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーのアクション（例：フォーム送信、ボタンクリック）の後にデータを再検証します；

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)を参照してください。より詳しい情報が記載されています。

> **`revalidatePath`**対**`router.refresh`**:
>
> `router.refresh`を呼び出すと、Router Cacheをクリアし、Data CacheやFull Route Cacheを無効にせずにサーバー上でルートセグメントを再レンダリングします。
>
> 違いは、`revalidatePath`がData CacheとFull Route Cacheをパージするのに対し、`router.refresh()`は、クライアント側APIとしてData CacheとFull Route Cacheを変更しません。

### 動的API {#dynamic-apis}

`cookies`や`headers`などの動的APIおよびPagesの中の`searchParams`プロップは、ランタイムの着信リクエスト情報に依存しています。これを使用すると、ルートはFull Route Cacheから外れ、ルートが動的にレンダリングされます。

#### `cookies` {#cookies}

サーバーアクション内で`cookies.set`または `cookies.delete`を使用すると、クッキーを使用するルートが古くならないようにRouter Cacheを無効にします（例：認証の変更を反映するため）。

[`cookies`](/docs/app/api-reference/functions/cookies) APIリファレンスを参照してください。

### セグメント構成オプション {#segment-config-options}

Route Segment Configのオプションは、ルートセグメントのデフォルトを上書きするか、`fetch`APIを使用できない場合（例：データベースクライアントまたはサードパーティライブラリ）に使用できます。

Full Route Cacheからオプトアウトするための以下のRoute Segment Configオプションがあります：

- `const dynamic = 'force-dynamic'`

この構成オプションは、全てのフェッチからData Cacheをオプトアウトします（例：`no-store`）：

- `const fetchCache = 'default-no-store'`

[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントを参照してください。他のオプションも記載されています。

### `generateStaticParams` {#generate-static-params}

[ダイナミックセグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）の場合、 `generateStaticParams`によって提供されたパスはビルド時にFull Route Cacheにキャッシュされます。リクエスト時には、Next.jsはビルド時に知られなかったパスもキャッシュし、初めて訪問されたときにキャッシュします。

ビルド時にすべてのパスを静的にレンダリングするには、完全なパスリストを`generateStaticParams`に提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

ビルド時にパスのサブセットを静的レンダリングし、実行時に最初に訪問されたときに残りをレンダリングするには、パスの部分リストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // ビルド時に最初の10件の投稿をレンダリングします
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

すべてのパスを初めて訪問されたときに静的にレンダリングするために、空の配列を返す（ビルド時にパスはレンダリングされません）か、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic) を使用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **知っておくと良い情報**: `generateStaticParams`からは、たとえ空の配列でも配列を返す必要があります。そうでなければ、ルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時のキャッシュを無効にするには、ルートセグメントに`export const dynamicParams = false`オプションを追加します。この構成オプションを使用すると、`generateStaticParams`によって提供されたパスのみが提供され、他のルートは404または一致（[catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合）します。

### React `cache` 関数 {#react-cache-function}

React `cache` 関数は、関数の返り値をメモ化し、同じ関数を複数回呼び出しながら、1回だけ実行することを許可します。

`fetch` リクエストは自動的にメモ化されるため、React `cache`でラップする必要はありません。ただし、`fetch` APIが適さないユースケースの場合、`cache` を使用して手動でデータリクエストをメモ化できます。例えば、一部のデータベースクライアント、CMSクライアント、GraphQLクライアントです。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
