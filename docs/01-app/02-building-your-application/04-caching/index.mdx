---
title: 'Next.jsにおけるキャッシング'
nav_title: 'キャッシング'
description: 'Next.jsにおけるキャッシングメカニズムの概要。'
---

Next.jsは、レンダリング作業やデータリクエストをキャッシュすることによって、アプリケーションのパフォーマンスを向上させ、コストを削減します。このページでは、Next.jsのキャッシングメカニズムの詳細、設定可能なAPI、それらがどのように相互に作用するかを紹介します。

> **Good to know**: このページは、Next.jsの内部動作を理解するのに役立ちますが、Next.jsで生産的に作業するためには必須の知識ではありません。Next.jsのほとんどのキャッシングのヒューリスティックスは、APIの使用方法によって決まり、ゼロまたは最小限の設定で最高のパフォーマンスを発揮するデフォルト設定があります。 もし例を見たい場合は、[こちら](/docs/app/building-your-application/data-fetching/fetching)を参照してください。

## 概要 {#overview}

以下は、異なるキャッシングメカニズムとその目的の概要です：

| メカニズム                                  | 内容                | 場所         | 目的                                                   | 期間                           |
| ------------------------------------------- | ------------------- | ------------ | ------------------------------------------------------ | ------------------------------ |
| [Request Memoization](#request-memoization) | 関数の戻り値        | サーバー     | React Component tree内でデータを再利用                 | リクエストライフサイクル全体   |
| [Data Cache](#data-cache)                   | データ              | サーバー     | ユーザーリクエストとデプロイメントを超えてデータを保存 | 永続的（再検証可能）           |
| [Full Route Cache](#full-route-cache)       | HTMLとRSCペイロード | サーバー     | レンダリングコストを削減し、パフォーマンスを向上       | 永続的（再検証可能）           |
| [Router Cache](#client-side-router-cache)   | RSCペイロード       | クライアント | ナビゲーション時にサーバーリクエストを削減             | ユーザーセッションや時間ベース |

デフォルトで、Next.jsはパフォーマンスを向上させ、コストを削減するために可能な限りキャッシュします。これは、ルートが**静的にレンダリング**され、データリクエストが**キャッシュされる**ということを意味します。次の図は、ビルド時と静的ルートが最初に訪問されたときのデフォルトのキャッシング動作を示しています。

<Image
  alt="Next.jsにおける4つのメカニズムのデフォルトキャッシュ動作を示す図。ビルド時とルートが最初に訪問されたときにHIT、MISS、SETが表示される。"
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

キャッシングの動作は、ルートが静的または動的にレンダリングされるか、データがキャッシュされるかされないか、リクエストが最初の訪問か、後続のナビゲーションの一部かによって変わります。ユースケースに応じて、個々のルートやデータリクエストのキャッシング動作を設定できます。

## Request Memoization {#request-memoization}

Reactは[`fetch` API](#fetch)を拡張して、同じURLとオプションを持つリクエストを自動的に**メモ化**します。これにより、React component treeの複数個所で同じデータに対してfetch関数を呼び出しても、それが一度だけ実行されます。

<Image
  alt="重複排除されたFetchリクエスト"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

たとえば、ルート全体で同じデータを使用する必要がある場合（例：Layout、Page、および複数のコンポーネントで）、ツリーの上位でデータを取得し、コンポーネント間でpropsを転送する必要はありません。その代わりに、必要なデータを必要なコンポーネント内で取得し、ネットワークを介して同じデータに対して複数のリクエストを行うことによるパフォーマンスへの影響を心配する必要はありません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example.tsx" switcher
async function getItem() {
  // `fetch` 関数は自動的にメモ化され、その結果がキャッシュされる
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルート内のどこにでもできます
const item = await getItem() // cache HIT
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example.js" switcher
async function getItem() {
  // `fetch` 関数は自動的にメモ化され、その結果がキャッシュされる
  const res = await fetch('https://.../item/1')
  return res.json()
}

// この関数は2回呼び出されますが、最初の1回だけ実行されます
const item = await getItem() // cache MISS

// 2回目の呼び出しはルート内のどこにでもできます
const item = await getItem() // cache HIT
```

</TabItem>
</Tabs>

**Request Memoizationの仕組み**

<Image
  alt="Reactレンダリング中のfetchメモ化の仕組みを示す図。"
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- ルートをレンダリングしている間、特定のリクエストが初めて呼び出されたとき、その結果はメモリに存在せず、キャッシュ`MISS`になります。
- そのため、関数が実行され、外部ソースからデータが取得され、結果はメモリに保存されます。
- 同じレンダリングパス内の後続のリクエストの関数呼び出しはキャッシュ`HIT`となり、関数を実行せずにメモリからデータが返されます。
- ルートがレンダリングされ、レンダリングパスが完了すると、メモリは「リセット」され、すべてのrequest memoizationのエントリがクリアされます。

> **Good to know**:
>
> - Request memoizationはReactの機能であり、Next.jsの機能ではありません。他のキャッシングメカニズムとどのように相互作用するかを示すためにここに含まれています。
> - メモ化は`fetch`リクエストの`GET`メソッドにのみ適用されます。
> - メモ化はReact Component treeにのみ適用されます。つまり、次のようになります：
>   - `generateMetadata`、`generateStaticParams`、Layouts、Pages、およびその他のServer Components内の`fetch`リクエストに適用されます。
>   - Route Handler内の`fetch`リクエストには適用されません。これらはReact component treeの一部ではないためです。
> - `fetch`が適していない場合（例：一部のデータベースクライアント、CMSクライアント、またはGraphQLクライアント）、関数をメモ化するために[React `cache`関数](#react-cache-function)を使用できます。

### 期間 {#duration}

キャッシュはReact component treeのレンダリングが完了するまで、サーバーリクエストのライフタイムにわたって持続します。

### 再検証 {#revalidating}

メモ化はサーバーリクエスト間で共有されず、レンダリング中にのみ適用されるため、再検証は不要です。

### オプトアウト {#opting-out}

メモ化は`fetch`リクエストの`GET`メソッドにのみ適用され、`POST`や`DELETE`などの他のメソッドはメモ化されません。このデフォルトの動作はReactの最適化であり、これをオプトアウトすることはお勧めしません。

個々のリクエストを管理するために、[`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)から[`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal)プロパティを使用できます。ただし、これによりリクエストのメモ化からはオプトアウトされません。代わりに、飛行中のリクエストを中止します。

```js title="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Data Cache {#data-cache}

Next.jsには、**サーバーリクエスト**および**デプロイメント**を超えてデータフェッチの結果を**永続化**する組み込みのData Cacheがあります。これは、Next.jsがネイティブの`fetch` APIを拡張し、サーバー上の各リクエストが独自の永続的なキャッシュ係数を設定できるようにすることで可能になります。

> **Good to know**: ブラウザでは、`fetch`の`cache`オプションはリクエストがブラウザのHTTPキャッシュとどのように相互作用するかを示します。Next.jsでは、`cache`オプションはサーバーサイドリクエストがサーバーのData Cacheとどのように相互作用するかを示します。

[`cache`](#fetch-optionscache)および[`next.revalidate`](#fetch-optionsnextrevalidate)の`fetch`オプションを使用してキャッシング動作を設定できます。

**Data Cacheの動作**

<Image
  alt="キャッシュされたおよびキャッシュされていないfetchリクエストがData Cacheとどのように相互作用するかを示す図。キャッシュされたリクエストはData Cacheに保存され、メモ化されます。キャッシュされていないリクエストはデータソースからフェッチされ、Data Cacheに保存されず、メモ化されます。"
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- レンダリング中に`'force-cache'`オプションによる`fetch`リクエストが初めて呼び出されたとき、Next.jsはData Cacheでキャッシュされたレスポンスを確認します。
- キャッシュされたレスポンスが見つかった場合、それが即座に返され、[メモ化](#request-memoization)されます。
- キャッシュされたレスポンスが見つからない場合、リクエストはデータソースに送信され、結果はData Cacheに保存され、メモ化されます。
- キャッシュされていないデータ（例：`cache`オプションが定義されていない場合や`{ cache: 'no-store' }`を使用している場合）、結果は常にデータソースからフェッチされ、メモ化されます。
- データがキャッシュされているかどうかにかかわらず、リクエストは常にメモ化され、React renderパス中に同じデータに対して重複リクエストを作成しないようにします。

> **Data CacheとRequest Memoizationの違い**
>
> どちらのキャッシングメカニズムもキャッシュされたデータを再利用することでパフォーマンスを向上させますが、Data Cacheは受信リクエストとデプロイメント間で永続する一方で、メモ化はリクエストのライフタイムにのみ続きます。

### 期間 {#duration}

再検証またはオプトアウトしない限り、Data Cacheは受信リクエストとデプロイメント間で持続します。

### 再検証 {#revalidating}

キャッシュされたデータは2つの方法で再検証できます：

- **時間ベースの再検証**：ある時間が経過した後に新しいリクエストが行われたとき、データを再検証します。これは、データがめったに変わらず、新鮮さがそれほど重要でない場合に役立ちます。
- **オンデマンド再検証**：イベントに基づいてデータを再検証します（例：フォーム送信）。オンデマンド再検証は、タグベースやパスベースのアプローチを使用してデータのグループを一度に再検証することができます。これは、ヘッドレスCMSのコンテンツが更新されたときなど、新しいデータをできるだけ早く表示したい場合に役立ちます。

#### 時間ベースの再検証 {#time-based-revalidation}

一定のインターバルでデータを再検証するには、`fetch`の`next.revalidate`オプションを使用してリソースのキャッシュライフタイムを秒単位で設定します。

```js
// 最大で1時間ごとに再検証する
fetch('https://...', { next: { revalidate: 3600 } })
```

もしくは、[Route Segment Configオプション](#segment-config-options)を使用して、セグメント内のすべての`fetch`リクエストを設定できます。または、`fetch`を使用できない場合に有効です。

**時間ベースの再検証の仕組み**

<Image
  alt="時間ベースの再検証の動作を示す図。再検証期間が経過すると、最初のリクエストで古いデータが返され、その後データが再検証される。"
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- `revalidate`を使用したfetchリクエストが初めて呼び出されたとき、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- 定義された期間内（例：60秒）に呼び出されたリクエストはキャッシュされたデータを返します。
- 期間の後、次のリクエストは依然としてキャッシュされた（現在は古い）データを返します。
  - Next.jsはバックグラウンドでデータの再検証をトリガーします。
  - データが正常にフェッチされると、Next.jsは新鮮なデータでData Cacheを更新します。
  - バックグラウンド再検証が失敗すると、前のデータは変更されずに残ります。

これは[**stale-while-revalidate**](https://web.dev/stale-while-revalidate/)の動作に似ています。

#### オンデマンド再検証 {#on-demand-revalidation}

データは、パス（[`revalidatePath`](#revalidatepath)）やキャッシュタグ（[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)）によってオンデマンドで再検証できます。

**オンデマンド再検証の仕組み**

<Image
  alt="オンデマンド再検証の動作を示す図。再検証リクエストの後にData Cacheが新しいデータで更新される。"
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- `fetch`リクエストが初めて呼び出されたとき、データは外部データソースからフェッチされ、Data Cacheに保存されます。
- オンデマンド再検証がトリガーされると、適切なキャッシュエントリがキャッシュから削除されます。
  - これは、時間ベースの再検証とは異なり、新鮮なデータがフェッチされるまでキャッシュに古いデータが残ります。
- 次回リクエストが行われるとき、再びキャッシュ`MISS`となり、外部データソースからデータがフェッチされ、Data Cacheに保存されます。

### オプトアウト {#opting-out}

`fetch`からのレスポンスをキャッシュ**しない**場合は、以下の方法で行えます：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Full Route Cache {#full-route-cache}

> **関連する用語**：
>
> アプリケーションのルートをビルド時にレンダリングおよびキャッシュするプロセスを指すために、**Automatic Static Optimization**、**Static Site Generation**、または**Static Rendering**という用語が使われることがあります。

Next.jsはビルド時に自動的にルートをレンダリングし、キャッシュします。これは、キャッシュされたルートを提供することで、各リクエストごとにサーバーでレンダリングする代わりに、高速なページ読み込みを実現する最適化です。

Full Route Cacheの仕組みを理解するには、Reactがレンダリングをどのように処理するか、そしてNext.jsがその結果をどのようにキャッシュするかを見ていくと役立ちます：

### 1. サーバー上でのReactレンダリング {#1-react-rendering-on-the-server}

サーバー上でNext.jsはReactのAPIを使用してレンダリングを調整します。レンダリング作業は、個々のルートのセグメントとSuspense boundaryごとに分かれています。

各チャンクは次の2ステップでレンダリングされます：

1. ReactはReact Server Component Payloadという、ストリーミングに最適化された特別なデータ形式にServer Componentsをレンダリングします。
2. Next.jsはReact Server Component PayloadとClient ComponentのJavaScript命令を使用して、サーバー上でHTMLをレンダリングします。

これによって、すべてをレンダリングするのを待たずに、作業をキャッシュしたり、レスポンスを送信したりすることができます。代わりに、作業が完了するたびにストリームレスポンスを送信できます。

> **React Server Component Payloadとは？**
>
> React Server Component Payloadは、レンダリングされたReact Server Components treeのコンパクトなバイナリ表現です。クライアントでReactによってブラウザのDOMを更新するのに使用されます。React Server Component Payloadには以下が含まれます：
>
> - Server Componentsのレンダリング結果
> - Client Componentsをレンダリングすべき場所とそのJavaScriptファイルへの参照
> - Server ComponentからClient Componentに渡されるprops
>
> 詳細は、[Server Components](/docs/app/building-your-application/rendering/server-components)のドキュメントを参照してください。

### 2. サーバーでのNext.jsのキャッシング (Full Route Cache) {#2-next-js-caching-on-the-server-full-route-cache}

<Image
  alt="Full Route Cacheのデフォルトの動作を示す図。React Server Component PayloadとHTMLがサーバー側で静的にレンダリングされたルートのためにキャッシュされている。"
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Next.jsのデフォルトの動作は、ルートのレンダリング結果（React Server Component PayloadとHTML）をサーバー内でキャッシュすることです。これは、ビルド時または再検証時に静的にレンダリングされたルートに適用されます。

### 3. クライアントでのReactのハイドレーションと調整 {#3-react-hydration-and-reconciliation-on-the-client}

リクエストタイムにおいて、クライアント側では：

1. HTMLはClientとServer Componentsの対話的ではない初期プレビューをすぐに表示します。
2. React Server Components Payloadは、ClientおよびレンダリングされたServer Component treeを調整し、DOMを更新します。
3. JavaScript命令は、Client Componentsを[ハイドレート](https://react.dev/reference/react-dom/client/hydrateRoot)し、アプリケーションをインタラクティブにします。

### 4. クライアントでのNext.jsのキャッシング (Router Cache) {#4-next-js-caching-on-the-client-router-cache}

React Server Component Payloadはクライアント側の[Router Cache](#client-side-router-cache)に保存され、レイアウト、ロード状態、ページごとに分割された別のメモリ内キャッシュとなります。このRouter Cacheは、以前に訪れたルートを保存し、将来のルートをプレフェッチすることでナビゲーション体験を向上させます。

### 5. 続くナビゲーション {#5-subsequent-navigations}

次のナビゲーションまたはプレフェッチ中に、Next.jsはReact Server Components PayloadがRouter Cacheに保存されているかどうかを確認します。もしそうであれば、サーバーへの新しいリクエストの送信をスキップします。

ルートセグメントがキャッシュにない場合、Next.jsはサーバーからReact Server Components Payloadをフェッチし、クライアント上でRouter Cacheをポピュレートします。

### 静的と動的レンダリング {#static-and-dynamic-rendering}

ルートがビルド時にキャッシュされるかどうかは、そのルートが静的にレンダリングされるか動的にレンダリングされるかに依存します。静的ルートはデフォルトでキャッシュされ、動的ルートはリクエストタイムにレンダリングされ、キャッシュされません。

この図は、静的および動的にレンダリングされたルートと、キャッシュされたデータとキャッシュされていないデータの違いを示しています：

<Image
  alt="静的と動的レンダリングがFull Route Cacheに与える影響を示す図。静的ルートはビルド時またはデータの再検証後にキャッシュされ、動的ルートは決してキャッシュされません"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

[静的および動的レンダリング](/docs/app/building-your-application/rendering/server-components#server-rendering-strategies)の詳細を学ぶ。

### 期間 {#duration}

デフォルトで、Full Route Cacheは永続的です。これは、レンダリング出力がユーザーリクエストを超えてキャッシュされることを意味します。

### 無効化 {#invalidation}

Full Route Cacheを無効化する方法は2つあります：

- **[データの再検証](/docs/app/building-your-application/caching#revalidating)**：Data Cacheを再検証すると、サーバーでコンポーネントを再レンダリングして新しいレンダリング出力をキャッシュすることで、Router Cacheも無効化されます。
- **リデプロイメント**：デプロイメント間で永続するData Cacheとは異なり、Full Route Cacheは新しいデプロイメントでクリアされます。

### オプトアウト {#opting-out}

Full Route Cacheをオプトアウトする、つまり、各受信リクエストに対して動的にコンポーネントをレンダリングするには、次の方法があります：

- **[動的APIを使用する](#dynamic-apis)**：これにより、Full Route Cacheからルートがオプトアウトされ、リクエストタイムに動的にレンダリングされます。Data Cacheは引き続き使用可能です。
- **`dynamic = 'force-dynamic'`またはルートセグメント設定オプションの`revalidate = 0`を使用する**：これにより、Full Route CacheとData Cacheがスキップされます。これにより、コンポーネントがレンダリングされ、受信サーバーリクエストごとにデータがフェッチされます。Router Cacheは引き続き適用されますが、クライアント側のキャッシュです。
- **[Data Cacheをオプトアウトする](#data-cache)**：キャッシュされない`fetch`リクエストを持つルートがある場合、これはそのルートをFull Route Cacheからオプトアウトします。特定の`fetch`リクエストのデータは、受信サーバーリクエストごとにフェッチされます。キャッシングをオプトアウトしない他の`fetch`リクエストは、Data Cacheに引き続きキャッシュされます。これは、キャッシュされたデータとキャッシュされていないデータのハイブリッドを可能にします。

## クライアント側Router Cache {#client-side-router-cache}

Next.jsには、ルートセグメントのRSCペイロードをレイアウト、ロード状態、ページごとに分割して格納するメモリ内のクライアントサイドのルータキャッシュがあります。

ユーザーがルート間をナビゲートすると、Next.jsは訪れたルートセグメントをキャッシュし、ユーザーがナビゲートする可能性の高いルートを[プレフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します。これにより、即時の戻る/進むナビゲーションが可能になり、ナビゲーション間でページ全体を再読み込みすることなく、React状態とブラウザ状態を維持します。

Router Cacheを使用すると：

- **レイアウト**はナビゲーションでキャッシュされ、再利用されます（[部分的なレンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)）。
- **ロード状態**はナビゲーションでキャッシュされ、[即時ナビゲーション](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)のために再利用されます。
- **ページ**はデフォルトではキャッシュされませんが、ブラウザの戻るおよび進むナビゲーション中は再利用されます。実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用して、ページセグメントのキャッシングを有効にできます。

{/* TODO: v15の動作に合わせて図を更新する */}

> **Good to know:** このキャッシュは特にNext.jsおよびServer Componentsに適用され、ブラウザの[bfcache](https://web.dev/bfcache/)とは異なりますが、同様の結果をもたらします。

### 期間 {#duration}

キャッシュはブラウザの一時メモリに格納されます。2つの要因がルータキャッシュの持続期間を決定します：

- **セッション**：キャッシュはナビゲーション中に持続します。ただし、ページの更新時にクリアされます。
- **自動無効化期間**：レイアウトおよびロード状態のキャッシュは、特定の時間が経過すると自動的に無効化されます。この期間は、リソースがどのようにプレフェッチされ、リソースが[静的に生成](/docs/app/building-your-application/rendering/server-components#static-rendering-default)されたかによって異なります：
  - **デフォルトのプレフェッチ**（`prefetch={null}`または指定されていない場合）：動的ページの場合はキャッシュされず、静的ページの場合は5分間。
  - **フルプレフェッチ**（`prefetch={true}`または`router.prefetch`）：静的&動的ページの場合は5分間。

ページの更新は**すべて**のキャッシュされたセグメントをクリアしますが、自動無効化期間はプレフェッチされた個々のセグメントにのみ影響を与えます。

> **Good to know**: 実験的な[`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes)設定オプションを使用して、上記の自動無効化期間を調整できます。

### 無効化 {#invalidation}

Router Cacheを無効化する方法は2つあります：

- **サーバーアクション**内で：
  - パスごとにオンデマンドでデータを再検証する場合は、([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath))またはキャッシュタグで([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag))を使用
  - [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie)または[`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies)を使用すると、Router Cacheが無効化され、cookieを使用するルートが古くならないようにします（例：認証）。
- [`router.refresh`](/docs/app/api-reference/functions/use-router)を呼び出すと、Router Cacheが無効化され、サーバーへの新しいリクエストが現在のルートに対して行われます。

### オプトアウト {#opting-out}

Next.js 15から、ページセグメントはデフォルトでオプトアウトされています。

> **Good to know:** `<Link>`コンポーネントの`prefetch`プロップを`false`に設定することで、[プレフェッチ](./building-your-application/routing/linking-and-navigating#2-prefetching)をオプトアウトすることもできます。

## キャッシュの相互作用 {#cache-interactions}

異なるキャッシングメカニズムを設定する際には、それらがどのように相互に作用するかを理解することが重要です：

### Data CacheとFull Route Cache {#data-cache-and-full-route-cache}

- Data Cacheを再検証またはオプトアウトすることで、レンダリング出力がデータに依存するため、Full Route Cacheも無効化されます。
- Full Route Cacheを無効化またはオプトアウトすることは、Data Cacheには影響しません。キャッシュされたデータとキャッシュされていないデータを持つルートを動的にレンダリングできます。たとえば、ページのほとんどがキャッシュされたデータを使用しますが、いくつかのコンポーネントがリクエスト時にフェッチされる必要があるデータに依存して場合に便利です。すべてのデータを再フェッチすることによるパフォーマンスへの影響を心配せずに動的にレンダリングできます。

### Data Cacheとクライアント側Router Cache {#data-cache-and-client-side-router-cache}

- Data CacheとRouter Cacheを即座に無効化するには、[サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)内で[`revalidatePath`](#revalidatepath)または[`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)を使用できます。
- [Route Handler](/docs/app/building-your-application/routing/route-handlers)におけるData Cacheの再検証は、Router Cacheを直ちに無効化**しません**。Route Handler自体は特定のルートに結び付けられていないためです。したがって、Router Cacheはハードリフレッシュや自動無効化期間が経過するまで、以前のペイロードを提供し続けます。

## APIs {#apis}

次のテーブルは、さまざまなNext.js APIがキャッシングにどのように影響するかの概要を示しています：

| API                                                                     | Router Cache               | Full Route Cache      | Data Cache            | React Cache |
| ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | Cache                      |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                    | Cache                      |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                      | Revalidate                 |                       |                       |             |
| [`fetch`](#fetch)                                                       |                            |                       | Cache                 | Cache       |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                       | Cache or Opt out      |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Revalidate            | Revalidate            |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Cache                 | Cache                 |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`revalidatePath`](#revalidatepath)                                     | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`const revalidate`](#segment-config-options)                           |                            | Revalidate or Opt out | Revalidate or Opt out |             |
| [`const dynamic`](#segment-config-options)                              |                            | Cache or Opt out      | Cache or Opt out      |             |
| [`cookies`](#cookies)                                                   | Revalidate (Server Action) | Opt out               |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Opt out               |                       |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Cache                 |                       |             |
| [`React.cache`](#react-cache-function)                                  |                            |                       |                       | Cache       |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                       | Cache                 |             |

### `<Link>` {#link}

デフォルトで、`<Link>`コンポーネントは、Full Route Cacheからのルートを自動的にプレフェッチし、Router CacheにReact Server Component Payloadを追加します。

プレフェッチを無効にするには、`prefetch`プロップを`false`に設定できます。ただし、これによりキャッシュが恒久的にスキップされるわけではなく、ユーザーがそのルートにアクセスしたときにルートセグメントはクライアント側にキャッシュされます。

[`<Link>`コンポーネント](/docs/app/api-reference/components/link)の詳細を学ぶ。

### `router.prefetch` {#router-prefetch}

`useRouter`フックの`prefetch`オプションを使用して、ルートを手動でプレフェッチできます。これにより、React Server Component PayloadがRouter Cacheに追加されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)APIリファレンスを参照してください。

### `router.refresh` {#router-refresh}

`useRouter`フックの`refresh`オプションを使用して、ルートを手動で更新することができます。これにより、Router Cacheが完全にクリアされ、現在のルートに対してサーバーへの新しいリクエストが行われます。`refresh`はData CacheまたはFull Route Cacheには影響しません。

レンダリングされた結果はクライアントで調整されながら、React状態とブラウザ状態が維持されます。

[`useRouter`フック](/docs/app/api-reference/functions/use-router)APIリファレンスを参照してください。

### `fetch` {#fetch}

`fetch`から返されるデータは、Data Cacheに自動的にキャッシュされ**ません**。

`fetch`のデフォルトのキャッシング動作（例：`cache`オプションが指定されていない場合）は、`cache`オプションを`no-store`に設定することと同等です：

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)の詳細を参照してください。

### `fetch options.cache` {#fetch-options-cache}

個別の`fetch`をキャッシングにオプトインするには、`cache` オプションを`force-cache` に設定します：

```jsx
// キャッシングにオプトインする
fetch(`https://...`, { cache: 'force-cache' })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)の詳細を参照してください。

### `fetch options.next.revalidate` {#fetch-options-next-revalidate}

個別の`fetch`リクエストの再検証期間を秒単位で設定するには、`fetch`の`next.revalidate` オプションを使用できます。これにより、Data Cacheが再検証され、それに伴いFull Route Cacheも再検証されます。新鮮なデータがフェッチされ、サーバーでコンポーネントが再レンダリングされます。

```jsx
// 少なくとも1時間ごとに再検証する
fetch(`https://...`, { next: { revalidate: 3600 } })
```

[`fetch` APIリファレンス](/docs/app/api-reference/functions/fetch)の詳細を参照してください。

### `fetch options.next.tags` と `revalidateTag` {#fetch-options-next-tags-and-revalidatetag}

Next.jsには、データキャッシングおよび再検証を微細に制御するためのキャッシュタグシステムがあります。

1. `fetch`または[`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)を使用する場合、キャッシュエントリに1つまたは複数のタグを付けるオプションがあります。
2. その後、`revalidateTag`を呼び出して、そのタグに関連付けられたキャッシュエントリをパージできます。

たとえば、データをフェッチするときにタグを設定できます：

```jsx
// タグ付きでデータをキャッシュする
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

その後、特定のタグを持つキャッシュエントリをパージするために`revalidateTag`を呼び出します：

```jsx
// 特定のタグを持つエントリを再検証する
revalidateTag('a')
```

達成したいことによって、`revalidateTag`を使用できる場所が2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティのイベントに応じてデータを再検証するため（例：Webhook)。ただし、Router Handlerは特定のルートに結び付けられていないため、Router Cacheはすぐには無効になりません。
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーアクション後にデータを再検証するため（例：フォーム送信）。これにより、関連するルートのRouter Cacheが無効になります。

### `revalidatePath` {#revalidatepath}

`revalidatePath`を使用すると、単一の操作でデータ**と**特定のパス以下のルートセグメントを再検証し、再レンダリングすることができます。`revalidatePath`メソッドを呼び出すと、Data Cacheが再検証され、Full Route Cacheも無効化されます。

```jsx
revalidatePath('/')
```

達成したいことによって、`revalidatePath`を使用できる場所が2つあります：

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - サードパーティのイベントに応じてデータを再検証するため（例：Webhook)。
2. [サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - ユーザーインタラクション後にデータを再検証するため（例：フォーム送信、ボタンをクリック）。

[`revalidatePath` APIリファレンス](/docs/app/api-reference/functions/revalidatePath)の詳細を参照してください。

> **`revalidatePath`** と **`router.refresh`** の違い：
>
> `router.refresh`を呼び出すと、Router Cacheがクリアされ、Data CacheまたはFull Route Cacheを無効にすることなくサーバーでルートセグメントが再レンダリングされます。
>
> 違いは`revalidatePath`がData CacheとFull Route Cacheをパージするのに対し、`router.refresh()`はData CacheとFull Route Cacheを変更しません。これはクライアントサイドAPIです。

### 動的API {#dynamic-apis}

`cookies`や`headers`、そしてPagesの`searchParams`プロップのような動的APIは、ランタイムの受信リクエスト情報に依存しています。これらを使用すると、ルートがFull Route Cacheからオプトアウトします。つまり、そのルートは動的にレンダリングされます。

#### `cookies` {#cookies}

Server Action内で`cookies.set`または`cookies.delete`を使用すると、cookieを使用するルートが古くならないようにするため（例：認証の変更を反映するため）、Router Cacheが無効化されます。

[`cookies`](/docs/app/api-reference/functions/cookies)APIリファレンスをご覧ください。

### セグメント設定オプション {#segment-config-options}

Route Segment Configオプションは、ルートセグメントのデフォルトを上書きするか、`fetch` APIを使用できない場合（例：データベースクライアントやサードパーティライブラリ）に使用できます。

Full Route Cacheからオプトアウトする以下のRoute Segment Configオプションがあります：

- `const dynamic = 'force-dynamic'`

この設定オプションは、Data Cacheからすべてのfetchをオプトアウトします（すなわち、`no-store`）。

- `const fetchCache = 'default-no-store'`

より高度なオプションを見るために[`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)を参照してください。

詳細は、[Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config)ドキュメントを参照してください。

### `generateStaticParams` {#generatestaticparams}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)（例：`app/blog/[slug]/page.js`）のために、`generateStaticParams`で提供されるパスは、ビルド時にFull Route Cacheにキャッシュされます。リクエスト時に、Next.jsはビルド時に知られていなかったパスも、初めて訪れたときにキャッシュします。

すべてのパスをビルド時に静的にレンダリングするには、`generateStaticParams`にフルリストを提供します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

一部のパスをビルド時に静的にレンダリングし、残りを実行時に初めて訪れたときにレンダリングするには、部分的なパスのリストを返します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // 最初の10投稿をビルド時にレンダリング
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

すべてのパスを初めて訪れたときに静的にレンダリングするには、空の配列を返します（ビルド時にパスはレンダリングされません）。または、[`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic)を利用します：

```jsx title="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** `generateStaticParams`から配列を返す必要があります。たとえそれが空であってもそうです。そうでないとルートは動的にレンダリングされます。

```jsx title="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

リクエスト時にキャッシュを無効にするには、ルートセグメント内で`export const dynamicParams = false`オプションを追加します。この設定オプションを使用すると、`generateStaticParams`によって提供されるパスのみが提供され、他のルートは404になります（[catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)の場合に一致します）。

### React `cache`関数 {#react-cache-function}

Reactの`cache`関数を使用すると、関数の戻り値をメモ化することができ、一度しか実行しないにもかかわらず同じ関数を複数回呼び出すことができます。

`fetch`リクエストは自動的にメモ化されるため、React `cache`でラップする必要はありません。ただし、`fetch` APIが適していないケース（例：一部のデータベースクライアント、CMSクライアント、GraphQLクライアント）では、データ要求を手動でメモ化するために`cache`を使用できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

</TabItem>
</Tabs>
