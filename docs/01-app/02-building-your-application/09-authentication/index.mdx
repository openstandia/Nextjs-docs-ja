---
title: 'Authentication'
description: 'Next.jsアプリケーションにおける認証の実装方法を学びます。'
---

認証を理解することは、アプリケーションのデータを保護するために重要です。このページでは、ReactとNext.jsの機能を使って認証を実装するためのガイドを行います。

開始する前に、プロセスを次の3つの概念に分解することが役立ちます：

1. **[Authentication](#authentication)**: ユーザーが自称する人物であるかを確認する。ユーザーは、ユーザー名やパスワードなど、所有している何かでその身元を証明する必要があります。
2. **[Session Management](#session-management)**: リクエストを跨いでユーザーの認証状態を追跡します。
3. **[Authorization](#authorization)**: ユーザーがアクセスできるルートやデータを決定します。

この図は、ReactとNext.jsの機能を使用した認証フローを示しています：

<Image
  alt="ReactとNext.jsの機能を使用した認証フローを示す図"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

このページの例では、学習目的で基本的なユーザー名とパスワード認証を紹介します。カスタムの認証ソリューションを実装することも可能ですが、セキュリティ向上と簡素化のために認証ライブラリの使用を推奨します。これらは、認証、セッション管理、および承認のための組込みソリューションを提供するだけでなく、ソーシャルログイン、多要素認証、ロールベースのアクセス制御などの追加機能も提供します。詳細は[Auth Libraries](#auth-libraries)セクションで確認できます。

## Authentication {#authentication}

<AppOnly>

### Sign-up and login functionality {#sign-up-and-login-functionality}

Reactの[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)と`useActionState`を用いて、ユーザーの資格情報をキャプチャし、フォームフィールドを検証し、認証プロバイダーのAPIやデータベースを呼び出すことができます。

Server Actionsは常にサーバーで実行されるため、認証ロジックを処理するための安全な環境を提供します。

サインアップ／ログイン機能を実装する手順は次のとおりです：

#### 1. Capture user credentials {#1-capture-user-credentials}

ユーザーの資格情報をキャプチャするために、Server Actionを送信時に呼び出すフォームを作成します。例えば、ユーザーの名前、メールアドレス、パスワードを受け取るサインアップフォーム：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions/auth.tsx" switcher
export async function signup(formData: FormData) {}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions/auth.js" switcher
export async function signup(formData) {}
```

</TabItem>
</Tabs>

#### 2. Validate form fields on the server {#2-validate-form-fields-on-the-server}

Server Actionを使用して、サーバー側でフォームフィールドを検証します。認証プロバイダーがフォームの検証を行わない場合、[Zod](https://zod.dev/)や[Yup](https://github.com/jquense/yup)などのスキーマ検証ライブラリを使用できます。

Zodを例にとると、適切なエラーメッセージを設定してフォームスキーマを定義できます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: '名前は少なくとも2文字以上でなければいけません。' })
    .trim(),
  email: z
    .string()
    .email({ message: '有効なメールアドレスを入力してください。' })
    .trim(),
  password: z
    .string()
    .min(8, { message: '少なくとも8文字以上であること。' })
    .regex(/[a-zA-Z]/, { message: '少なくとも1文字は文字を含むこと。' })
    .regex(/[0-9]/, { message: '少なくとも1文字は数字を含むこと。' })
    .regex(/[^a-zA-Z0-9]/, {
      message: '少なくとも1文字は特殊文字を含むこと。',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: '名前は少なくとも2文字以上でなければいけません。' })
    .trim(),
  email: z
    .string()
    .email({ message: '有効なメールアドレスを入力してください。' })
    .trim(),
  password: z
    .string()
    .min(8, { message: '少なくとも8文字以上であること。' })
    .regex(/[a-zA-Z]/, { message: '少なくとも1文字は文字を含むこと。' })
    .regex(/[0-9]/, { message: '少なくとも1文字は数字を含むこと。' })
    .regex(/[^a-zA-Z0-9]/, {
      message: '少なくとも1文字は特殊文字を含むこと。',
    })
    .trim(),
})
```

</TabItem>
</Tabs>

認証プロバイダーのAPIやデータベースへの不必要な呼び出しを防ぐために、フォームフィールドが定義されたスキーマに一致しない場合はServer Action内で早めに`return`することができます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // フォームフィールドを検証します
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // もしフォームフィールドが無効な場合は、早く返します
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // プロバイダーまたはデータベースにユーザーを作成する...
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // フォームフィールドを検証します
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // もしフォームフィールドが無効な場合は、早く返します
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // プロバイダーまたはデータベースにユーザーを作成する...
}
```

</TabItem>
</Tabs>

`<SignupForm />`に戻り、Reactの`useActionState`フックを使用して、フォーム送信中に検証エラーを表示できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup-form.tsx" switcher
highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Password must:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Sign Up
      </button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup-form.js" switcher
highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Password must:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Sign Up
      </button>
    </form>
  )
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - React 19では、`useFormStatus`は、返されるオブジェクトにデータ、メソッド、およびアクションなどの追加のキーを含んでいます。React 19を使用していない場合、`pending`キーのみが利用可能です。
> - React 19では、`useActionState`も返される状態に`pending`キーを含んでいます。
> - データを変更する前に、ユーザーがそのアクションを実行する権限を持っているかを常に確認するべきです。詳細は[Authentication and Authorization](#authorization)を参照してください。

#### 3. Create a user or check user credentials {#3-create-a-user-or-check-user-credentials}

フォームフィールドの検証後、認証プロバイダーのAPIまたはデータベースを呼び出して、新しいユーザーアカウントを作成するか、ユーザーの存在を確認できます。

前回の例から続けて：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. フォームフィールドを検証します
  // ...

  // 2. データベースへの挿入用のデータを準備します
  const { name, email, password } = validatedFields.data
  // 例: ユーザーのパスワードを保存する前にハッシュ化します。
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. データベースにユーザーを挿入するか、認証ライブラリのAPIを呼び出します
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'アカウントを作成中にエラーが発生しました。',
    }
  }

  // TODO：
  // 4. ユーザーセッションを作成する
  // 5. ユーザーをリダイレクトする
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. フォームフィールドを検証します
  // ...

  // 2. データベースへの挿入用のデータを準備します
  const { name, email, password } = validatedFields.data
  // 例: ユーザーのパスワードを保存する前にハッシュ化します。
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. データベースにユーザーを挿入するか、ライブラリーAPIを呼び出します
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'アカウントを作成中にエラーが発生しました。',
    }
  }

  // TODO：
  // 4. ユーザーセッションを作成する
  // 5. ユーザーをリダイレクトする
}
```

</TabItem>
</Tabs>

ユーザーアカウントの作成やユーザー資格情報の確認が成功した後、ユーザーの認証状態を管理するためのセッションを作成できます。セッション管理戦略によっては、セッションをcookieやデータベースに保存する、またはその両方に保存することができます。[Session Management](#session-management)セクションを続けてご覧ください。

> **Tips:**
>
> - 上記の例は教育のために認証手順を細かく分解しているため冗長です。独自の安全なソリューションを実装するのはすぐに複雑になる可能性があるため、プロセスを簡素化するために[Auth Library](#auth-libraries)を使用することを検討してください。
> - ユーザーエクスペリエンスを向上させるために、登録フローの早い段階で重複するメールアドレスやユーザー名を確認することが役立ちます。たとえば、ユーザーがユーザー名を入力したり、入力フィールドがフォーカスを失ったときなどに行います。これにより、不要なフォーム送信を防ぎ、ユーザーに即時のフィードバックを提供できます。リクエストの頻度を管理するために、[use-debounce](https://www.npmjs.com/package/use-debounce)などのライブラリを使ってデバウンスを行うことができます。

</AppOnly>

<PagesOnly>

サインアップまたはログインフォームを実装するための手順は以下の通りです：

1. ユーザーはフォームを通じて資格情報を送信します。
2. フォームはリクエストを送信し、それがAPIルートによって処理されます。
3. 検証が成功すれば、処理が完了し、ユーザーの認証が成功したことを示します。
4. 検証が失敗した場合、エラーメッセージが表示されます。

次に、ユーザーが資格情報を入力できるログインフォームを検討します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // エラーを処理する
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // エラーを処理する
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

上記のフォームには、ユーザーのメールアドレスとパスワードをキャプチャするための2つの入力フィールドがあります。送信時に、`/api/auth/login`というAPIルートにPOSTリクエストを送信する関数がトリガーされます。

その後、APIルートでAuthentication ProviderのAPIを呼び出して認証を処理します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: '無効な資格情報です。' })
    } else {
      res.status(500).json({ error: '何か問題が発生しました。' })
    }
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: '無効な資格情報です。' })
    } else {
      res.status(500).json({ error: '何か問題が発生しました。' })
    }
  }
}
```

</TabItem>
</Tabs>

</PagesOnly>

## Session Management {#session-management}

セッション管理は、ユーザーの認証された状態をリクエストの間に維持することを保証します。これには、セッションやトークンの作成、保存、更新、および削除が含まれます。

セッションには2つのタイプがあります：

1. [**Stateless**](#stateless-sessions): セッションデータ（またはトークン）はブラウザのcookiesに保存されます。このcookieは各リクエストとともに送信され、セッションをサーバーで確認できるようにします。この方法はシンプルですが、正しく実装されない場合、セキュリティが低くなる可能性があります。
2. [**Database**](#database-sessions): セッションデータがデータベースに保存され、ユーザーのブラウザには暗号化されたセッションIDのみが受け取られます。この方法はより安全ですが、複雑でサーバーのリソースを多く使用する可能性があります。

> **Good to know:** いずれの方法も使用できますが、両方、またはsession managementのライブラリとして[iron-session](https://github.com/vvo/iron-session)や[Jose](https://github.com/panva/jose)を使用することを推奨します。

### Stateless Sessions {#stateless-sessions}

<AppOnly>

Statelessなセッションを作成し管理するには、いくつかのステップを従う必要があります：

1. セッションを署名するために使用する秘密鍵を生成し、[環境変数](/docs/app/building-your-application/configuring/environment-variables)として保存します。
2. セッション管理ライブラリを使ってセッションデータを暗号化／復号します。
3. Next.jsの[`cookies`](/docs/app/api-reference/functions/cookies) APIを使用してcookiesを管理します。

上記に加えて、ユーザーがアプリケーションに戻るときにセッションを[更新またはリフレッシュ](#updating-or-refreshing-sessions)する機能を考慮し、ユーザーがログアウトするときにセッションを削除するようにしてください。

> **Good to know:** 使用する認証ライブラリがセッション管理を含んでいるか確認してください。

#### 1. Generating a secret key {#1-generating-a-secret-key}

セッションを署名する秘密鍵を生成する方法は複数あります。例えば、ターミナルで`openssl`コマンドを使用することができます：

```bash title="terminal"
openssl rand -base64 32
```

このコマンドは32文字のランダムな文字列を生成し、あなたの[環境変数ファイル](/docs/app/building-your-application/configuring/environment-variables)に秘密鍵として保存することができます：

```bash title=".env"
SESSION_SECRET=your_secret_key
```

その後、この鍵をセッション管理ロジックで参照できます：

```js title="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. Encrypting and decrypting sessions {#2-encrypting-and-decrypting-sessions}

次に、好みの[セッション管理ライブラリ](#session-management-libraries)を使ってセッションを暗号化、復号化できます。前回の例から続けて、Reactの[`server-only`](https://www.npmjs.com/package/server-only)パッケージで[Jose](https://www.npmjs.com/package/jose)（[Edge Runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)に対応）を使用して、セッション管理ロジックがサーバー上でのみ実行されることを保証します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('セッションの確認に失敗しました。')
  }
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('セッションの確認に失敗しました。')
  }
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - ペイロードには、今後のリクエストで使用される最小限の、ユニークなユーザーデータ（例：ユーザーID、ロール等）を含むべきです。電話番号、メールアドレス、クレジットカード情報などの個人を識別できる情報、またはパスワードのような機密データを含むべきではありません。

#### 3. Setting cookies (recommended options) {#3-setting-cookies-recommended-options}

セッションをcookieに保存するには、Next.jsの[`cookies`](/docs/app/api-reference/functions/cookies) APIを利用します。cookieはサーバーに設定され、以下の推奨オプションを含むべきです：

- **HttpOnly**: クライアント側のJavaScriptがcookieにアクセスすることを防ぐ。
- **Secure**: cookieの送信にはhttpsを使用します。
- **SameSite**: cookieがクロスサイトリクエストで送信可能かを指定します。
- **Max-AgeまたはExpires**: 一定期間後にcookieを削除します。
- **Path**: cookieのURLパスを定義します。

各オプションに関する詳細は[MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)を参照してください。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

Server Action内で、`createSession()`関数を呼び出し、[`redirect()`](/docs/app/building-your-application/routing/redirecting) APIを使用して、ユーザーを適切なページにリダイレクトすることができます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // 前のステップ：
  // 1. フォームフィールドを検証します
  // 2. データベースへの挿入用のデータを準備します
  // 3. データベースにユーザーを挿入するか、ライブラリーAPIを呼び出します

  // 現在のステップ：
  // 4. ユーザーセッションを作成します
  await createSession(user.id)
  // 5. ユーザーをリダイレクトします
  redirect('/profile')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // 前のステップ：
  // 1. フォームフィールドを検証します
  // 2. データベースへの挿入用のデータを準備します
  // 3. データベースにユーザーを挿入するか、ライブラリーAPIを呼び出します

  // 現在のステップ：
  // 4. ユーザーセッションを作成します
  await createSession(user.id)
  // 5. ユーザーをリダイレクトします
  redirect('/profile')
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - **Cookiesはサーバーで設定するべき** です。これがクライアント側の改ざんを防ぎます。
> - 🎥 視聴: Next.jsを使用したstatelessなセッションと認証についてもっと学ぶ → [YouTube (11分)](https://www.youtube.com/watch?v=DJvM2lSPn6w)。

#### Updating (or refreshing) sessions {#updating-or-refreshing-sessions}

また、セッションの有効期限を延長することもできます。これは、ユーザーがアプリケーションに再びアクセスしたときにログイン状態を維持するために役立ちます。例：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

> **Tip:** ご利用の認証ライブラリがリフレッシュトークンに対応しているか確認してください。リフレッシュトークンを利用して、ユーザーのセッションを延長することができます。

#### Deleting the session {#deleting-the-session}

セッションを削除するために、cookieを削除します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

</TabItem>
</Tabs>

その後、アプリケーション内で`deleteSession()`関数を再利用することができ、例えばログアウト時に使用します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  deleteSession()
  redirect('/login')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  deleteSession()
  redirect('/login')
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

#### Setting and deleting cookies {#setting-and-deleting-cookies}

セッションをサーバー上のcookieとして設定するために[APIルート](https://nextjs.org/docs/canary/pages/building-your-application/routing/api-routes)を使用することができます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 一週間
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'cookieの設定に成功しました！' })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 一週間
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'cookieの設定に成功しました！' })
}
```

</TabItem>
</Tabs>

</PagesOnly>

### Database Sessions {#database-sessions}

データベースセッションを作成し管理するには、次のステップを従う必要があります：

1. セッションとデータを保存するデータベース内のテーブルを作成する（または認証ライブラリがこれを処理しているかを確認する）。
2. セッションを挿入、更新、削除する機能を実装する
3. セッションIDをユーザーのブラウザに保存する前に暗号化し、データベースとcookieを同期させる（これはオプションですが、[Middleware](#optimistic-checks-with-middleware-optional)での楽観的な認証チェックのために推奨されます）。

<AppOnly>

例として：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. データベースにセッションを作成する
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // セッションIDを返す
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. セッションIDを暗号化する
  const session = await encrypt({ sessionId, expiresAt })

  // 3. 楽観的な認証チェックのためにcookieにセッションを保存する
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. データベースにセッションを作成する
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // セッションIDを返す
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. セッションIDを暗号化する
  const session = await encrypt({ sessionId, expiresAt })

  // 3. 楽観的な認証チェックのためにcookieにセッションを保存する
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - データの取得を高速化するために、[Vercel Redis](https://vercel.com/docs/storage/vercel-kv)のようなデータベースを使用することも検討してください。ただし、プライマリデータベースにセッションデータを保持し、データ要求をまとめることで、クエリの数を減少させることもできます。
> - データベースセッションは、ユーザーの最終ログイン時間、アクティブデバイスの数を追跡したり、ユーザーにすべてのデバイスからログアウトさせる能力を与えるなど、より高度なユースケースに使われることが考えられます。

セッション管理を実装した後は、アプリケーション内でユーザーがアクセスし実行できる内容を制御するための承認ロジックを追加する必要があります。[Authorization](#authorization)セクションを続けてご覧ください。

</AppOnly>

<PagesOnly>

**サーバーでセッションを作成する**：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: '内部サーバーエラー' })
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: '内部サーバーエラー' })
  }
}
```

</TabItem>
</Tabs>

</PagesOnly>

## Authorization {#authorization}

ユーザーが認証され、セッションが作成されたら、アプリケーション内で何にユーザーがアクセスでき、何を実行できるかを制御するために認可を実装することができます。

承認チェックには2つの主要なタイプがあります：

1. **楽観的**：cookieに保存されたセッションデータを用いて、ユーザーがルートや操作を実行する権限があるかを確認します。これらのチェックは、UI要素の表示／非表示や、権限や役割に基づいてユーザーをリダイレクトするような迅速な操作に有効です。
2. **安全な**：データベースに保存されたセッションデータを用いて、ユーザーがルートや操作を実行する権限があるかを確認します。これらのチェックはより安全で、機密データや操作へのアクセスを必要とする場合に使用されます。

どちらの場合も次を推奨します：

- 承認ロジックを集中化するための[データアクセス層（DAL）](#creating-a-data-access-layer-dal)を作成すること
- 必要なデータだけを返すための[データ転送オブジェクト（DTO）](#using-data-transfer-objects-dto)を使用すること
- [ミドルウェアを使用して楽観的なチェックを](#optimistic-checks-with-middleware-optional)行うこと。

### 楽観的チェックを行うミドルウェア（オプション）{#optimistic-checks-with-middleware-optional}

場合によっては、[ミドルウェア](/docs/app/building-your-application/routing/middleware)を使用して、権限に基づいてユーザーをリダイレクトすることを望むことがあります：

- 楽観的なチェックを行うため、ミドルウェアはすべてのルートで動作するため、リダイレクトロジックを中央集権化し、未承認のユーザーを事前にフィルタリングするのに適しています。
- 文書を境にユーザー間でデータを共有する静的ルートを保護します（例：ペイウォールの裏のコンテンツ）。

ただし、ミドルウェアはすべてのルートで動作するため、[prefetched](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)ルートを含め、パフォーマンスの問題を避けるためにデータベースチェックではなくcookieからセッションを読み取る（楽観的なチェック）するように注意が必要です。

例：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. 保護されたルートと公開ルートを指定する
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. 現在のルートが保護されたものか公開されたものかをチェックする
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. cookieからセッションを復号化する
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. ユーザーが認証されていない場合は/loginにリダイレクトする
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. ユーザーが認証された場合は/dashboardにリダイレクトする
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// ミドルウェアが動作しないルート
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. 保護されたルートと公開ルートを指定する
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. 現在のルートが保護されたものか公開されたものかをチェックする
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. cookieからセッションを復号化する
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. ユーザーが認証されていない場合は/loginにリダイレクトする
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. ユーザーが認証された場合は/dashboardにリダイレクトする
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// ミドルウェアが動作しないルート
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

</TabItem>
</Tabs>

ミドルウェアは初期のチェックに役立ちますが、データを保護するうえでの唯一のセキュリティ対策とすべきではありません。セキュリティチェックの大部分はデータソースにできるだけ近い場所で行う必要があります。詳細は[データアクセス層（DAL）](#creating-a-data-access-layer-dal)を参照してください。

> **Tips**:
>
> - ミドルウェア内で`req.cookies.get('session').value`を使用してcookieを読むこともできます。
> - ミドルウェアは[Edge Runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を使用します。認証ライブラリおよびセッション管理ライブラリが互換性があるか確認してください。
> - ミドルウェアで動作するルートを`matcher`プロパティを使用して指定できます。ただし、認証においてはミドルウェアがすべてのルートで動作することを推奨します。

<AppOnly>

### データアクセス層（DAL）の作成 {#creating-a-data-access-layer-dal}

データ要求と承認ロジックを集中化するためにDALを作成することを推奨します。

DALには、ユーザーがアプリケーションを操作する際にユーザーのセッションを確認する関数が含まれているべきです。最低でも、その関数はセッションが有効であるかを確認し、リダイレクトまたはさらなる要求を行うために必要なユーザー情報を返すべきです。

例えば、DAL用のファイルを作成し、関数`verifySession()`を含めます。Reactの[cache](https://react.dev/reference/react/cache) APIを使用して、Reactのレンダーパス中に関数の返り値をメモ化します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

</TabItem>
</Tabs>

その後、データ要求、Server Actions、Route Handlersで`verifySession()`関数を呼び出すことができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // 必要な列を明示的に指定し、ユーザーオブジェクト全体よりも特定の列を返す
  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('ユーザー情報の取得に失敗しました。')
    return null
  }
})
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // 必要な列を明示的に指定し、ユーザーオブジェクト全体よりも特定の列を返す
  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('ユーザー情報の取得に失敗しました。')
    return null
  }
})
```

</TabItem>
</Tabs>

> **Tip**:
>
> - DALはリクエスト時に取得されるデータを保護するために使用できます。ただし、ユーザー間でデータを共有する静的ルートの場合、データはビルド時に取得され、リクエスト時には取得されません。[ミドルウェア](#optimistic-checks-with-middleware-optional)を使用して静的なルートを保護します。
> - セキュリティチェックを安全に行うため、データベースとセッションのIDを比較してセッションが有効であることを確認できます。Reactの[cache](https://react.dev/reference/react/cache)を使用することで、レンダーパス中にデータベースへの重複したリクエストを避けることができます。
> - 関連したデータ要求をJavaScriptクラスにまとめ、`verifySession()`を実行する処理を統一することを検討するかもしれません。

### データ転送オブジェクト（DTO）の使用 {#using-data-transfer-objects-dto}

データを取得する際、アプリケーションで使用される必要なデータだけを返し、全てのオブジェクトを返さないことが推奨されます。例として、ユーザーデータを取得する場合、ユーザーのIDや名前のみを返すかもしれませんが、パスワード、電話番号などを含むユーザーオブジェクト全体を返すべきではありません。

ただし、返されるデータ構造を制御することができない場合や、チームで作業する際にクライアントに全てのオブジェクトを送信することを避けるために、クライアントに公開しても安全なフィールドを指定するなどの戦略を使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // 特定の列をここで返す
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // または、クエリに特化した内容だけを返します
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // 特定の列をここで返す
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // または、クエリに特化した内容だけを返します
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

</TabItem>
</Tabs>

データ要求と承認ロジックをDALに集中し、DTOを使用することで、すべてのデータ要求が安全で一貫性があることが保証され、アプリケーションがスケールする際にメンテナンス、監査、デバッグが簡単になります。

> **Good to know**:
>
> - DTOを定義する方法はいくつかあり、`toJSON()`を使う方法、個別の関数を使う方法、またはJSクラスを使用する方法があります。これらはJavaScriptのパターンであり、ReactやNext.jsの機能ではないため、アプリケーションに最適なパターンを見つけるためにいくつか調査を行うことをお勧めします。
> - セキュリティベストプラクティスについての詳細は、[Next.jsの記事「Security in Next.js」](https://nextjs.org/blog/security-nextjs-server-components-actions)を参照してください。

### Server Components {#server-components}

[Server Components](/docs/app/building-your-application/rendering/server-components)での認証チェックは、ロールベースのアクセスに有用です。例えば、ユーザーのロールに基づいてコンポーネントを条件的にレンダリングする場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // 'role'がセッションオブジェクトの一部であると仮定する

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // 'role'がセッションオブジェクトの一部であると仮定する

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

</TabItem>
</Tabs>

この例では、DALからの`verifySession()`関数を使用して、'admin'、'user'、および未認可のロールをチェックします。このパターンは、各ユーザーがそのロールに適したコンポーネントとのみ対話することを確保します。

### レイアウトと認証チェック {#layouts-and-auth-checks}

[部分レンダリング](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)のため、[Layouts](/docs/app/building-your-application/routing/layouts-and-templates)でチェックを行う場合、これらはナビゲーションで再レンダリングされないため、すべてのルート変更でユーザーセッションがチェックされないことに注意が必要です。

代わりに、データソースに近い場所や条件付きでレンダリングされるコンポーネントでチェックを行うべきです。

例として、ユーザーデータを取得してナビゲーションでユーザー画像を表示する共有レイアウトを検討します。レイアウトで認証チェックを行う代わりに、レイアウトでユーザーデータ（`getUser()`）を取得し、DALで認証チェックを行うべきです。

これにより、アプリケーション内で`getUser()`が呼び出される場所ならどこでも認証チェックが行われることが保証され、開発者がユーザーがデータにアクセスするために認証されていることを確認することを忘れることを防ぎます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // セッションからユーザーIDを取得し、データを取得する
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // セッションからユーザーIDを取得し、データを取得する
})
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - SPAにおける共通のパターンは、ユーザーが認証されていない場合、レイアウトまたはトップレベルコンポーネントで`return null`を返すことです。このパターンは**推奨されません**。なぜなら、Next.jsアプリケーションには複数のエントリポイントがあり、ネストされたルートセグメントおよびServer Actionsへのアクセスを防げないためです。

### Server Actions {#server-actions}

[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)は、公開APIエンドポイントと同じセキュリティを考慮し、ユーザーが変更を行うことが許可されているか確認します。

以下の例では、アクションを施行する前にユーザーの役割を確認します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // ユーザーにアクションを実行する権限がない場合は早く返す
  if (userRole !== 'admin') {
    return null
  }

  // 認可されたユーザーのアクションを続行します
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // ユーザーにアクションを実行する権限がない場合は早く返す
  if (userRole !== 'admin') {
    return null
  }

  // 認可されたユーザーのアクションを続行します
}
```

</TabItem>
</Tabs>

### Route Handlers {#route-handlers}

[Route Handlers](/docs/app/building-your-application/routing/route-handlers)は、公開APIエンドポイントと同じセキュリティ考慮を行い、ユーザーがRoute Handlerにアクセスすることができるか確認します。

例として：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // ユーザー認証と役割の確認
  const session = await verifySession()

  // ユーザーが認証されているかどうかを確認する
  if (!session) {
    // ユーザーは認証されていません
    return new Response(null, { status: 401 })
  }

  // ユーザーが'admin'役割を持っているか確認します
  if (session.user.role !== 'admin') {
    // ユーザーは認証されていますが、適切な権限を持っていません
    return new Response(null, { status: 403 })
  }

  // 認可されたユーザーに対して続行します
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // ユーザー認証と役割の確認
  const session = await verifySession()

  // ユーザーが認証されているかどうかを確認する
  if (!session) {
    // ユーザーは認証されていません
    return new Response(null, { status: 401 })
  }

  // ユーザーが'admin'役割を持っているか確認します
  if (session.user.role !== 'admin') {
    // ユーザーは認証されていますが、適切な権限を持っていません
    return new Response(null, { status: 403 })
  }

  // 認可されたユーザーに対して続行します
}
```

</TabItem>
</Tabs>

上記の例は、2層のセキュリティチェックを持つRoute Handlerを示しています。まず現在のアクティブセッションを確認し、その後ログイン済みユーザーが'admin'であるかを確認します。

## Context Providers {#context-providers}

Context Providerを使った認証は、[差し込み](/docs/app/building-your-application/rendering/composition-patterns#interleaving-server-and-client-components)のおかげで機能します。ただし、Reactの`context`はServer Componentsではサポートされておらず、Client Componentsでのみ適用されます。

これにより、子Server Componentsはまずサーバーでレンダリングされ、Context Providerのセッションデータにアクセスできません：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

```tsx title="app/ui/profile.ts switcher
"use client";

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx title="app/ui/profile.js switcher
"use client";

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

クライアントコンポーネントでセッションデータが必要な場合（例：クライアント側でのデータフェッチには）、Reactの[`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) APIを使って機密セッションデータがクライアントに露出しないようにすることができます。

</AppOnly>

<PagesOnly>

### データアクセス層（DAL）の作成 {#creating-a-data-access-layer-dal}

#### APIルートの保護 {#protecting-api-routes}

Next.jsにおけるAPIルートは、サーバー側のロジックとデータ管理を処理するために不可欠です。これらのルートを保護し、特定の機能にアクセスできるのは認…されたユーザーだけであることを確認することが重要です。通常は、ユーザーの認証状態と役割ベースの権限を確認します。

APIルートを保護する例を以下に示します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // ユーザーが認証されているかを確認します
  if (!session) {
    res.status(401).json({
      error: 'ユーザーは認証されていません。',
    })
    return
  }

  // ユーザーが'admin'役割を持っているかを確認します
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: '認可されていないアクセス：ユーザーには管理者特権がありません。',
    })
    return
  }

  // 認可されたユーザーに対してルートを続行います
  // ... APIルートの実装
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // ユーザーが認証されているかを確認します
  if (!session) {
    res.status(401).json({
      error: 'ユーザーは認証されていません。',
    })
    return
  }

  // ユーザーが'admin'役割を持っているかを確認します
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: '認可されていないアクセス：ユーザーには管理者特権がありません。',
    })
    return
  }

  // 認可されたユーザーに対してルートを続行します
  // ... APIルートの実装
}
```

</TabItem>
</Tabs>

この例は、認証と承認の二段階セキュリティチェック付きのAPIルートを示しています。まず、アクティブセッションの存在を確認し、その後ログインしたユーザーが'admin'であるかを確認します。このアプローチにより、リクエスト処理が認証および承認されたユーザーに限定され、安全なアクセスが確保されます。

</PagesOnly>

## Resources {#resources}

Next.jsでの認証について学んだ今、多くのライブラリやリソースがあります。これらを使用して、より安全な認証とセッション管理を実現し、実装の品質を高めましょう：

### Auth Libraries {#auth-libraries}

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### Session Management Libraries {#session-management-libraries}

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## Further Reading {#further-reading}

認証とセキュリティについて学び続けるために、以下のリソースを参考にしてください：

- [How to think about security in Next.js](https://nextjs.org/blog/security-nextjs-server-components-actions)
- [Understanding XSS Attacks](https://vercel.com/guides/understanding-xss-attacks)
- [Understanding CSRF Attacks](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
