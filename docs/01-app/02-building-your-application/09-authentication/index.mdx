---
title: '認証'
description: 'Next.jsアプリケーションにおける認証の実装方法を学ぶ。'
---

認証を理解することは、アプリケーションのデータを保護するために非常に重要です。このページでは、ReactとNext.jsの機能を使用して認証を実装する方法をガイドします。

始める前に、プロセスを3つの概念に分解すると役立ちます：

1. **[認証](#authentication)**: ユーザーが主張する人物であるかを確認します。ユーザーは、ユーザー名やパスワードなど、持っている何かを使って自分の身元を証明する必要があります。
2. **[セッション管理](#session-management)**: リクエストをまたいでユーザーの認証状態を追跡します。
3. **[認可](#authorization)**: ユーザーがアクセスできるルートやデータを決定します。

この図は、ReactとNext.jsの機能を使用した認証フローを示しています：

<Image
  alt="ReactとNext.jsの機能を用いた認証フローを示す図"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

このページの例では、教育目的のために基本的なユーザー名とパスワード認証について説明します。独自の認証ソリューションを実装することもできますが、セキュリティを強化し、シンプル化するために、認証ライブラリを使用することをお勧めします。これらのライブラリは、認証、セッション管理、認可について組み込みのソリューションを提供し、さらにソーシャルログイン、多要素認証、ロールベースのアクセス制御などの追加機能を提供します。詳細は[Auth Libraries](#auth-libraries)のセクションでリストを確認できます。

## 認証 {#authentication}

<AppOnly>

### サインアップとログイン機能 {#sign-up-and-login-functionality}

Reactの[`<form>`](https://react.dev/reference/react-dom/components/form)要素とReactの[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)および`useFormState`を使用してユーザーの認証情報をキャプチャし、フォームのフィールドを検証し、認証プロバイダーのAPIやデータベースに呼び出します。

Server Actionsは常にサーバー上で実行されるため、認証ロジックを処理する安全な環境を提供します。

サインアップ/ログイン機能の実装手順は以下のとおりです：

#### 1. ユーザーの認証情報をキャプチャする {#1-capture-user-credentials}

ユーザーの認証情報をキャプチャするには、送信時にServer Actionを呼び出すフォームを作成します。たとえば、ユーザーの名前、メールアドレス、パスワードを受け付けるサインアップフォームです：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions/auth.tsx" switcher
export async function signup(formData: FormData) {}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions/auth.js" switcher
export async function signup(formData) {}
```

</TabItem>
</Tabs>

#### 2. フォームフィールドをサーバー上で検証する {#2-validate-form-fields-on-the-server}

Server Actionを使用してサーバー上でフォームフィールドを検証します。認証プロバイダーがフォーム検証を提供しない場合、[Zod](https://zod.dev/)や[Yup](https://github.com/jquense/yup)のようなスキーマ検証ライブラリを使用できます。

例としてZodを使用して、適切なエラーメッセージ付きのフォームスキーマを定義できます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Name must be at least 2 characters long.' })
    .trim(),
  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Be at least 8 characters long' })
    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })
    .regex(/[0-9]/, { message: 'Contain at least one number.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Contain at least one special character.',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Name must be at least 2 characters long.' })
    .trim(),
  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Be at least 8 characters long' })
    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })
    .regex(/[0-9]/, { message: 'Contain at least one number.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Contain at least one special character.',
    })
    .trim(),
})
```

</TabItem>
</Tabs>

認証プロバイダーのAPIやデータベースへの不要な呼び出しを防ぐために、定義されたスキーマに一致しないフォームフィールドがある場合はServer Actionで早めに`return`します。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // Validate form fields
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // If any form fields are invalid, return early
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Call the provider or db to create a user...
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // Validate form fields
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // If any form fields are invalid, return early
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Call the provider or db to create a user...
}
```

</TabItem>
</Tabs>

`<SignupForm />`では、Reactの`useFormState`フックを使用して、フォームの送信中に検証エラーを表示できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup-form.tsx" switcher
highlight={7,15,21,27-39}
'use client'

import { useFormState, useFormStatus } from 'react-dom'
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  const [state, action] = useFormState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Password must:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <SubmitButton />
    </form>
  )
}

function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      Sign Up
    </button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup-form.js" switcher
highlight={7,15,21,27-39}
'use client'

import { useFormState, useFormStatus } from 'react-dom'
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  const [state, action] = useFormState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="John Doe" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="john@example.com" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Password must:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <SubmitButton />
    </form>
  )
}

function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      Sign Up
    </button>
  )
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - この例ではNext.jsのApp RouterにバンドルされているReactの`useFormState`フックを使用しています。React 19を使用している場合、`useActionState`を使用してください。詳細は[Reactドキュメント](https://react.dev/reference/react/useActionState)を参照してください。
> - React 19では、`useFormStatus`には返されるオブジェクトにdata, method, actionなどの追加キーが含まれています。React 19を使用していない場合、利用できるのは`pending`キーのみです。
> - React 19では、`useActionState`には返される状態に`pending`キーも含まれています。
> - データを変更する前に、常にユーザーがそのアクションを実行する権限も持っていることを確認する必要があります。[Authentication and Authorization](#authorization)を参照してください。

#### 3. ユーザーを作成またはユーザーの認証情報を確認する {#3-create-a-user-or-check-user-credentials}

フォームフィールドを検証した後、認証プロバイダーのAPIまたはデータベースを呼び出して新しいユーザー アカウントを作成するか、ユーザーが存在するかどうかを確認できます。

前の例から続けます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. Validate form fields
  // ...

  // 2. Prepare data for insertion into database
  const { name, email, password } = validatedFields.data
  // e.g. Hash the user's password before storing it
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Insert the user into the database or call an Auth Library's API
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'An error occurred while creating your account.',
    }
  }

  // TODO:
  // 4. Create user session
  // 5. Redirect user
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. Validate form fields
  // ...

  // 2. Prepare data for insertion into database
  const { name, email, password } = validatedFields.data
  // e.g. Hash the user's password before storing it
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Insert the user into the database or call an Library API
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'An error occurred while creating your account.',
    }
  }

  // TODO:
  // 4. Create user session
  // 5. Redirect user
}
```

</TabItem>
</Tabs>

ユーザー アカウントの作成またはユーザー資格情報の確認に成功した後、セッションを作成してユーザーの認証状態を管理できます。セッション管理戦略によっては、セッションがcookieまたはデータベース、またはその両方に保存される場合があります。詳細については、[セッション管理](#session-management)セクションに進んでください。

> **Tips:**
>
> - 上記の例は、教育目的のために認証手順を分解しているため冗長です。これは、独自の安全なソリューションを実装することが迅速に複雑になる可能性があることを強調しています。プロセスを簡略化するために[Auth Library](#auth-libraries)の使用を検討してください。
> - ユーザー エクスペリエンスを向上させるために、登録フローの早い段階で重複するメールやユーザー名があるかどうかを確認することをお勧めします。たとえば、ユーザーがユーザー名を入力中または入力フィールドが焦点を失ったときです。これにより、不要なフォーム送信を防ぎ、ユーザーに即時フィードバックを提供するのに役立ちます。これらのチェックの頻度を管理するには、[use-debounce](https://www.npmjs.com/package/use-debounce)などのライブラリを使用してリクエストをデバウンスできます。

</AppOnly>

<PagesOnly>

サインアップまたはログイン フォームを実装する手順は次のとおりです：

1. ユーザーがフォームから資格情報を送信します。
2. フォームがリクエストを送信し、APIルートで処理されます。
3. 検証に成功すると、プロセスが完了し、ユーザーの認証が成功したことを示します。
4. 検証が失敗した場合、エラーメッセージが表示されます。

ユーザーが資格情報を入力できるログインフォームを考えてみましょう：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Handle errors
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Handle errors
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

上記のフォームには、ユーザーのメールアドレスとパスワードを取得するための2つの入力フィールドがあります。送信時に、APIルート (`/api/auth/login`) にPOSTリクエストを送信する関数をトリガーします。

その後、APIルートで認証を処理するために、認証プロバイダーのAPIを呼び出すことができます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Invalid credentials.' })
    } else {
      res.status(500).json({ error: 'Something went wrong.' })
    }
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Invalid credentials.' })
    } else {
      res.status(500).json({ error: 'Something went wrong.' })
    }
  }
}
```

</TabItem>
</Tabs>

</PagesOnly>

## セッション管理 {#session-management}

セッション管理は、ユーザーの認証状態をリクエスト間で保持することを保証します。これには、セッションまたはトークンの作成、保存、更新、削除が含まれます。

セッションには2つのタイプがあります：

1.  [**ステートレス**](#stateless-sessions)： セッションデータ（またはトークン）はブラウザーのcookieに保存されます。このcookieはリクエストごとに送信され、サーバーでのセッションの検証を可能にします。この方法は、正しく実装されないと安全性が低下する可能性がありますが、よりシンプルです。
2.  [**データベース**](#database-sessions)：セッションデータはデータベースに保存され、ユーザーのブラウザには暗号化されたセッションIDのみが送信されます。この方法はより安全ですが、複雑であり、サーバーリソースをより多く使用する場合があります。

> **Good to know:** どちらの方法でも、またはその両方を使用できますが、[Iron-Session](https://github.com/vvo/iron-session)や[Jose](https://github.com/panva/jose)のようなセッション管理ライブラリを使用することをお勧めします。

### ステートレス セッション {#stateless-sessions}

<AppOnly>

ステートレスセッションを作成および管理するには、次のいくつかの手順に従う必要があります：

1. セッションの署名に使用する秘密鍵を生成し、[環境変数](/docs/app/building-your-application/configuring/environment-variables)として保存します。
2. セッション管理ライブラリを使用してセッションデータを暗号化/復号化するロジックを書きます。
3. Next.js の[`cookies`](/docs/app/api-reference/functions/cookies) APIを使用してクッキーを管理します。

上記に加えて、ユーザーがアプリケーションに戻ったときにセッションを[更新（または更新）](#updating-or-refreshing-sessions)したり、ユーザーがログアウトしたときにセッションを[削除](#deleting-the-session)したりする機能を追加することを検討してください。

> **Good to know:** [auth ライブラリ](#auth-libraries)にセッション管理が含まれているかどうかを確認します。

#### 1. 秘密鍵の生成 {#1-generating-a-secret-key}

セッションに署名するための秘密鍵を生成する方法はいくつかあります。たとえば、ターミナルで`openssl`コマンドを使用することもできます：

```bash title="terminal"
/openssl rand -base64 32
```

このコマンドはランダムな32文字の文字列を生成します。これを秘密鍵として、[環境変数ファイル](/docs/app/building-your-application/configuring/environment-variables)に保存します：

```bash title=".env"
SESSION_SECRET=your_secret_key
```

その後、この秘密鍵をセッション管理ロジック内で参照できます：

```js title="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. セッションの暗号化と復号化 {#2-encrypting-and-decrypting-sessions}

次に、選択した[セッション管理ライブラリ](#session-management-libraries)を使用してセッションを暗号化および復号化できます。前の例から続けて、Reactの[`server-only`](https://www.npmjs.com/package/server-only)パッケージと[Jose](https://www.npmjs.com/package/jose)（[Edge Runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)と互換性があります）を使用して、セッション管理ロジックがサーバー上でのみ実行されることを確認します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Failed to verify session')
  }
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Failed to verify session')
  }
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - ペイロードには、ユーザーの ID、役割など、後続のリクエストで使用される**最小限の**ユニークユーザー データが含まれている必要があります。電話番号、メールアドレス、クレジットカード情報などの個人情報や、パスワードなどの機密データを含めるべきではありません。

#### 3. クッキーの設定（推奨オプション） {#3-setting-cookies-recommended-options}

cookieにセッションを保存するには、Next.js [`cookies`](/docs/app/api-reference/functions/cookies) APIを使用します。Cookieはサーバー上で設定され、推奨オプションを含める必要があります：

- **HttpOnly**: クライアント側のJavaScriptからCookieへのアクセスを防ぎます。
- **Secure**: httpsを使用してcookieを送信します。
- **SameSite**: cookieをクロスサイトリクエストと一緒に送信できるかどうかを指定します。
- **Max-AgeまたはExpires**: 一定期間後にcookieを削除します。
- **Path**: cookieのURLパスを定義します。

これらのオプションの詳細については、[MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)を参照してください。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })(await cookies()).set(
    'session',
    session,
    {
      httpOnly: true,
      secure: true,
      expires: expiresAt,
      sameSite: 'lax',
      path: '/',
    }
  )
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

Server Action 内に戻って、`createSession()` 関数を呼び出し、[`redirect()`](/docs/app/building-your-application/routing/redirecting) APIを使用してユーザーを適切なページにリダイレクトできます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // Previous steps:
  // 1. Validate form fields
  // 2. Prepare data for insertion into database
  // 3. Insert the user into the database or call an Library API

  // Current steps:
  // 4. Create user session
  await createSession(user.id)
  // 5. Redirect user
  redirect('/profile')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // Previous steps:
  // 1. Validate form fields
  // 2. Prepare data for insertion into database
  // 3. Insert the user into the database or call an Library API

  // Current steps:
  // 4. Create user session
  await createSession(user.id)
  // 5. Redirect user
  redirect('/profile')
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - クッキー**はサーバーで設定する必要があります**。これにより、クライアント側での改ざんを防ぐことができます。
> - 🎥 視聴： Next.js でのステートレス セッションと認証について詳しく学ぶ → [YouTube（11分）](https://www.youtube.com/watch?v=DJvM2lSPn6w)。

#### セッションの更新 (または更新) {#updating-or-refreshing-sessions}

セッションの有効期限を延長することも可能です。これは、ユーザーがアプリケーションに再アクセスした後もログインを維持するのに役立ちます。 たとえば：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

> **Tip:** 認証ライブラリがユーザーのセッションを延長するために使用できる更新トークンをサポートしているか確認してください。

#### セッションの削除 {#deleting-the-session}

セッションを削除するには、cookieを削除できます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

</TabItem>
</Tabs>

次に、ログアウト時など、アプリケーション内で`deleteSession()`関数を再利用できます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  deleteSession()
  redirect('/login')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  deleteSession()
  redirect('/login')
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

#### クッキーの設定と削除 {#setting-and-deleting-cookies}

[API Routes](https://nextjs.org/docs/canary/pages/building-your-application/routing/api-routes) を使用して、サーバーでクッキーとしてセッションを設定できます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // One week
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // One week
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</TabItem>
</Tabs>

</PagesOnly>

### データベース セッション {#database-sessions}

データベースセッションを作成および管理するには、次の手順に従う必要があります：

1. セッションとデータを保存するデータベースにテーブルを作成します（または、お使いの認証ライブラリがこれを処理するかどうかを確認します）。
2. セッションを挿入、更新、および削除する機能を実装する
3. セッションIDをクライアントのブラウザに保存する前に暗号化し、データベースとクッキーが同期した状態を維持します（これはオプションですが、[Middleware](#optimistic-checks-with-middleware-optional)での楽観的認証チェックには推奨されます）。

<AppOnly>

例えば：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Create a session in the database
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Return the session ID
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Encrypt the session ID
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Store the session in cookies for optimistic auth checks
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Create a session in the database
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Return the session ID
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Encrypt the session ID
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Store the session in cookies for optimistic auth checks
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - より高速なデータ取得のために、[Vercel Redis](https://vercel.com/docs/storage/vercel-kv)のようなデータベースを使用することを検討してください。ただし、主要なデータベースにセッション データを保持することもでき、データ要求を組み合わせてクエリの数を減らすことも可能です。
> - より高度なユースケースには、ユーザーが最後にログインした時間やアクティブなデバイスの数を追跡したり、ユーザーにすべてのデバイスからログアウトする機能を提供したりするために、データベースセッションの使用を選択する場合があります。

セッション管理を実装した後、アプリケーション内でユーザーがアクセスできるものと実行できる操作を制御するために、認可ロジックを追加する必要があります。詳細については、[認可](#authorization)セクションに進んでください。

</AppOnly>

<PagesOnly>

**サーバー上のセッションの作成**：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</TabItem>
</Tabs>

</PagesOnly>

## 認可 {#authorization}

ユーザーが認証され、セッションが作成されたら、認可を実装して、アプリケーション内でユーザーがアクセスできる内容と実行できる内容を制御できます。

認証チェックには主に2つのタイプがあります：

1. **楽観的**: cookie に保存されているセッション データを使用して、ユーザーがルートまたはアクションを実行する権限があるかどうかを確認します。これらのチェックは、許可や役割に基づいてUI要素を表示/非表示にしたり、ユーザーをリダイレクトしたりするなど、迅速な操作に役立ちます。
2. **セキュア**: ユーザーがルートまたはアクションを実行する権限があるかどうかを確認するために、データベースに保存されているセッションデータを使用します。これらのチェックはより安全であり、機密データへのアクセスや操作が必要な場合に使用されます。

どちらの場合も次をお勧めします：

- 認証ロジックを集約するために[データ アクセス層 (DAL)](#creating-a-data-access-layer-dal)を作成する
- [データ転送オブジェクト (DTO)](#using-data-transfer-objects-dto) を使用して、必要なデータのみを返す
- 楽観的チェックを実行するために[Middleware](#optimistic-checks-with-middleware-optional)を使用する (オプション).

### ミドルウェアを使用した楽観的チェック (オプション) {#optimistic-checks-with-middleware-optional}

ある場合には、[Middleware](/docs/app/building-your-application/routing/middleware)を使用して、権限に基づいてユーザーをリダイレクトしたいこともあります：

- 楽観的チェックを実行するため。Middlewareはすべてのルートで実行されるため、リダイレクトロジックを統合し、認可されていないユーザーを事前にフィルタリングするための良い方法です。
- ユーザー間でデータを共有する静的ルートを保護するため（例：ペイウォールの後ろのコンテンツ）。

ただし、ミドルウェアは[プリフェッチされた](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)ルートを含むすべてのルートで実行されるため、パフォーマンスの問題を防ぐためにデータベース チェックを避け、クッキーからセッションを読み取るだけにすることが重要です（楽観的チェック）。

例えば：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Specify protected and public routes
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. Check if the current route is protected or public
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Decrypt the session from the cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. Redirect to /login if the user is not authenticated
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. Redirect to /dashboard if the user is authenticated
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Routes Middleware should not run on
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Specify protected and public routes
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. Check if the current route is protected or public
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Decrypt the session from the cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. Redirect to /login if the user is not authenticated
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. Redirect to /dashboard if the user is authenticated
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Routes Middleware should not run on
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

</TabItem>
</Tabs>

ミドルウェアは初期チェックには役立ちますが、データを保護するための唯一の手段にはすべきではありません。セキュリティ チェックの大部分は、データ ソースにできるだけ近いところで実行する必要があります。詳細については、[Data Access Layer](#creating-a-data-access-layer-dal)を参照してください。

> **Tips**:
>
> - ミドルウェアでは、`req.cookies.get('session').value` を使用して cookie を読み取ることもできます。
> - ミドルウェアは[Edge Runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を使用します。auth ライブラリとセッション管理ライブラリが互換性があるかどうかを確認してください。
> - ミドルウェアの`matcher` プロパティを使用して、ミドルウェアを実行するルートを指定できます。ただし、認証には、ミドルウェアがすべてのルートで実行されることをお勧めします。

<AppOnly>

### データアクセス層（DAL）の作成 {#creating-a-data-access-layer-dal}

データリクエストと認可ロジックを集約するために、DAL の作成をお勧めします。

DAL には、アプリケーションと対話するときにユーザーのセッションを検証する関数を含める必要があります。少なくとも、この関数はセッションが有効かどうかを確認した後、リダイレクトするか、追加のリクエストを行うために必要なユーザー情報を返す必要があります。

たとえば、DAL の別のファイルを作成して`verifySession()` 関数を含めます。次に、React の[cache](https://react.dev/reference/react/cache) API を使用して、React のレンダー パス中に関数の戻り値をメモ化します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

</TabItem>
</Tabs>

その後、データリクエスト、Server Actions、Route Handlersで`verifySession()`関数を呼び出すことができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Explicitly return the columns you need rather than the whole user object
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Explicitly return the columns you need rather than the whole user object
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

</TabItem>
</Tabs>

> **Tip**:
>
> - DAL は、リクエスト時にフェッチされたデータを保護するために使用できます。ただし、ユーザー間でデータを共有する静的ルートでは、データはビルド時ではなくリクエスト時にフェッチされます。静的ルートを保護するには、[Middleware](#optimistic-checks-with-middleware-optional)を使用します。
> - セキュアチェックの場合、データベースとセッションIDを比較することで、セッションが有効かどうかを確認できます。React の [cache](https://react.dev/reference/react/cache) 関数を使用して、レンダー パス中にデータベースへの不必要な重複リクエストを回避します。
> - 関連するデータ リクエストをJavaScriptクラスにまとめて、メソッドの前に`verifySession()`を実行することをお勧めします。

### データ転送オブジェクト (DTO) の使用 {#using-data-transfer-objects-dto}

データを取得する場合、アプリケーションで使用される必要なデータのみを返し、オブジェクト全体を返さないことをお勧めします。たとえば、ユーザーデータをフェッチする場合、そのユーザーの ID と名前だけを返すかもしれません。ユーザーオブジェクト全体を返すと、パスワード、電話番号などが含まれる可能性があるからです。

ただし、返されるデータ構造を制御できない場合や、全体のオブジェクトがクライアントに渡されることを防ぎたいチームで作業している場合は、クライアントにエクスポートしても安全なフィールドを指定するなどの戦略を使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Return specific columns here
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Or return only what's specific to the query here
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Return specific columns here
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Or return only what's specific to the query here
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

</TabItem>
</Tabs>

データ リクエストと認可ロジックを DAL に集約し、DTO を使用することで、すべてのデータ リクエストが安全で一貫したものであることが保証され、アプリケーションのスケールに応じてメンテナンス、監査、デバッグが容易になります。

> **Good to know**:
>
> - DTOを定義する方法はいくつかあり、`toJSON()`を使用する方法から、個別関数を使用する方法までさまざまです。これらはJavaScriptのパターンであり、ReactまたはNext.jsの機能ではないため、アプリケーションに最も適したパターンを見つけるために調査することをお勧めします。
> - [Next.js のセキュリティに関する記事](https://nextjs.org/blog/security-nextjs-server-components-actions)でセキュリティのベストプラクティスについて詳しく学びます。

### Server Components {#server-components}

[Server Components](/docs/app/building-your-application/rendering/server-components)での認証チェックは、役割ベースのアクセスに役立ちます。たとえば、ユーザーの役割に基づいてコンポーネントを条件付きでレンダリングするとします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // Assuming 'role' is part of the session object

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // Assuming 'role' is part of the session object

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

</TabItem>
</Tabs>

例では、DAL の `verifySession()` 関数を使用して、「admin」、「user」、および許可されていない役割をチェックしています。このパターンにより、各ユーザーが役割に適したコンポーネントと対話できるようになります。

### レイアウトと認証チェック {#layouts-and-auth-checks}

[Partial Rendering](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering) のため、[レイアウト](/docs/app/building-your-application/routing/layouts-and-templates)でチェックを行う場合は注意が必要です。これらはナビゲーション時に再レンダリングされず、ユーザーセッションがすべてのルート変更でチェックされるわけではありません。

代わりに、データ ソースまたは条件付きでレンダリングされるコンポーネントに近い場所でチェックを行う必要があります。

たとえば、ユーザー データをフェッチしてナビゲーションにユーザー画像を表示する共有レイアウトを考えてみましょう。レイアウトで認証チェックを行う代わりに、`getUser()` のユーザー データをフェッチし、DAL で認証チェックを行う必要があります。

これにより、アプリケーション内のどこで `getUser()` が呼び出されても、認証チェックが行われ、データにアクセスすることをユーザーが許可されていることを確認することを開発者が欠かさずに行えます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Get user ID from session and fetch data
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Get user ID from session and fetch data
})
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - SPA の一般的なパターンは、ユーザーが許可されていない場合、レイアウトやトップレベルのコンポーネントで `null` を返すことです。このパターンは推奨されません。なぜなら、Next.js アプリケーションには複数のエントリ ポイントがあり、これではネストされたルートセグメントやServer Actionへのアクセスを防ぐことができないからです。

### サーバーアクション {#server-actions}

[Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)には、公開された API エンドポイントと同じセキュリティ上の考慮事項を適用し、ユーザーがミューテーションを実行できるかどうかを確認してください。

以下の例では、アクションを進める前にユーザーの役割を確認します。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // Return early if user is not authorized to perform the action
  if (userRole !== 'admin') {
    return null
  }

  // Proceed with the action for authorized users
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // Return early if user is not authorized to perform the action
  if (userRole !== 'admin') {
    return null
  }

  // Proceed with the action for authorized users
}
```

</TabItem>
</Tabs>

### ルート ハンドラ {#route-handlers}

[ルート ハンドラー](/docs/app/building-your-application/routing/route-handlers)には、公開されている API エンドポイントと同じセキュリティ上の考慮事項を適用し、ユーザーがルート ハンドラーにアクセスすることが許可されているかどうかを確認してください。

例えば：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // User authentication and role verification
  const session = await verifySession()

  // Check if the user is authenticated
  if (!session) {
    // User is not authenticated
    return new Response(null, { status: 401 })
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    // User is authenticated but does not have the right permissions
    return new Response(null, { status: 403 })
  }

  // Continue for authorized users
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // User authentication and role verification
  const session = await verifySession()

  // Check if the user is authenticated
  if (!session) {
    // User is not authenticated
    return new Response(null, { status: 401 })
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    // User is authenticated but does not have the right permissions
    return new Response(null, { status: 403 })
  }

  // Continue for authorized users
}
```

</TabItem>
</Tabs>

上記の例は、2 段階のセキュリティ チェックを備えたルート ハンドラーを示しています。まずアクティブなセッションを確認し、次にログインしているユーザーが「管理者」であるかどうかを確認します。

## コンテキスト プロバイダー {#context-providers}

認証には、[インターリーブ](/docs/app/building-your-application/rendering/composition-patterns#interleaving-server-and-client-components) により、コンテキストプロバイダーの使用が有効です。ただし、React `context` はサーバー コンポーネントではサポートされていないため、クライアント コンポーネントにのみ適用されます。

これが実現しますが、子サーバー コンポーネントはまずサーバーでレンダリングされるため、コンテキストプロバイダーのセッションデータへのアクセスはできなくなります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

```tsx title="app/ui/profile.ts" switcher
"use client";

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx title="app/ui/profile.js" switcher
"use client";

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

セッションデータがクライアント コンポーネントに必要な場合 (たとえば、クライアント側のデータ フェッチの場合)、React の [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) API を使用して、機密セッションデータがクライアントに公開されないようにします。

</AppOnly>

<PagesOnly>

### データアクセス層（DAL）の作成 {#creating-a-data-access-layer-dal}

#### API ルートの保護 {#protecting-api-routes}

Next.js の API ルートは、サーバー側のロジックとデータ管理を処理するための重要な機能です。これらのルートを保護して、特定の機能にアクセスできるのは承認されたユーザーだけであることを確認することが重要です。これには通常、ユーザーの認証ステータスと役割ベースの権限を確認することが含まれます。

APIルートを保護する方法の例を次に示します：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // Check if the user is authenticated
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // Proceed with the route for authorized users
  // ... implementation of the API Route
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // Check if the user is authenticated
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // Proceed with the route for authorized users
  // ... implementation of the API Route
}
```

</TabItem>
</Tabs>

この例は、認証と承認のための二重セキュリティチェックを備えたAPIルートを示しています。まず、アクティブなセッションを確認し、次にログインしているユーザーが「管理者」であるかどうかを確認します。このアプローチにより、アクセスが認証および承認されたユーザーに限定されるため、リクエスト処理の堅牢なセキュリティが保証されます。

</PagesOnly>

## リソース {#resources}

Next.js における認証について学んだ今、セキュリティ認証およびセッション管理を実装するのに役立つ Next.js と互換性のあるライブラリとリソースを次に示します：

### Auth ライブラリ {#auth-libraries}

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### セッション管理ライブラリ {#session-management-libraries}

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## さらなる学び {#further-reading}

認証とセキュリティについて学び続けるには、次のリソースをチェックしてください：

- [Next.js におけるセキュリティを考える方法](https://nextjs.org/blog/security-nextjs-server-components-actions)
- [XSS攻撃を理解する](https://vercel.com/guides/understanding-xss-attacks)
- [CSRF攻撃を理解する](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
