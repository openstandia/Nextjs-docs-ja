---
title: 'Authentication'
description: 'Next.js アプリケーションで認証を実装する方法を学ぶ。'
---

認証を理解することは、アプリケーションのデータを保護するために重要です。このページでは、React と Next.js の機能を使って認証を実装する方法を案内します。

まず、プロセスを3つの概念に分解することから始めると役立ちます。

1. **[Authentication](#authentication)**: ユーザーが自分が主張する人物であるかどうかを確認します。ユーザーには、ユーザー名とパスワードのように、何かを所持していることを証明することが必要です
2. **[Session Management](#session-management)**: リクエスト間でのユーザーの認証状態を追跡します
3. **[Authorization](#authorization)**: ユーザーがアクセスできるルートとデータを決定します

この図は、React と Next.js の機能を使用した認証フローを示しています。

<Image
  alt="ReactとNext.js機能を使用した認証フローを示す図"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

このページの例では、教育目的で基本的なユーザー名とパスワードによる認証を説明しています。独自の認証ソリューションを実装することも可能ですが、セキュリティとシンプルさを向上させるために、認証ライブラリの使用をおすすめします。これらは、認証、セッション管理、承認のための組み込みのソリューションを提供するだけでなく、ソーシャルログイン、多要素認証、ロールベースのアクセス制御などの追加機能も提供します。詳細は [Auth Libraries](#auth-libraries) セクションで確認できます。

## Authentication {#authentication}

<AppOnly>

### サインアップとログイン機能 {#sign-up-and-login-functionality}

ユーザーの資格情報をキャプチャし、フォームフィールドを検証し、Authentication Provider のAPIまたはデータベースを呼び出すために、React の [`<form>`](https://react.dev/reference/react-dom/components/form) 要素と [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) および `useActionState` を使用できます。

Server Actions は常にサーバーで実行されるため、認証ロジックを処理するための安全な環境を提供します。

サインアップ/ログイン機能を実装するためのステップは以下のとおりです。

#### 1. ユーザーの資格情報をキャプチャ {#1-capture-user-credentials}

ユーザーの資格情報をキャプチャするには、送信時に Server Action を呼び出すフォームを作成します。たとえば、ユーザーの名前、メール、パスワードを受け取るサインアップフォームです。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions/auth.tsx" switcher
export async function signup(formData: FormData) {}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions/auth.js" switcher
export async function signup(formData) {}
```

</TabItem>
</Tabs>

#### 2. サーバーでフォームフィールドを検証 {#2-validate-form-fields-on-the-server}

Server Action を使用して、サーバー上でフォームフィールドを検証します。認証プロバイダーがフォームの検証を提供していない場合は、[Zod](https://zod.dev/) や [Yup](https://github.com/jquense/yup) のようなスキーマ検証ライブラリを使用できます。

Zod を使用する例として、適切なエラーメッセージを含むフォームスキーマを定義できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Name must be at least 2 characters long.' })
    .trim(),
  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Be at least 8 characters long' })
    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })
    .regex(/[0-9]/, { message: 'Contain at least one number.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Contain at least one special character.',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Name must be at least 2 characters long.' })
    .trim(),
  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Be at least 8 characters long' })
    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })
    .regex(/[0-9]/, { message: 'Contain at least one number.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Contain at least one special character.',
    })
    .trim(),
})
```

</TabItem>
</Tabs>

フォームフィールドが定義されたスキーマに一致しない場合、不要な認証プロバイダーの API またはデータベースへの呼び出しを防ぐために、Server Action 内で早期に `return` できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // フォームフィールドを検証
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // フォームフィールドが無効な場合は早期に帰る
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // プロバイダーまたはデータベースを呼び出してユーザーを作成...
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // フォームフィールドを検証
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // フォームフィールドが無効な場合は早期に帰る
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // プロバイダーまたはデータベースを呼び出してユーザーを作成...
}
```

</TabItem>
</Tabs>

`<SignupForm />` に戻り、React の `useActionState` フックを使用して、フォーム送信中に検証エラーを表示できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/signup-form.tsx" switcher
highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Password must:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Sign Up
      </button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/signup-form.js" switcher
highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Password must:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Sign Up
      </button>
    </form>
  )
}
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - React 19 では、`useFormStatus` が返されるオブジェクトに `data`、 `method`、 `action` のような追加のキーを含みます。React 19 を使用していない場合は、`pending` キーのみが利用可能です。
> - React 19 では、`useActionState` の返される状態に `pending` キーも含まれます。
> - データを変更する前に、ユーザーがそのアクションを実行する権限があることを常に確認してください。詳細は [Authentication and Authorization](#authorization) を参照してください。

#### 3. ユーザーを作成するか、ユーザーの資格情報を確認する {#3-create-a-user-or-check-user-credentials}

フォームフィールドを検証した後に、認証プロバイダーの API またはデータベースを呼び出して、新しいユーザーアカウントを作成するか、ユーザーが存在するかどうかを確認できます。

前の例に続行して:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. フォームフィールドを検証
  // ...

  // 2. データベースにデータを挿入するためのデータを準備する
  const { name, email, password } = validatedFields.data
  // e.g. ハッシュ化したユーザーのパスワードを保存する前に
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. ユーザーをデータベースに挿入するか、Auth Library の API を呼び出す
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'An error occurred while creating your account.',
    }
  }

  // TODO:
  // 4. ユーザーセッションを作成
  // 5. ユーザーをリダイレクト
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. フォームフィールドを検証
  // ...

  // 2. データベースにデータを挿入するためのデータを準備する
  const { name, email, password } = validatedFields.data
  // e.g. ハッシュ化したユーザーのパスワードを保存する前に
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. ユーザーをデータベースに挿入するか、Auth Library の API を呼び出す
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'An error occurred while creating your account.',
    }
  }

  // TODO:
  // 4. ユーザーセッションを作成
  // 5. ユーザーをリダイレクト
}
```

</TabItem>
</Tabs>

ユーザーアカウントの作成またはユーザーの資格情報の確認が成功した後、ユーザーの認証状態を管理するセッションを作成できます。セッション管理戦略に応じて、セッションは cookie またはデータベース、またはその両方に格納できます。詳細については、[Session Management](#session-management) セクションに進んでください。

> **Tips:**
>
> - 上記の例は、教育目的で認証ステップを詳細に説明しているため冗長です。独自のセキュアなソリューションを実装することはすぐに複雑になることを示しています。プロセスを簡素化するために [Auth Library](#auth-libraries) の使用を検討してください
> - ユーザーエクスペリエンスを向上させるために、登録フローの初期段階で重複するメールまたはユーザー名を確認することをお勧めします。たとえば、ユーザーがユーザー名を入力する際や、入力フィールドがフォーカスを失うときに。この方法は、不要なフォーム送信を防ぎ、ユーザーに即時のフィードバックを提供するのに役立ちます。このチェックの頻度を管理するために、[use-debounce](https://www.npmjs.com/package/use-debounce) などのライブラリを使用してリクエストをデバウンスすることができます。

</AppOnly>

<PagesOnly>

サインアップおよび/またはログインフォームを実装する手順は次のとおりです。

1. ユーザーがフォームを通じて資格情報を送信します。
2. フォームは送信されたリクエストを受け取る API ルートを呼び出します。
3. 成功した認証後、プログレスバーが表示され、ユーザーの認証が成功したことを示します。
4. 認証が失敗した場合、エラーメッセージが表示されます。

ユーザーが資格情報を入力できるログインフォームを検討してください。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // エラーを処理
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // エラーを処理
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  )
}
```

</TabItem>
</Tabs>

このフォームにはユーザーのメールアドレスとパスワードをキャプチャするための二つの入力フィールドがあります。送信時に、`/api/auth/login` への POST リクエストを送信する関数が呼び出されます。

その後、APIルートで Authentication Provider のAPIを呼び出して認証を処理できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Invalid credentials.' })
    } else {
      res.status(500).json({ error: 'Something went wrong.' })
    }
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Invalid credentials.' })
    } else {
      res.status(500).json({ error: 'Something went wrong.' })
    }
  }
}
```

</TabItem>
</Tabs>

</PagesOnly>

## Session Management {#session-management}

セッション管理は、リクエスト間でユーザーの認証された状態を保持することを保証します。セッションまたはトークンの作成、保存、更新、削除が含まれます。

セッションには2つのタイプがあります。

1. [**Stateless**](#stateless-sessions): セッションデータ（またはトークン）がブラウザの cookie に保存されます。 cookie は各リクエストと共に送信され、サーバーでセッションを確認できます。この方法はシンプルですが、実装が正しくないとセキュリティが低くなる可能性があります
2. [**Database**](#database-sessions): セッションデータはデータベースに保存され、ユーザーのブラウザには暗号化されたセッションIDのみが送信されます。この方法はより安全ですが、複雑でサーバーリソースを多く使用することがあります

> **Good to know:** どちらの方法でも、または両方を使用できますが、[iron-session](https://github.com/vvo/iron-session) や [Jose](https://github.com/panva/jose) などのセッション管理ライブラリを使用することをお勧めします。

### Stateless Sessions {#stateless-sessions}

<AppOnly>

stateless セッションを作成し管理するためには、いくつかのステップに従う必要があります。

1. セッションをサインするために使用する秘密鍵を生成し、環境変数として保存します。
2. セッション管理ライブラリを使用してセッションデータを暗号化/復号化するロジックを書く。
3. Next.js の [`cookies`](/docs/app/api-reference/functions/cookies) API を使用して cookie を管理します。

上記に加えて、セッションを更新（またはリフレッシュする）機能を追加して、ユーザーがアプリケーションに戻った際にセッションを延長し、ユーザーがログアウトした際にセッションを削除することを検討してください。

> **Good to know:** あなたの [auth library](#auth-libraries) がセッション管理を含んでいるか確認してください。

#### 1. 秘密鍵を生成する {#1-generating-a-secret-key}

セッションをサインするための秘密鍵を生成する方法はいくつかあります。たとえば、ターミナルで `openssl` コマンドを使用することを選択できます。

```bash title="terminal"
openssl rand -base64 32
```

このコマンドは、秘密鍵として使用できる32文字のランダムな文字列を生成し、[環境変数ファイル](/docs/app/building-your-application/configuring/environment-variables) に保存できます。

```bash title=".env"
SESSION_SECRET=your_secret_key
```

次に、セッション管理ロジックでこの鍵を参照できます。

```js title="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. セッションを暗号化/復号化する {#2-encrypting-and-decrypting-sessions}

次に、選択した [session management library](#session-management-libraries) を使ってセッションを暗号化/復号化できます。前の例に続けて、[Jose](https://www.npmjs.com/package/jose) （[Edge Runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes) に対応）と React の [`server-only`](https://www.npmjs.com/package/server-only) パッケージを使用して、セッション管理ロジックがサーバーでのみ実行されるようにします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Failed to verify session')
  }
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Failed to verify session')
  }
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - payload には、ユーザー ID、役割（role）など、後続のリクエストで使用される**最小限**のユーザーデータを含めるべきです。電話番号、メールアドレス、クレジットカード情報などの個人を特定できる情報や、パスワードなどの機密データを含まないようにしてください。

#### 3. Cookie の設定（推奨オプション） {#3-setting-cookies-recommended-options}

セッションを Cookie に保存するには、Next.js の [`cookies`](/docs/app/api-reference/functions/cookies) API を使用します。 Cookie はサーバー上で設定され、以下の推奨オプションを含むべきです。

- **HttpOnly**: Cookie にクライアント側の JavaScript によるアクセスを防ぎます。
- **Secure**: https を使用して Cookie を送信する。
- **SameSite**: Cookie がクロスサイトリクエストに送信できるかどうか指定します。
- **Max-Age または Expires**: 指定した期間の後に Cookie を削除します。
- **Path**: Cookie の URL パスを定義します。

これらのオプションの詳細は [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) を参照してください。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

サーバーアクションで `createSession()` 関数を呼び出し、ユーザーを適切なページにリダイレクトするために [`redirect()`](/docs/app/building-your-application/routing/redirecting) API を使用できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // 以前のステップ:
  // 1. フォームフィールドを検証
  // 2. データベースにデータを挿入するためのデータを準備する
  // 3. ユーザーをデータベースに挿入するか、認証 ライブラリの API を呼び出す

  // 現在のステップ:
  // 4. ユーザーセッションを作成
  await createSession(user.id)
  // 5. ユーザーをリダイレクト
  redirect('/profile')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // 以前のステップ:
  // 1. フォームフィールドを検証
  // 2. データベースにデータを挿入するためのデータを準備する
  // 3. ユーザーをデータベースに挿入するか、認証 ライブラリの API を呼び出す

  // 現在のステップ:
  // 4. ユーザーセッションを作成
  await createSession(user.id)
  // 5. ユーザーをリダイレクト
  redirect('/profile')
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - cookie はクライアント側の改ざんを防ぐために**サーバー上で設定する**べきです。
> - 🎥 こちらを視聴してください: Next.js と stateless セッションおよび認証についての詳細を学ぶ→ [YouTube (11分)](https://www.youtube.com/watch?v=DJvM2lSPn6w)。

#### セッションの更新（またはリフレッシュ） {#updating-or-refreshing-sessions}

セッションの有効期限を延長することもできます。これは、ユーザーがアプリケーションにアクセスした後にログイン状態を保持するのに役立ちます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

> **Tip:** Auth ライブラリーがリフレッシュトークンをサポートしているかどうかを確認します。リフレッシュトークンを使用してユーザーのセッションを延長することができます。

#### セッションの削除 {#deleting-the-session}

セッションを削除するには、cookie を削除できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

</TabItem>
</Tabs>

その後、アプリケーション内で例えばログアウト時に `deleteSession()` 関数を再利用できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  deleteSession()
  redirect('/login')
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  deleteSession()
  redirect('/login')
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

#### Cookie の設定と削除 {#setting-and-deleting-cookies}

[API Routes](https://nextjs.org/docs/canary/pages/building-your-application/routing/api-routes) を使用して、サーバー上の cookie としてセッションを設定できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 一週間
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 一週間
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</TabItem>
</Tabs>

</PagesOnly>

### Database Sessions {#database-sessions}

データベースセッションを作成および管理するには、以下の手順に従う必要があります。

1. データベースにセッションとデータを保存するためのテーブルを作成する(またはAuth Library がこれを処理するかどうか確認する)
2. セッションを挿入、更新、削除する機能の実装
3. セッションIDをユーザーのブラウザに保存する前に暗号化し、データベースと Cookie の同期を確保する（これは任意ですが、[Middleware](#optimistic-checks-with-middleware-optional) で楽観的な認証チェックを行う場合には推奨されます）

<AppOnly>

たとえば:

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. データベースにセッションを作成
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // セッションIDを返す
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. セッションIDを暗号化
  const session = await encrypt({ sessionId, expiresAt })

  // 3. 楽観的認証チェックのために Cookie にセッションを保存
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. データベースにセッションを作成
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // セッションIDを返す
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. セッションIDを暗号化
  const session = await encrypt({ sessionId, expiresAt })

  // 3. 楽観的認証チェックのために Cookie にセッションを保存
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

</TabItem>
</Tabs>

> **Tips**:
>
> - データの取得を速くするために、[Vercel Redis](https://vercel.com/docs/storage/vercel-kv) のようなデータベースを使用することを検討してください。ただし、セッションデータをプライマリデータベースに保持し、データリクエストを組み合わせてクエリの数を減らすこともできます。
> - より高度なユースケースには、データベースセッションを使用することを選択できます。たとえば、ユーザーが最後にログインした時間を記録すること、アクティブなデバイスの数を追跡すること、またはユーザーにすべてのデバイスからログアウトする機能を提供します。

セッション管理を実装した後、承認ロジックを追加して、アプリケーションでユーザーがアクセスできることとできないことを制御する必要があります。[Authorization](#authorization) セクションで詳細を学んでください。

</AppOnly>

<PagesOnly>

**サーバー上でのセッションの作成**:

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</TabItem>
</Tabs>

</PagesOnly>

## Authorization {#authorization}

ユーザーが認証されセッションが作成された後、アプリケーション内でユーザーがアクセスできることとできないことを制御するために承認を実装できます。

承認チェックには二つのタイプがあります。

1. **楽観的**: Cookieに格納されたセッションデータを使用して、ユーザーがルートにアクセスしたり、アクションを実行する権限があるかどうかをチェックします。これらのチェックは、UI要素の表示/非表示のようなクイックな操作あるいは、権限や役割に基づいてユーザーをリダイレクトするために便利です。
2. **セキュア**: データベースに保存されたセッションデータを使用して、ユーザーがルートにアクセスしたり、アクションを実行する権限があるかどうかをチェックします。これらのチェックはより安全であり、機密データや操作を要求する操作に使用されます。

両方のケースで以下を推奨します。

- 承認ロジックを集約するために[Data Access Layer](#creating-a-data-access-layer-dal)を作成する
- 必要なデータのみを返すために[Data Transfer Objects（DTO）](#using-data-transfer-objects-dto)を使用する
- オプションで[Middleware](#optimistic-checks-with-middleware-optional)を使用して楽観的チェックを実行する。

### 楽観的チェックとミドルウェア (オプション) {#optimistic-checks-with-middleware-optional}

場合によっては[Middleware] ページとルートに基づいてユーザーをリダイレクトすることを選択できます。

- 楽観的なチェックを実行するため。ミドルウェアはすべてのルートで実行され、このためリダイレクトロジックを集約し、許可されていないユーザーを事前にフィルターするのに適しています。
- ユーザー間でデータを共有するスタティックなルートを保護するため（たとえば、ペイウォールの背後にあるコンテンツ）。

ただし、ミドルウェアは、[事前フェッチ](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)されたルートを含むすべてのルートで実行されるため、パフォーマンスの問題を防ぐために、Cookie からセッションのみを読み取る（楽観的なチェック）ようにしてください。

例:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. 保護されたルートと許可されたルートを指定
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. 現在のルートが保護されたルートか公衆ルートかを確認
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Cookie からセッションを復号化
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. ユーザーが認証されていない場合 /login にリダイレクト
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. ユーザーが認証されている場合 /dashboard にリダイレクト
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// ミドルウェアを実行しないルートを指定
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. 保護されたルートと許可されたルートを指定
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. 現在のルートが保護されたルートか公衆ルートかを確認
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Cookie からセッションを復号化
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. ユーザーが認証されていない場合 /login にリダイレクト
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. ユーザーが認証されている場合 /dashboard にリダイレクト
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// ミドルウェアを実行しないルートを指定
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

</TabItem>
</Tabs>

ミドルウェアは初期チェックには便利ですが、データを保護するためにこれが唯一の防御手段であるべきではありません。セキュリティチェックの大部分はできるだけデータソースに近いところで行うべきです。詳細については [Data Access Layer](#creating-a-data-access-layer-dal) を参照してください。

> **Tips**:
>
> - ミドルウェアでは `req.cookies.get('session').value` を使用して cookie を読み取ることもできます。
> - ミドルウェアは [Edge Runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes) を使用します。Auth ライブラリおよびセッション管理ライブラリが互換性があるか確認してください。
> - ミドルウェアが実行されるルートを指定するためにミドルウェアの `matcher` プロパティを使用することができます。ただし、認証のためにはミドルウェアがすべてのルートで実行されることをお勧めします。

<AppOnly>

### Data Access Layer（DAL）の作成 {#creating-a-data-access-layer-dal}

データリクエストおよび承認ロジックを集約するために DAL の作成をお勧めします。

DAL にはユーザーがアプリケーションとやり取りする際にそのセッションを確認する機能が含まれているべきです。少なくともこの機能はセッションが有効であるかどうかをチェックし、リダイレクトするか、さらなるリクエストを行うために必要なユーザー情報を返すべきです。

たとえば、DALのために別のファイルを作成し、`verifySession()` 関数を含めます。次に、Reactの[cache](https://react.dev/reference/react/cache) API を使用して関数の戻り値を React のレンダーパス中にメモ化できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

</TabItem>
</Tabs>

その後、データリクエスト、サーバーアクション、ルートハンドラーで `verifySession()` 関数を呼び出すことができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // ユーザーオブジェクト全体ではなく必要な列のみを明示的に返す
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('ユーザーの取得に失敗しました')
    return null
  }
})
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // ユーザーオブジェクト全体ではなく必要な列のみを明示的に返す
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('ユーザーの取得に失敗しました')
    return null
  }
})
```

</TabItem>
</Tabs>

> **Tip**:
>
> - DAL はリクエスト時に取得されるデータを保護するのに使用できます。しかし、ユーザー間でデータを共有する静的なルートの場合、データはビルド時に取得され、リクエスト時には取得されません。静的ルートを保護するために [Middleware](#optimistic-checks-with-middleware-optional) を使用してください。
> - セキュリティ チェックを行うには、データベースとセッション ID を比較することで、セッションが有効かどうかを確認できます。React の [cache](https://react.dev/reference/react/cache) 機能を使用して、レンダーパス中のデータベースへの不要な重複リクエストを回避します。
> - 関連データ リクエストを JavaScript クラスに統合し、メソッドの前に `verifySession()` を実行することを検討することもできます。

### Data Transfer Objects (DTO) の使用 {#using-data-transfer-objects-dto}

データを取得するとき、アプリケーションで使用される必要なデータのみを返すことをお勧めします。たとえば、ユーザーデータを取得する場合、ユーザーオブジェクト全体ではなく、ユーザーの ID と名前のみを返すことがあります。

ただし、返されるデータ構造を制御できない場合、またはチームで全オブジェクトがクライアントに渡されることを避けたい場合には、クライアントで公開するのに安全なフィールドを指定するなどの戦略を使用することができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // 特定の列をここで返す
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // またはクエリ固有の部分のみをここで返す
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // 特定の列をここで返す
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // またはクエリ固有の部分のみをここで返す
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

</TabItem>
</Tabs>

データリクエストと承認ロジックをDALで集約し、DTOを使用することで、すべてのデータリクエストが安全で一貫性があることを保証し、アプリケーションのスケールアップに応じて保守、監査、デバッグが容易になります。

> **Good to know**:
>
> - DTO を定義する方法はいくつかあります。たとえば `toJSON()` を使うこと、上記のような個々の関数、または JS クラスのようにです。これらは JavaScript のパターンであり、React やNext.js の機能ではないため、アプリケーションに最適なパターンを見つけるために調査を行うことをお勧めします。
> - 当社の [Security in Next.js article](https://nextjs.org/blog/security-nextjs-server-components-actions) でセキュリティのベストプラクティスについて学ぶ。

### Server Components {#server-components}

[Server Components](/docs/app/building-your-application/rendering/server-components) 内での認証チェックはロールベースのアクセスに便利です。たとえば、ユーザーの役割に応じてコンポーネントを条件付きでレンダリングする。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // 'role'がセッションオブジェクトの一部と仮定

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // 'role'がセッションオブジェクトの一部と仮定

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

</TabItem>
</Tabs>

この例では、DAL の `verifySession()` 関数を使用して 'admin'、'user'、および権限のない役割をチェックします。このパターンは、各ユーザーが自分の役割に応じたコンポーネントとやり取りすることを保証します。

### レイアウトとオーセンティケーション チェック {#layouts-and-auth-checks}

[Partial Rendering](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering) に伴い、これらがナビゲーションで再レンダリングされないため、[Layouts](/docs/app/building-your-application/routing/layouts-and-templates) でのチェックは注意が必要です。つまり、ユーザー セッションはすべてのルート変更でチェックされません。

代わりに、データ ソースに近いか、条件付きでレンダリングされるコンポーネントでチェックを行う必要があります。

たとえば、ユーザー データを取得し、ナビゲーションにユーザー イメージを表示する共有レイアウトを検討してください。レイアウトで認証チェックを行う代わりに、`getUser()` のユーザー データを取得し、DAL で認証チェックを行う必要があります。

これにより、アプリケーション内のどこで `getUser()` が呼び出されても、認証チェックが実行され、許可されたデータにユーザーがアクセスしていることを開発者が忘れないようにします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser()

  return (
    // ...
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser()

  return (
    // ...
  )
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // セッションからユーザー ID を取得してデータを取得する
})
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // セッションからユーザー ID を取得してデータを取得する
})
```

</TabItem>
</Tabs>

> **Good to know:**
>
> - SPAs でよくあるパターンは、ユーザーが認証されていない場合、レイアウトまたはトップレベルのコンポーネントで `return null` を返すことです。このパターンは、Next.js アプリケーションには複数のエントリポイントがあるため **推奨されません**。これにより、ネストされたルートセグメントやサーバーアクションへのアクセスを防ぐことはできません。

### Server Actions {#server-actions}

[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) を公開 API エンドポイントと同様のセキュリティ考慮事項と見なし、ユーザーがミューテーションを実行する許可を得ているかどうか確認します。

次の例では、アクションの進行を許可する前にユーザーの役割をチェックします。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // ユーザーがアクションを実行する権限を持っていない場合は早期に戻る
  if (userRole !== 'admin') {
    return null
  }

  // 許可されたユーザーに対してアクションを進行
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // ユーザーがアクションを実行する権限を持っていない場合は早期に戻る
  if (userRole !== 'admin') {
    return null
  }

  // 許可されたユーザーに対してアクションを進行
}
```

</TabItem>
</Tabs>

### ルートハンドラー {#route-handlers}

[Route Handlers](/docs/app/building-your-application/routing/route-handlers) を公開 API エンドポイントと同様のセキュリティ考慮事項とし、ユーザーがルートハンドラーへのアクセスを許可されているかどうか確認します。

例:

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // ユーザー認証と役割確認
  const session = await verifySession()

  // ユーザーが認証されているか確認
  if (!session) {
    // ユーザーは認証されていない
    return new Response(null, { status: 401 })
  }

  // ユーザーが'admin'権限を持っているか確認
  if (session.user.role !== 'admin') {
    // ユーザーは認証されていますが、適切な権限を持っていない
    return new Response(null, { status: 403 })
  }

  // 許可されたユーザーに対して処理を進行
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // ユーザー認証と役割確認
  const session = await verifySession()

  // ユーザーが認証されているか確認
  if (!session) {
    // ユーザーは認証されていない
    return new Response(null, { status: 401 })
  }

  // ユーザーが'admin'権限を持っているか確認
  if (session.user.role !== 'admin') {
    // ユーザーは認証されていますが、適切な権限を持っていない
    return new Response(null, { status: 403 })
  }

  // 許可されたユーザーに対して処理を進行
}
```

</TabItem>
</Tabs>

上記の例では、二層のセキュリティチェックを備えたルートハンドラーを示しています。ここでは、まずアクティブセッションを確認し、その後ログインしたユーザーが'admin'であるかどうかを確認しています。

## コンテキストプロバイダー {#context-providers}

コンテキストプロバイダーを使用して認証を行うことは、[interleaving](/docs/app/building-your-application/rendering/composition-patterns#interleaving-server-and-client-components) によって機能します。ただし、React の `context` は クライアントコンポーネントのみでサポートされるため、Server Components では利用できません。

これは機能しますが、子サーバーコンポーネントは最初にサーバーでレンダリングされ、コンテキストプロバイダーのセッションデータにはアクセスできません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

```tsx title="app/ui/profile.ts switcher
"use client";

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx title="app/ui/profile.js switcher
"use client";

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

クライアントコンポーネント（たとえばクライアント側データ取得）にセッションデータが必要な場合は、React の [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) API を使用して、機密セッションデータがクライアントに公開されないようにします。

</AppOnly>

<PagesOnly>

### Data Access Layer (DAL) の作成 {#creating-a-data-access-layer-dal}

#### API Routes の保護 {#protecting-api-routes}

Next.js での API Routes は、サーバーサイドロジックとデータ管理を処理するために重要です。これらのルートを保護して、特定の機能にアクセスできるのは許可されたユーザーだけであることを保証することが重要です。これには通常、ユーザーの認証状態と役割ベースの権限を確認することが含まれます。

API Route を保護する方法の例を次に示します。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // ユーザーが認証されているか確認
  if (!session) {
    res.status(401).json({
      error: 'ユーザーが認証されていません',
    })
    return
  }

  // ユーザーが 'admin' 権限を持っているか確認
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: '不正なアクセス: ユーザーは admin 権限を持っていません。',
    })
    return
  }

  // 許可されたユーザーに対してルートを進行
  // ... API Route の実装
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = awaitgetSession(req)

  // ユーザーが認証されているか確認
  if (!session) {
    res.status(401).json({
      error: 'ユーザーが認証されていません',
    })
    return
  }

  // ユーザーが 'admin' 権限を持っているか確認
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: '不正なアクセス: ユーザーは admin 権限を持っていません。',
    })
    return
  }

  // 許可されたユーザーに対してルートを進行
  // ... API Route の実装
```

</TabItem>
</Tabs>

この例では、認証と承認の二層のセキュリティチェックを備えたAPIルートを示しています。まず、アクティブセッションを確認し、その後ログインしたユーザーが'admin'であるかどうかを確認しています。このアプローチにより、リクエスト処理のための堅牢なセキュリティを維持しながら、認証済みかつ許可されたユーザーに限定されたセキュアアクセスを保証します。

</PagesOnly>

## リソース {#resources}

Next.js での認証について学んだ今、次は、セキュアな認証とセッション管理を実施するための Next.js 対応のライブラリとリソースを紹介します。

### 認証ライブラリ {#auth-libraries}

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### セッション管理ライブラリ {#session-management-libraries}

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## さらなる学習 {#further-reading}

認証とセキュリティについての学びを深めるために、次のリソースをご覧ください。

- [How to think about security in Next.js](https://nextjs.org/blog/security-nextjs-server-components-actions)
- [Understanding XSS Attacks](https://vercel.com/guides/understanding-xss-attacks)
- [Understanding CSRF Attacks](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
