---
title: 'TypeScript'
description: 'Next.jsは、Reactアプリケーションを構築するためのTypeScript-firstの開発体験を提供します。'
---

{/* このドキュメントの内容は、app router と pages router の間で共有されています。Pages Router に特有のコンテンツを追加するには、`<PagesOnly>Content</PagesOnly>` コンポーネントを使用できます。共有されたコンテンツはコンポーネントでラップしないでください。 */}

Next.jsは組み込みのTypeScriptを備えており、`create-next-app`で新しいプロジェクトを作成する際に必要なパッケージを自動でインストールし、適切な設定を構成します。

既存のプロジェクトにTypeScriptを追加するには、ファイルを `.ts` / `.tsx` にリネームします。`next dev` と `next build` を実行すると、必要な依存関係が自動的にインストールされ、推奨される設定オプションを持つ `tsconfig.json` ファイルが追加されます。

> **Good to know**: もしすでに `jsconfig.json` ファイルがある場合は、古い `jsconfig.json` から `paths` コンパイラオプションを新しい `tsconfig.json` ファイルにコピーし、古い `jsconfig.json` ファイルを削除してください。

<AppOnly>

## IDE プラグイン {#ide-plugin}

Next.jsはカスタムTypeScriptプラグインとタイプチェッカーを含んでおり、VSCodeや他のコードエディタが高度な型チェックと自動補完を行うために使用できます。

VS Codeでプラグインを有効にするには：

1. コマンドパレットを開く（`Ctrl/⌘` + `Shift` + `P`）
2. 「TypeScript: Select TypeScript Version」を検索
3. 「Use Workspace Version」を選択

<Image
  alt="TypeScript Command Palette"
  srcLight="/docs/light/typescript-command-palette.png"
  srcDark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

これで、ファイルを編集するときにカスタムプラグインが有効になります。`next build`を実行すると、カスタムタイプチェッカーが使用されます。

TypeScriptプラグインは以下を手助けします：

- [segment config options](/docs/app/api-reference/file-conventions/route-segment-config)に無効な値が渡された場合の警告を表示します
- 利用可能なオプションとコンテキスト固有のドキュメントを表示します
- `use client` 指示が正しく使われていることを確認します
- `useState` のようなクライアントフックがClient Componentsでのみ使用されていることを確認します

> **🎥 Watch:** 組み込みのTypeScriptプラグインについて学ぶ→ [YouTube（3分）](https://www.youtube.com/watch?v=pqMqn9fKEf8)

## エンドツーエンドの型安全性 {#end-to-end-type-safety}

Next.jsのapp routerは、**強化された型の安全性**を持っています。これには以下が含まれます：

1. **データのシリアライズ不要**: コンポーネント、レイアウト、およびサーバー上のページで直接 `fetch` できます。このデータはクライアントサイドでReactで消費されるためにシリアライズ（文字列化）する必要はありません。代わりに、`app` がデフォルトでServer Componentsを使用するため、`Date`、`Map`、`Set` などを追加作業なしで使用できます。以前は、Next.js特有の型を使ってサーバーとクライアントの境界を手動で型指定する必要がありました。
2. **コンポーネント間のデータフローの簡素化**: `_app`を root レイアウトに置き換えることで、コンポーネントとページ間のデータフローの可視化がより簡単になりました。以前は、個々の`page`と`_app`の間を流れるデータを型指定するのが難しく、混乱を招くバグを引き起こす可能性がありました。App Routerでの[共存データ取得](/docs/app/building-your-application/data-fetching/fetching)により、これはもはや問題ではなくなりました。

[Next.jsでのデータ取得](/docs/app/building-your-application/data-fetching/fetching)は、データベースやコンテンツプロバイダーの選択について規範を設けることなく、可能な限りエンドツーエンドの型安全を提供しています。

私たちは、通常のTypeScriptと同様にレスポンスデータを型指定できます。例えば：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // 戻り値はシリアライズされません
  // Date, Map, Setなどを返すことができます
  return res.json()
}

export default async function Page() {
  const name = await getData()

  return '...'
}
```

</TabItem>
</Tabs>

エンドツーエンドの型安全性を完全に達成するためには、使用するデータベースやコンテンツプロバイダーがTypeScriptをサポートする必要があります。これには[ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)や型安全なクエリビルダーの使用が含まれることがあります。

</AppOnly>

## 例 {#examples}

### `next.config.ts` の型チェック {#type-checking-next-config-ts}

TypeScriptを使ってNext.jsの設定を行うために `next.config.ts` を使用し、型をインポートできます。

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  /* config options here */
}

export default nextConfig
```

> **Good to know**: `next.config.ts` のモジュール解決は現在 `CommonJS` に限定されています。これにより、`next.config.ts` で読み込まれるESMのみのパッケージとの互換性の問題が発生する可能性があります。

`next.config.js` ファイルを使用する場合、以下のようにJSDocを使用してIDEに型チェックを追加できます：

```js title="next.config.js"
// @ts-check

/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
}

module.exports = nextConfig
```

<AppOnly>

### 静的に型付けされたリンク {#statically-typed-links}

Next.jsは、`next/link` を使用してページ間をナビゲートする際のタイプミスや他のエラーを防ぐために、リンクを静的に型付けすることができます。これにより型安全性が向上します。

この機能を利用するには、`experimental.typedRoutes` を有効にし、プロジェクトがTypeScriptを使用する必要があります。

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    typedRoutes: true,
  },
}

export default nextConfig
```

Next.jsは`.next/types`内に存在するすべてのルートに関する情報を持つリンク定義を生成します。これをTypeScriptが使用して、無効なリンクに関するフィードバックをエディタに提供します。

現在、実験的サポートには動的セグメントを含む任意の文字列リテラルが含まれます。非リテラル文字列に対しては、現在 `href` を `as Route` として手動で型変換する必要があります：

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// hrefが有効なルートの場合、TypeScriptエラーはありません
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// hrefが無効なルートの場合、TypeScriptエラーが発生
<Link href="/aboot" />
```

`next/link` をラッピングするカスタムコンポーネントで `href` を受け入れるには、ジェネリックを使用します：

```tsx
import type { Route } from 'next'
import Link from 'next/link'

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  )
}
```

> **How does it work?**
>
> `next dev` または `next build` を実行すると、Next.jsはアプリケーション内のすべての既存ルートに関する情報を持つ隠し `.d.ts` ファイルを `.next` 内に生成します（すべての有効なルートが `Link` の `href` 型として扱われます）。この `.d.ts` ファイルは `tsconfig.json` に含まれ、TypeScriptコンパイラがその `.d.ts` をチェックし、無効なリンクについてエディタにフィードバックを提供します。

### 非同期Server Componentsと共に {#with-async-server-components}

TypeScriptと非同期Server Componentを使用するには、TypeScript `5.1.3` 以上と `@types/react` `18.2.8` 以上を使用していることを確認してください。

古いバージョンのTypeScriptを使用している場合、`'Promise<Element>' is not a valid JSX element` という型エラーが表示されることがあります。TypeScriptおよび`@types/react`の最新バージョンに更新することで、この問題は解決されます。

</AppOnly>

<PagesOnly>

### 静的生成およびサーバーサイドレンダリング {#static-generation-and-server-side-rendering}

[`getStaticProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-props)、[`getStaticPaths`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-paths)、および[`getServerSideProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-server-side-props)には、それぞれ`GetStaticProps`、`GetStaticPaths`、`GetServerSideProps`タイプを使用できます：

```tsx title="pages/blog/[slug].tsx"
import type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'

export const getStaticProps = (async (context) => {
  // ...
}) satisfies GetStaticProps

export const getStaticPaths = (async () => {
  // ...
}) satisfies GetStaticPaths

export const getServerSideProps = (async (context) => {
  // ...
}) satisfies GetServerSideProps
```

> **Good to know:** `satisfies`はTypeScript [4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html)で追加されました。最新のTypeScriptバージョンにアップグレードすることをお勧めします。

### API Routesで {#with-api-routes}

API routesで組み込みの型を使用する方法の例は以下のとおりです：

```ts title="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: 'John Doe' })
}
```

レスポンスデータをタイプすることもできます：

```ts title="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}
```

### カスタム `App` で {#with-custom-app}

[カスタム `App`](https://nextjs.org/docs/canary/pages/building-your-application/routing/custom-app)がある場合、組み込みのタイプ `AppProps` を使用し、ファイル名を`./pages/_app.tsx`に変更して以下のようにします：

```ts
import type { AppProps } from 'next/app'

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
```

</PagesOnly>

### インクリメンタル型チェック {#incremental-type-checking}

Next.jsは`v10.2.1`以降、`tsconfig.json`で有効にされたときに[インクリメンタル型チェック](https://www.typescriptlang.org/tsconfig#incremental)をサポートしています。これにより、大規模なアプリケーションの型チェックが高速化される可能性があります。

### 本番環境でのTypeScriptエラーの無効化 {#disabling-typescript-errors-in-production}

Next.jsは、プロジェクトにTypeScriptエラーが存在する場合、**本番ビルド** (`next build`) を失敗させます。

アプリケーションにエラーがあっても本番コードを危険を冒して生成したい場合は、組み込みの型チェック手順を無効にできます。

無効にした場合、ビルドまたはデプロイプロセスの一環として型チェックを実行していることを確認してください。さもなければ、非常に危険です。

`next.config.ts`を開き、`typescript`設定で`ignoreBuildErrors`オプションを有効にします：

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  typescript: {
    // !! WARN !!
    // あなたのプロジェクトにタイプエラーがあっても
    // 危険を伴う本番ビルドを正常に完了させます。
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}

export default nextConfig
```

> **Good to know**: `tsc --noEmit`を実行して、自分でTypeScriptエラーをビルド前にチェックすることができます。これは、デプロイ前にTypeScriptエラーを確認したいCI/CDパイプラインには有用です。

### カスタムの型宣言 {#custom-type-declarations}

カスタムの型を宣言する必要がある場合、`next-env.d.ts` を変更したくなるかもしれません。しかし、このファイルは自動生成されるため、行った変更は上書きされます。代わりに、新しいファイル、例えば `new-types.d.ts` を作成し、それを `tsconfig.json` に参照するべきです：

```json title="tsconfig.json"
{
  "compilerOptions": {
    "skipLibCheck": true
    //...truncated...
  },
  "include": [
    "new-types.d.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
```

## バージョン履歴 {#version-changes}

| バージョン | 変更                                                                                                                                  |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `v15.0.0`  | [`next.config.ts`](#type-checking-nextconfigts) がTypeScriptプロジェクトをサポート                                                    |
| `v13.2.0`  | 静的に型付けされたリンクがベータ版で利用可能                                                                                          |
| `v12.0.0`  | [SWC](/docs/architecture/nextjs-compiler) がデフォルトでTypeScriptおよびTSXをコンパイルするようになり、ビルドが高速化                 |
| `v10.2.1`  | `tsconfig.json`で有効にされたとき、[インクリメンタル型チェック](https://www.typescriptlang.org/tsconfig#incremental) のサポートが追加 |
