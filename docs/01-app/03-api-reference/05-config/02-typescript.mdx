---
title: 'TypeScript'
description: 'Next.jsはReactアプリケーションの構築においてTypeScript優先の開発体験を提供します。'
---

{/* このドキュメントの内容はappとpages routerの間で共有されています。Pages Routerに特化した内容を追加するには、`<PagesOnly>Content</PagesOnly>`コンポーネントを使用できます。共有コンテンツはコンポーネントでラップしないでください。 */}

Next.js は組み込みの TypeScript を備えており、`create-next-app`で新しいプロジェクトを作成するときに必要なパッケージを自動的にインストールし、適切な設定を行います。

既存のプロジェクトに TypeScript を追加するには、ファイル名を `.ts` / `.tsx` にリネームします。`next dev` や `next build` を実行すると、必要な依存関係が自動的にインストールされ、推奨される設定オプションが含まれた `tsconfig.json` ファイルが追加されます。

> **Good to know**: 既に `jsconfig.json` ファイルがある場合は、古い `jsconfig.json` から `paths` コンパイラーオプションを新しい `tsconfig.json` ファイルにコピーし、古い `jsconfig.json` ファイルを削除してください。

<AppOnly>

## IDE プラグイン {#ide-plugin}

Next.js にはカスタム TypeScriptプラグインと型チェッカーが含まれており、VSCode や他のコードエディタが高度な型チェックや自動補完を行うのに使用できます。

VS Code でプラグインを有効にするには、以下の手順に従ってください：

1. コマンドパレットを開く（`Ctrl/⌘` + `Shift` + `P`）
2. 「TypeScript: TypeScript バージョンを選択する」を検索
3. 「ワークスペースバージョンを使用」を選択

<Image
  alt="TypeScript コマンドパレット"
  srcLight="/docs/light/typescript-command-palette.png"
  srcDark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

これで、ファイルを編集するときにカスタムプラグインが有効になります。`next build`を実行するときには、カスタム型チェッカーが使用されます。

TypeScript プラグインが役立つこと：

- [segment config options](/docs/app/api-reference/file-conventions/route-segment-config)に無効な値が渡された場合に警告を表示
- 利用可能なオプションとコンテキスト内でのドキュメント表示
- `use client`ディレクティブが正しく使用されていることを確認
- クライアントのフック（`useState` など）がクライアントコンポーネント内のみで使用されていることを確認

> **🎥 視聴:** 組み込みの TypeScript プラグインについて学ぶ → [YouTube (3分)](https://www.youtube.com/watch?v=pqMqn9fKEf8)

## エンドツーエンドの型安全性 {#end-to-end-type-safety}

Next.jsのApp Router は**型安全性を強化**しています。これには以下が含まれます：

1. **データのシリアライズなし**: サーバー上でコンポーネント、レイアウト、ページ内部で`fetch`を直接行うことができます。このデータはReactのクライアント側で消費するためにシリアライズ（文字列に変換）する必要がありません。代わりに、`app`はデフォルトでServer Componentsを使用しているため、`Date`や`Map`、`Set`などの値を追加の手段なしに使用できます。以前は、Next.js専用の型を使ってサーバーとクライアントの境界を手動で型指定する必要がありました。
2. **コンポーネント間のデータフローの合理化**: root レイアウトに基づいて`_app`が削除され、コンポーネントとページ間のデータフローの視覚化が容易になりました。以前は、個々の`pages`と`_app`間を流れるデータは型の指定が難しく、混乱を招くバグを引き起こす可能性がありました。[データフェッチングの所在が合致した場所に配置](/docs/app/building-your-application/data-fetching/fetching)されたApp Routerでは、もう問題ではありません。

[Data Fetching in Next.js](/docs/app/building-your-application/data-fetching/fetching)は、データベースやコンテンツプロバイダの選択について指示を与えることなく、できる限りエンドツーエンドの型安全性を提供します。

通常の TypeScriptで期待できるフォーマットでレスポンスデータを型指定することができ、例えば以下のようになります：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // 戻り値はシリアライズされていません
  // Date, Map, Set などを返すことができます
  return res.json()
}

export default async function Page() {
  const name = await getData()

  return '...'
}
```

</TabItem>
</Tabs>

エンドツーエンドの型安全性を完全に実現するために、データベースまたはコンテンツプロバイダが TypeScript をサポートする必要があります。これは、[ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)や型安全なクエリビルダーを使用することで実現できるかもしれません。

</AppOnly>

## 例 {#examples}

### `next.config.ts`における型チェック {#type-checking-next-config-ts}

あなたの Next.js 設定には`next.config.ts`を使って TypeScript や型をインポートできます。

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  /* 設定オプションはここに */
}

export default nextConfig
```

> **Good to know**: `next.config.ts`のモジュール解決は現在`CommonJS`に限定されており、これが `next.config.ts` にロードされるESMのみのパッケージと互換性を持たない可能性があります。

`next.config.js`ファイルを使用する場合、以下のようにJSDocを用いてIDEで型チェックを追加できます：

```js title="next.config.js"
// @ts-check

/** @type {import('next').NextConfig} */
const nextConfig = {
  /* 設定オプションはここに */
}

module.exports = nextConfig
```

<AppOnly>

### 静的に型付けされたリンク {#statically-typed-links}

Next.jsは、`next/link`を使用する際のタイプミスやその他のエラーを防止するためにリンクを静的に型付けすることができ、ページ間のナビゲーション時の型安全性を向上させます。

この機能をオプトインするには、`experimental.typedRoutes`を有効にしてプロジェクトでTypeScriptを使用する必要があります。

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    typedRoutes: true,
  },
}

export default nextConfig
```

Next.jsは、アプリケーション内で存在するすべてのルートに関する情報を含むリンク定義を`.next/types`内に生成し、これをTypeScriptが使って無効なリンクについてのフィードバックをエディタ内で提供することができます。

現在、実験的サポートは動的セグメントを含む任意の文字列リテラルが含まれています。非リテラルの文字列の場合、現在`as Route`を使用して`href`を手動でキャストする必要があります：

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// hrefが有効なルートであればTypeScriptエラーは発生しません
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// hrefが有効なルートでない場合TypeScriptエラーが発生
<Link href="/aboot" />
```

`next/link`をラップするカスタムコンポーネントで`href`を受け入れるためには、ジェネリックを使用します：

```tsx
import type { Route } from 'next'
import Link from 'next/link'

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  )
}
```

> **どのように機能するのか？**
>
> `next dev`や`next build`を実行するとき、Next.jsはアプリケーション内のすべての存在するルートに関する情報を含む隠された`.d.ts`ファイルを`.next`内に生成します（`Link`のhrefタイプとして全ての有効なルート）。この`.d.ts`ファイルは`tsconfig.json`に含まれており、TypeScriptコンパイラはその`.d.ts`をチェックし、無効なリンクについてエディタ内でフィードバックを提供します。

### 非同期 Server Componentとともに {#with-async-server-components}

TypeScriptとともに`async` Server Componentを使用するには、TypeScript `5.1.3`以上と `@types/react` `18.2.8`以上を使用していることを確認してください。

古いバージョンのTypeScriptを使用している場合、`'Promise<Element>'は有効なJSX要素ではありません`という型エラーが表示されるかもしれません。TypeScriptと`@types/react`の最新バージョンに更新することで、この問題は解決されるはずです。

</AppOnly>

<PagesOnly>

### 静的生成とサーバーサイドレンダリング {#static-generation-and-server-side-rendering}

[`getStaticProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-props)、[`getStaticPaths`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-paths)、[`getServerSideProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-server-side-props)に対して、それぞれ`GetStaticProps`、`GetStaticPaths`、`GetServerSideProps`型を使用できます：

```tsx title="pages/blog/[slug].tsx"
import type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'

export const getStaticProps = (async (context) => {
  // ...
}) satisfies GetStaticProps

export const getStaticPaths = (async () => {
  // ...
}) satisfies GetStaticPaths

export const getServerSideProps = (async (context) => {
  // ...
}) satisfies GetServerSideProps
```

> **Good to know:** `satisfies`はTypeScript[4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html)で追加されました。最新バージョンのTypeScriptにアップグレードすることをお勧めします。

### APIルートの使用 {#with-api-routes}

APIルートに組み込まれた型を使用する例を以下に示します：

```ts title="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: 'John Doe' })
}
```

レスポンスデータを型指定することもできます：

```ts title="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}
```

### カスタム `App` の場合 {#with-custom-app}

[カスタム `App`](https://nextjs.org/docs/canary/pages/building-your-application/routing/custom-app)を持つ場合、組み込み型 `AppProps` を使用し、ファイル名を `./pages/_app.tsx` に変更します：

```ts
import type { AppProps } from 'next/app'

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
```

</PagesOnly>

### 増分的型チェック {#incremental-type-checking}

`v10.2.1`以降、`tsconfig.json`で有効になっている場合、Next.jsは[増分型チェック](https://www.typescriptlang.org/tsconfig#incremental)をサポートしており、これにより大規模なアプリケーションでの型チェックの速度向上に役立ちます。

### 本番環境での TypeScript エラーの無効化 {#disabling-typescript-errors-in-production}

Next.js はプロジェクトに TypeScript エラーがある場合、**本番ビルド**（`next build`）に失敗します。

あなたのアプリケーションにエラーがある場合でも危険を承知でNext.jsが本番コードを生成するようにしたい場合、組み込み型チェックステップを無効にすることができます。

無効にする場合、代わりに型チェックをビルドまたはデプロイプロセスの一部として実行していることを確認してください。さもないと非常に危険です。

`next.config.ts`を開いて、`typescript`の設定で`ignoreBuildErrors`オプションを有効にします：

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  typescript: {
    // !! 警告 !!
    // プロジェクトに型エラーがある場合でも本番ビルドを成功させることを許可します
    // !! 警告 !!
    ignoreBuildErrors: true,
  },
}

export default nextConfig
```

> **Good to know**: 自分でTypeScriptエラーをビルド前にチェックするために `tsc --noEmit` を実行できます。これは、CI/CDパイプラインでデプロイ前にTypeScriptエラーをチェックしたい場合に有用です。

### カスタム型宣言 {#custom-type-declarations}

カスタム型を宣言する必要がある場合、`next-env.d.ts`を変更したくなるかもしれません。しかし、このファイルは自動生成されるため、行った変更は上書きされます。代わりに、新しいファイル、`new-types.d.ts`と呼ぶことにし、それを`tsconfig.json`で参照してください：

```json title="tsconfig.json"
{
  "compilerOptions": {
    "skipLibCheck": true
    //...省略...
  },
  "include": [
    "new-types.d.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
```

## バージョン変更 {#version-changes}

| バージョン | 変更点                                                                                                                                        |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `v15.0.0`  | TypeScriptプロジェクト用に[`next.config.ts`](#type-checking-next-config-ts)サポートを追加しました。                                           |
| `v13.2.0`  | 静的に型付けされたリンクがベータ版で利用可能になります。                                                                                      |
| `v12.0.0`  | [SWC](/docs/architecture/nextjs-compiler) は、ビルド速度を上げるためにTypeScriptとTSXをコンパイルするデフォルトの手段として使用されています。 |
| `v10.2.1`  | `tsconfig.json`で有効になっている場合、 [増分型チェック](https://www.typescriptlang.org/tsconfig#incremental)サポートを追加しました。         |
