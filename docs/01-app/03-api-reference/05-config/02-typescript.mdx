---
title: 'TypeScript'
description: 'Next.js は、React アプリケーションの開発において TypeScript を優先的にサポートします。'
---

{/* このドキュメントの内容は app router と pages router の間で共有されています。Pages Router 特有の内容を追加する際は、 `<PagesOnly>Content</PagesOnly>` コンポーネントを使用してください。共有されている内容にはコンポーネントをラップしないでください。 */}

Next.js は TypeScript をビルトインでサポートしており、`create-next-app` で新しいプロジェクトを作成するときに必要なパッケージを自動的にインストールし、適切な設定を行います。

既存のプロジェクトに TypeScript を追加するには、ファイルを `.ts` または `.tsx` にリネームしてください。`next dev` と `next build` を実行すると、必要な依存関係が自動的にインストールされ、推奨される構成オプションを含む `tsconfig.json` ファイルが追加されます。

> **Good to know**: 既に `jsconfig.json` ファイルを持っている場合は、古い `jsconfig.json` から新しい `tsconfig.json` ファイルに `paths` コンパイラオプションをコピーし、古い `jsconfig.json` ファイルを削除してください。

<AppOnly>

## IDE プラグイン {#ide-plugin}

Next.js はカスタムの TypeScript プラグインと型チェッカーを含んでおり、VSCode やその他のコードエディタで高度な型チェックとオートコンプリートを利用することができます。

VS Codeでプラグインを有効にするには、以下の手順を行います:

1. コマンドパレットを開く（`Ctrl/⌘` + `Shift` + `P`）
2. 「TypeScript: Select TypeScript Version」を検索
3. 「Use Workspace Version」を選択

<Image
  alt="TypeScript Command Palette"
  srcLight="/docs/light/typescript-command-palette.png"
  srcDark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

これで、ファイルを編集するときにカスタムプラグインが有効になります。`next build` を実行すると、カスタム型チェッカーが使用されます。

TypeScript プラグインが役立つ点は以下の通りです：

- [segment config options](/docs/app/api-reference/file-conventions/route-segment-config) が無効な値の場合に警告する
- 利用可能なオプションや文脈に応じたドキュメントを表示する
- `use client` ディレクティブが正しく使用されていることを確認する
- クライアントフック（例: `useState`）が Client Component 内でのみ使用されていることを確認する

> **🎥 Watch:** ビルトイン TypeScript プラグインについて学ぶ → [YouTube (3 minutes)](https://www.youtube.com/watch?v=pqMqn9fKEf8)

## エンドツーエンドの型安全性 {#end-to-end-type-safety}

Next.js の App Router には **強化された型安全性** が備わっています。これには以下が含まれます：

1. **フェッチ関数とページ間でのデータのシリアライズなし**：コンポーネント、レイアウト、サーバ上のページ内で直接 `fetch` できます。このデータはクライアント側で使用するためにシリアライズ（文字列に変換）する必要はありません。代わりに、`app` はデフォルトで Server Components を使用しているため、`Date`、`Map`、`Set` などの値を手間なく使用できます。以前は、サーバとクライアント間の境界を Next.js 固有の型で手動で定義する必要がありました。
2. **コンポーネント間のデータフローの簡素化**：`_app` の代わりに root レイアウトを使用することで、コンポーネントとページ間のデータフローが見やすくなりました。かつて、個々の `pages` と `_app` 間のデータフローは型付けが難しく、混乱を招くバグを引き起こす可能性がありました。App Router の [colocated data fetching](/docs/app/building-your-application/data-fetching/fetching) により、この問題は解消されました。

[Next.js でのデータフェッチ](/docs/app/building-your-application/data-fetching/fetching) は、データベースやコンテンツプロバイダーの選択に関して指示的にならず、できるだけエンドツーエンドの型安全性を提供します。

通常の TypeScript で期待されるようにレスポンスデータを型付けできます。例えば：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // 戻り値はシリアライズされません
  // Date, Map, Set などを返すことができます
  return res.json()
}

export default async function Page() {
  const name = await getData()

  return '...'
}
```

</TabItem>
</Tabs>

完全なエンドツーエンドの型安全性を実現するためには、データベースやコンテンツプロバイダーが TypeScript をサポートしている必要があります。これは、[ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping) や型安全なクエリビルダーを使用することを通じて実現できます。

</AppOnly>

## 例 {#examples}

### `next.config.ts` の型チェック {#type-checking-next-config-ts}

`next.config.ts` を使用して、Next.js の設定で TypeScript と型をインポートできます。

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  /* 設定オプションはここに */
}

export default nextConfig
```

> **Good to know**: `next.config.ts` のモジュール解決は現在 `CommonJS` に限定されています。これが原因で、`next.config.ts` に ESM のみのパッケージをロードする際に互換性の問題が発生するかもしれません。

`next.config.js` ファイルを使用する場合は、以下のように JSDoc を使って IDE に型チェックを追加できます：

```js title="next.config.js"
// @ts-check

/** @type {import('next').NextConfig} */
const nextConfig = {
  /* 設定オプションはここに */
}

module.exports = nextConfig
```

<AppOnly>

### 静的に型付けされたリンク {#statically-typed-links}

Next.js では、`next/link` を使用してページ間をナビゲートするときにタイプミスやその他のエラーを防ぐため、リンクを静的に型付けして型安全性を向上させることができます。

この機能を利用するには、`experimental.typedRoutes` を有効にし、プロジェクトが TypeScript を使用している必要があります。

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    typedRoutes: true,
  },
}

export default nextConfig
```

Next.js は、アプリケーション内の既存のすべてのルートに関する情報を含むリンク定義を `.next/types` に生成し、それを TypeScript が使用して、無効なリンクについてエディタにフィードバックを提供します。

現在のところ、実験的サポートは動的セグメントを含む任意の文字列リテラルをサポートしています。リテラルでない文字列の場合、現在は `as Route` で `href` を手動でキャストする必要があります：

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// href が有効なルートであれば TypeScript のエラーはありません
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// href が有効なルートでない場合は TypeScript のエラー
<Link href="/aboot" />
```

`next/link` をラップするカスタムコンポーネントで `href` を受け入れる場合は、ジェネリックを使用します：

```tsx
import type { Route } from 'next'
import Link from 'next/link'

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  )
}
```

> **How does it work?**
>
> `next dev` または `next build` を実行すると、Next.js はアプリケーション内の既存のすべてのルートに関する情報を含む隠し `.d.ts` ファイルを `.next` 内に生成します（すべての有効なルートを `Link` の `href` 型として提供）。この `.d.ts` ファイルは `tsconfig.json` に含まれており、TypeScript コンパイラによってチェックされて、エディタに無効なリンクについてフィードバックを提供します。

### Async Server Components の使用 {#with-async-server-components}

TypeScript で `async` Server Component を使用するには、TypeScript `5.1.3` またはそれ以降、および `@types/react` `18.2.8` またはそれ以降を使用してください。

古いバージョンの TypeScript を使用している場合、「'Promise<Element>' is not a valid JSX element」という型エラーが表示されるかもしれません。TypeScript および `@types/react` の最新バージョンに更新することで、この問題は解決されます。

</AppOnly>

<PagesOnly>

### 静的生成とサーバサイドレンダリング {#static-generation-and-server-side-rendering}

[`getStaticProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-props)、[`getStaticPaths`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-paths)、[`getServerSideProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-server-side-props) では、それぞれ `GetStaticProps`、`GetStaticPaths`、`GetServerSideProps` 型を使用できます：

```tsx title="pages/blog/[slug].tsx"
import type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'

export const getStaticProps = (async (context) => {
  // ...
}) satisfies GetStaticProps

export const getStaticPaths = (async () => {
  // ...
}) satisfies GetStaticPaths

export const getServerSideProps = (async (context) => {
  // ...
}) satisfies GetServerSideProps
```

> **Good to know:** `satisfies` は TypeScript の [4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html) に追加されました。最新バージョンの TypeScript へアップグレードすることをお勧めします。

### API Routes とともに {#with-api-routes}

次の例は、API ルートにビルトインの型を使用する方法を示しています：

```ts title="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: 'John Doe' })
}
```

また、レスポンスデータに型を付けることもできます：

```ts title="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}
```

### カスタム `App` とともに {#with-custom-app}

[カスタム `App`](https://nextjs.org/docs/canary/pages/building-your-application/routing/custom-app) がある場合、組み込み型 `AppProps` を使用し、ファイル名を `./pages/_app.tsx` に変更します：

```ts
import type { AppProps } from 'next/app'

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
```

</PagesOnly>

### 増分型チェック {#incremental-type-checking}

`v10.2.1` 以降、Next.js は `tsconfig.json` で有効にされているときに [incremenal type checking](https://www.typescriptlang.org/tsconfig#incremental) をサポートしており、大規模なアプリケーションでの型チェックの速度を向上させるのに役立ちます。

### 本番での TypeScript エラーの無効化 {#disabling-typescript-errors-in-production}

Next.js は、プロジェクトに TypeScript エラーがある場合、**本番ビルド** (`next build`) を失敗させます。

アプリケーションにエラーがある状態でも Next.js に本番コードを危険にも生成させたい場合は、ビルトインの型チェックステップを無効にすることができます。

ただし、無効にする場合は、ビルドまたはデプロイプロセスの一環として型チェックを実行するようにしてください。でないと、非常に危険です。

`next.config.ts` を開いて、`typescript` 設定で `ignoreBuildErrors` オプションを有効にします：

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  typescript: {
    // !! 警告 !!
    // プロジェクトに型エラーがあっても、本番ビルドを正常に完了させる危険な設定
    // !! 警告 !!
    ignoreBuildErrors: true,
  },
}

export default nextConfig
```

> **Good to know**: 自ら `tsc --noEmit` を実行して TypeScript のエラーをビルド前に確認できます。これは、デプロイ前に TypeScript のエラーをチェックしたい CI/CD パイプラインで有用です。

### カスタム型宣言 {#custom-type-declarations}

カスタム型を宣言する必要があるとき、`next-env.d.ts` を変更したくなるかもしれません。しかし、このファイルは自動生成されるため、変更が上書きされます。代わりに、新しいファイルを作成し（例えば `new-types.d.ts` とします）、それを `tsconfig.json` に参照するようにします：

```json title="tsconfig.json"
{
  "compilerOptions": {
    "skipLibCheck": true
    //...省略...
  },
  "include": [
    "new-types.d.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
```

## バージョン履歴 {#version-changes}

| バージョン | 変更点                                                                                                                                                 |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `v15.0.0`  | TypeScript プロジェクト向けに [`next.config.ts`](#type-checking-nextconfigts) のサポートが追加されました。                                             |
| `v13.2.0`  | 静的に型付けされたリンクがベータ版で利用可能です。                                                                                                     |
| `v12.0.0`  | [SWC](/docs/architecture/nextjs-compiler) がデフォルトで TypeScript と TSX をコンパイルするようになり、ビルドがより高速になりました。                  |
| `v10.2.1`  | `tsconfig.json` で有効にされているときに [incremental type checking](https://www.typescriptlang.org/tsconfig#incremental) のサポートが追加されました。 |
