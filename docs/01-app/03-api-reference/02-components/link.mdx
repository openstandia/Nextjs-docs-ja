---
title: '<Link>'
description: '組み込みの`next/link`コンポーネントで高速なクライアントサイドナビゲーションを有効にします。'
---

{/* このドキュメントの内容は、app routerとpages routerの両方で共有されています。Pages Routerに固有のコンテンツを追加する場合は、`<PagesOnly>Content</PagesOnly>`コンポーネントを利用できます。共有コンテンツはコンポーネントでラップしないでください。 */}

`<Link>`は、[事前フェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)とクライアントサイドナビゲーションを提供するためにHTMLの`<a>`要素を拡張したReactコンポーネントです。Next.jsでルート間をナビゲートする主要な方法です。

基本的な使用法：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">ダッシュボード</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">ダッシュボード</Link>
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">ダッシュボード</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">ダッシュボード</Link>
}
```

</TabItem>
</Tabs>

</PagesOnly>

## 参照 {#reference}

`<Link>`コンポーネントに渡すことができる以下のpropsがあります：

<PagesOnly>

| Prop                                | 例                      | タイプ                   | 必須 |
| ----------------------------------- | ----------------------- | ------------------------ | ---- |
| [`href`](#href-required)            | `href="/dashboard"`     | 文字列またはオブジェクト | はい |
| [`replace`](#replace)               | `replace={false}`       | boolean                  | -    |
| [`scroll`](#scroll)                 | `scroll={false}`        | boolean                  | -    |
| [`prefetch`](#prefetch)             | `prefetch={false}`      | boolean                  | -    |
| [`legacyBehavior`](#legacybehavior) | `legacyBehavior={true}` | boolean                  | -    |
| [`passHref`](#passhref)             | `passHref={true}`       | boolean                  | -    |
| [`shallow`](#shallow)               | `shallow={false}`       | boolean                  | -    |
| [`locale`](#locale)                 | `locale="fr"`           | 文字列またはboolean      | -    |

</PagesOnly>

<AppOnly>

| Prop                     | 例                  | タイプ                   | 必須 |
| ------------------------ | ------------------- | ------------------------ | ---- |
| [`href`](#href-required) | `href="/dashboard"` | 文字列またはオブジェクト | はい |
| [`replace`](#replace)    | `replace={false}`   | boolean                  | -    |
| [`scroll`](#scroll)      | `scroll={false}`    | boolean                  | -    |
| [`prefetch`](#prefetch)  | `prefetch={false}`  | booleanまたはnull        | -    |

</AppOnly>

> **Good to know**: `className`や`target="_blank"`などの`<a>`タグ属性は、propsとして`<Link>`に追加でき、基になる`<a>`要素に渡されます。

### `href`（必須） {#href-required}

移動先のパスまたはURL。

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

// /about?name=testに移動します
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

// /about?name=testに移動します
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

// /about?name=testに移動します
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

// /about?name=testに移動します
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `replace` {#replace}

**デフォルトは`false`です。** `true`の場合、`next/link`は現在の履歴状態を[ブラウザのヒストリー](https://developer.mozilla.org/docs/Web/API/History_API)スタックに新しいURLを追加する代わりに置き換えます。

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `scroll` {#scroll}

**デフォルトは`true`です。** Next.jsの`<Link>`のデフォルトのスクロール挙動は、**スクロール位置を維持すること**です。これはブラウザが前後のナビゲーションを処理する方法に似ています。新しい[Page](/docs/app/building-your-application/routing/pages)に移動する時に、ページがビューポート内で表示されている限り、スクロール位置は同じままです。しかし、ページがビューポートに表示されていない場合、Next.jsは最初のページ要素の先頭までスクロールします。

`scroll = {false}`の場合、Next.jsは最初のページ要素にスクロールしません。

> **Good to know**: Next.jsはスクロールの挙動を管理する前に`scroll: false`を確認します。スクロールが有効である場合、ナビゲーションの関連するDOMノードを特定し、各トップレベル要素を確認します。すべての非スクロール可能な要素とレンダリングされていないHTMLを持つ要素はスキップされます。これには、固定された要素や`getBoundingClientRect`で計算された非表示の要素が含まれます。Next.jsはビューポートで表示されているスクロール可能な要素を見つけるまで兄弟要素を続けます。

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `prefetch` {#prefetch}

<AppOnly>

事前フェッチは、`<Link />`コンポーネントがユーザーのビューポートに入る時（最初またはスクロールによって）行われます。Next.jsはリンクされたルート（`href`で示される）とそのデータをバックグラウンドで事前フェッチして、クライアントサイドナビゲーションのパフォーマンスを向上させます。もし事前フェッチされたデータが`<Link />`にマウスを乗せる時に期限切れの場合、Next.jsは再度事前フェッチを試みます。**事前フェッチはプロダクションでのみ有効です。**

`prefetch`propに渡せる値は以下の通りです：

- **`null`（デフォルト）**：事前フェッチの動作は、ルートが静的か動的かに依存します。静的ルートの場合、完全なルートが事前フェッチされます（すべてのデータを含む）。動的ルートの場合、最も近い[`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)境界までの部分ルートが事前フェッチされます。
- `true`：静的および動的ルートの両方に対して完全なルートが事前フェッチされます。
- `false`：ビューポートに入った時も、ホバー時も事前フェッチは行われません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

事前フェッチは、`<Link />`コンポーネントがユーザーのビューポートに入る時（最初またはスクロールによって）行われます。Next.jsはリンクされたルート（`href`で示される）とデータをバックグラウンドで事前フェッチして、クライアントサイドナビゲーションのパフォーマンスを向上させます。**事前フェッチはプロダクションでのみ有効です。**

`prefetch`propに渡せる値は以下の通りです：

- **`true`（デフォルト）**：完全なルートとそのデータが事前フェッチされます。
- `false`：ビューポートに入った時は事前フェッチが行われませんが、ホバー時には事前フェッチが行われます。ホバー時にも完全にフェッチを削除したい場合は、`<a>`タグを使用するか、App Routerを[部分的に導入](/docs/app/building-your-application/upgrading/app-router-migration)し、ホバーでの事前フェッチを無効にすることを検討してください。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

### `legacyBehavior` {#legacybehavior}

`<a>`要素は`<Link>`の子として必要ありません。レガシーな動作を使用するには、`legacyBehavior` propを追加するか、アップグレードするために`<a>`を削除します。[コードモッドが利用可能です](/docs/app/building-your-application/upgrading/codemods#new-link)ので、コードの自動アップグレードが可能です。

> **Good to know**: `legacyBehavior`が`true`に設定されていない場合は、すべての[`anchor`](https://developer.mozilla.org/docs/Web/HTML/Element/a)タグのプロパティが`next/link`にも渡せます。例えば、`className`や`onClick`などです。

### `passHref` {#passhref}

`Link`が`href`プロパティをその子に送信することを強制します。デフォルトは`false`です。詳細については、[関数コンポーネントを渡す](#nesting-a-functional-component)の例を参照してください。

### `scroll` {#scroll}

ナビゲーション後にページの先頭にスクロールします。デフォルトは`true`です。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

### `shallow` {#shallow}

現在のページのパスを更新しても、[`getStaticProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)、[`getServerSideProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-server-side-props)、または[`getInitialProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-initial-props)を再実行しません。デフォルトは`false`です。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

### `locale` {#locale}

アクティブなロケールは自動的に呼び出されます。`locale`は異なるロケールを提供するために使用します。`false`の場合、`href`はデフォルトの動作が無効になるのでロケールを含める必要があります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* デフォルトの動作：ロケールが呼び出されます */}
      <Link href="/dashboard">ダッシュボード（ロケールあり）</Link>

      {/* ロケールの呼び出しを無効にします */}
      <Link href="/dashboard" locale={false}>
        ダッシュボード（ロケールなし）
      </Link>

      {/* 異なるロケールを指定します */}
      <Link href="/dashboard" locale="fr">
        ダッシュボード（フランス語）
      </Link>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* デフォルトの動作：ロケールが呼び出されます */}
      <Link href="/dashboard">ダッシュボード（ロケールあり）</Link>

      {/* ロケールの呼び出しを無効にします */}
      <Link href="/dashboard" locale={false}>
        ダッシュボード（ロケールなし）
      </Link>

      {/* 異なるロケールを指定します */}
      <Link href="/dashboard" locale="fr">
        ダッシュボード（フランス語）
      </Link>
    </>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

## 使用例 {#examples}

以下の使用例は、さまざまなシナリオで`<Link>`コンポーネントを使用する方法を示しています。

<AppOnly>

### 動的セグメントにリンクを張る {#linking-to-dynamic-segments}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes)にリンクを張る時に、[テンプレート リテラルと補間](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals)を使用してリンクのリストを生成できます。例えば、ブログ投稿のリストを生成するには：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/post-list.tsx" switcher
import Link from 'next/link'

interface Post {
  id: number
  title: string
  slug: string
}

export default function PostList({ posts }: { posts: Post[] }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/post-list.js" switcher
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

### アクティブリンクの確認 {#checking-active-links}

[`usePathname()`](/docs/app/api-reference/functions/use-pathname)を使用して、リンクがアクティブかどうかを確認できます。例えば、アクティブなリンクにクラスを追加するためには、現在の`pathname`がリンクの`href`に一致するかを確認します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/nav-links.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        ホーム
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        アバウト
      </Link>
    </nav>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/nav-links.js" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        ホーム
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        アバウト
      </Link>
    </nav>
  )
}
```

</TabItem>
</Tabs>

### `id`にスクロールする {#scrolling-to-an-id}

特定の`id`にナビゲーションする場合、URLに`#`ハッシュリンクを追加するか、ハッシュリンクを`href`propに渡すことができます。これは、`<Link>`が`<a>`要素にレンダリングされるため可能です。

```jsx
<Link href="/dashboard#settings">設定</Link>

// 出力
<a href="/dashboard#settings">設定</a>
```

> **Good to know**:
>
> - ナビゲーションの際にページがビューポート内で表示されていない場合、Next.jsは[Page](/docs/app/building-your-application/routing/pages)までスクロールします。

</AppOnly>

### 動的ルートセグメントにリンクを張る {#linking-to-dynamic-route-segments}

[動的ルートセグメント](/docs/app/building-your-application/routing/dynamic-routes)の場合、テンプレートリテラルを使用してリンクのパスを作成するのが便利です。

<PagesOnly>

例えば、動的ルート`pages/blog/[slug].js`へのリンクのリストを生成できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/blog/index.tsx" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/blog/index.js" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}

export default Posts
```

</TabItem>
</Tabs>

</PagesOnly>

<AppOnly>

例えば、動的ルート`app/blog/[slug]/page.js`へのリンクのリストを生成できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

### `<a>`タグをラップするカスタムコンポーネントが子の場合 {#if-the-child-is-a-custom-component-that-wraps-an-a-tag}

<AppOnly>

`Link`の子が`<a>`タグをラップするカスタムコンポーネントである場合、`passHref`を`Link`に追加する必要があります。これは[styled-components](https://styled-components.com/)のようなライブラリを使用する場合に必要です。これがないと`<a>`タグは`href`属性を持たず、サイトのアクセシビリティが損なわれ、SEOに影響する可能性があります。[ESLint](https://nextjs.org/docs/canary/pages/api-reference/config/eslint)を使用している場合、`passHref`を正しく使用するための組み込みルール`next/link-passhref`があります。

</AppOnly>

<PagesOnly>

`Link`の子が`<a>`タグをラップするカスタムコンポーネントである場合、`passHref`を`Link`に追加する必要があります。これは[styled-components](https://styled-components.com/)のようなライブラリを使用する場合に必要です。これがないと`<a>`タグは`href`属性を持たず、サイトのアクセシビリティが損なわれ、SEOに影響する可能性があります。[ESLint](https://nextjs.org/docs/canary/pages/api-reference/config/eslint)を使用している場合、`passHref`を正しく使用するための組み込みルール`next/link-passhref`があります。

</PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="components/nav-link.tsx" switcher
import Link from 'next/link'
import styled from 'styled-components'

// これは<a>タグをラップするカスタムコンポーネントを作成します
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="components/nav-link.js" switcher
import Link from 'next/link'
import styled from 'styled-components'

// これは<a>タグをラップするカスタムコンポーネントを作成します
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

</TabItem>
</Tabs>

- [emotion](https://emotion.sh/)のJSXプラグマ機能（`@jsx jsx`）を使用している場合、`<a>`タグを直接使用している場合でも`passHref`を使用する必要があります。
- コンポーネントは`onClick`プロパティに対応し、ナビゲーションを正しくトリガーする必要があります。

### 関数コンポーネントのネスト {#nesting-a-functional-component}

`Link`の子が関数コンポーネントの場合、`passHref`と`legacyBehavior`を使用することに加えて、コンポーネントを[`React.forwardRef`](https://react.dev/reference/react/forwardRef)でラップする必要があります：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'
import React from 'react'

// MyButtonのpropsの型を定義
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// React.ForwardRefRenderFunctionを使用して、適切に転送されたrefを型付け
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      クリックしてください
    </a>
  )
}

// React.forwardRefを使用してコンポーネントをラップ
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`、`href`、および`ref`は、適切な処理のためにDOM要素に渡す必要があります
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      クリックしてください
    </a>
  )
})

// デバッグに便利なコンポーネントの表示名を追加
MyButton.displayName = 'MyButton'

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'
import React from 'react'

// MyButtonのpropsの型を定義
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// React.ForwardRefRenderFunctionを使用して、適切に転送されたrefを型付け
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      クリックしてください
    </a>
  )
}

// React.forwardRefを使用してコンポーネントをラップ
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`、`href`、および`ref`は、適切な処理のためにDOM要素に渡す必要があります
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      クリックしてください
    </a>
  )
})

// デバッグに便利なコンポーネントの表示名を追加
MyButton.displayName = 'MyButton'

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

<PagesOnly>

### URLオブジェクトを渡す {#passing-a-url-object}

`Link`はURLオブジェクトを受け取り、URL文字列を作成するためにそれを自動的にフォーマットします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.ts" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          私たちについて
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          ブログ投稿
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          私たちについて
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          ブログ投稿
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

</TabItem>
</Tabs>

上記の例には、次のリンクがあります：

- あらかじめ定義されたルート：`/about?name=test`
- [動的ルート](/docs/app/building-your-application/routing/dynamic-routes)：`/blog/my-post`

[Node.jsのURLモジュールドキュメント](https://nodejs.org/api/url.html#url_url_strings_and_url_objects)で定義されているすべてのプロパティを使用できます。

</PagesOnly>

### URLをプッシュせずに置き換える {#replace-the-url-instead-of-push}

`Link`コンポーネントのデフォルトの動作は、新しいURLを履歴スタックに`push`することです。新しいエントリを追加しないようにするためには、次の例のように`replace` propを使用できます：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      私たちについて
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      私たちについて
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      私たちについて
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      私たちについて
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### ページの先頭へのスクロールを無効にする {#disable-scrolling-to-the-top-of-the-page}

<AppOnly>

Next.jsの`<Link>`のデフォルトのスクロール動作は、**スクロール位置を維持することです**。これはブラウザが前後のナビゲーションを処理する方法に似ています。新しい[Page](/docs/app/building-your-application/routing/pages)に移動する時、ページがビューポート内で表示されている限り、スクロール位置は同じままです。

しかし、ページがビューポートに表示されていない場合、Next.jsは最初のページ要素の先頭にスクロールします。この動作を無効にしたい場合は、`<Link>`コンポーネントに`scroll={false}`を渡すか、`router.push()`または`router.replace()`に`scroll: false`を渡します。

<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      先頭へのスクロールを無効にする
    </Link>
  )
}
```

</TabItem>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      先頭へのスクロールを無効にする
    </Link>
  )
}
```

</TabItem>
</Tabs>

`router.push()`または`router.replace()`を使用する場合：

```jsx
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

</AppOnly>

<PagesOnly>

`Link`のデフォルトの動作はページの先頭にスクロールすることです。ハッシュが定義されている場合、通常の`<a>`タグのように特定のidまでスクロールします。ページの先頭/ハッシュへのスクロールを防ぐためには、`Link`に`scroll={false}`を追加できます：

<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      先頭へのスクロールを無効にする
    </Link>
  )
}
```

</TabItem>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      先頭へのスクロールを無効にする
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### ミドルウェアでのリンクの事前フェッチ {#prefetching-links-in-middleware}

[ミドルウェア](/docs/app/building-your-application/routing/middleware)は、認証やユーザーを別のページにリダイレクトする目的などによく使用されます。`<Link />`コンポーネントがミドルウェアを介してリライトされたリンクを正しく事前フェッチするためには、Next.jsに表示するURLと事前フェッチするURLの両方を指定する必要があります。これにより、事前フェッチする正しいルートを知るためにミドルウェアへの不要なフェッチが避けられます。

例えば、認証されたビューとビジタービューを持つ`/dashboard`ルートを提供したい場合、ユーザーを正しいページにリダイレクトするためにミドルウェアで次のように追加できます：

```ts title="middleware.ts"
import { NextResponse } from 'next/server'

export function middleware(request: Request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

```js title="middleware.js"
import { NextResponse } from 'next/server'

export function middleware(request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

この場合、`<Link />`コンポーネントで以下のコードを使用する必要があります：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/page.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/index.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      ダッシュボード
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

<PagesOnly>

> **Good to know**: [動的ルート](/docs/app/building-your-application/routing/dynamic-routes)を使用している場合は、`as`と`href`propsを適応させる必要があります。例えば、ミドルウェアを介して異なる形で表示したい動的ルート`/dashboard/authed/[user]`がある場合、次のように書きます：`<Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as="/dashboard/[user]">プロファイル</Link>`。

</PagesOnly>

## バージョン履歴 {#version-history}

| バージョン | 変更内容                                                                                                                                                                                             |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `v13.0.0`  | 子`<a>`タグを必要としなくなりました。[コードモッド](/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components)が提供されており、コードベースを自動的に更新できます。 |
| `v10.0.0`  | 動的ルートを指している`href`propは自動的に解決され、`as`propを必要としなくなりました。                                                                                                               |
| `v8.0.0`   | 事前フェッチのパフォーマンスが向上しました。                                                                                                                                                         |
| `v1.0.0`   | `next/link`が導入されました。                                                                                                                                                                        |
