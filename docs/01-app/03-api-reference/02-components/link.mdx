---
title: '<Link>'
description: '組み込みの `next/link`コンポーネントで高速なクライアントサイドナビゲーションを実現する。'
---

`<Link>` は、ルート間の[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)とクライアントサイドのナビゲーションを提供するために、HTMLの `<a>` 要素を拡張したReactコンポーネントです; Next.jsでルート間をナビゲートするための主な方法です;

基本的な使用方法：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

</PagesOnly>

## 参考 {#reference}

次のpropsを `<Link>` コンポーネントに渡すことができます:

<PagesOnly>

| Prop                                | Example                 | Type              | Required |
| ----------------------------------- | ----------------------- | ----------------- | -------- |
| [`href`](#href-required)            | `href="/dashboard"`     | String or Object  | Yes      |
| [`replace`](#replace)               | `replace={false}`       | Boolean           | -        |
| [`scroll`](#scroll)                 | `scroll={false}`        | Boolean           | -        |
| [`prefetch`](#prefetch)             | `prefetch={false}`      | Boolean           | -        |
| [`legacyBehavior`](#legacybehavior) | `legacyBehavior={true}` | Boolean           | -        |
| [`passHref`](#passhref)             | `passHref={true}`       | Boolean           | -        |
| [`shallow`](#shallow)               | `shallow={false}`       | Boolean           | -        |
| [`locale`](#locale)                 | `locale="fr"`           | String or Boolean | -        |

</PagesOnly>

<AppOnly>

| Prop                     | Example             | Type             | Required |
| ------------------------ | ------------------- | ---------------- | -------- |
| [`href`](#href-required) | `href="/dashboard"` | String or Object | Yes      |
| [`replace`](#replace)    | `replace={false}`   | Boolean          | -        |
| [`scroll`](#scroll)      | `scroll={false}`    | Boolean          | -        |
| [`prefetch`](#prefetch)  | `prefetch={false}`  | Boolean or null  | -        |

</AppOnly>

> **Good to know**: `<a>` タグの属性（例: `className` や `target="_blank"`）は、propsとして `<Link>` に追加可能で、ベースの `<a>` 要素に渡されます;

### `href`（必須） {#href-required}

ナビゲート先のパスまたはURLです;

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

// /about?name=test にナビゲート
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

// /about?name=test にナビゲート
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

// /about?name=test にナビゲート
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

// /about?name=test にナビゲート
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `replace` {#replace}

**デフォルトは `false`です;** `true` にすると、 `next/link` は[ブラウザの履歴](https://developer.mozilla.org/docs/Web/API/History_API)スタックに新しいURLを追加するのではなく、現在の履歴状態を置き換えます;

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `scroll` {#scroll}

**デフォルトは `true`です;** Next.jsの `<Link>` のデフォルトのスクロール動作は、ブラウザがバックやフォワードナビゲーションを行う場合と同様に**スクロール位置を維持すること**です; 新しい[ページ](/docs/app/building-your-application/routing/pages)に移動すると、ページがビューポートに表示されている限り、スクロール位置はそのままです; ただし、ページがビューポートに表示されていない場合、Next.jsは最初のページ要素の先頭にスクロールします;

`scroll = {false}` のとき、Next.jsは最初のページ要素にスクロールしようとしません;

> **Good to know**: Next.jsは、スクロールの動作を管理する前に `scroll: false`かどうかをチェックします; スクロールが有効な場合、ナビゲーションに関連するDOMノードを識別し、各トップレベル要素を調査します; すべてのスクロール可能でない要素およびレンダリングされたHTMLのない要素はバイパスされます;これは、固定またはステート固定された要素や、`getBoundingClientRect`で計算されるものなどの非表示要素を含みます; 次に、Next.jsはスクロール可能でビューポート内で表示される要素を特定するまで、兄弟要素を通じて処理を続けます;

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### `prefetch` {#prefetch}

<AppOnly>

プリフェッチは、`<Link />` コンポーネントがユーザーのビューポートに入ったとき（初めてまたはスクロールで）に発生します; Next.jsはリンクされたルート（`href`で示される）とデータをバックグラウンドでプリフェッチし、クライアントサイドナビゲーションのパフォーマンスを向上させます; プリフェッチされたデータが `<Link />` にホバーした時点で期限切れになっている場合、Next.jsは再度プリフェッチを試みます; **プリフェッチは本番環境のみで有効です;**

`prefetch` propに渡すことができる値は以下の通りです;

- **`null` （デフォルト）**: プリフェッチの動作は、そのルートが静的または動的であるかどうかに依存します; 静的ルートの場合、完全なルートがプリフェッチされ、そのすべてのデータが含まれます; 動的ルートの場合、最近の [`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states) 境界までの部分的なルートがプリフェッチされます;
- `true`: 静的および動的ルートの両方で完全なルートがプリフェッチされます;
- `false`: ビューポートに入ったときやホバーしたときでも、プリフェッチは発生しません;

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

プリフェッチは、`<Link />` コンポーネントがユーザーのビューポートに入ったとき（初めてまたはスクロールで）に発生します; Next.jsはリンクされたルート（`href`で示される）とデータをバックグラウンドでプリフェッチし、クライアントサイドナビゲーションのパフォーマンスを向上させます; **プリフェッチは本番環境でのみ有効です;**

`prefetch` propに渡すことができる値は以下の通りです;

- **`true` （デフォルト）**: 完全なルートとそのデータがプリフェッチされます;
- `false`: ビューポートに入ったときはプリフェッチは発生しませんが、ホバー時には発生します; ホバー時のプリフェッチを完全に無効にしたい場合は、`<a>` タグの使用や[段階的なApp Routerの採用](/docs/app/building-your-application/upgrading/app-router-migration)を検討してください;これにより、ホバー時のプリフェッチも無効にできます;

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

### `legacyBehavior` {#legacybehavior}

`<a>` 要素は、もはや `<Link>` の子として必須ではありません; `legacyBehavior` prop を追加してレガシー動作を使用するか `<a>` タグを削除してアップグレードしてください; 自動アップグレードを行うための[コードモッドが利用可能](/docs/app/building-your-application/upgrading/codemods#new-link)です;

> **Good to know**: `legacyBehavior`が `true` に設定されていない場合、全ての[`アンカー`](https://developer.mozilla.org/docs/Web/HTML/Element/a)タグのプロパティは、`className`、`onClick`などと共に `next/link`に渡すことができます;

### `passHref` {#passhref}

`Link`に `href` プロパティをその子に送るように強制します; デフォルトは `false`です; 詳細については、[関数コンポーネントの渡し](#nesting-a-functional-component)の例を参照してください;

### `scroll` {#scroll}

ナビゲーション後にページのトップにスクロールします; デフォルトは `true`です;

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

### `shallow` {#shallow}

[`getStaticProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)、 [`getServerSideProps`](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-server-side-props)、または [`getInitialProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-initial-props)を再度実行することなく、現在のページのパスを更新します; デフォルトは `false`です;

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

### `locale` {#locale}

アクティブなロケールは自動的に追加されます; `locale` は異なるロケールを指定することができます; `false` の場合、`href` はデフォルトの動作が無効化されるため、ロケールを含む必要があります;

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* デフォルトの動作: ロケールが追加される */}
      <Link href="/dashboard">Dashboard (with locale)</Link>

      {/* ロケール追加を無効化 */}
      <Link href="/dashboard" locale={false}>
        Dashboard (without locale)
      </Link>

      {/* 異なるロケールを指定 */}
      <Link href="/dashboard" locale="fr">
        Dashboard (French)
      </Link>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* デフォルトの動作: ロケールが追加される */}
      <Link href="/dashboard">Dashboard (with locale)</Link>

      {/* ロケール追加を無効化 */}
      <Link href="/dashboard" locale={false}>
        Dashboard (without locale)
      </Link>

      {/* 異なるロケールを指定 */}
      <Link href="/dashboard" locale="fr">
        Dashboard (French)
      </Link>
    </>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

## 例 {#examples}

以下の例は、さまざまなシナリオで `<Link>` コンポーネントを使用する方法を示しています;

<AppOnly>

### 動的セグメントへのリンク {#linking-to-dynamic-segments}

[動的セグメント](/docs/app/building-your-application/routing/dynamic-routes) にリンクする際には、[テンプレートリテラルと補間](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals)を使用してリンクのリストを生成できます; 例えば、ブログ投稿のリストを生成するには:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/post-list.tsx" switcher
import Link from 'next/link'

interface Post {
  id: number
  title: string
  slug: string
}

export default function PostList({ posts }: { posts: Post[] }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/post-list.js" switcher
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

### アクティブなリンクのチェック {#checking-active-links}

[`usePathname()`](/docs/app/api-reference/functions/use-pathname) を利用して、リンクがアクティブかどうかを判断できます; 例えば、現在の `pathname` がリンクの `href` と一致するかどうかをチェックして、アクティブなリンクにクラスを追加するには:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/nav-links.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/nav-links.js" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

</TabItem>
</Tabs>

### `id`へのスクロール {#scrolling-to-an-id}

ナビゲーション時に特定の `id` へスクロールしたい場合は、URLに`#`ハッシュリンクを追加するか、ハッシュリンクだけを `href` prop に渡すことができます; `<Link>` は `<a>` 要素にレンダリングされるため可能です;

```jsx
<Link href="/dashboard#settings">Settings</Link>

// 出力
<a href="/dashboard#settings">Settings</a>
```

> **Good to know**:
>
> - Next.jsはナビゲーション時にビューポート内に表示されない場合、[ページ](/docs/app/building-your-application/routing/pages)にスクロールされます;

</AppOnly>

### 動的ルートセグメントへのリンク {#linking-to-dynamic-route-segments}

[動的ルートセグメント](/docs/app/building-your-application/routing/dynamic-routes) では、リンクのパスを生成するためにテンプレートリテラルを使用すると便利です;

<PagesOnly>

例えば、動的ルート `pages/blog/[slug].js` へのリンクリストを生成できます:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/blog/index.tsx" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/blog/index.js" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}

export default Posts
```

</TabItem>
</Tabs>

</PagesOnly>

<AppOnly>

例えば、動的ルート `app/blog/[slug]/page.js` へのリンクリストを生成できます:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

### 子が `<a>` タグをラップするカスタムコンポーネントの場合 {#if-the-child-is-a-custom-component-that-wraps-an-a-tag}

<AppOnly>

`Link` の子が `<a>` タグをラップするカスタムコンポーネントの場合、`passHref` を `Link` に追加する必要があります; これは、[styled-components](https://styled-components.com/)のようなライブラリを使用している場合に必要です; これがないと `<a>` タグに`href`属性が設定されなくなり、サイトのアクセシビリティが損なわれ、SEOに影響する可能性があります; [ESLint](https://nextjs.org/docs/canary/pages/api-reference/config/eslint)を使用している場合、`passHref`の正しい使用を保証するための組み込みルール `next/link-passhref` があります;

</AppOnly>

<PagesOnly>

`Link` の子が `<a>` タグをラップするカスタムコンポーネントの場合、`passHref` を `Link` に追加する必要があります; これは、[styled-components](https://styled-components.com/)のようなライブラリを使用している場合に必要です; これがないと `<a>` タグに`href`属性が設定されなくなり、サイトのアクセシビリティが損なわれ、SEOに影響する可能性があります; [ESLint](https://nextjs.org/docs/canary/pages/api-reference/config/eslint)を使用している場合、`passHref`の正しい使用を保証するための組み込みルール `next/link-passhref` があります;

</PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="components/nav-link.tsx" switcher
import Link from 'next/link'
import styled from 'styled-components'

// これは<a>タグをラップするカスタムコンポーネントを生成します
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="components/nav-link.js" switcher
import Link from 'next/link'
import styled from 'styled-components'

// これは<a>タグをラップするカスタムコンポーネントを生成します
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

</TabItem>
</Tabs>

- [emotion](https://emotion.sh/)のJSXプリプロセッサ機能（`@jsx jsx`）を使用している場合、`<a>` タグを直接使用しても `passHref` を使用する必要があります;
- ナビゲーションを正しくトリガーするため、コンポーネントは `onClick` プロパティをサポートする必要があります;

### 関数コンポーネントをネストする {#nesting-a-functional-component}

`Link` の子が関数コンポーネントの場合、`passHref`と`legacyBehavior`を使用することに加えて、[`React.forwardRef`](https://react.dev/reference/react/forwardRef)でコンポーネントをラップする必要があります;

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'
import React from 'react'

// MyButton のprops 型を定義
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// React.ForwardRefRenderFunction を使用して転送された ref の型を適切に設定
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// コンポーネントをラップするためにReact.forwardRefを使用
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`、`href`、`ref`は、適切な処理を行うためにDOM要素に渡す必要があります
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// コンポーネントの表示名を追加（デバッグに便利）
MyButton.displayName = 'MyButton'

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'
import React from 'react'

// MyButton のprops 型を定義
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// React.ForwardRefRenderFunction を使用して転送された ref の型を適切に設定
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// コンポーネントをラップするためにReact.forwardRefを使用
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`、`href`、`ref`は、適切な処理を行うためにDOM要素に渡す必要があります
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// コンポーネントの表示名を追加（デバッグに便利）
MyButton.displayName = 'MyButton'

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

<PagesOnly>

### URLオブジェクトの渡し {#passing-a-url-object}

`Link` にURLオブジェクトを渡すこともでき、それによりURL文字列を自動的にフォーマットします;

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.ts" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

</TabItem>
</Tabs>

上記の例には、以下のリンクが含まれます;

- 事前定義されたルート: `/about?name=test`
- [動的ルート](/docs/app/building-your-application/routing/dynamic-routes): `/blog/my-post`

[Node.jsのURLモジュールのドキュメント](https://nodejs.org/api/url.html#url_url_strings_and_url_objects)に定義されているすべてのプロパティを使用できます;

</PagesOnly>

### URLの置き換え {#replace-the-url-instead-of-push}

`Link` コンポーネントのデフォルト動作は、`history`スタックに新しいURLを`push`することです; 以下の例のように、`replace` プロップを使用して新しいエントリの追加を防ぐことができます;

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### ページのトップへのスクロールを無効にする {#disable-scrolling-to-the-top-of-the-page}

<AppOnly>

Next.jsにおける `<Link>` のデフォルトスクロール動作は、ブラウザがバックやフォワードナビゲーションを行う場合と同様に**スクロール位置を維持すること**です; 新しい[ページ](/docs/app/building-your-application/routing/pages)に移動すると、ページがビューポートに表示されている限り、スクロール位置はそのままです;

ただし、ページがビューポート内に表示されていない場合、Next.jsは最初のページ要素のトップへスクロールします; この動作を無効化したい場合は、`<Link>` コンポーネントに `scroll={false}` を渡すか、`router.push()` または `router.replace()` に `scroll: false` を渡すことができます;

<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</TabItem>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</TabItem>
</Tabs>

`router.push()` または `router.replace()` を使用：

```jsx
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

</AppOnly>

<PagesOnly>

`Link` のデフォルト動作はページのトップへスクロールすることです; ハッシュが定義されている場合、通常の`<a>`タグのように特定のidにスクロールします; 上の / ハッシュへのスクロールを防ぐために `scroll={false}` を `Link` に追加できます;

<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</TabItem>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

### ミドルウェアでリンクをプリフェッチする {#prefetching-links-in-middleware}

[ミドルウェア](/docs/app/building-your-application/routing/middleware)は認証やその他の目的でユーザーを別のページに転送する場合によく使用されます; `<Link />` コンポーネントがミドルウェアによるリライトでリンクを正しくプリフェッチするためには、Next.jsに表示するURLとプリフェッチするURLの両方を伝える必要があります; 正しいルートをプリフェッチするためにミドルウェアへの無駄なフェッチを避けるために、これは必要です;

例えば、認証済みおよび訪問者ビューを持つ `/dashboard` ルートを提供したい場合、ユーザーを正しいページにリダイレクトするためにミドルウェアに以下を追加できます:

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="middleware.ts" switcher
import { NextResponse } from 'next/server'

export function middleware(request: Request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

</TabItem>
</Tabs>

この場合、`<Link />` コンポーネントで以下のコードを使用したい場合があります:

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/page.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/index.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="pages/index.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // 認証フック

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

<PagesOnly>

> **Good to know**: [Dynamic Routes](/docs/app/building-your-application/routing/dynamic-routes) を使用している場合、`as` と `href` のプロップを適応させる必要があります; 例えば、`/dashboard/authed/[user]` のような、ミドルウェアで異なる形で表示したいDynamic Routeがある場合は、`<Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as="/dashboard/[user]">Profile</Link>` と記述します;

</PagesOnly>

## バージョン履歴 {#version-history}

| バージョン | 変更点                                                                                                                                                                                             |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `v13.0.0`  | 子に `<a>` タグが不要になりました; [コードモッド](/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components) が提供されており、自動的にコードベースを更新できます; |
| `v10.0.0`  | 動的ルートを指す `href` プロップが `as` プロップを必要とせず、 自動的に解決されるようになりました;                                                                                                 |
| `v8.0.0`   | プリフェッチ性能が向上しました;                                                                                                                                                                    |
| `v1.0.0`   | `next/link` が導入されました;                                                                                                                                                                      |
