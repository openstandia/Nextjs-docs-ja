---
title: '<Form>'
description: '<Form>コンポーネントを使って、フォームの送信と検索パラメータの更新をクライアントサイドでナビゲーションする方法を学べます。'
---

`<Form>`コンポーネントは、HTML `<form>` 要素を拡張して<AppOnly>[**先読み**](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)の[読み込みUI](/docs/app/building-your-application/routing/loading-ui-and-streaming)、</AppOnly> **クライアントサイドナビゲーション**の送信時、**プログレッシブエンハンスメント**を提供します。

これはURL検索パラメータを更新するフォームに便利で、上記を達成するために必要な定型コードを削減します。

基本的な使い方:

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/ui/search.tsx" switcher
import Form from 'next/form'

export default function Page() {
  return (
    <Form action="/search">
      {/* フォーム送信時、入力値はURLに追加されます 
          例: /search?query=abc */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/ui/search.js" switcher
import Form from 'next/form'

export default function Search() {
  return (
    <Form action="/search">
      {/* フォーム送信時、入力値はURLに追加されます 
          例: /search?query=abc */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/ui/search.js" switcher
import Form from 'next/form'

export default function Page() {
  return (
    <Form action="/search">
      {/* フォーム送信時、入力値はURLに追加されます 
          例: /search?query=abc */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/ui/search.js" switcher
import Form from 'next/form'

export default function Search() {
  return (
    <Form action="/search">
      {/* フォーム送信時、入力値はURLに追加されます 
          例: /search?query=abc */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
</Tabs>

</PagesOnly>

## 参照 {#reference}

`<Form>`コンポーネントの動作は、`action`プロップに渡された値が`string`か`function`（サーバーアクション）かによって異なります。

<AppOnly>

- `action`が**文字列**の場合、`<Form>`はネイティブのHTMLフォームのように**`GET`**メソッドを使用し、フォームデータはURLに検索パラメータとしてエンコードされ、フォームが送信されると指定されたURLにナビゲートします。追加で、Next.jsでは:
  - フォームが表示されると、パスが先読みされ、共有UI（例: `layout.js` と `loading.js`）がプリロードされ、より速いナビゲーションが可能になります。
  - フォームが送信されたときにページ全体のリロードを避けた[クライアントサイドナビゲーション](/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation)を行います。これにより、共有UIとクライアントサイドの状態が保持されます。
- `action`が**関数**（サーバーアクション）の場合、`<Form>`は[React フォーム](https://react.dev/reference/react-dom/components/form)のように動作し、フォーム送信時にアクションを実行します。

</AppOnly>

<PagesOnly>

- `action`が**文字列**の場合、`<Form>`はネイティブのHTMLフォームのように**`GET`**メソッドを使用し、フォームデータはURLに検索パラメータとしてエンコードされ、フォームが送信されると指定されたURLにナビゲートします。追加で、Next.jsでは:
  - フォームが送信されたときにページ全体のリロードを避けた[クライアントサイドナビゲーション](/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation)を行います。これにより、共有UIとクライアントサイドの状態が保持されます。

</PagesOnly>

### `action`（文字列）プロップ {#action-string-props}

<PagesOnly>

`action`が文字列の場合、`<Form>`コンポーネントは以下のプロップをサポートします:

| Prop      | Example            | Type                          | Required |
| --------- | ------------------ | ----------------------------- | -------- |
| `action`  | `action="/search"` | `string`（URLまたは相対パス） | Yes      |
| `replace` | `replace={false}`  | `boolean`                     | -        |
| `scroll`  | `scroll={true}`    | `boolean`                     | -        |

- **`action`**: フォーム送信時にナビゲートするURLまたはパス
  - 空の文字列`""`は、更新された検索パラメータで同じルートにナビゲートします。
- **`replace`**: 新しい履歴状態をブラウザの[履歴](https://developer.mozilla.org/en-US/docs/Web/API/History_API)スタックにプッシュするのではなく、現在の履歴状態を置き換えるかどうかを決定します。デフォルトは`false`です。
- **`scroll`**: ナビゲーション時のスクロール動作を制御します。デフォルトは`true`で、新しいルートのトップまでスクロールし、前後のナビゲーションではスクロール位置を維持します。

</PagesOnly>

<AppOnly>

`action`が文字列の場合、`<Form>`コンポーネントは以下のプロップをサポートします:

| Prop       | Example            | Type                          | Required |
| ---------- | ------------------ | ----------------------------- | -------- |
| `action`   | `action="/search"` | `string`（URLまたは相対パス） | Yes      |
| `replace`  | `replace={false}`  | `boolean`                     | -        |
| `scroll`   | `scroll={true}`    | `boolean`                     | -        |
| `prefetch` | `prefetch={true}`  | `boolean`                     | -        |

- **`action`**: フォーム送信時にナビゲートするURLまたはパス
  - 空の文字列`""`は、更新された検索パラメータで同じルートにナビゲートします。
- **`replace`**: 新しい履歴状態をブラウザの[履歴](https://developer.mozilla.org/en-US/docs/Web/API/History_API)スタックにプッシュするのではなく、現在の履歴状態を置き換えるかどうかを制御します。デフォルトは`false`です。
- **`scroll`**: ナビゲーション時のスクロール動作を制御します。デフォルトは`true`で、新しいルートのトップまでスクロールし、前後のナビゲーションではスクロール位置を維持します。
- **`prefetch`**: フォームがユーザーのビューポートに表示されるときにパスを先読みするかどうかを制御します。デフォルトは`true`です。

### `action`（関数）プロップ {#action-function-props}

`action`に関数が指定された場合、`<Form>`コンポーネントは以下のプロップをサポートします:

| Prop     | Example             | Type                             | Required |
| -------- | ------------------- | -------------------------------- | -------- |
| `action` | `action={myAction}` | `function`（サーバーアクション） | Yes      |

- **`action`**: フォーム送信時に呼び出されるサーバーアクション。詳細は[React ドキュメント](https://react.dev/reference/react-dom/components/form#props)をご覧ください。

> **Good to know**: `action`が関数の場合、`replace`および`scroll`プロップは無視されます。

</AppOnly>

### 注意事項 {#caveats}

<AppOnly>

- **`formAction`**: `<button>`または`<input type="submit">` フィールドで`action`プロップを上書きするために使用できます。Next.jsはクライアントサイドナビゲーションを実行しますが、このアプローチは先読みをサポートしません。
  - [`basePath`](/docs/app/api-reference/config/next-config-js/basePath)を使用する際は、`formAction`パスにもそれを含める必要があります。例: `formAction="/base-path/search"`。
- **`key`**: 文字列`action`に`key`プロップを渡すことはサポートされていません。レンダリングを再度トリガーするかミューテーションを実行したい場合は、関数`action`を使用することを検討してください。

</AppOnly>

- **`onSubmit`**: フォーム送信ロジックを処理するために使用できます。ただし、`event.preventDefault()`を呼び出すと、指定されたURLへのナビゲーションといった`<Form>`の動作がオーバーライドされます。
- **[`method`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#method)、[`encType`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#enctype)、[`target`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#target)**: これらのプロップは`<Form>`の動作を上書きするため、サポートされていません。
  - 同様に、`formMethod`、`formEncType`、および`formTarget`は、それぞれ`method`、`encType`、および`target`プロップを上書きするために使用でき、使用するとネイティブブラウザの動作にフォールバックします。
  - これらのプロップを使用する必要がある場合は、HTML `<form>` 要素を使用してください。
- **`<input type="file">`**: `action`が文字列の場合、この入力タイプを使用すると、ブラウザの動作と一致して、ファイルオブジェクトではなくファイル名が送信されます。

<AppOnly>

## 例 {#examples}

### 検索結果ページに移動する検索フォーム {#search-form-that-leads-to-a-search-result-page}

パスを`action`として渡すことで、検索結果ページに移動する検索フォームを作成できます:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/page.tsx" switcher
import Form from 'next/form'

export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/page.js" switcher
import Form from 'next/form'

export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

</TabItem>
</Tabs>

ユーザーがクエリ入力フィールドを更新してフォームを送信すると、フォームデータがURLに検索パラメータとしてエンコードされます（例: `/search?query=abc`）。

> **Good to know**: `action`に空の文字列`""`を渡すと、フォームは更新された検索パラメータで同じルートにナビゲートします。

結果ページで、[`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) `page.js` プロップを使用してクエリにアクセスし、外部ソースからデータをフェッチできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/search/page.tsx" switcher
import { getSearchResults } from '@/lib/search'

export default async function SearchPage({
  searchParams,
}: {
  searchParams: { [key: string]: string | string[] | undefined }
}) {
  const results = await getSearchResults(searchParams.query)

  return <div>...</div>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/search/page.js" switcher
import { getSearchResults } from '@/lib/search'

export default async function SearchPage({ searchParams }) {
  const results = await getSearchResults(searchParams.query)

  return <div>...</div>
}
```

</TabItem>
</Tabs>

ユーザーのビューポートに `<Form>` が表示されると、共有UI（例: `/search` ページの `layout.js` と `loading.js`）が先読みされます。フォーム送信時に、新しいルートに即座にナビゲートし、結果がフェッチされる間、読み込みUIを表示します。フォールバックUIを[`loading.js`](/docs/app/api-reference/file-conventions/loading)を使ってデザインできます:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/search/loading.tsx" switcher
export default function Loading() {
  return <div>Loading...</div>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/search/loading.js" switcher
export default function Loading() {
  return <div>Loading...</div>
}
```

</TabItem>
</Tabs>

共有UIがまだロードされていない場合に備えて、[`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) を利用してユーザーに即時のフィードバックを表示できます。

まず、フォームが保留中のときにローディング状態を表示するコンポーネントを作成します:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/ui/search-button.tsx" switcher
'use client'
import { useFormStatus } from 'react-dom'

export default function SearchButton() {
  const status = useFormStatus()
  return (
    <button type="submit">{status.pending ? 'Searching...' : 'Search'}</button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/ui/search-button.js" switcher
'use client'
import { useFormStatus } from 'react-dom'

export default function SearchButton() {
  const status = useFormStatus()
  return (
    <button type="submit">{status.pending ? 'Searching...' : 'Search'}</button>
  )
}
```

</TabItem>
</Tabs>

次に、`SearchButton`コンポーネントを使用して検索フォームページを更新します:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/page.tsx" switcher
import Form from 'next/form'
import { SearchButton } from '@/ui/search-button'

export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <SearchButton />
    </Form>
  )
}
```

</TabItem>
</Tabs>
<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/ui/search-button.js" switcher
import Form from 'next/form'
import { SearchButton } from '@/ui/search-button'

export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <SearchButton />
    </Form>
  )
}
```

</TabItem>
</Tabs>

### サーバーアクションを使用したミューテーション {#mutations-with-server-actions}

`action`プロップに関数を渡すことでミューテーションを行うことができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/posts/create/page.tsx" switcher
import Form from 'next/form'
import { createPost } from '@/posts/actions'

export default function Page() {
  return (
    <Form action={createPost}>
      <input name="title" />
      {/* ... */}
      <button type="submit">Create Post</button>
    </Form>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/posts/create/page.js" switcher
import Form from 'next/form'
import { createPost } from '@/posts/actions'

export default function Page() {
  return (
    <Form action={createPost}>
      <input name="title" />
      {/* ... */}
      <button type="submit">Create Post</button>
    </Form>
  )
}
```

</TabItem>
</Tabs>

ミューテーション後に新しいリソースにリダイレクトするのが一般的です。`next/navigation` から[`redirect`](/docs/app/building-your-application/routing/redirecting)関数を使用して新しい投稿ページにナビゲートできます。

> **Good to know**: フォーム送信の"宛先"はアクションが実行されるまでわからないため、`<Form>`は自動的に共有UIを先読みすることはできません。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/posts/actions.ts" switcher
'use server'
import { redirect } from 'next/navigation'

export async function createPost(formData: FormData) {
  // 新しい投稿を作成
  // ...

  // 新しい投稿にリダイレクト
  redirect(`/posts/${data.id}`)
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/posts/actions.js" switcher
'use server'
import { redirect } from 'next/navigation'

export async function createPost(formData) {
  // 新しい投稿を作成
  // ...

  // 新しい投稿にリダイレクト
  redirect(`/posts/${data.id}`)
}
```

</TabItem>
</Tabs>

次に、新しいページで`params`プロップを使用してデータをフェッチできます:

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="/app/posts/[id]/page.tsx" switcher
import { getPost } from '@/posts/data'

export default async function PostPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const data = await getPost((await params).id)

  return (
    <div>
      <h1>{data.title}</h1>
      {/* ... */}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="/app/posts/[id]/page.js" switcher
import { getPost } from '@/posts/data'

export default async function PostPage({ params }) {
  const data = await getPost((await params).id)

  return (
    <div>
      <h1>{data.title}</h1>
      {/* ... */}
    </div>
  )
}
```

</TabItem>
</Tabs>

詳しくは[サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)ドキュメントをご覧ください。

</AppOnly>
