---
title: 'useRouter'
description: 'useRouter フックの API リファレンス。'
---

`useRouter` フックにより、[Client Components](/docs/app/building-your-application/rendering/client-components)内でプログラム的にルートを変更できます。

> **推奨事項：** ナビゲーションには `useRouter` を使用する特定の要件がない限り、[`<Link>` コンポーネント](/docs/app/building-your-application/routing/linking-and-navigating#link-component)を使用してください。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example-client-component.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example-client-component.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

</TabItem>
</Tabs>

## `useRouter()` {#userouter}

- `router.push(href: string, { scroll: boolean })`: 指定されたルートにクライアントサイドのナビゲーションを行います。ブラウザの[履歴](https://developer.mozilla.org/docs/Web/API/History_API)スタックに新しいエントリを追加します
- `router.replace(href: string, { scroll: boolean })`: 指定されたルートにクライアントサイドのナビゲーションを行いますが、ブラウザの[履歴スタック](https://developer.mozilla.org/docs/Web/API/History_API)に新しいエントリは追加しません
- `router.refresh()`: 現在のルートをリフレッシュします。サーバーへの新しいリクエスト、データリクエストの再取得、Server Components の再レンダリングを行います。クライアントは更新された React Server Component のペイロードを統合しますが、影響を受けないクライアントサイドの React（例：`useState`）やブラウザの状態（例：スクロール位置）は失われません
- `router.prefetch(href: string)`: クライアントサイドでの遷移をより高速化するために指定されたルートを[プリフェッチ](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)します
- `router.back()`: ブラウザの履歴スタックで前のルートに戻ります
- `router.forward()`: ブラウザの履歴スタックで次のページに進みます

> **Good to know**:
>
> - 信頼されていないまたは未サニタイズの URL を `router.push` もしくは `router.replace` に送信してはいけません。これにより、サイトがクロスサイトスクリプティング（XSS）の脆弱性にさらされる可能性があります。たとえば、`javascript:` の URL を `router.push` や `router.replace` に送信すると、その URL はページのコンテキストで実行されます
> - `<Link>` コンポーネントは、自動的にルートをプリフェッチし、ビューポート内で見えるようになるときにルートをプリフェッチします
> - `refresh()` は、フェッチリクエストがキャッシュされている場合、同じ結果を再現する可能性があります。他の動的な API（例：`cookies`、`headers`）もレスポンスを変更する可能性があります

### `next/router` からの移行 {#migrating-from-next-router}

- App Routerを使用する際には、`useRouter` フックは `next/navigation` からインポートする必要があり、`next/router` からではありません
- `pathname` 文字列は削除され、[`usePathname()`](/docs/app/api-reference/functions/use-pathname) に置き換えられました
- `query` オブジェクトは削除され、[`useSearchParams()`](/docs/app/api-reference/functions/use-search-params) に置き換えられました
- `router.events` は置き換えられました。[以下を参照。](#router-events)

[完全な移行ガイドを表示](/docs/app/building-your-application/upgrading/app-router-migration)。

## 例 {#examples}

### ルーターイベント {#router-events}

`usePathname` や `useSearchParams` のような他の Client Component フックを組み合わせることでページの変更を監視できます。

```jsx title="app/components/navigation-events.js"
'use client'

import { useEffect } from 'react'
import { usePathname, useSearchParams } from 'next/navigation'

export function NavigationEvents() {
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    const url = `${pathname}?${searchParams}`
    console.log(url)
    // 現在のURLを使用できます
    // ...
  }, [pathname, searchParams])

  return '...'
}
```

これを layout にインポートできます。

```jsx title="app/layout.js" highlight={2,10-12}
import { Suspense } from 'react'
import { NavigationEvents } from './components/navigation-events'

export default function Layout({ children }) {
  return (
    <html lang="en">
      <body>
        {children}

        <Suspense fallback={null}>
          <NavigationEvents />
        </Suspense>
      </body>
    </html>
  )
}
```

> **Good to know**: `<NavigationEvents>` は[`Suspense` boundary](/docs/app/building-your-application/routing/loading-ui-and-streaming#example)でラップされています。[`useSearchParams()`](/docs/app/api-reference/functions/use-search-params) は[静的レンダリング](/docs/app/building-your-application/rendering/server-components#static-rendering-default)中に最も近い `Suspense` boundary までクライアントサイドのレンダリングを引き起こすためです。[詳細はこちら](/docs/app/api-reference/functions/use-search-params#behavior)を参照してください。

### スクロールの無効化 {#disabling-scroll-to-top}

デフォルトでは、Next.js は新しいルートにナビゲートする際にページのトップにスクロールします。この動作を無効にするには、`router.push()` または `router.replace()` に `scroll: false` を渡します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/example-client-component.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button
      type="button"
      onClick={() => router.push('/dashboard', { scroll: false })}
    >
      Dashboard
    </button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/example-client-component.jsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button
      type="button"
      onClick={() => router.push('/dashboard', { scroll: false })}
    >
      Dashboard
    </button>
  )
}
```

</TabItem>
</Tabs>

## バージョン履歴 {#version-history}

| バージョン | 変更点                                             |
| ---------- | -------------------------------------------------- |
| `v13.0.0`  | `next/navigation`から `useRouter` が導入されました |
