---
title: 'TypeScript'
description: 'Next.jsはReactアプリケーションを構築するためのTypeScriptファーストの開発体験を提供します。'
---

{/* このドキュメントの内容はapp routerとpages routerで共有されています。Pages Routerに特化した内容を追加するには`<PagesOnly>Content</PagesOnly>`コンポーネントを使用してください。共有コンテンツはコンポーネントで囲むべきではありません。 */}

Next.jsは標準でTypeScriptを搭載しています。`create-next-app`で新しいプロジェクトを作成するときに、必要なパッケージが自動的にインストールされて、適切な設定が構成されます。

既存のプロジェクトにTypeScriptを追加するには、ファイルを`.ts`または`.tsx`にリネームしてください。`next dev`および`next build`を実行すると、必要な依存関係が自動的にインストールされ、推奨される構成オプションを含む`tsconfig.json`ファイルが追加されます。

> **Good to know**: すでに`jsconfig.json`ファイルをお持ちの場合は、古い`jsconfig.json`から`paths`コンパイラオプションを新しい`tsconfig.json`ファイルにコピーし、古い`jsconfig.json`ファイルを削除してください。

<AppOnly>

## IDEプラグイン {#ide-plugin}

Next.jsにはカスタムTypeScriptプラグインと型チェッカーが含まれており、VSCodeや他のコードエディタで使われるときに、先進的な型チェックと自動補完を提供します。

VS Codeでプラグインを有効にするには以下の手順を行ってください：

1. コマンドパレットを開く（`Ctrl/⌘` + `Shift` + `P`）
2. 「TypeScript: Select TypeScript Version」を検索
3. 「Use Workspace Version」を選択

<Image
  alt="TypeScriptコマンドパレット"
  srcLight="/docs/light/typescript-command-palette.png"
  srcDark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

ファイルを編集するときには、カスタムプラグインが有効になります。`next build`を実行するときには、カスタム型チェッカーが使用されます。

TypeScriptプラグインは次のことに役立ちます：

- [segment config options](/docs/app/api-reference/file-conventions/route-segment-config)に無効な値が渡された場合の警告を表示
- 利用可能なオプションとコンテキスト内のドキュメントを表示
- `use client`ディレクティブが正しく使用されていることを確認
- Client Componentsでのみ利用されるクライアントフック（`useState`など）が正しく使われていることを確認

> **🎥 視聴:** ビルトインTypeScriptプラグインについて学ぶ→ [YouTube (3分)](https://www.youtube.com/watch?v=pqMqn9fKEf8)

## エンドツーエンドの型安全性 {#end-to-end-type-safety}

Next.jsのapp routerには**強化された型の安全性**があります。これには以下が含まれます：

1. **取得関数とページ間のデータのシリアライズ化なし**：コンポーネント、レイアウト、およびサーバー上のページで直接`fetch`を行うことができます。このデータは、クライアントサイドでのReactの消費に渡すためにシリアライズ（文字列への変換）する必要はありません。代わりに、`app`はデフォルトでServer Componentsを使用するため、`Date`、`Map`、`Set`などの値を追加の手順なしで使用できます。これまで、サーバーとクライアント間の境界を手動でタイプ指定する必要がありました。
2. **コンポーネント間のデータフローの効率化**：`_app`の除去とroot レイアウトの採用により、コンポーネントとページ間のデータフローを視覚化することが容易になりました。以前は、個々の`pages`と`_app`の間でのデータフローはタイプ指定が難しく、不明瞭なバグを引き起こす可能性がありました。App Routerでの[コロケートされたデータ取得](/docs/app/building-your-application/data-fetching/fetching)により、これはもはや問題ではありません。

[Next.jsのデータ取得](/docs/app/building-your-application/data-fetching/fetching)は、データベースやコンテンツプロバイダーの選択について具体的に指定することなく、可能な限りエンドツーエンドの型安全性を提供します。

通常のTypeScriptで予想されるようにレスポンスデータをタイプ指定できます。たとえば：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // 戻り値はシリアライズされません
  // 日付、マップ、セットなどを返すことができます
  return res.json()
}

export default async function Page() {
  const name = await getData()

  return '...'
}
```

</TabItem>
</Tabs>

完全なエンドツーエンドの型安全性を実現するには、これに加えてデータベースまたはコンテンツプロバイダーがTypeScriptに対応している必要があります。これには、[ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)や型安全なクエリビルダーを使用する方法があります。

</AppOnly>

## 例 {#examples}

### `next.config.ts`の型チェック {#type-checking-next-config-ts}

Next.jsの設定にTypeScriptを使用し、型をインポートすることが`next.config.ts`を使用することで可能です。

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  /* 設定オプションはここに */
}

export default nextConfig
```

> **Good to know**: 現在、`next.config.ts`のモジュール解決は`CommonJS`に限定されています。これにより、`next.config.ts`で読み込まれるESM専用パッケージとの互換性の問題が発生する可能性があります。

`next.config.js`ファイルを使用する場合、以下のようにJSDocを用いてIDEで型チェックを追加することができます：

```js title="next.config.js"
// @ts-check

/** @type {import('next').NextConfig} */
const nextConfig = {
  /* 設定オプションはここに */
}

module.exports = nextConfig
```

<AppOnly>

### 静的に型付けされたリンク {#statically-typed-links}

`next/link`を使用するときにスペルミスやその他のエラーを防ぎ、ページ間のナビゲーションでの型安全性を向上させるために、Next.jsはリンクを静的に型付けできます。

この機能を有効にするには、`experimental.typedRoutes`を有効にし、プロジェクトがTypeScriptを使用している必要があります。

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    typedRoutes: true,
  },
}

export default nextConfig
```

Next.jsはアプリケーション内のすべての既存ルートに関する情報を含むリンク定義を`.next/types`に生成します。これにより、TypeScriptは無効なリンクに関するフィードバックをエディタで提供できます。

現在、実験的サポートは動的セグメントを含む任意の文字列リテラルに対応しています。非リテラル文字列には、現在`href`を`as Route`で手動でキャストする必要があります：

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// ルートが有効である場合、TypeScriptエラーはありません
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// ルートが無効である場合、TypeScriptはエラーを表示します
<Link href="/aboot" />
```

`next/link`をラップするカスタムコンポーネントで`href`を受け入れるために、ジェネリックを使用します：

```tsx
import type { Route } from 'next'
import Link from 'next/link'

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  )
}
```

> **どう機能するのか？**
>
> `next dev`または`next build`を実行すると、Next.jsはアプリケーション内のすべての既存ルートに関する情報を含む非表示の`.d.ts`ファイルを`.next`内に生成します（`Link`の`href`型として有効なすべてのルート）。この`.d.ts`ファイルは`tsconfig.json`に含まれており、TypeScriptコンパイラはその`.d.ts`をチェックし、無効なリンクに関するフィードバックをエディタに提供します。

## 非同期サーバーコンポーネントとともに {#with-async-server-componens}

TypeScriptで`async` Server Componentを使用するには、TypeScript `5.1.3`以上および`@types/react` `18.2.8`以上を使用していることを確認してください。

古いバージョンのTypeScriptを使用している場合、`'Promise<Element>' is not a valid JSX element`型エラーが表示されることがあります。TypeScriptと`@types/react`の最新バージョンにアップデートすることでこの問題を解決できます。

</AppOnly>

<PagesOnly>

## 静的生成とサーバーサイドレンダリング {#static-generation-and-server-side-rendering}

[`getStaticProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-props)、[`getStaticPaths`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-static-paths)、そして[`getServerSideProps`](https://nextjs.org/docs/canary/pages/api-reference/functions/get-server-side-props)には、それぞれ`GetStaticProps`、`GetStaticPaths`、`GetServerSideProps`の型を使用できます：

```tsx title="pages/blog/[slug].tsx"
import type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'

export const getStaticProps = (async (context) => {
  // ...
}) satisfies GetStaticProps

export const getStaticPaths = (async () => {
  // ...
}) satisfies GetStaticPaths

export const getServerSideProps = (async (context) => {
  // ...
}) satisfies GetServerSideProps
```

> **Good to know:** `satisfies`はTypeScriptの[4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html)で追加されました。TypeScriptの最新バージョンへのアップグレードをお勧めします。

## APIルートとともに {#with-api-routes}

以下の例は、APIルートに組み込みの型をどのように使用するかを示しています：

```ts title="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: 'John Doe' })
}
```

レスポンスデータを型付けることも可能です：

```ts title="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}
```

## カスタム`App`とともに {#with-custom-app}

[カスタム`App`](https://nextjs.org/docs/canary/pages/building-your-application/routing/custom-app)をお持ちの場合、ビルトインの型`AppProps`を使用してファイル名を`./pages/_app.tsx`に変更できます：

```ts
import type { AppProps } from 'next/app'

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
```

</PagesOnly>

## 増分型チェック {#incremental-type-checking}

`v10.2.1`以降、Next.jsは`tsconfig.json`で有効にされている場合に[増分型チェック](https://www.typescriptlang.org/tsconfig#incremental)をサポートしており、大規模なアプリケーションでの型チェックの速度を向上させることができます。

## 本番環境でのTypeScriptエラーの無効化 {#disabling-typescript-errors-in-production}

Next.jsはプロジェクト内にTypeScriptエラーが存在する場合、**本番ビルド**（`next build`）を失敗させます。

アプリケーションにエラーがある場合においても、Next.jsで本番コードを危険を冒して生成したい場合は、組み込みの型チェックステップを無効にすることができます。

無効にする場合は、型チェックをビルドまたは展開プロセスの一部として実行していることを確認しなければ非常に危険です。

`next.config.ts`を開き、`typescript`設定に`ignoreBuildErrors`オプションを有効にします：

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  typescript: {
    // !! 警告 !!
    // プロジェクトに型エラーがある場合でも
    // 本番ビルドを成功させることを危険を冒して許可します。
    // !! 警告 !!
    ignoreBuildErrors: true,
  },
}

export default nextConfig
```

> **Good to know**: `tsc --noEmit`を実行して、ビルド前に自分自身でTypeScriptエラーをチェックすることができます。これは、デプロイ前にTypeScriptエラーをチェックしたいCI/CDパイプラインにとって便利です。

## カスタム型宣言 {#custom-type-declarations}

カスタム型を宣言する必要がある場合、`next-env.d.ts`を変更したくなるかもしれません。しかし、このファイルは自動的に生成されるため、変更した内容は上書きされます。代わりに、新しいファイル`new-types.d.ts`を作成し、`tsconfig.json`で参照するべきです：

```json title="tsconfig.json"
{
  "compilerOptions": {
    "skipLibCheck": true
    //...省略...
  },
  "include": [
    "new-types.d.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
```

## バージョンの変更 {#version-changes}

| バージョン | 変更点                                                                                                                                         |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `v15.0.0`  | TypeScriptプロジェクトのために[`next.config.ts`](#type-checking-nextconfigts)のサポートが追加されました。                                      |
| `v13.2.0`  | 静的型付けされたリンクがベータで利用可能です。                                                                                                 |
| `v12.0.0`  | [SWC](/docs/architecture/nextjs-compiler)が今後はデフォルトで使用され、TypeScriptおよびTSXのビルドを高速化するためにコンパイルします。         |
| `v10.2.1`  | 増分型チェックのサポートが追加されました。[増分型チェック](https://www.typescriptlang.org/tsconfig#incremental)が`tsconfig.json`で有効な場合。 |
