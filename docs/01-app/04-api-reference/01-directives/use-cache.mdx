---
title: 'use cache'
description: 'Next.js アプリケーションで use cache ディレクティブを使用してデータをキャッシュする方法を学びます'
version: 'canary'
related:
  title: 'Related'
  description: '関連する API リファレンスを表示します'
  links:
    - app/api-reference/config/next-config-js/dynamicIO
    - app/api-reference/config/next-config-js/cacheLife
    - app/api-reference/functions/cacheTag
    - app/api-reference/functions/cacheLife
    - app/api-reference/functions/revalidateTag
---

`use cache` ディレクティブは、コンポーネントや関数をキャッシュするために指定します。ファイルの先頭で使用すると、ファイル内のすべてのエクスポートがキャッシュ可能であることを示すことができます。また、関数やコンポーネントの先頭にインラインで使用すると、Next.js に対して返り値をキャッシュし、後続のリクエストで再利用することを通知できます。これは Next.js の実験的な機能であり、`use client`や`use server`のようなネイティブな React の機能ではありません。

## 使用法 {#usage}

`next.config.ts` ファイル内で `dynamicIO` フラグを使用することで、`use cache` ディレクティブのサポートを有効にします：

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    dynamicIO: true,
  },
}

export default nextConfig
```

次に、`use cache` ディレクティブをファイル、コンポーネント、または関数レベルで使用できます：

```tsx
// ファイルレベル
'use cache'

export default async function Page() {
  // ...
}

// コンポーネントレベル
export async function MyComponent() {
  'use cache'
  return <></>
}

// 関数レベル
export async function getData() {
  'use cache'
  const data = await fetch('/api/data')
  return data
}
```

## Good to know {#good-to-know}

- `use cache` は Next.js の実験的な機能で、`use client`や`use server`のようなネイティブな React の機能ではありません
- キャッシュされた関数に渡される [serializable](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values) な引数（または props）と、親スコープから読み取る一部のシリアライズ可能な値は、JSON 形式のようなフォーマットに変換され、自動的にキャッシュキーの一部となります
- 非シリアライズ可能な引数、プロップス、またはクローズオーバーされた値は、キャッシュされた関数内で不透明な参照に変換され、渡されるだけで、調査も修正も行うことはできません。これらの非シリアライズ可能な値はリクエスト時に補完され、キャッシュキーの一部にはなりません
  - たとえば、キャッシュされた関数は `children` prop として JSX を受け取り、`<div>{children}</div>` を返すことができますが、実際の `children` オブジェクトを introspect することはできません
- キャッシュ可能な関数の戻り値もシリアライズ可能でなければなりません。これにより、キャッシュされたデータが正しく保存および取得されることが保証されます
- `use cache` ディレクティブを使用する関数は、副作用を持たないようにする必要があります。たとえば、状態を変更したり、DOM を直接操作したり、コードを定期的に実行するためにタイマーを設定したりしてはいけません
- [Partial Prerendering](/docs/app/building-your-application/rendering/partial-prerendering) と一緒に使用される場合、`use cache` を持つセグメントは静的 HTML シェルの一部として事前レンダリングされます
- `use cache` ディレクティブは、将来的には `dynamicIO` フラグとは別に利用可能になります
- `unstable_cache` は JSON データのみをサポートするのに対し、`use cache` は、コンポーネントのレンダー出力を含む、React がレンダリングできる任意のシリアライズ可能なデータをキャッシュできます

## 例 {#examples}

### `use cache` によるルート全体のキャッシュ {#caching-entire-routes-with-use-cache}

ルート全体を事前レンダリングするには、`layout` と `page` ファイルの両方の先頭に `use cache` を追加します。これらの各セグメントは、アプリケーションの個別のエントリーポイントとして扱われ、それぞれ独立してキャッシュされます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
'use cache'
import { unstable_cacheLife as cacheLife } from 'next/cache'

export default function Layout({ children }: { children: ReactNode }) {
  return <div>{children}</div>
}
```

</TabItem>
</Tabs>
<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.tsx" switcher
'use cache'
import { unstable_cacheLife as cacheLife } from 'next/cache'

export default function Layout({ children }) {
  return <div>{children}</div>
}
```

</TabItem>
</Tabs>

`page` ファイルにインポートされ、ネストされたコンポーネントは、`page` のキャッシュ動作を継承します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use cache'
import { unstable_cacheLife as cacheLife } from 'next/cache'

async function Users() {
  const users = await fetch('/api/users')
  // ユーザーをループします
}

export default function Page() {
  return (
    <main>
      <Users />
    </main>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
'use cache'
import { unstable_cacheLife as cacheLife } from 'next/cache'

async function Users() {
  const users = await fetch('/api/users')
  // ユーザーをループします
}

export default function Page() {
  return (
    <main>
      <Users />
    </main>
  )
}
```

</TabItem>
</Tabs>

> これは、以前に [`export const dynamic = "force-static"`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic) オプションを使用していたアプリケーションに推奨され、ルート全体が事前レンダリングされることを保証します。

### `use cache` を使用したコンポーネント出力のキャッシュ {#caching-component-output-with-use-cache}

コンポーネントレベルで `use cache` を使用して、そのコンポーネント内で行われるフェッチや計算をキャッシュすることができます。アプリケーション全体でコンポーネントを再利用すると、props が同じ構造を維持する限り、同じキャッシュエントリを共有できます。

この props はシリアライズされ、キャッシュキーの一部を形成し、シリアライズされた props が各インスタンスで同じ値を生成する限り、キャッシュエントリは再利用されます。

```tsx title="app/components/bookings.tsx" highlight={2}
export async function Bookings({ type = 'haircut' }: BookingsProps) {
  'use cache'
  async function getBookingsData() {
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    return data
  }
  return //...
}

interface BookingsProps {
  type: string
}
```

```jsx title="app/components/bookings.js" highlight={2}
export async function Bookings({ type = 'haircut' }) {
  'use cache'
  async function getBookingsData() {
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    return data
  }
  return //...
}
```

### `use cache` を使用した関数出力のキャッシュ {#caching-function-output-with-use-cache}

`use cache` を任意の非同期関数に追加できるので、コンポーネントやルートのみをキャッシュすることには限定されません。ネットワークリクエストやデータベースクエリをキャッシュしたり、非常に遅い計算を行ったりすることがあります。この種の作業を含む関数に `use cache` を追加することで、その関数がキャッシュ可能になり、再利用時には同じキャッシュエントリを共有します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/actions.ts" highlight={2} switcher
export async function getData() {
  'use cache'

  const data = await fetch('/api/data')
  return data
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/actions.js" highlight={2} switcher
export async function getData() {
  'use cache'

  const data = await fetch('/api/data')
  return data
}
```

</TabItem>
</Tabs>

### 再検証 {#revalidating}

デフォルトでは、Next.js は `use cache` ディレクティブを使用する場合、**[再検証期間](/docs/app/building-your-application/data-fetching/fetching#revalidating-cached-data) を 15 分** に設定します。Next.js はほぼ無限の有効期限を設定しており、頻繁な更新が必要ないコンテンツに適しています。

この再検証期間が役立つ場合もありますが、`cacheLife` と `cacheTag` API を使用してキャッシュの動作を構成できます：

- [`cacheLife`](/docs/app/api-reference/functions/cacheLife)：時間ベースの再検証期間を設定するため
- [`cacheTag`](/docs/app/api-reference/functions/cacheTag)：オンデマンドでの再検証用

これらの API はクライアントとサーバーのキャッシングレイヤー全体で統合されているため、一か所でキャッシュセマンティクスを構成し、それをすべての場所に適用することができます。

詳細については、[`cacheLife`](/docs/app/api-reference/functions/cacheLife) および [`cacheTag`](/docs/app/api-reference/functions/cacheTag) のドキュメントを参照してください。

### インターリーブ {#interleaving}

キャッシュ可能な関数に非シリアライズ可能な引数を渡す必要がある場合、`children` として渡すことができます。これにより、`children` 参照はキャッシュエントリに影響を与えることなく変更できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
export default async function Page() {
  const uncachedData = await getData()
  return (
    <CacheComponent>
      <DynamicComponent data={uncachedData} />
    </CacheComponent>
  )
}

async function CacheComponent({ children }: { children: ReactNode }) {
  'use cache'
  const cachedData = await fetch('/api/cached-data')
  return (
    <div>
      <PrerenderedComponent data={cachedData} />
      {children}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
export default async function Page() {
  const uncachedData = await getData()
  return (
    <CacheComponent>
      <DynamicComponent data={uncachedData} />
    </CacheComponent>
  )
}

async function CacheComponent({ children }) {
  'use cache'
  const cachedData = await fetch('/api/cached-data')
  return (
    <div>
      <PrerenderedComponent data={cachedData} />
      {children}
    </div>
  )
}
```

</TabItem>
</Tabs>

キャッシュされたコンポーネントを通じてサーバーアクションをクライアントコンポーネントに渡し、キャッシュ可能な関数内でそれらを呼び出すことなく渡すこともできます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import ClientComponent from './ClientComponent'

export default async function Page() {
  const performUpdate = async () => {
    'use server'
    // サーバーサイドの更新を実行します
    await db.update(...)
  }

  return <CacheComponent performUpdate={performUpdate} />
}

async function CachedComponent({
  performUpdate,
}: {
  performUpdate: () => Promise<void>
}) {
  'use cache'
  // performUpdate をここで呼び出してはいけません
  return <ClientComponent action={performUpdate} />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import ClientComponent from './ClientComponent'

export default async function Page() {
  const performUpdate = async () => {
    'use server'
    // サーバーサイドの更新を実行します
    await db.update(...)
  }

  return <CacheComponent performUpdate={performUpdate} />
}

async function CachedComponent({ performUpdate }) {
  'use cache'
  // performUpdate をここで呼び出してはいけません
  return <ClientComponent action={performUpdate} />
}
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ClientComponent.tsx" switcher
'use client'

export default function ClientComponent({ action }) {
  return <button onClick={action}>Update</button>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ClientComponent.js" switcher
'use client'

export default function ClientComponent({ action }) {
  return <button onClick={action}>Update</button>
}
```

</TabItem>
</Tabs>
