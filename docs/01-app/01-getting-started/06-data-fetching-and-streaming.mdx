---
title: 'データをフェッチしてストリームする方法'
nav_title: 'データのフェッチとストリーミング'
description: 'アプリケーションでデータ取得とコンテンツストリーミングを開始します。'
related:
  title: 'APIリファレンス'
  description: 'このページで紹介されている機能について、APIリファレンスを読んでさらに詳しく学びましょう。'
  links:
    - 'app/api-reference/functions/fetch'
    - 'app/api-reference/file-conventions/loading'
---

このページでは、[server component](#server-components)および[client component](#client-components)でのデータフェッチ方法を解説します。また、データに依存するコンテンツをどのように[ストリーム](#streaming)するかについても説明します。

## データのフェッチ {#fetching-data}

### Server Components {#server-components}

Server Componentsでデータをフェッチするには次の方法があります：

1. [`fetch` API](#with-the-fetch-api)を使用する
2. [ORMやデータベース](#with-an-orm-or-database)を使用する

#### `fetch` APIを使用する場合 {#with-the-fetch-api}

`fetch` APIを使用してデータをフェッチするには、コンポーネントを非同期関数に変え、`fetch`呼び出しをawaitします。例えば：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

#### ORMやデータベースを使用する場合 {#with-an-orm-or-database}

ORMやデータベースを使用してデータを取得するには、コンポーネントを非同期関数に変えて、その呼び出しをawaitします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
import { db, posts } from '@/lib/db'

export default async function Page() {
  const allPosts = await db.select().from(posts)
  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
import { db, posts } from '@/lib/db'

export default async function Page() {
  const allPosts = await db.select().from(posts)
  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

### Client Components {#client-components}

Client Componentsでデータをフェッチする方法は2つあります：

1. Reactの[`use`フック](https://react.dev/reference/react/use)を使用する
2. [SWR](https://swr.vercel.app/)や[React Query](https://tanstack.com/query/latest)のようなコミュニティライブラリを使用する

#### `use` フックを使用する場合 {#with-the-use-hook}

Reactの[`use`フック](https://react.dev/reference/react/use)を使用して、サーバーからクライアントにデータを[ストリーム](#streaming)できます。まず、Server Componentsでデータをフェッチし、そのプロミスをClient Componentsにプロップとして渡します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
import Posts from '@/app/ui/posts
import { Suspense } from 'react'

export default function Page() {
  // データ取得関数をawaitしないでください
  const posts = getPosts()

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Posts posts={posts} />
    </Suspense>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
import Posts from '@/app/ui/posts
import { Suspense } from 'react'

export default function Page() {
  // データ取得関数をawaitしないでください
  const posts = getPosts()

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Posts posts={posts} />
    </Suspense>
  )
}
```

</TabItem>
</Tabs>

次に、Client Componentsで`use`フックを使用してプロミスを読み込みます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/posts.tsx" switcher
'use client'
import { use } from 'react'

export default function Posts({ posts }) {
  const posts = use(posts)

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/posts.js" switcher
'use client'
import { use } from 'react'

export default function Posts({ posts }) {
  const posts = use(posts)

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

上記の例では、`<Posts />`コンポーネントを[`<Suspense>`境界](https://react.dev/reference/react/Suspense)でラップする必要があります。これは、プロミスが解決されるまでフォールバックが表示されることを意味します。[ストリーミング](#streaming)についてさらに学びましょう。

#### コミュニティライブラリ {#community-libraries}

[SWR](https://swr.vercel.app/)や[React Query](https://tanstack.com/query/latest)のようなコミュニティライブラリを使用して、Client Components内でデータを取得できます。これらのライブラリは、キャッシュ、ストリーミング、およびその他の機能について独自のセマンティクスを持っています。例えば、SWRを使用した場合：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
'use client'
import useSWR from 'swr'

const fetcher = (url) => fetch(url).then((r) => r.json())

export default function BlogPage() {
  const { data, error, isLoading } = useSWR(
    'https://api.vercel.app/blog',
    fetcher
  )

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <ul>
      {data.map((post: { id: string; title: string }) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
'use client'
import useSWR from 'swr'

const fetcher = (url) => fetch(url).then((r) => r.json())

export default function BlogPage() {
  const { data, error, isLoading } = useSWR(
    'https://api.vercel.app/blog',
    fetcher
  )

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

</TabItem>
</Tabs>

## ストリーミング {#streaming}

> **警告：** サーバーコンポーネントで`async/await`を使用する際には、アプリケーションの[`dynamicIO`設定オプション](/docs/app/api-reference/config/next-config-js/dynamicIO)が有効になっていることが前提です。このフラグはNext.js 15のcanaryで導入されました。

Server Componentsで`async/await`を使用すると、Next.jsは**動的レンダリング**に切り替わります。これは、データがユーザーのリクエストごとにサーバーでフェッチされ、レンダリングされることを意味します。遅いデータリクエストがある場合、ルート全体がレンダリングをブロックされます。

初期ロード時間とユーザー体験を改善するために、ストリーミングを使用してページのHTMLを小さなチャンクに分割し、そのチャンクをサーバーからクライアントへ徐々に送信できます。

<Image
  alt="ストリーミングを使用したサーバーレンダリングの動作"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

アプリケーションでストリーミングを実装する方法は2つあります：

1. [`loading.js`ファイル](#with-loading-js)を使用する
2. Reactの[`<Suspense>`コンポーネント](#with-suspense)を使用する

### `loading.js`を使用する {#with-loading-js}

ページと同じフォルダーに`loading.js`ファイルを作成して、データ取得中に**ページ全体**をストリームします。例えば、`app/blog/page.js`をストリームするには、`app/blog`フォルダー内にファイルを追加します。

<Image
  alt="loading.jsファイルを含むブログフォルダ構造"
  srcLight="/docs/light/loading-file.png"
  srcDark="/docs/dark/loading-file.png"
  width="1600"
  height="525"
/>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/loading.tsx" switcher
export default function Loading() {
  // ここで読み込みUIを定義します
  return <div>Loading...</div>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/loading.js" switcher
export default function Loading() {
  // ここで読み込みUIを定義します
  return <div>Loading...</div>
}
```

</TabItem>
</Tabs>

ナビゲーション時に、ページがレンダリングされるまでユーザーにはすぐにレイアウトと[読み込み状態](#creating-meaningful-loading-states)が表示されます。新しいコンテンツはレンダリング完了後に自動的にスワップされます。

<Image
  alt="ロード中のUI"
  srcLight="/docs/light/loading-ui.png"
  srcDark="/docs/dark/loading-ui.png"
  width="1600"
  height="691"
/>

舞台裏では、`loading.js`は`layout.js`内にネストされ、`page.js`ファイルとその下の子を自動的に`<Suspense>`境界でラップします。

<Image
  alt="loading.jsの概要"
  srcLight="/docs/light/loading-overview.png"
  srcDark="/docs/dark/loading-overview.png"
  width="1600"
  height="768"
/>

このアプローチはルートセグメント（レイアウトとページ）に対してうまく機能しますが、より細かいストリーミングには`<Suspense>`を使用できます。

### `<Suspense>`を使用する {#with-suspense}

`<Suspense>`を使用すると、ページのどの部分をストリームするかをより細かく制御できます。例えば、`<Suspense>`境界外のページコンテンツを即座に表示し、境界内のブログ投稿リストをストリームすることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
import { Suspense } from 'react'
import BlogList from '@/components/BlogList'
import BlogListSkeleton from '@/components/BlogListSkeleton'

export default function BlogPage() {
  return (
    <div>
      {/* このコンテンツは即座にクライアントに送信されます */}
      <header>
        <h1>ブログへようこそ</h1>
        <p>最新の投稿を以下でお読みください。</p>
      </header>
      <main>
        {/* <Suspense>境界でラップされたコンテンツはストリームされます */}
        <Suspense fallback={<BlogListSkeleton />}>
          <BlogList />
        </Suspense>
      </main>
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
import { Suspense } from 'react'
import BlogList from '@/components/BlogList'
import BlogListSkeleton from '@/components/BlogListSkeleton'

export default function BlogPage() {
  return (
    <div>
      {/* このコンテンツは即座にクライアントに送信されます */}
      <header>
        <h1>ブログへようこそ</h1>
        <p>最新の投稿を以下でお読みください。</p>
      </header>
      <main>
        {/* <Suspense>境界でラップされたコンテンツはストリームされます */}
        <Suspense fallback={<BlogListSkeleton />}>
          <BlogList />
        </Suspense>
      </main>
    </div>
  )
}
```

</TabItem>
</Tabs>

### 意味のある読み込み状態を作成する {#creating-meaningful-loading-states}

インスタントロード状態は、ナビゲーション後にユーザーに即座に表示されるフォールバックUIです。最高のユーザー体験のために、意味があり、アプリが応答しているとユーザーに理解させるような読み込み状態を設計することをお勧めします。例えば、スケルトンやスピナー、または将来の画面のカバーフォトやタイトルなどの小さいが意味のある部分を使用できます。

開発中は、[React Devtools](https://react.dev/learn/react-developer-tools)を使用してコンポーネントの読み込み状態をプレビューおよびインスペクトすることができます。
