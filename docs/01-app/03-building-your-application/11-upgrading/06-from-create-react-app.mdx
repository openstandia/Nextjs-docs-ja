---
title: 'Create React App からの移行'
description: '既存の React アプリケーションを Create React App から Next.js に移行する方法を学びましょう。'
---

このガイドは、既存の Create React App サイトを Next.js に移行する手助けをします。

## なぜ移行するのか？ {#why-switch}

Create React App から Next.js に切り替えたいと考える理由はいくつかあります：

### ページ初期読み込み時間の遅さ {#slow-initial-page-loading-time}

Create React App は純粋にクライアントサイドの React を使用しています。クライアントサイドのみのアプリケーション、別名シングルページアプリケーション（SPA）は、しばしば遅い初期ページ読み込み時間を経験します。これにはいくつかの理由があります：

1. ブラウザは React コードとアプリケーション全体のバンドルがダウンロードされて実行されるのを待つ必要があり、その後にコードがデータをロードするリクエストを送信できるようになります。
2. アプリケーションコードは、新しい機能や依存関係を追加するたびに増加します。

### 自動コード分割がない {#no-automatic-code-splitting}

遅い読み込み時間の問題はコード分割である程度管理できます。しかし、手動でコード分割を試みると、多くの場合パフォーマンスが悪化します。手動でコード分割する際に、ネットワークのウォーターフォールを誤って導入することは容易です。Next.js には、ルーターに自動コード分割が組み込まれています。

### ネットワークウォーターフォール {#network-waterfalls}

パフォーマンスが悪い一般的な原因は、アプリケーションがデータを取得するためにクライアント-サーバー間で逐次リクエストを行う場合です。SPA での一般的なデータ取得パターンは、最初にプレースホルダーをレンダリングし、コンポーネントのマウント後にデータを取得することです。残念ながら、これはデータを取得する子コンポーネントが親コンポーネントが自身のデータを読み込むまでデータ取得を開始できないことを意味します。

Next.js ではクライアントでのデータ取得もサポートされていますが、データ取得をサーバーに移すオプションもあり、クライアント-サーバーのウォーターフォールを排除できます。

### 高速で意図的なロード状態 {#fast-and-intentional-loading-states}

[React Suspense を使用したストリーミング](/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense)をサポートしているため、UI のどの部分を最初に読み込むかを意図的に選択し、ネットワークのウォーターフォールを導入せずに順番を決めることができます。

これにより、読み込みが速くレイアウトシフトのないページを構築できます。

### データ取得戦略の選択 {#choose-the-data-fetching-strategy}

必要に応じて、Next.js ではページやコンポーネント単位でデータ取得戦略を選ぶことができます。ビルド時に、サーバー上のリクエスト時に、あるいはクライアント上で取得するかを決められます。例えば、CMS からデータを取得してビルド時にブログ投稿をレンダリングし、その後 CDN で効率的にキャッシュできます。

### ミドルウェア {#middleware}

[Next.js ミドルウェア](/docs/app/building-your-application/routing/middleware)は、リクエストが完了する前にサーバーでコードを実行することを可能にします。特に、ユーザーが認証済みのみのページを訪れる際に未認証のコンテンツが一瞬表示されるのを避けるために、ログインページにリダイレクトすることで役立ちます。ミドルウェアは実験や[国際化](/docs/app/building-your-application/routing/internationalization)にも役立ちます。

### 組み込みの最適化 {#built-in-optimizations}

[画像](/docs/app/building-your-application/optimizing/images)、[フォント](/docs/app/building-your-application/optimizing/fonts)、および[サードパーティスクリプト](/docs/app/building-your-application/optimizing/scripts)は、アプリケーションのパフォーマンスに大きく影響します。Next.js には、それらを自動的に最適化する組み込みコンポーネントが用意されています。

## 移行ステップ {#migration-steps}

この移行の目標は、Next.js アプリケーションをできるだけ早く動作させ、その後に Next.js の機能を適用していくことです。まずは既存のルーターを移行せずに、純粋にクライアントサイドアプリケーション（SPA）として維持します。これにより、移行プロセス中に発生する可能性のある問題を減らし、マージの競合を低減します。

### ステップ 1: Next.js 依存関係のインストール {#step-1-install-the-next-js-dependency}

最初に `next` を依存関係としてインストールする必要があります：

```bash title="Terminal"
npm install next@latest
```

### ステップ 2: Next.js 設定ファイルの作成 {#step-2-create-the-next-js-configuration-file}

プロジェクトの root に `next.config.mjs` を作成します。このファイルには [Next.js の設定オプション](/docs/app/api-reference/config/next-config-js)が格納されます。

```js title="next.config.mjs"
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export', // シングルページアプリケーション (SPA) を出力します。
  distDir: './build', // ビルド出力ディレクトリを `./dist` に変更します。
}

export default nextConfig
```

### ステップ 3: root レイアウトの作成 {#step-3-create-the-root-layout}

Next.js の [App Router](/docs/app) アプリケーションには、[root レイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required) ファイルが含まれていなければなりません。これはアプリケーション内のすべてのページをラップする [React Server Component](/docs/app/building-your-application/rendering/server-components) です。このファイルは `app` ディレクトリの最上位に定義されます。

CRA アプリケーションでの root レイアウトファイルに最も近いのは、`<html>`、`<head>`、および `<body>` タグが含まれる `index.html` ファイルです。

このステップでは、`index.html` ファイルを root レイアウトファイルに変換します：

1. `src` ディレクトリ内に新しい `app` ディレクトリを作成します。
2. その `app` ディレクトリ内に新しい `layout.tsx` ファイルを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({ children }) {
  return '...'
}
```

</TabItem>
</Tabs>

> **Good to know**: `.js`、`.jsx`、または `.tsx` 拡張子を Layout ファイルで使用できます。

`index.html` ファイルの内容を作成した `<RootLayout>` コンポーネントにコピーし、`body.div#root` および `body.noscript` タグを `<div id="root">{children}</div>` に置き換えます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <meta charSet="UTF-8" />
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

> **Good to know**: Next.js は CRA の `public/manifest.json` ファイル、追加のアイコノグラフィ（[`favicon`、`icon`、および `apple-icon`](/docs/app/api-reference/file-conventions/metadata/app-icons) を除く）、および[テスト設定](/docs/app/building-your-application/testing)を無視しますが、これらが必要な場合、Next.js もこれらのオプションをサポートしています。詳細は [Metadata API](/docs/app/building-your-application/optimizing/metadata) と [Testing](/docs/app/building-your-application/testing) のドキュメントを参照してください。

### ステップ 4: メタデータ {#step-4-metadata}

Next.js にはデフォルトで [meta charset](https://developer.mozilla.org/docs/Web/HTML/Element/meta#charset) および [meta viewport](https://developer.mozilla.org/docs/Web/HTML/Viewport_meta_tag) タグが含まれているため、これらは次の `<head>` から安全に削除できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

`favicon.ico`、`icon.png`、`robots.txt` などの[メタデータファイル](/docs/app/building-your-application/optimizing/metadata#file-based-metadata)は、`app` ディレクトリの最上位に配置されている限り、アプリケーションの `<head>` タグに自動的に追加されます。[サポートされているすべてのファイル](/docs/app/building-your-application/optimizing/metadata#file-based-metadata)を `app` ディレクトリに移動したら、それらの `<link>` タグを安全に削除できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

最後に、Next.js は [Metadata API](/docs/app/building-your-application/optimizing/metadata) を使用して最後の `<head>` タグを管理できます。最終的なメタデータ情報をエクスポートされた [`metadata` オブジェクト](/docs/app/api-reference/functions/generate-metadata#metadata-object) に移動します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'React App',
  description: 'Web site created with Next.js.',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
export const metadata = {
  title: 'React App',
  description: 'Web site created with Next.js.',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

上記の変更により、`index.html` にすべてを宣言するのではなく、Next.js のフレームワークに組み込まれた規約ベースのアプローチを使用するようになりました（[Metadata API](/docs/app/building-your-application/optimizing/metadata)）。このアプローチにより、ページの SEO とウェブの共有性をより簡単に向上させることができます。

### ステップ 5: スタイル {#step-5-styles}

Create React App と同様に、Next.js は [CSS Modules](/docs/app/building-your-application/styling/css#css-modules) をサポートしています。

グローバル CSS ファイルを使用している場合、それを `app/layout.tsx` ファイルにインポートします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import '../index.css'

// ...
```

</TabItem>
</Tabs>

Tailwind を使用する場合は、`postcss` と `autoprefixer` をインストールする必要があります：

```bash title="Terminal"
npm install postcss autoprefixer
```

続いて、プロジェクトの root に `postcss.config.js` ファイルを作成します：

```js title="postcss.config.js"
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

### ステップ 6: エントリポイントページの作成 {#step-6-create-the-entrypoint-page}

Next.js では、`page.tsx` ファイルを作成することでアプリケーションのエントリポイントを宣言します。このファイルの CRA における最も近いものは `src/index.tsx` ファイルです。このステップでは、アプリケーションのエントリポイントをセットアップします。

**`[[...slug]]` ディレクトリを `app` ディレクトリに作成する。**

このガイドは、まず Next.js を SPA（シングルページアプリケーション）としてセットアップすることを目指しており、アプリケーションのすべての可能なルートをキャッチするためにページのエントリポイントを設定する必要があります。そのために、`app` ディレクトリに新しい `[[...slug]]` ディレクトリを作成します。

このディレクトリは、[オプショナル・キャッチオール・ルートセグメント](/docs/app/building-your-application/routing/dynamic-routes#optional-catch-all-segments)と呼ばれるものです。Next.js はファイルシステムベースのルーターを使用しており、フォルダーはルートを定義するために使用されます。この特別なディレクトリは、アプリケーションのすべてのルートがその中に含まれる `page.tsx` ファイルに向けられることを保証します。

**`app/[[...slug]]` ディレクトリ内に新しい `page.tsx` ファイルを作成し、次の内容を記述する：**

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[[...slug]]/page.tsx" switcher
export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return '...' // ここを更新します
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[[...slug]]/page.js" switcher
export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return '...' // ここを更新します
}
```

</TabItem>
</Tabs>

このファイルは[Server Component](/docs/app/building-your-application/rendering/server-components)です。`next build` を実行すると、ファイルは静的アセットとしてプリレンダリングされます。動的なコードは _必要ありません_。

このファイルはグローバル CSS をインポートし、[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)で生成するルートがインデックスルート `/` のみであることを伝えます。

次に、純粋にクライアントのみで動作する CRA アプリケーションを移動させます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[[...slug]]/client.tsx" switcher
'use client'

import dynamic from 'next/dynamic'

const App = dynamic(() => import('../../App'), { ssr: false })

export function ClientOnly() {
  return <App />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[[...slug]]/client.js" switcher
'use client'

import dynamic from 'next/dynamic'

const App = dynamic(() => import('../../App'), { ssr: false })

export function ClientOnly() {
  return <App />
}
```

</TabItem>
</Tabs>

このファイルは [Client Component](/docs/app/building-your-application/rendering/client-components) です。その識別子は `'use client'` ディレクティブです。Client Component はサーバーで [HTML にプリレンダリング](/docs/app/building-your-application/rendering/client-components#how-are-client-components-rendered) されてからクライアントに送信されます。

クライアントのみのアプリケーションを開始したいので、Next.js を設定して `App` コンポーネント以下のプリレンダリングを無効にします。

```tsx
const App = dynamic(() => import('../../App'), { ssr: false })
```

次に、エントリポイントページを新しいコンポーネントを使用するように更新します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[[...slug]]/page.tsx" switcher
import { ClientOnly } from './client'

export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return <ClientOnly />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[[...slug]]/page.js" switcher
import { ClientOnly } from './client'

export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return <ClientOnly />
}
```

</TabItem>
</Tabs>

### ステップ 7: 静的画像インポートの更新 {#step-7-update-static-image-imports}

Next.js は CRA とは異なり、静的画像インポートを扱います。CRA では、画像ファイルをインポートすると、その画像の公開 URL が文字列として返されます：

```tsx title="App.tsx"
import image from './img.png'

export default function App() {
  return <img src={image} />
}
```

Next.js では、静的画像インポートがオブジェクトを返します。このオブジェクトは Next.js の [`<Image>` コンポーネント](/docs/app/api-reference/components/image)と直接使用することができ、また既存の `<img>` タグでオブジェクトの `src` プロパティを使用することもできます。

`<Image>` コンポーネントには[自動画像最適化](/docs/app/building-your-application/optimizing/images)の利点があります。`<Image>` コンポーネントは画像の寸法に基づいて、結果的に `<img>` の `width` および `height` 属性を自動的に設定します。これにより、画像が読み込まれる際のレイアウトシフトが防止されます。ただし、アプリケーションに片方の寸法だけがスタイル設定されている画像が含まれる場合には問題が発生する可能性があります。スタイル設定されていないときは、その寸法はデフォルトで `<img>` の寸法属性の値になり、画像が歪んで表示されることがあります。

`<img>` タグを維持することで、アプリケーション内の変更量を減らし、上記の問題を防ぐことができます。その後、後からオプションで `<Image>` コンポーネントに移行し、画像を最適化するために [ローダーを設定](/docs/app/building-your-application/optimizing/images#loaders)したり、自動画像最適化を持つデフォルトの Next.js サーバーに移行したりすることができます。

**絶対インポートパスを `/public` からの相対インポートに変換します：**

```tsx
// 以前
import logo from '/logo.png'

// 以降
import logo from '../public/logo.png'
```

**画像の `src` プロパティを `<img>` タグに渡します：**

```tsx
// 以前
<img src={logo} />

// 以降
<img src={logo.src} />
```

あるいは、画像アセットのファイル名に基づいて公開 URL を参照することもできます。たとえば、`public/logo.png` はアプリケーションの `/logo.png` で画像を提供します。これが `src` 値になります。

> **警告:** TypeScript を使用している場合、`src` プロパティにアクセスする際に型エラーが発生する可能性があります。それを修正するためには、`tsconfig.json` ファイルの [`include` 配列](https://www.typescriptlang.org/tsconfig#include) に `next-env.d.ts` を追加する必要があります。このファイルは、ステップ 9 でアプリケーションを実行するときに Next.js が自動的に生成します。

### ステップ 8: 環境変数の移行 {#step-8-migrate-the-environment-variables}

Next.js には CRA と同様に `.env` [環境変数](/docs/app/building-your-application/configuring/environment-variables)のサポートがあります。

主な違いは、クライアント側で環境変数を公開するために使用されるプレフィックスです。`REACT_APP_` プレフィックスのすべての環境変数を `NEXT_PUBLIC_` に変更します。

### ステップ 9: `package.json` のスクリプトの更新 {#step-9-update-scripts-in-package-json}

これでアプリケーションを実行し、Next.js への移行が成功したかどうかを確認できます。しかしその前に、`package.json` の `scripts` を Next.js 関連のコマンドで更新し、`.next` と `next-env.d.ts` を `.gitignore` ファイルに追加する必要があります：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "npx serve@latest ./build"
  }
}
```

```txt title=".gitignore"
# ... {#}
.next
next-env.d.ts
```

`npm run dev` を実行し、[`http://localhost:3000`](http://localhost:3000) を開きます。Next.js でアプリケーションが動作しているのが確認できるはずです。

### ステップ 10: クリーンアップ {#step-10-clean-up}

Create React App 関連のアーティファクトからコードベースをクリーンアップできます：

- `public/index.html` を削除
- `src/index.tsx` を削除
- `src/react-app-env.d.ts` を削除
- `reportWebVitals` セットアップを削除
- CRA 依存関係（`react-scripts`）をアンインストール

## バンドラーの互換性 {#bundler-compatibility}

Create React App と Next.js は両方ともバンドリングに webpack をデフォルトで使用します。

CRA アプリケーションを Next.js に移行する際に、移行を検討しているカスタム webpack 設定を持っているかもしれません。Next.js は [カスタム webpack 設定](/docs/app/api-reference/config/next-config-js/webpack) の提供をサポートしています。

さらに、Next.js は `next dev --turbopack` 経由での [Turbopack](/docs/app/api-reference/config/next-config-js/turbo) のサポートもあり、ローカルの開発のパフォーマンスを向上させます。Turbopack は [一部の webpack ローダー](/docs/app/api-reference/config/next-config-js/turbo) もサポートしており、互換性とインクリメンタルな適用が可能です。

## 次のステップ {#next-steps}

すべてが計画通りに進んだ場合、現在 Next.js アプリケーションがシングルページアプリケーションとして動作しています。しかし、Next.js の多くの利点を活用しているわけではありませんが、今後インクリメンタルな変更を行いすべての恩恵を享受できるようになります。次に行うべきことは：

- リアクトルーターから[Next.js App Router](/docs/app/building-your-application/routing)に移行して以下を実現：
  - 自動コード分割
  - [ストリーミングサーバーレンダリング](/docs/app/building-your-application/routing/loading-ui-and-streaming)
  - [React サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)
- [`<Image>` コンポーネントを使用して画像を最適化する](/docs/app/building-your-application/optimizing/images)
- [`next/font` を使用してフォントを最適化する](/docs/app/building-your-application/optimizing/fonts)
- [`<Script>` コンポーネントを使用してサードパーティスクリプトを最適化する](/docs/app/building-your-application/optimizing/scripts)
- [Next.js ルールをサポートするために ESLint 設定を更新する](/docs/app/api-reference/config/eslint)

> **Good to know:** 静的エクスポートを使用することは、`useParams` フックの使用を[現在サポートしていません](https://github.com/vercel/next.js/issues/54393)。
