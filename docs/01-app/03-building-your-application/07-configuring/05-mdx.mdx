---
title: 'Markdown and MDX'
nav_title: 'MDX'
description: 'Next.jsアプリでMDXを設定し、使用する方法を学びます。'
---

{/* このドキュメントの内容は、app routerとpages routerの間で共有されています。Pages Routerに特化したコンテンツを追加するには、`<PagesOnly>Content</PagesOnly>`コンポーネントを使用できます。共有コンテンツは、コンポーネントでラップしないようにしてください。 */}

[Markdown](https://daringfireball.net/projects/markdown/syntax)はテキストをフォーマットするために使用される軽量マークアップ言語です。プレーンテキストの書式を使用して記述し、それを構造的に有効なHTMLに変換できます。ウェブサイトやブログのコンテンツを書くためによく使用されます。

以下のように書きます...

```md
I **love** using [Next.js](https://nextjs.org/)
```

出力:

```html
<p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>
```

[MDX](https://mdxjs.com/)は、マークダウンのスーパーセットであり、[JSX](https://react.dev/learn/writing-markup-with-jsx)を直接マークダウンファイル内で記述できるようにします。コンテンツ内に動的なインタラクティビティを追加し、Reactコンポーネントを埋め込む強力な方法です。

Next.jsはアプリケーション内のローカルMDXコンテンツだけでなく、サーバー上で動的に取得したリモートMDXファイルもサポートできます。Next.jsプラグインは、マークダウンとReactコンポーネントをHTMLに変換し、App Routerのサーバーコンポーネントでの使用をサポートします（デフォルト）。

> **Good to know**: 完全に動作する例として、[Portfolio Starter Kit](https://vercel.com/templates/next.js/portfolio-starter-kit)テンプレートを参照してください。

## 依存関係のインストール {#install-dependencies}

`@next/mdx`パッケージおよび関連パッケージが、Next.jsを設定してマークダウンとMDXを処理できるようにするために使用されます。**ローカルファイルからデータを取り込み**、`/pages`や`/app`ディレクトリ内に直接`.md`や`.mdx`拡張子を持つページを作成できます。

Next.jsでMDXをレンダリングするには、以下のパッケージをインストールしてください：

```bash title="Terminal"
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx
```

## `next.config.mjs`を設定する {#configure-next-config-mjs}

プロジェクトのルートにある`next.config.mjs`ファイルを更新して、MDXを使用するように構成します：

```js title="next.config.mjs"
import createMDX from '@next/mdx'

/** @type {import('next').NextConfig} */
const nextConfig = {
  // `pageExtensions`を設定して、マークダウンとMDXファイルを含める
  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],
  // 任意で、その他のNext.js設定を追加
}

const withMDX = createMDX({
  // 追加したいマークダウンプラグインを記述
})

// MDXの設定をNext.jsの設定とマージ
export default withMDX(nextConfig)
```

これにより`.md`および`.mdx`ファイルが、アプリケーション内でページ、ルート、またはインポートとして機能するようになります。

## `mdx-components.tsx`ファイルを追加する {#add-an-mdx-components-tsx-file}

プロジェクトのルートに`mdx-components.tsx`（または`.js`）ファイルを作成して、グローバルなMDXコンポーネントを定義します。たとえば、`pages`や`app`と同じレベル、あるいは`src`内（該当する場合）に配置します。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="mdx-components.tsx" switcher
import type { MDXComponents } from 'mdx/types'

export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    ...components,
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="mdx-components.js" switcher
export function useMDXComponents(components) {
  return {
    ...components,
  }
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - `mdx-components.tsx`はApp Routerで`@next/mdx`を使用するのに**必須**であり、これなしでは機能しません。
> - [`mdx-components.tsx`ファイルの規約](/docs/app/api-reference/file-conventions/mdx-components)についてもっと学びましょう。
> - [カスタムスタイルとコンポーネントを使用する](#using-custom-styles-and-components)方法を学びましょう。

## MDXのレンダリング {#rendering-mdx}

Next.jsのファイルベースルーティングを使用してMDXをレンダリングするか、他のページにMDXファイルをインポートします。

### ファイルベースのルーティングを使用する {#using-file-based-routing}

ファイルベースのルーティングを使用すると、他のページと同様にMDXページを使用できます。

<AppOnly>

App Routerアプリでは、[メタデータ](/docs/app/building-your-application/optimizing/metadata)を使用することもできます。

`/app`ディレクトリ内に新しいMDXページを作成します：

```txt
  my-project
  ├── app
  │   └── mdx-page
  │       └── page.(mdx/md)
  |── mdx-components.(tsx/js)
  └── package.json
```

</AppOnly>

<PagesOnly>

`/pages`ディレクトリ内に新しいMDXページを作成します：

```txt
  my-project
  |── mdx-components.(tsx/js)
  ├── pages
  │   └── mdx-page.(mdx/md)
  └── package.json
```

</PagesOnly>

これらのファイル内でMDXを使用し、さらにReactコンポーネントを直接MDXページ内にインポートできます：

```mdx
import { MyComponent } from 'my-component'

# Welcome to my MDX page! {#welcome-to-my-mdx-page}

これは一部の**太字**と*イタリック*のテキストです。

以下はマークダウンのリストです：

- One
- Two
- Three

私のReactコンポーネントを確認してください：

<MyComponent />
```

`/mdx-page`ルートに移動すると、レンダリングされたMDXページが表示されます。

### インポートを使用する {#using-imports}

<AppOnly>

`/app`ディレクトリに新しいページを作成し、好きな場所にMDXファイルを作成します：

```txt
  my-project
  ├── app
  │   └── mdx-page
  │       └── page.(tsx/js)
  ├── markdown
  │   └── welcome.(mdx/md)
  |── mdx-components.(tsx/js)
  └── package.json
```

</AppOnly>

<PagesOnly>

`/pages`ディレクトリに新しいページを作成し、好きな場所にMDXファイルを作成します：

```txt
  my-project
  ├── pages
  │   └── mdx-page.(tsx/js)
  ├── markdown
  │   └── welcome.(mdx/md)
  |── mdx-components.(tsx/js)
  └── package.json
```

</PagesOnly>

これらのファイルでMDXを使用し、さらにReactコンポーネントを直接MDXページ内にインポートできます：

<Tabs>
<TabItem value="mdx" label="mdx">

```mdx title="markdown/welcome.mdx" switcher
import { MyComponent } from 'my-component'

# Welcome to my MDX page! {#welcome-to-my-mdx-page}

これは一部の**太字**と*イタリック*のテキストです。

以下はマークダウンのリストです：

- One
- Two
- Three

私のReactコンポーネントを確認してください：

<MyComponent />
```

</TabItem>
</Tabs>

ページ内にMDXファイルをインポートしてコンテンツを表示します：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/mdx-page/page.tsx" switcher
import Welcome from '@/markdown/welcome.mdx'

export default function Page() {
  return <Welcome />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/mdx-page/page.js" switcher
import Welcome from '@/markdown/welcome.mdx'

export default function Page() {
  return <Welcome />
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/mdx-page.tsx" switcher
import Welcome from '@/markdown/welcome.mdx'

export default function Page() {
  return <Welcome />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/mdx-page.js" switcher
import Welcome from '@/markdown/welcome.mdx'

export default function Page() {
  return <Welcome />
}
```

</TabItem>
</Tabs>

</PagesOnly>

`/mdx-page`ルートに移動すると、レンダリングされたMDXページが表示されます。

<AppOnly>

### 動的インポートを使用する {#using-dynamic-imports}

ファイルシステムルーティングを使用する代わりに動的なMDXコンポーネントをインポートできます。

たとえば、別のディレクトリからMDXコンポーネントを読み込むdynamic route segmentを持つことができます：

<Image
  alt="動的なMDXコンポーネントのためのルートセグメント"
  srcLight="/docs/light/mdx-files.png"
  srcDark="/docs/dark/mdx-files.png"
  width="1600"
  height="849"
>

[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)を使用して提供されたルートをプリレンダリングできます。`dynamicParams`を`false`としてマークすると、`generateStaticParams`で定義されていないルートにアクセスした場合は404になります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/[slug]/page.tsx" switcher
export default async function Page({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const slug = (await params).slug
  const { default: Post } = await import(`@/content/${slug}.mdx`)

  return <Post />
}

export function generateStaticParams() {
  return [{ slug: 'welcome' }, { slug: 'about' }]
}

export const dynamicParams = false
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/[slug]/page.js" switcher
export default async function Page({ params }) {
  const slug = params.slug
  const { default: Post } = await import(`@/content/${slug}.mdx`)

  return <Post />
}

export function generateStaticParams() {
  return [{ slug: 'welcome' }, { slug: 'about' }]
}

export const dynamicParams = false
```

</TabItem>
</Tabs>

> **Good to know**: インポートで`.mdx`ファイル拡張子を指定することを確認してください。[モジュールパスエイリアス](/docs/app/getting-started/installation#set-up-absolute-imports-and-module-path-aliases)（例：`@/content`）を使用する必要はありませんが、インポートパスを簡素化します。

</AppOnly>

## カスタムスタイルとコンポーネントを使用する {#using-custom-styles-and-components}

マークダウンがレンダリングされるとき、ネイティブHTML要素にマッピングされます。たとえば、次のようにマークダウンを書くと：

```md
## This is a heading {#this-is-a-heading}

以下はマークダウンのリストです：

- One
- Two
- Three
```

次のHTMLが生成されます：

```html
<h2>This is a heading</h2>

<p>以下はマークダウンのリストです：</p>

<ul>
  <li>One</li>
  <li>Two</li>
  <li>Three</li>
</ul>
```

マークダウンをスタイル付けするには、生成されたHTML要素にマッピングするカスタムコンポーネントを提供できます。スタイルやコンポーネントは、グローバル、ローカル、共有レイアウトで実装できます。

### グローバルスタイルとコンポーネント {#global-styles-and-components}

`mdx-components.tsx`にスタイルとコンポーネントを追加すると、アプリケーション内の\_すべての\_MDXファイルに影響を与えます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="mdx-components.tsx" switcher
import type { MDXComponents } from 'mdx/types'
import Image, { ImageProps } from 'next/image'

// このファイルは、MDXファイルで使用するカスタムReactコンポーネントを提供するためのものです。
// インラインスタイル、他のライブラリからのコンポーネントなど、任意のReactコンポーネントをインポートして使用できます。

export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    // 組み込みコンポーネントをカスタマイズするため、例：スタイリングを追加します。
    h1: ({ children }) => (
      <h1 style={{ color: 'red', fontSize: '48px' }}>{children}</h1>
    ),
    img: (props) => (
      <Image
        sizes="100vw"
        style={{ width: '100%', height: 'auto' }}
        {...(props as ImageProps)}
      />
    ),
    ...components,
  }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="mdx-components.js" switcher
import Image from 'next/image'

// このファイルは、MDXファイルで使用するカスタムReactコンポーネントを提供するためのものです。
// インラインスタイル、他のライブラリからのコンポーネントなど、任意のReactコンポーネントをインポートして使用できます。

export function useMDXComponents(components) {
  return {
    // 組み込みコンポーネントをカスタマイズするため、例：スタイリングを追加します。
    h1: ({ children }) => (
      <h1 style={{ color: 'red', fontSize: '48px' }}>{children}</h1>
    ),
    img: (props) => (
      <Image
        sizes="100vw"
        style={{ width: '100%', height: 'auto' }}
        {...props}
      />
    ),
    ...components,
  }
}
```

</TabItem>
</Tabs>

### ローカルスタイルとコンポーネント {#local-styles-and-components}

インポートしたMDXコンポーネントに渡すことで、特定のページにローカルスタイルやコンポーネントを適用できます。これらは[グローバルスタイルとコンポーネント](#global-styles-and-components)とマージおよび上書きされます。

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/mdx-page/page.tsx" switcher
import Welcome from '@/markdown/welcome.mdx'

function CustomH1({ children }) {
  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>
}

const overrideComponents = {
  h1: CustomH1,
}

export default function Page() {
  return <Welcome components={overrideComponents} />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/mdx-page/page.js" switcher
import Welcome from '@/markdown/welcome.mdx'

function CustomH1({ children }) {
  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>
}

const overrideComponents = {
  h1: CustomH1,
}

export default function Page() {
  return <Welcome components={overrideComponents} />
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/mdx-page.tsx" switcher
import Welcome from '@/markdown/welcome.mdx'

function CustomH1({ children }) {
  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>
}

const overrideComponents = {
  h1: CustomH1,
}

export default function Page() {
  return <Welcome components={overrideComponents} />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/mdx-page.js" switcher
import Welcome from '@/markdown/welcome.mdx'

function CustomH1({ children }) {
  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>
}

const overrideComponents = {
  h1: CustomH1,
}

export default function Page() {
  return <Welcome components={overrideComponents} />
}
```

</TabItem>
</Tabs>

</PagesOnly>

### 共有レイアウト {#shared-layouts}

<AppOnly>

MDXページ間でレイアウトを共有するには、App Routerに組み込まれた[レイアウトサポート](/docs/app/building-your-application/routing/layouts-and-templates#layouts)を使用できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/mdx-page/layout.tsx" switcher
export default function MdxLayout({ children }: { children: React.ReactNode }) {
  // 任意の共有レイアウトまたはスタイルをここに作成します
  return <div style={{ color: 'blue' }}>{children}</div>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/mdx-page/layout.js" switcher
export default function MdxLayout({ children }) {
  // 任意の共有レイアウトまたはスタイルをここに作成します
  return <div style={{ color: 'blue' }}>{children}</div>
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

MDXページの周りでレイアウトを共有するには、レイアウトコンポーネントを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="components/mdx-layout.tsx" switcher
export default function MdxLayout({ children }: { children: React.ReactNode }) {
  // 任意の共有レイアウトまたはスタイルをここに作成します
  return <div style={{ color: 'blue' }}>{children}</div>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="components/mdx-layout.js" switcher
export default function MdxLayout({ children }) {
  // 任意の共有レイアウトまたはスタイルをここに作成します
  return <div style={{ color: 'blue' }}>{children}</div>
}
```

</TabItem>
</Tabs>

次に、レイアウトコンポーネントをMDXページにインポートし、MDXコンテンツをレイアウトでラップし、エクスポートします：

```mdx
import MdxLayout from '../components/mdx-layout'

# Welcome to my MDX page! {#welcome-to-my-mdx-page}

export default function MDXPage({ children }) {
  return <MdxLayout>{children}</MdxLayout>

}
```

</PagesOnly>

### Tailwind typographyプラグインの使用 {#using-tailwind-typography-plugin}

アプリケーションのスタイルに[Tailwind](https://tailwindcss.com)を使用している場合、[`@tailwindcss/typography`プラグイン](https://tailwindcss.com/docs/plugins#typography)を使用すると、Tailwindの設定とスタイルをマークダウンファイル内で再利用できます。

このプラグインは、マークダウンのようなソースからのコンテンツブロックに対して、typographicスタイルを追加するための`prose`クラスセットを追加します。

[Tailwind typography](https://github.com/tailwindlabs/tailwindcss-typography?tab=readme-ov-file#installation)をインストールし、[共有レイアウト](#shared-layouts)で使用して希望する`prose`を追加します。

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/mdx-page/layout.tsx" switcher
export default function MdxLayout({ children }: { children: React.ReactNode }) {
  // 任意の共有レイアウトまたはスタイルをここに作成します
  return (
    <div className="prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white">
      {children}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/mdx-page/layout.js" switcher
export default function MdxLayout({ children }) {
  // 任意の共有レイアウトまたはスタイルをここに作成します
  return (
    <div className="prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white">
      {children}
    </div>
  )
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

MDXページの周りでレイアウトを共有するには、レイアウトコンポーネントを作成します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="components/mdx-layout.tsx" switcher
export default function MdxLayout({ children }: { children: React.ReactNode }) {
  // 任意の共有レイアウトまたはスタイルをここに作成します
  return (
    <div className="prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white">
      {children}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="components/mdx-layout.js" switcher
export default function MdxLayout({ children }) {
  // 任意の共有レイアウトまたはスタイルをここに作成します
  return (
    <div className="prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white">
      {children}
    </div>
  )
}
```

</TabItem>
</Tabs>

次に、レイアウトコンポーネントをMDXページにインポートし、MDXコンテンツをレイアウトでラップし、エクスポートします：

```mdx
import MdxLayout from '../components/mdx-layout'

# Welcome to my MDX page! {#welcome-to-my-mdx-page}

export default function MDXPage({ children }) {
  return <MdxLayout>{children}</MdxLayout>

}
```

</PagesOnly >

## Frontmatter {#frontmatter}

Frontmatterはページに関するデータを保存するために使用できるYAMLのようなキー/値ペアリングです。`@next/mdx`はデフォルトでfrontmatterをサポートしていませんが、MDXコンテンツにfrontmatterを追加するための多くの解決策があります。たとえば：

- [remark-frontmatter](https://github.com/remarkjs/remark-frontmatter)
- [remark-mdx-frontmatter](https://github.com/remcohaszing/remark-mdx-frontmatter)
- [gray-matter](https://github.com/jonschlinkert/gray-matter)

`@next/mdx`は、他のJavaScriptコンポーネントと同様にエクスポートを使用できます：

<Tabs>
<TabItem value="mdx" label="mdx">

```mdx title="content/blog-post.mdx" switcher
export const metadata = {
  author: 'ジョン・ドウ',
}

# ブログ投稿 {#blog-post}
```

</TabItem>
</Tabs>

メタデータは、MDXファイルの外部で参照できるようになります：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/blog/page.tsx" switcher
import BlogPost, { metadata } from '@/content/blog-post.mdx'

export default function Page() {
  console.log('metadata: ', metadata)
  //=> { author: 'ジョン・ドウ' }
  return <BlogPost />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/blog/page.js" switcher
import BlogPost, { metadata } from '@/content/blog-post.mdx'

export default function Page() {
  console.log('metadata: ', metadata)
  //=> { author: 'ジョン・ドウ' }
  return <BlogPost />
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/blog.tsx" switcher
import BlogPost, { metadata } from '@/content/blog-post.mdx'

export default function Page() {
  console.log('metadata: ', metadata)
  //=> { author: 'ジョン・ドウ' }
  return <BlogPost />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/blog.js" switcher
import BlogPost, { metadata } from '@/content/blog-post.mdx'

export default function Page() {
  console.log('metadata: ', metadata)
  //=> { author: 'ジョン・ドウ' }
  return <BlogPost />
}
```

</TabItem>
</Tabs>

</PagesOnly>

これが一般的に使用されるケースは、MDXコレクションを反復してデータを抽出したいときです。たとえば、すべてのブログ投稿からブログインデックスページを作成する場合です。[Nodeの`fs`モジュール](https://nodejs.org/api/fs.html)や[globby](https://www.npmjs.com/package/globby)などのパッケージを使用して、投稿のディレクトリを読み取り、メタデータを抽出できます。

> **Good to know**:
>
> - `fs`、`globby`などはサーバー側でのみ使用できます。
> - 完全に動作する例として、[Portfolio Starter Kit](https://vercel.com/templates/next.js/portfolio-starter-kit)テンプレートを参照してください。

## remarkとrehypeのプラグイン {#remark-and-rehype-plugins}

remarkとrehypeプラグインを任意で提供し、MDXコンテンツを変換することができます。

たとえば、[`remark-gfm`](https://github.com/remarkjs/remark-gfm)を使用してGitHub風味のマークダウンをサポートできます。

remarkとrehypeのエコシステムはESMのみのため、設定ファイルとして`next.config.mjs`または`next.config.ts`を使用する必要があります。

```js title="next.config.mjs"
import remarkGfm from 'remark-gfm'
import createMDX from '@next/mdx'

/** @type {import('next').NextConfig} */
const nextConfig = {
  // ファイルの拡張子に.mdを許可
  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],
  // 任意で、その他のNext.js設定を追加
}

const withMDX = createMDX({
  // 追加したいマークダウンプラグインを記述
  options: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [],
  },
})

// MDXとNext.jsの設定を組み合わせ
export default withMDX(nextConfig)
```

### Turbopackでプラグインを使用する {#using-plugins-with-turbopack}

[Turbopack](/docs/app/api-reference/turbopack)と一緒にプラグインを使用するには、`@next/mdx`を最新バージョンにアップグレードし、プラグイン名を文字列で指定します：

```js title="next.config.mjs"
import createMDX from '@next/mdx'

/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],
}

const withMDX = createMDX({
  options: {
    remarkPlugins: [],
    rehypePlugins: [['rehype-katex', { strict: true, throwOnError: true }]],
  },
})

export default withMDX(nextConfig)
```

> **Good to know**:
>
> JavaScript関数をRustに渡すことができないため、シリアル化可能なオプションのないremarkおよびrehypeプラグインは、まだ[Turbopack](/docs/app/api-reference/turbopack)で使用できません（[詳細](https://github.com/vercel/next.js/issues/71819#issuecomment-2461802968)）

## リモートMDX {#remote-mdx}

MDXファイルやコンテンツが他の場所にある場合、サーバー上で動的にそれを取得できます。これは、CMSやデータベース、その他の場所に保存されたコンテンツに役立ちます。この用途に人気のあるコミュニティパッケージは[`next-mdx-remote`](https://github.com/hashicorp/next-mdx-remote#react-server-components-rsc--nextjs-app-directory-support)です。

> **Good to know**: 注意して進めてください。MDXはJavaScriptにコンパイルされ、サーバーで実行されます。信頼できるソースからのみMDXコンテンツを取得する必要があります。そうしないと、リモートコード実行（RCE）につながる可能性があります。

以下の例では、`next-mdx-remote`を使用します：

<AppOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/mdx-page-remote/page.tsx" switcher
import { MDXRemote } from 'next-mdx-remote/rsc'

export default async function RemoteMdxPage() {
  // MDXテキスト-データベース、CMS、フェッチ、どこからでも...
  const res = await fetch('https://...')
  const markdown = await res.text()
  return <MDXRemote source={markdown} />
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/mdx-page-remote/page.js" switcher
import { MDXRemote } from 'next-mdx-remote/rsc'

export default async function RemoteMdxPage() {
  // MDXテキスト-データベース、CMS、フェッチ、どこからでも...
  const res = await fetch('https://...')
  const markdown = await res.text()
  return <MDXRemote source={markdown} />
}
```

</TabItem>
</Tabs>

</AppOnly>

<PagesOnly>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="pages/mdx-page-remote.tsx" switcher
import { serialize } from 'next-mdx-remote/serialize'
import { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'

interface Props {
  mdxSource: MDXRemoteSerializeResult
}

export default function RemoteMdxPage({ mdxSource }: Props) {
  return <MDXRemote {...mdxSource} />
}

export async function getStaticProps() {
  // MDXテキスト-データベース、CMS、フェッチ、どこからでも...
  const res = await fetch('https:...')
  const mdxText = await res.text()
  const mdxSource = await serialize(mdxText)
  return { props: { mdxSource } }
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="pages/mdx-page-remote.js" switcher
import { serialize } from 'next-mdx-remote/serialize'
import { MDXRemote } from 'next-mdx-remote'

export default function RemoteMdxPage({ mdxSource }) {
  return <MDXRemote {...mdxSource} />
}

export async function getStaticProps() {
  // MDXテキスト-データベース、CMS、フェッチ、どこからでも...
  const res = await fetch('https:...')
  const mdxText = await res.text()
  const mdxSource = await serialize(mdxText)
  return { props: { mdxSource } }
}
```

</TabItem>
</Tabs>

</PagesOnly>

`/mdx-page-remote`ルートに移動すると、レンダリングされたMDXが表示されます。

## ディープダイブ：マークダウンをHTMLに変換する方法 {#deep-dive-how-do-you-transform-markdown-into-html}

Reactはマークダウンをネイティブに理解しません。まず、マークダウンのプレーンテキストをHTMLに変換する必要があります。これは、`remark`と`rehype`を使用して達成できます。

`remark`はマークダウンに関するツールのエコシステムです。`rehype`はHTMLに関連したもので、同様のエコシステムです。たとえば、次のコードスニペットはマークダウンをHTMLに変換します：

```js
import { unified } from 'unified'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import rehypeSanitize from 'rehype-sanitize'
import rehypeStringify from 'rehype-stringify'

main()

async function main() {
  const file = await unified()
    .use(remarkParse) // マークダウンASTに変換
    .use(remarkRehype) // HTML ASTに変換
    .use(rehypeSanitize) // HTML入力をサニタイズ
    .use(rehypeStringify) // ASTをシリアル化されたHTMLに変換
    .process('Hello, Next.js!')

  console.log(String(file)) // <p>Hello, Next.js!</p>
}
```

`remark`と`rehype`のエコシステムには、[シンタックスハイライト](https://github.com/atomiks/rehype-pretty-code)、[ヘディングのリンク](https://github.com/rehypejs/rehype-autolink-headings)、[目次の生成](https://github.com/remarkjs/remark-toc)などのプラグインがあります。

上記のように`@next/mdx`を使用するとき、`remark`または`rehype`を直接使用する必要は**ありません**。それはあなたのために処理されます。ここでは、`@next/mdx`パッケージが裏で実行していることを深く理解するために説明しています。

## RustベースのMDXコンパイラを使用する（実験的） {#using-the-rust-based-mdx-compiler-experimental}

Next.jsは、新しいRustで書かれたMDXコンパイラをサポートしています。このコンパイラはまだ実験的であり、実運用ではお勧めできません。新しいコンパイラを使用するには、`next.config.js`を`withMDX`に渡す際に構成する必要があります：

```js title="next.config.js"
module.exports = withMDX({
  experimental: {
    mdxRs: true,
  },
})
```

`mdxRs`は、mdxファイルを変換する方法を構成するためのオブジェクトも受け入れます。

```js title="next.config.js"
module.exports = withMDX({
  experimental: {
    mdxRs: {
      jsxRuntime?: string            // カスタムjsxランタイム
      jsxImportSource?: string       // カスタムjsxインポートソース
      mdxType?: 'gfm' | 'commonmark' // 解析と変換に使用するmdx構文を設定
    },
  },
})
```

## 参考リンク {#helpful-links}

- [MDX](https://mdxjs.com)
- [`@next/mdx`](https://www.npmjs.com/package/@next/mdx)
- [remark](https://github.com/remarkjs/remark)
- [rehype](https://github.com/rehypejs/rehype)
- [Markdoc](https://markdoc.dev/docs/nextjs)
