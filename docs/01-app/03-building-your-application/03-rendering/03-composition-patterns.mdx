---
title: 'サーバーとクライアントのコンポジションパターン'
nav_title: 'コンポジションパターン'
description: 'ServerとClient Componentsを使用する際の推奨パターンです。'
---

Reactアプリケーションを構築する際に、アプリケーションのどの部分をサーバーまたはクライアントでレンダリングするべきかを考慮する必要があります。このページでは、Server ComponentとClient Componentを使用する際の推奨コンポジションパターンについて説明します。

## Server ComponentとClient Componentの使い分け {#when-to-use-server-and-client-components}

Server ComponentとClient Componentのさまざまなユースケースを簡単にまとめます：

| 必要な操作                                                                                  | Server Component    | Client Component    |
| ------------------------------------------------------------------------------------------- | ------------------- | ------------------- |
| データを取得する                                                                            | <Check size={18} /> | <Cross size={18} /> |
| バックエンドリソースに直接アクセスする                                                      | <Check size={18} /> | <Cross size={18} /> |
| センシティブな情報をサーバーに保持する（アクセストークン、APIキーなど）                     | <Check size={18} /> | <Cross size={18} /> |
| 大きな依存関係をサーバーに保持する／クライアントサイドのJavaScriptを減らす                  | <Check size={18} /> | <Cross size={18} /> |
| インタラクティブな機能とイベントリスナーを追加する（`onClick()`, `onChange()`など）         | <Cross size={18} /> | <Check size={18} /> |
| 状態とライフサイクルエフェクトを使用する（`useState()`, `useReducer()`, `useEffect()`など） | <Cross size={18} /> | <Check size={18} /> |
| ブラウザ専用のAPIを使用する                                                                 | <Cross size={18} /> | <Check size={18} /> |
| 状態、エフェクト、またはブラウザ専用のAPIに依存するカスタムフックを使用する                 | <Cross size={18} /> | <Check size={18} /> |
| [Reactクラスコンポーネント](https://react.dev/reference/react/Component)を使用する          | <Cross size={18} /> | <Check size={18} /> |

## Server Componentパターン {#server-component-patterns}

クライアントサイドレンダリングを選択する前に、データを取得したり、データベースやバックエンドサービスにアクセスしたりするなどの作業をサーバーで行うことを検討するかもしれません。

以下はServer Componentを使用する際の一般的なパターンです：

### コンポーネント間でデータを共有する {#sharing-data-between-components}

サーバーでデータを取得する際、異なるコンポーネントでデータを共有する必要がある場合があります。たとえば、同じデータに依存するレイアウトとページがあるかもしれません。

[React Context](https://react.dev/learn/passing-data-deeply-with-context)（サーバー上では使用できない）を使ったり、データをpropsとして渡したりする代わりに、`fetch`やReactの`cache`関数を使用して、必要なコンポーネントで同じデータを取得できます。これにより、同じデータの重複したリクエストを行う心配がありません。`fetch`を拡張することでReactがデータリクエストを自動的にメモ化し、`fetch`が利用できない場合に`cache`関数を使用できます。

このパターンの[例を見る](/docs/app/building-your-application/data-fetching/fetching#reusing-data-across-multiple-functions)。

### サーバー専用コードをクライアント環境から除外する {#keeping-server-only-code-out-of-the-client-environment}

JavaScriptモジュールはサーバーとクライアントの両方のComponentモジュール間で共有できるため、サーバー上でのみ動作させることを意図したコードが、意図せずにクライアントに流出する可能性があります。

例として、次のデータ取得関数をご覧ください：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="lib/data.ts" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="lib/data.js" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

</TabItem>
</Tabs>

一見すると、`getData`はサーバーとクライアントの両方で動作すると考えるかもしれません。しかし、この関数には`API_KEY`が含まれており、サーバー上でのみ実行されることを意図しています。

環境変数`API_KEY`が`NEXT_PUBLIC`でプレフィックスされていないため、これはサーバーのみでアクセスできるプライベートな変数です。環境変数が誤ってクライアントに漏れるのを防ぐために、Next.jsはプライベート環境変数を空の文字列で置き換えます。

その結果、`getData()`をクライアントでインポートして実行できても、期待どおりには動作しません。変数を公開することで関数をクライアントで機能させることはできますが、センシティブな情報をクライアントに公開したくないかもしれません。

このようなサーバーコードの意図しないクライアントでの使用を防ぐために、`server-only`パッケージを使用して、他の開発者がこれらのモジュールのいずれかを誤ってClient Componentにインポートしてしまった場合に、ビルド時エラーを発生させることができます。

`server-only`を使うには、まずパッケージをインストールします：

```bash title="Terminal"
npm install server-only
```

その後、サーバー専用のコードを含むモジュールでパッケージをインポートします：

```js title="lib/data.js"
import 'server-only'

export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

これで、`getData()`をインポートするいかなるClient Componentも、このモジュールがサーバーでのみ使用されることを示すビルド時エラーを受け取ることになります。

対応するパッケージ`client-only`は、クライアント専用のコードを含むモジュールをマークするために使用できます。たとえば、`window`オブジェクトにアクセスするコードです。

### サードパーティパッケージとプロバイダーの利用 {#using-third-party-packages-and-providers}

Server Componentは新しいReactの機能であるため、エコシステムにおけるサードパーティパッケージやプロバイダーは、`useState`、`useEffect`、`createContext`など、クライアント専用機能を使用するコンポーネントに`"use client"`ディレクティブを追加し始めたばかりです。

現在のところ、クライアント専用機能を使用する多くの`npm`パッケージのコンポーネントには、このディレクティブがまだありません。これらのサードパーティコンポーネントは、`"use client"`ディレクティブがあるためClient Component内では期待どおり動作しますが、Server Component内では動作しません。

たとえば、`acme-carousel`という仮想のパッケージをインストールし、`<Carousel />`コンポーネントを提供しているとします。このコンポーネントは`useState`を使用しますが、まだ`"use client"`ディレクティブが付いていません。

Client Component内で`<Carousel />`を使用すると、期待どおり動作します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/gallery.tsx" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* Works, since Carousel is used within a Client Component */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/gallery.js" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/*  Works, since Carousel is used within a Client Component */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

</TabItem>
</Tabs>

しかし、Server Component内で直接使用しようとすると、エラーが発生します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/* Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { Carousel } from 'acme-carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/*  Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

これは、Next.jsが`<Carousel />`がクライアント専用機能を使用していることを知らないためです。

これを修正するには、クライアント専用機能に依存するサードパーティコンポーネントを、自分のClient Component内でラップします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/carousel.tsx" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/carousel.js" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

</TabItem>
</Tabs>

これで、Server Component内で`<Carousel />`を直接使用することができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/*  Works, since Carousel is a Client Component */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>

      {/*  Works, since Carousel is a Client Component */}
      <Carousel />
    </div>
  )
}
```

</TabItem>
</Tabs>

ほとんどのサードパーティコンポーネントをラップする必要はないと考えています。なぜなら、Client Component内で使用する可能性が高いからです。しかし、プロバイダーは例外であり、Reactの状態とコンテキストに依存しており、通常はアプリケーションのrootで必要とされます。[以下でサードパーティコンテキストプロバイダーについて学ぶ](#using-context-providers)。

#### コンテキストプロバイダーの使用 {#using-context-providers}

コンテキストプロバイダーは通常、アプリケーションのroot近くで現在のテーマなどのグローバルな関心事を共有するためにレンダリングされます。 [Reactのコンテキスト](https://react.dev/learn/passing-data-deeply-with-context)はServer Componentでサポートされていないので、アプリケーションのrootでコンテキストを作成しようとするとエラーが発生します：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import { createContext } from 'react'

//  createContext is not supported in Server Components
export const ThemeContext = createContext({})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import { createContext } from 'react'

//  createContext is not supported in Server Components
export const ThemeContext = createContext({})

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

これを修正するには、コンテキストを作成し、そのプロバイダーをクライアントコンポーネント内でレンダリングします：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/theme-provider.tsx" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode
}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/theme-provider.js" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

</TabItem>
</Tabs>

Server Componentは、プロバイダーがClient Componentとしてマークされているので、プロバイダーを直接レンダリングすることができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

</TabItem>
</Tabs>

プロバイダーがrootでレンダリングされると、アプリ全体の他のClient Componentがこのコンテキストを利用できるようになります。

> **Good to know**: プロバイダーはtreeの中でできるだけ深くレンダリングする必要があります。`ThemeProvider`が`<html>`全体ではなく`{children}`だけをラップしていることに注目してください。これにより、Next.jsがServer Componentの静的な部分を最適化しやすくなります。

#### ライブラリアーサーへのアドバイス {#advice-for-library-authors}

同様に、他の開発者が利用するパッケージを作成するライブラリアーサーは、パッケージのクライアントエントリポイントに`"use client"`ディレクティブを使用できます。これにより、パッケージの利用者がServer Componentに直接パッケージのコンポーネントをインポートでき、ラッピングバウンダリを作成する必要がなくなります。

`"use client"`をtreeの奥深くで使用することによりインポートされたモジュールをServer Componentのモジュールグラフの一部にすることで、パッケージを最適化できます。

一部のバンドラは`"use client"`ディレクティブを削除する可能性があることに注意してください。[React Wrap Balancer](https://github.com/shuding/react-wrap-balancer/blob/main/tsup.config.ts#L10-L13)と[Vercel Analytics](https://github.com/vercel/analytics/blob/main/packages/web/tsup.config.js#L26-L30)のリポジトリで`"use client"`ディレクティブを含めるためのesbuildの設定方法の例を見つけることができます。

## Client Component {#client-components}

### Client Componentをtreeの下へ移動 {#moving-client-components-down-the-tree}

Client JavaScriptバンドルサイズを減らすために、Client Componentをコンポーネントtreeの下へ移動することをお勧めします。

たとえば、静的な要素（例：ロゴ、リンクなど）と状態を持つインタラクティブな検索バーを持つレイアウトがあるかもしれません。

レイアウト全体をClient Componentにする代わりに、インタラクティブなロジックをClient Component（例：`<SearchBar />`）に移動し、レイアウトはServer Componentのままにしておきます。これにより、レイアウトのコンポーネントJavaScript全体をクライアントに送信する必要がなくなります。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/layout.tsx" switcher
// SearchBarはClient Component
import SearchBar from './searchbar'
// LogoはServer Component
import Logo from './logo'

// LayoutはデフォルトでServer Component
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/layout.js" switcher
// SearchBarはClient Component
import SearchBar from './searchbar'
// LogoはServer Component
import Logo from './logo'

// LayoutはデフォルトでServer Component
export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

</TabItem>
</Tabs>

### ServerからClient Componentへpropsを渡す（シリアライズ化） {#passing-props-from-server-to-client-components-serialization}

Server Component内でデータを取得する場合、そのデータをpropsとしてClient Componentに渡したいかもしれません。ServerからClient Componentに渡されるpropsは、Reactによって[シリアライズ可能](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)である必要があります。

Client Componentがシリアライズできないデータに依存している場合は、[サードパーティライブラリでクライアント側でデータを取得します](/docs/app/building-your-application/data-fetching/fetching#fetching-data-on-the-client)か、[Route Handler](/docs/app/building-your-application/routing/route-handlers)を使用してサーバー側でデータを取得します。

## ServerとClient Componentsのインターリーブ {#interleaving-server-and-client-components}

Client ComponentとServer Componentを交互に使用する際、UIをコンポーネントのtreeとして視覚化するのが役立つ場合があります。Server Componentである[ルートレイアウト](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)から始め、`"use client"`ディレクティブを追加してクライアントで特定のサブtreeのコンポーネントをレンダリングできます。

{/* Diagram - interleaving */}

これらのクライアントサブtree内でも、Server Componentをネストしたり、Server Actionを呼び出したりすることができますが、いくつかの点に注意が必要です：

- リクエスト-レスポンスのライフサイクル中に、コードはサーバーからクライアントに移動します。クライアント側でサーバーのデータやリソースにアクセスする必要がある場合、サーバーへの**新しい**リクエストを行うことになるため、行ったり来たりすることはありません。
- 新しいリクエストがサーバーに行われると、すべてのServer Componentが最初にレンダリングされ、Client Component内にネストされているものも含まれます。レンダリングの結果（[RSC Payload](/docs/app/building-your-application/rendering/server-components#what-is-the-react-server-component-payload-rsc)）には、Client Componentの位置の参照が含まれます。その後、クライアント側で、ReactはRSC Payloadを使用してServer ComponentとClient Componentを1つのtreeに統合します。

{/* Diagram */}

- Client ComponentはServer Componentの後にレンダリングされるため、Client ComponentモジュールにServer Componentをインポートすることはできません（サーバーに新しいリクエストが必要になるため）。代わりに、Server ComponentをClient Componentに`props`として渡すことができます。 [サポートされていないパターン](#unsupported-pattern-importing-server-components-into-client-components)と[サポートされているパターン](#supported-pattern-passing-server-components-to-client-components-as-props)の節を参照してください。

### サポートされていないパターン：Client ComponentへのServer Componentのインポート {#unsupported-pattern-importing-server-components-into-client-components}

以下のパターンはサポートされていません。Server ComponentをClient Componentにインポートすることはできません：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={3,4,17}
'use client'

// クライアントコンポーネントにサーバーコンポーネントをインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={3,13}
'use client'

// クライアントコンポーネントにサーバーコンポーネントをインポートすることはできません。
import ServerComponent from './Server-Component'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ServerComponent />
    </>
  )
}
```

</TabItem>
</Tabs>

### サポートされているパターン：Server ComponentをClient Componentにpropsとして渡す {#supported-pattern-passing-server-components-to-client-components-as-props}

次のパターンはサポートされています。Server ComponentをClient Componentへのpropとして渡すことができます。

一般的なパターンは、Reactの`children` propを使用して、Client Componentに*"スロット"*を作成することです。

以下の例では、`<ClientComponent>`は`children` propを受け入れます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/client-component.tsx" switcher
highlight={6,15}
'use client'

import { useState } from 'react'

export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/client-component.js" switcher
highlight={5,12}
'use client'

import { useState } from 'react'

export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      {children}
    </>
  )
}
```

</TabItem>
</Tabs>

`<ClientComponent>`は、最終的にServer Componentの結果によって`children`が埋められることを知りません。 `<ClientComponent>`が持つ唯一の責任は、`children`を**どこ**に最終的に配置するかを決定することです。

親Server Componentでは、`<ClientComponent>`と`<ServerComponent>`の両方をインポートし、`<ServerComponent>`を`<ClientComponent>`の子として渡すことができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" highlight={11} switcher
// このパターンは動作します。
// サーバーコンポーネントをクライアントコンポーネントの子またはpropとして渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.jsのページはデフォルトでサーバーコンポーネントです
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" highlight={11} switcher
// このパターンは動作します。
// サーバーコンポーネントをクライアントコンポーネントの子またはpropとして渡すことができます。
import ClientComponent from './client-component'
import ServerComponent from './server-component'

// Next.jsのページはデフォルトでサーバーコンポーネントです
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

</TabItem>
</Tabs>

このアプローチでは、`<ClientComponent>`と`<ServerComponent>`は分離されており、独立してレンダリングできます。この場合、子である`<ServerComponent>`はクライアントで`<ClientComponent>`がレンダリングされる前にサーバーでレンダリングされることができます。

> **Good to know:**
>
> - 親コンポーネントが再レンダリングされるときにネストされた子コンポーネントを再レンダリングしないようにするために、"コンテンツのリフトアップ"のパターンが使用されてきました。
> - `children` propに限らず、任意のpropを使用してJSXを渡すことができます。
