---
title: 'レンダリング'
description: 'Next.jsのレンダリング環境、戦略、ランタイムの違いを学びましょう。'
---

レンダリングは、あなたが書いたコードをユーザーインターフェースに変換するプロセスです。ReactとNext.jsを使用すると、コードの一部をサーバーまたはクライアントでレンダリングできるハイブリッドWebアプリケーションを作成できます。このセクションでは、これらのレンダリング環境、戦略、およびランタイムの違いを理解するのに役立ちます。

## 基本 {#fundamentals}

まず、次の3つの基本的なWebの概念に精通していると役立ちます：

- アプリケーションコードが実行される[環境](#rendering-environments)：サーバーとクライアント
- ユーザーがアプリケーションを訪問または操作したときに開始される[リクエスト-レスポンスライフサイクル](#request-response-lifecycle)
- サーバーとクライアントコードを分ける[ネットワーク境界](#network-boundary)

### レンダリング環境 {#rendering-environments}

Webアプリケーションがレンダリングされる環境は、クライアントとサーバーの2つがあります。

<Image
  alt="クライアントとサーバーの環境"
  srcLight="/docs/light/client-and-server-environments.png"
  srcDark="/docs/dark/client-and-server-environments.png"
  width="1600"
  height="672"
/>

- **クライアント**は、ユーザーのデバイス上のブラウザを指し、サーバーにアプリケーションコードをリクエストします。その後、サーバーからのレスポンスをユーザーインターフェースに変換します。
- **サーバー**は、データセンター内のコンピュータを指し、アプリケーションコードを保存し、クライアントからのリクエストを受け取り、適切なレスポンスを返します。

歴史的に、開発者はサーバーとクライアントのコードを書く際に異なる言語（例：JavaScript、PHP）やフレームワークを使用しなければなりませんでした。Reactを使用すると、**同じ言語**（JavaScript）と**同じフレームワーク**（例：Next.jsやお好みのフレームワーク）を使用できます。この柔軟性により、コンテキストを切り替えることなく、両方の環境でシームレスにコードを書くことができます。

しかし、各環境には独自の機能と制約があります。そのため、サーバーとクライアントのために書くコードは常に同じではありません。特定の操作（例：データフェッチやユーザー状態の管理）は、ある環境により適している場合があります。

これらの違いを理解することは、ReactとNext.jsを効果的に使用するための鍵です。これらの違いとユースケースについては、[Server](/docs/app/building-your-application/rendering/server-components)および[Client](/docs/app/building-your-application/rendering/client-components) Componentsのページで詳しく説明しますが、まずは基礎を築き続けましょう。

### リクエスト-レスポンスライフサイクル {#request-response-lifecycle}

広く言えば、すべてのWebサイトは同じ**リクエスト-レスポンスライフサイクル**に従います：

1. **ユーザーアクション：** ユーザーがWebアプリケーションと対話します。これはリンクをクリックする、フォームを送信する、またはブラウザのアドレスバーにURLを直接入力することが含まれます。
2. **HTTPリクエスト：** クライアントは、リクエストされているリソースに関する必要な情報、使用されているメソッド（例：`GET`、`POST`）、および必要に応じて追加データを含む[HTTP](https://developer.mozilla.org/docs/Web/HTTP)リクエストをサーバーに送信します。
3. **サーバー：** サーバーはリクエストを処理し、適切なリソースを返します。このプロセスには、ルーティング、データフェッチなどのステップが含まれる場合があります。
4. **HTTPレスポンス：** リクエストを処理した後、サーバーはクライアントにHTTPレスポンスを送信します。このレスポンスには、ステータスコード（リクエストが成功したかどうかをクライアントに伝える）とリクエストされたリソース（例：HTML、CSS、JavaScript、静的アセットなど）が含まれます。
5. **クライアント：** クライアントはリソースを解析してユーザーインターフェースをレンダリングします。
6. **ユーザーアクション：** ユーザーインターフェースがレンダリングされると、ユーザーはそれと対話でき、プロセス全体が再び始まります。

ハイブリッドWebアプリケーションを構築する際の主要な部分は、ライフサイクル内で作業をどのように分割するか、ネットワーク境界をどこに配置するかを決定することです。

### ネットワーク境界 {#network-boundary}

Web開発において、**ネットワーク境界**は異なる環境を分ける概念的な線です。たとえば、クライアントとサーバー、またはサーバーとデータストアです。

{/* 図：ネットワーク境界 */}

Reactでは、クライアント-サーバーネットワーク境界を最も理にかなった場所に配置することを選択できます。

舞台裏では、作業は2つの部分に分割されます：**クライアントモジュールグラフ**と**サーバーモジュールグラフ**です。サーバーモジュールグラフにはサーバーでレンダリングされるすべてのコンポーネントが含まれ、クライアントモジュールグラフにはクライアントでレンダリングされるすべてのコンポーネントが含まれます。

{/* 図：クライアントとサーバーモジュールグラフ */}

モジュールグラフを、アプリケーション内のファイルがどのように依存しているかを視覚的に表現するものとして考えると役立つかもしれません。

{/* たとえば、サーバー上で`Page.jsx`というファイルが`Button.jsx`というファイルをインポートしている場合、モジュールグラフは次のようになります： - 図 - */}

Reactの`"use client"`規約を使用して境界を定義できます。また、`"use server"`規約もあり、サーバーでいくつかの計算作業を行うようにReactに指示します。

## ハイブリッドアプリケーションの構築 {#building-hybrid-applications}

これらの環境で作業する際、アプリケーション内のコードの流れを**一方向**として考えると役立ちます。つまり、レスポンス中にアプリケーションコードは一方向に流れます：サーバーからクライアントへ。

{/* 図：レスポンスフロー */}

クライアントからサーバーにアクセスする必要がある場合は、同じリクエストを再利用するのではなく、サーバーに**新しい**リクエストを送信します。これにより、コンポーネントをどこでレンダリングするか、ネットワーク境界をどこに配置するかを理解しやすくなります。

実際には、このモデルは開発者に、サーバーで何を実行したいかを最初に考えさせ、その結果をクライアントに送信してアプリケーションをインタラクティブにすることを奨励します。

この概念は、同じコンポーネントtreeで[ClientとServer Componentsをインターリーブする方法](/docs/app/building-your-application/rendering/composition-patterns)を見ていくと、より明確になります。
