---
title: 'Partial Prerendering'
description: 'Partial Prerenderingにより、静的レンダリングと動的レンダリングの利点を組み合わせる方法を学びましょう。'
---

> **Note:** Partial Prerenderingは、カナリア版でのみ利用可能な**実験的**機能であり、変更される可能性があります。商用利用にはまだ準備が整っていません。

Partial Prerendering（PPR）は、静的コンポーネントと動的コンポーネントを同じルート内で組み合わせることを可能にします。

ビルド中、Next.jsはルートの可能な限り多くの部分をprerenderします。もし[動的](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)なコードが検出された場合、例えば受信リクエストの読み取りのように、関連するコンポーネントを[React Suspense](https://react.dev/reference/react/Suspense)境界でラップすることができます。その後、Suspense境界のフォールバックがprerenderされたHTMLに含まれます。

<Image
  alt="静的なナビゲーションと商品情報、動的なカートおよびおすすめ商品を表示する一部prerenderされた商品ページ"
  srcLight="/learn/light/thinking-in-ppr.png"
  srcDark="/learn/dark/thinking-in-ppr.png"
  width="1600"
  height="632"
/>

> **🎥 視聴：** なぜPPRが必要か、そしてそれがどのように機能するのか → [YouTube（10分）](https://www.youtube.com/watch?v=MTcPrTIBkpA)。

## 背景 {#background}

PPRは、Next.jsサーバーがprerenderされたコンテンツを即座に送信できるようにします。

クライアントからサーバーへのウォーターフォールを防ぐために、動的コンポーネントは初期prerenderを提供する間に並行してサーバーからストリーミングを開始します。これにより、クライアントのJavaScriptがブラウザで読み込まれる前に、動的コンポーネントのレンダリングが開始されます。

各動的コンポーネントごとに多くのHTTPリクエストを生成することを防ぐために、PPRは静的prerenderと動的コンポーネントを一つのHTTPリクエストに結合することが可能です。これにより、各動的コンポーネントのために複数のネットワーク往復が必要なくなります。

## Partial Prerenderingの使用 {#using-partial-prerendering}

### 漸進的採用（バージョン15） {#incremental-adoption-version-15}

Next.js 15では、`next.config.js`で`ppr`オプションを`incremental`に設定し、ファイルの先頭で`experimental_ppr`[ルート設定オプション](/docs/app/api-reference/file-conventions/route-segment-config)をエクスポートすることで、[レイアウト](/docs/app/building-your-application/routing/layouts-and-templates)や[ページ](/docs/app/api-reference/file-conventions/page)でPartial Prerenderingを漸進的に採用できます：

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="next.config.ts" switcher
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}

export default nextConfig
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="next.config.js" switcher
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}

module.exports = nextConfig
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { Suspense } from "react"
import { StaticComponent, DynamicComponent, Fallback } from "@/app/ui"

export const experimental_ppr = true

export default function Page() {
  return {
     <>
      <StaticComponent />
      <Suspense fallback={<Fallback />}>
        <DynamicComponent />
      </Suspense>
     </>
  };
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { Suspense } from "react"
import { StaticComponent, DynamicComponent, Fallback } from "@/app/ui"

export const experimental_ppr = true

export default function Page() {
  return {
     <>
      <StaticComponent />
      <Suspense fallback={<Fallback />}>
        <DynamicComponent />
      </Suspense>
     </>
  };
}
```

</TabItem>
</Tabs>

> **Good to know**:
>
> - `experimental_ppr`を持たないルートはデフォルトで`false`になり、PPRを使用してprerenderされません。各ルートについてPPRを明示的に選択する必要があります。
> - `experimental_ppr`は、ネストされたレイアウトやページを含むすべての子のルートセグメントに適用されます。すべてのファイルに追加する必要はなく、ルートのトップセグメントだけで十分です。
> - 子のセグメントに対してPPRを無効にするには、子のセグメントで`experimental_ppr`を`false`に設定できます。

## 動的コンポーネント {#dynamic-components}

`next build`中にルートのprerenderを作成する際、Next.jsはReact Suspenseでラップされた動的APIを必要とします。`fallback`がprerenderに含まれます。

例えば、`cookies`や`headers`のような関数を使用する場合：

<Tabs>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/user.js" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

</TabItem>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/user.tsx" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

</TabItem>
</Tabs>

このコンポーネントは、cookieを読み取るために受信リクエストを確認する必要があります。これをPPRで使用するには、コンポーネントをSuspenseでラップする必要があります：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>これはprerenderされます</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>これはprerenderされます</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

</TabItem>
</Tabs>

コンポーネントは値がアクセスされたときにのみ動的レンダリングに切り替わります。

例えば、`page`から`searchParams`を読み取って、その値を他のコンポーネントにpropとして渡すことができます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import { Table } from './table'

export default function Page({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  return (
    <section>
      <h1>これはprerenderされます</h1>
      <Table searchParams={searchParams} />
    </section>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { Table } from './table'

export default function Page({ searchParams }) {
  return (
    <section>
      <h1>これはprerenderされます</h1>
      <Table searchParams={searchParams} />
    </section>
  )
}
```

</TabItem>
</Tabs>

`table`コンポーネント内で、`searchParams`から値をアクセスすると、コンポーネントは動的に実行されます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/table.tsx" switcher
export async function Table({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/table.js" switcher
export async function Table({ searchParams }) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```

</TabItem>
</Tabs>
