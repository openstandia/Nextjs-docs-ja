---
title: 'ルーティングとナビゲーション'
description: 'Next.jsにおけるナビゲーションの動作と、Linkコンポーネントや`useRouter`フックの使い方を学びます。'
related:
  links:
    - app/building-your-application/caching
    - app/api-reference/config/typescript
---

Next.jsにおけるルート間の移動には、次の4つの方法があります：

- [`<Link>`コンポーネントを使用する](#link-component)
- [`useRouter`フックを使用する](#userouter-hook) ([Client Components](/docs/app/building-your-application/rendering/client-components))
- [`redirect`関数を使用する](#redirect-function) ([Server Components](/docs/app/building-your-application/rendering/server-components))
- ネイティブな[History APIを使用する](#using-the-native-history-api)

このページでは、それぞれのオプションの使い方を解説し、ナビゲーションの動作について詳しく探ります。

## `<Link>`コンポーネント {#link-component}

`<Link>`はHTMLの`<a>`タグを拡張し、[プリフェッチ](#2-prefetching)とクライアントサイドでのルート間のナビゲーションを提供する組み込みのコンポーネントです。これは、Next.jsでルート間を移動するための主な推奨方法です。

`next/link`からインポートし、コンポーネントに`href`プロップを渡すことで使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</TabItem>
</Tabs>

`<Link>`に渡すことのできる他のオプションプロップについては、[APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

## `useRouter()`フック {#userouter-hook}

`useRouter`フックは、[Client Components](/docs/app/building-your-application/rendering/client-components)からプログラム的にルートを変更することを可能にします。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

</TabItem>
</Tabs>

`useRouter`メソッドの一覧については、[APIリファレンス](/docs/app/api-reference/functions/use-router)を参照してください。

> **推奨事項:** 特定の要件がない限り、ルート間の移動には`<Link>`コンポーネントを使用してください。

## `redirect`関数 {#redirect-function}

[Server Components](/docs/app/building-your-application/rendering/server-components)の場合は、`redirect`関数を使用してください。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const id = (await params).id
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

</TabItem>
</Tabs>

> **知っておくべきこと**:
>
> - `redirect`はデフォルトで307（Temporary Redirect）ステータスコードを返します。Server Actionで使用される場合、POSTリクエストの成功ページにリダイレクトするためによく使われる303（See Other）を返します。
> - `redirect`は内部でエラーをスローするため、`try/catch`ブロックの外で呼び出す必要があります。
> - `redirect`はClient Componentsのレンダリングプロセス中に呼び出すことができますが、イベントハンドラ内では使用できません。その場合は[`useRouter`フック](#userouter-hook)を代わりに使用できます。
> - `redirect`は絶対URLを受け入れ、外部リンクにリダイレクトするために使用できます。
> - レンダリングプロセスの前にリダイレクトしたい場合は、[`next.config.js`](/docs/app/building-your-application/routing/redirecting#redirects-in-nextconfigjs)または[Middleware](/docs/app/building-your-application/routing/redirecting#nextresponseredirect-in-middleware)を使用してください。

[`redirect` APIリファレンス](/docs/app/api-reference/functions/redirect)を参照してください。

## ネイティブなHistory APIを使用する {#using-the-native-history-api}

Next.jsでは、ネイティブの[`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)および[`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState)メソッドを使用して、ページをリロードせずにブラウザのヒストリースタックを更新できます。

`pushState`と`replaceState`の呼び出しはNext.js Routerに統合され、[`usePathname`](/docs/app/api-reference/functions/use-pathname)や[`useSearchParams`](/docs/app/api-reference/functions/use-search-params)と同期できます。

### `window.history.pushState` {#window-history-pushstate}

ユーザーが以前の状態に戻ることができるように、ブラウザのヒストリースタックに新しいエントリを追加します。たとえば、商品リストを並べ替えるために使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

</TabItem>
</Tabs>

### `window.history.replaceState` {#window-history-replacestate}

現在のエントリをブラウザのヒストリースタックで置き換えます。ユーザーは以前の状態に戻ることはできません。たとえば、アプリケーションのロケールを切り替えるために使用できます：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // 例： '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // 例： '/en/about' または '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

</TabItem>
</Tabs>

## ルーティングとナビゲーションの動作 {#how-routing-and-navigation-works}

App Routerは、ルーティングとナビゲーションのためのハイブリッドアプローチを使用します。サーバー上で、あなたのアプリケーションコードはルートセグメントによって自動的に[コード分割](#1-code-splitting)されます。そして、クライアント上で、Next.jsはルートセグメントを[プリフェッチ](#2-prefetching)し、[キャッシュします](#3-caching)。これにより、ユーザーが新しいルートに移動する際に、ブラウザはページをリロードせずに、変更されるルートセグメントのみを再レンダリングし、ナビゲーションの体験とパフォーマンスが向上します。

### 1. コード分割 {#1-code-splitting}

コード分割により、アプリケーションコードを小さなバンドルに分割し、ブラウザによるダウンロードと実行を行います。これにより、データ転送量と各リクエストの実行時間が削減され、パフォーマンスが向上します。

[Server Components](/docs/app/building-your-application/rendering/server-components)は、アプリケーションコードがルートセグメントによって自動的にコード分割されることを可能にします。これにより、ナビゲーション時に現在のルートに必要なコードだけが読み込まれ、最適化されます。

### 2. プリフェッチ {#2-prefetching}

プリフェッチは、ユーザーがそのルートを訪れる前に、バックグラウンドでルートをプレロードする方法です。

Next.jsにおけるルートのプリフェッチには次の2つの方法があります：

- **`<Link>`コンポーネント**: ルートはユーザーのビューポートに表示されると自動的にプリフェッチされます。プリフェッチはページが最初にロードされた時やスクロールによってビューポートに表示された際に行われます。
- **`router.prefetch()`**: `useRouter`フックを使用してルートをプログラム的にプリフェッチできます。

`<Link>`のデフォルトのプリフェッチ動作（`prefetch`プロップが未指定または`null`に設定されている場合）は、[`loading.js`](/docs/app/api-reference/file-conventions/loading)の使用に応じて異なります。最初の`loading.js`ファイルまでの共有レイアウトがプリフェッチされ、最大`30秒`間キャッシュされます。これにより、完全な動的ルートをフェッチするコストが削減され、ユーザーに対してより良い視覚的フィードバックを提供するための[即時のローディング状態](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)を表示することができます。

プリフェッチを無効にするには、`prefetch`プロップを`false`に設定します。代わりに、ロード境界を超えた完全なページデータをプリフェッチするには、`prefetch`プロップを`true`に設定します。

詳しくは、[`<Link>` APIリファレンス](/docs/app/api-reference/components/link)を参照してください。

> **知っておくべきこと**:
>
> - プリフェッチは開発環境では有効ではなく、本番環境でのみ有効です。

### 3. キャッシュ {#3-caching}

Next.jsには、**クライアントサイドのメモリ内キャッシュ**である[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)があります。アプリ内を移動する際に、[プリフェッチされた](#2-prefetching)ルートセグメントと訪問済みのルートのReact Server Component Payloadがキャッシュに保存されます。

これにより、ナビゲーション時にはキャッシュが可能な限り再利用され、新たなリクエストをサーバーに送信する必要がなくなり、リクエスト数とデータ転送が減少し、パフォーマンスが向上します。

[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)の動作と設定方法について詳しく学びましょう。

### 4. 部分的なレンダリング {#4-partial-rendering}

部分的なレンダリングとは、ナビゲーション時に変更されたルートセグメントのみがクライアントでレンダリングされ、共有されるセグメントは保存されることを意味します。

例えば、`/dashboard/settings`と`/dashboard/analytics`という2つの兄弟ルート間を移動する場合は、`settings`ページがアンマウントされ、`analytics`ページが新しい状態でマウントされ、共有されている`dashboard`レイアウトは保存されます。この動作は、動的セグメント同士の2つのルート間でも同様にあります。例えば、`/blog/[slug]/page`で`/blog/first`から`/blog/second`へのナビゲーションの場合です。

<Image
  alt="部分的レンダリングの動作を示す図"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

部分的なレンダリングがなければ、各ナビゲーションはクライアントでフルページが再レンダリングされます。変化したセグメントのみをレンダリングすることで、データ転送量と実行時間を削減し、パフォーマンスが向上します。

### 5. ソフトナビゲーション {#5-soft-navigation}

ブラウザはページ間の移動を行う際に「ハードナビゲーション」を行います。Next.jsのApp Routerは「ソフトナビゲーション」をページ間で有効にし、変更されたルートセグメントのみが再レンダリング（部分的なレンダリング）されるようにします。これにより、ナビゲーション中にクライアントのReact状態が保持されます。

### 6. 前後のナビゲーション {#6-back-and-forward-navigation}

デフォルトでは、Next.jsは前後のナビゲーションに対するスクロール位置を保持し、[Router Cache](/docs/app/building-your-application/caching#client-side-router-cache)のルートセグメントを再利用します。

### 7. `pages/`と`app/`間のルーティング {#7-routing-between-pages-and-app}

`pages/`から`app/`へ増分的に移行する際、Next.jsのルーターが`pages/`と`app/`の間でのハードナビゲーションを自動的に処理します。`pages/`から`app/`への移行を検出するために、クライアントルーターフィルタがアプリルートの確率チェックを活用しています。これにより、時々偽陽性の反応が起こることがありますが、デフォルトでは非常に稀です。偽陽性の可能性は0.01％に設定されており、`next.config.js`内の`experimental.clientRouterFilterAllowedRate`オプションでカスタマイズできます。このケースとしての偽陽性の割合を下げれば、クライアントバンドルで生成されたフィルターのサイズは増加します。

また、`experimental.clientRouterFilter`を`false`に設定することで、この操作を完全に無効にして、`pages/`と`app/`間のルーティングを手動で管理することもできます。この機能を無効化した場合、appルートと重なるページ内の動的ルートには通常ナビゲートされません。
