---
title: 'Internationalization'
description: '複数の言語に対応するため、国際化されたルーティングとローカライズされたコンテンツを追加する。'
---

Next.jsは、複数の言語に対応するためのルーティングとコンテンツのレンダリングを設定できるようにします。サイトがさまざまなロケールに適応するためには、翻訳されたコンテンツ（ローカライズ）と国際化されたルートを含む必要があります。

## 用語解説 {#terminology}

- **Locale:** 言語と書式設定のプリファレンスのセットを識別するための識別子です。これは通常、ユーザーの希望する言語や地理的地域が含まれます。
  - `en-US`: アメリカで話される英語
  - `nl-NL`: オランダで話されるオランダ語
  - `nl`: 特定の地域指定なしのオランダ語

## ルーティングの概要 {#routing-overview}

ブラウザ内のユーザーの言語設定を利用してどのロケールを使用するかを選択することをお勧めします。言語の好みを変更すると、アプリケーションに送られる`Accept-Language`ヘッダーが変更されます。

たとえば、次のライブラリを使用して、受信した`Request`を調べ、`Headers`やサポートするローカル、デフォルトのローカルに基づいて、どのローカルを選択すべきかを判断できます。

```js title="middleware.js"
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'

let headers = { 'accept-language': 'en-US,en;q=0.5' }
let languages = new Negotiator({ headers }).languages()
let locales = ['en-US', 'nl-NL', 'nl']
let defaultLocale = 'en-US'

match(languages, locales, defaultLocale) // -> 'en-US'
```

ルーティングは、サブパス（`/fr/products`）やドメイン（`my-site.fr/products`）によって国際化できます。この情報を利用して、[Middleware](/docs/app/building-your-application/routing/middleware)の内部でローカルに基づいてユーザーをリダイレクトできます。

```js title="middleware.js"
import { NextResponse } from "next/server";

let locales = ['en-US', 'nl-NL', 'nl']

// 上記と同様、またはライブラリを使用して推奨ローカルを取得します
function getLocale(request) { ... }

export function middleware(request) {
  // パス名にサポートされているローカルがあるかどうかを確認します
  const { pathname } = request.nextUrl
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )

  if (pathnameHasLocale) return

  // ローカルがない場合はリダイレクトします
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`
  // 例: 受信リクエストが /products である場合
  // 新しいURLは /en-US/products になります
  return NextResponse.redirect(request.nextUrl)
}

export const config = {
  matcher: [
    // すべての内部パス (_next) をスキップします
    '/((?!_next).*)',
    // 任意: ルート (/) URL でのみ実行します
    // '/'
  ],
}
```

最後に、`app/` 内のすべての特別なファイルを `app/[lang]` の下にネストすることを確認してください。これにより、Next.js routerは異なるローカルをルートで動的に処理し、`lang`パラメータを各レイアウトとページに転送できるようになります。たとえば：

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[lang]/page.tsx" switcher
// 現在のローカルにアクセスできます
// 例: /en-US/products -> `lang` は "en-US"
export default async function Page({
  params,
}: {
  params: Promise<{ lang: string }>
}) {
  const lang = (await params).lang;
  return ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[lang]/page.js" switcher
// 現在のローカルにアクセスできます
// 例: /en-US/products -> `lang` は "en-US"
export default async function Page({ params }) {
  const lang = (await params).lang;
  return ...
}
```

</TabItem>
</Tabs>

root レイアウトも、新しいフォルダー（例：`app/[lang]/layout.js`）にネストできます。

## ローカライゼーション {#localization}

ユーザーの希望するローカルに基づいて表示されるコンテンツを変更すること、つまりローカライゼーションは、Next.jsに特有のものではありません。以下に説明するパターンは、任意のWebアプリケーションでも同様に動作します。

アプリケーション内で英語コンテンツとオランダ語コンテンツをサポートしたいと仮定します。いくつかのキーに対応したローカライズされた文字列をマッピングするオブジェクトとして、異なる2つの「辞書」を維持します。例えば：

```json title="dictionaries/en.json"
{
  "products": {
    "cart": "Add to Cart"
  }
}
```

```json title="dictionaries/nl.json"
{
  "products": {
    "cart": "Toevoegen aan Winkelwagen"
  }
}
```

リクエストされたローカルの翻訳をロードするための`getDictionary`関数を作成できます。

<Tabs>
<TabItem value="ts" label="TypeScript">

```ts title="app/[lang]/dictionaries.ts" switcher
import 'server-only'

const dictionaries = {
  en: () => import('./dictionaries/en.json').then((module) => module.default),
  nl: () => import('./dictionaries/nl.json').then((module) => module.default),
}

export const getDictionary = async (locale: 'en' | 'nl') =>
  dictionaries[locale]()
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js title="app/[lang]/dictionaries.js" switcher
import 'server-only'

const dictionaries = {
  en: () => import('./dictionaries/en.json').then((module) => module.default),
  nl: () => import('./dictionaries/nl.json').then((module) => module.default),
}

export const getDictionary = async (locale) => dictionaries[locale]()
```

</TabItem>
</Tabs>

現在選択されている言語に基づいて、レイアウトやページ内で辞書を取得できます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[lang]/page.tsx" switcher
import { getDictionary } from './dictionaries'

export default async function Page({
  params,
}: {
  params: Promise<{ lang: 'en' | 'nl' }>
}) {
  const lang = (await params).lang
  const dict = await getDictionary(lang) // en
  return <button>{dict.products.cart}</button> // Add to Cart
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[lang]/page.js" switcher
import { getDictionary } from './dictionaries'

export default async function Page({ params }) {
  const lang = (await params).lang
  const dict = await getDictionary(lang) // en
  return <button>{dict.products.cart}</button> // Add to Cart
}
```

</TabItem>
</Tabs>

`app/` ディレクトリ内のすべてのレイアウトとページはデフォルトで[Server Components](/docs/app/building-your-application/rendering/server-components)であるため、クライアント側のJavaScriptバンドルサイズに翻訳ファイルのサイズが影響を及ぼすことを気にする必要はありません。このコードはサーバーでのみ実行され、結果のHTMLだけがブラウザに送信されます。

## 静的生成 {#static-generation}

特定のローカルのセットのために静的ルートを生成するには、任意のページまたはレイアウトで`generateStaticParams`を使用できます。これはグローバルであり、たとえばroot レイアウトで以下のように行えます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/[lang]/layout.tsx" switcher
export async function generateStaticParams() {
  return [{ lang: 'en-US' }, { lang: 'de' }]
}

export default function RootLayout({
  children,
  params,
}: Readonly<{
  children: React.ReactNode
  params: { lang: 'en-US' | 'de' }
}>) {
  return (
    <html lang={params.lang}>
      <body>{children}</body>
    </html>
  )
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/[lang]/layout.js" switcher
export async function generateStaticParams() {
  return [{ lang: 'en-US' }, { lang: 'de' }]
}

export default function RootLayout({ children, params }) {
  return (
    <html lang={params.lang}>
      <body>{children}</body>
    </html>
  )
}
```

</TabItem>
</Tabs>

## リソース {#resources}

- [Minimal i18n routing and translations](https://github.com/vercel/next.js/tree/canary/examples/i18n-routing)
- [`next-intl`](https://next-intl.dev)
- [`next-international`](https://github.com/QuiiBz/next-international)
- [`next-i18n-router`](https://github.com/i18nexus/next-i18n-router)
- [`paraglide-next`](https://inlang.com/m/osslbuzt/paraglide-next-i18n)
- [`lingui`](https://lingui.dev)
