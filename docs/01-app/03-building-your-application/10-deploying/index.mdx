---
title: 'デプロイ'
description: 'Next.js アプリケーションを本番環境にデプロイする方法を学びます。マネージドまたはセルフホストのどちらかを選べます。'
---

{/* このドキュメントのコンテンツは、app router と pages router の間で共有されています。Pages Router に特有のコンテンツを追加するには `<PagesOnly>Content</PagesOnly>` コンポーネントを使用してください。共有コンテンツはコンポーネントでラップしないでください。 */}

おめでとうございます。いよいよ本番環境に出荷する準備が整いました。

[マネージド Next.js を Vercel でデプロイ](#managed-next-js-with-vercel)するか、自分で Node.js サーバー、Docker イメージ、あるいは静的 HTML ファイルとしてホストすることができます。`next start`を使用してデプロイする場合は、すべての Next.js 機能がサポートされます。

## プロダクションビルド {#production-builds}

`next build` を実行すると、本番環境用に最適化されたアプリケーションのバージョンが生成されます。HTML、CSS、および JavaScript ファイルがページに基づいて作成されます。JavaScript は**コンパイル**され、ブラウザのバンドルは [Next.js Compiler](/docs/architecture/nextjs-compiler) を使用して**圧縮**され、最高のパフォーマンスを実現し、[すべての最新ブラウザ](/docs/architecture/supported-browsers)をサポートします。

Next.js は、マネージドおよびセルフホストされた Next.js に使用される標準的なデプロイ出力を生成します。これにより、デプロイの両方の方法でサポートされるすべての機能が確保されます。次のメジャーバージョンでは、この出力を[Build Output API 仕様](https://vercel.com/docs/build-output-api/v3?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)に変換します。

## マネージド Next.js を Vercel で {#managed-next-js-with-vercel}

Next.js のクリエイターであり、メンテナである [Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) は、Next.js アプリケーションのためのマネージドインフラストラクチャと開発者向けのエクスペリエンスプラットフォームを提供します。

Vercel へのデプロイは設定不要で、グローバルなスケーラビリティ、可用性、およびパフォーマンスにさらなる強化をもたらします。ただし、セルフホストの場合でもすべての Next.js 機能はサポートされています。

[Next.js on Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) についてもっと知るか、[テンプレートを無料でデプロイする](https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)ことで試してみてください。

## セルフホスティング {#self-hosting}

Next.js をセルフホストするには、次の3つの方法があります：

- [Node.js サーバー](#node-js-server)
- [Docker コンテナ](#docker-image)
- [静的エクスポート](#static-html-export)

> **🎥 視聴:** Next.js のセルフホスティングについて詳しく学ぶ → [YouTube（45分）](https://www.youtube.com/watch?v=sIVL4JMqRfc)。

以下のプロバイダーと一緒に、コミュニティがメンテナンスするデプロイ例があります：

- [Deno](https://github.com/nextjs/deploy-deno)
- [DigitalOcean](https://github.com/nextjs/deploy-digitalocean)
- [Flightcontrol](https://github.com/nextjs/deploy-flightcontrol)
- [Fly.io](https://github.com/nextjs/deploy-fly)
- [GitHub Pages](https://github.com/nextjs/deploy-github-pages)
- [Google Cloud Run](https://github.com/nextjs/deploy-google-cloud-run)
- [Railway](https://github.com/nextjs/deploy-railway)
- [Render](https://github.com/nextjs/deploy-render)
- [SST](https://github.com/nextjs/deploy-sst)

### Node.js サーバー {#node-js-server}

Next.js は Node.js をサポートする任意のホスティングプロバイダーにデプロイできます。`package.json` に `"build"` および `"start"` スクリプトが含まれていることを確認してください：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

その後、`npm run build` を実行してアプリケーションをビルドします。最後に、`npm run start` を実行して Node.js サーバーを開始します。このサーバーはすべての Next.js 機能をサポートします。

### Docker イメージ {#docker-image}

Next.js は [Docker](https://www.docker.com/) コンテナをサポートする任意のホスティングプロバイダーにデプロイできます。このアプローチは、[Kubernetes](https://kubernetes.io/) のようなコンテナオーケストレーターにデプロイする際や、任意のクラウドプロバイダーでコンテナ内で実行する際に使用できます。

1. [Docker をインストール](https://docs.docker.com/get-docker/)します
2. [例をクローン](https://github.com/vercel/next.js/tree/canary/examples/with-docker)（または[マルチ環境の例](https://github.com/vercel/next.js/tree/canary/examples/with-docker-multi-env)）します
3. コンテナをビルドします: `docker build -t nextjs-docker .`
4. コンテナを実行します: `docker run -p 3000:3000 nextjs-docker`

Docker を介した Next.js は、すべての Next.js 機能をサポートします。

### 静的HTMLエクスポート {#static-html-export}

Next.js は、最初に静的なサイトまたはシングルページアプリケーション（SPA）として開始し、その後、サーバーを必要とする機能をオプションでアップグレードすることを可能にします。

Next.js がこの [静的エクスポート](/docs/app/building-your-application/deploying/static-exports) をサポートするため、HTML/CSS/JS の静的アセットを提供できる任意の Web サーバーでデプロイおよびホストが可能です。これには、AWS S3、Nginx、Apache などのツールが含まれます。

[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)として実行することは、サーバーを必要とする Next.js 機能をサポートしません。[詳細はこちら](/docs/app/building-your-application/deploying/static-exports#unsupported-features)。

> **知っておくと良いこと:**
>
> - [Server Components](/docs/app/building-your-application/rendering/server-components) は静的エクスポートでサポートされています。

## 機能 {#features}

### 画像最適化 {#image-optimization}

`next/image` を使用した [画像最適化](/docs/app/building-your-application/optimizing/images) は、`next start` を使用してデプロイする際にセルフホストで無設定で動作します。画像を最適化するための別のサービスを利用する場合は、[画像ローダーを設定](/docs/app/building-your-application/optimizing/images#loaders)することができます。

画像最適化は、`next.config.js` にカスタム画像ローダーを定義することで [静的エクスポート](/docs/app/building-your-application/deploying/static-exports#image-optimization)と一緒に使用できます。なお、画像はビルド中にではなく、実行時に最適化されます。

> **知っておくと良いこと:**
>
> - glibcベースのLinuxシステムでは、過剰なメモリ使用を防ぐために画像最適化が[追加の設定](https://sharp.pixelplumbing.com/install#linux-memory-allocator)を必要とする場合があります。
> - [最適化された画像のキャッシュ動作](/docs/app/api-reference/components/image#caching-behavior)とTTLの設定方法について詳しく学んでください。
> - 画像の最適化を無効にしても、`next/image`の他の利点を保持することもできます。たとえば、画像を別に自分で最適化する場合などです。

### ミドルウェア {#middleware}

[ミドルウェア](/docs/app/building-your-application/routing/middleware) は、`next start` を使用してデプロイする際にゼロ設定でセルフホストで動作します。入力されるリクエストへのアクセスが必要なため、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports)ではサポートされていません。

ミドルウェアは利用可能なすべての Node.js API のサブセットである [runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)を使用して、低遅延を確保するために行います。これはアプリケーションのすべてのルートやアセットの前に実行することができます。このランタイムは「エッジで」実行する必要はなく、単一のリージョンサーバで動作します。ミドルウェアを複数のリージョンで実行するには、追加の設定とインフラストラクチャが必要です。

すべての Node.js API を必要とするロジックを追加する場合（あるいは外部パッケージを使用する場合）、[layout](/docs/app/building-your-application/routing/layouts-and-templates#layouts)として、このロジックを[Server Component](/docs/app/building-your-application/rendering/server-components)に移動することができます。例えば、[ヘッダ](/docs/app/api-reference/functions/headers)の確認や[リダイレクト](/docs/app/api-reference/functions/redirect)などです。また、`next.config.js` でのヘッダ、cookie、クエリパラメータを使って[リダイレクト](/docs/app/api-reference/config/next-config-js/redirects#header-cookie-and-query-matching)や[書き換え](/docs/app/api-reference/config/next-config-js/rewrites#header-cookie-and-query-matching)を行うことができます。それがうまくいかない場合は、[カスタムサーバー](https://nextjs.org/docs/canary/pages/building-your-application/configuring/custom-server)を使用することもできます。

### 環境変数 {#environment-variables}

Next.js はビルドタイムおよびランタイムの両方の環境変数をサポートしています。

**デフォルトでは、環境変数はサーバーにのみ公開されます**。環境変数をブラウザに公開するには、`NEXT_PUBLIC_`で始める必要があります。ただし、これらのパブリック環境変数は、`next build`中にJavaScriptバンドルにインラインされます。

<PagesOnly>

ランタイム環境変数を読み取るには、`getServerSideProps` を使用するか、[App Router のインクリメンタルアダプション](/docs/app/building-your-application/upgrading/app-router-migration)を使用することをお勧めします。

</PagesOnly>

<AppOnly>

ダイナミックレンダリング中に、サーバーで環境変数を安全に読み取ることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.ts" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies、ヘッダ、その他のダイナミックAPIも
  // ダイナミックレンダリングを選択することになるため、
  // この環境変数は実行時に評価されます
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies、ヘッダ、その他のダイナミックAPIも
  // ダイナミックレンダリングを選択することになるため、
  // この環境変数は実行時に評価されます
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
</Tabs>

</AppOnly>

これにより、異なる値を持つ複数の環境を通じて昇進する単一の Docker イメージを使用することができます。

> **知っておくと良いこと:**
>
> - [`register` 関数](/docs/app/building-your-application/optimizing/instrumentation)を使用して、サーバーの起動時にコードを実行することができます。
> - [runtimeConfig](https://nextjs.org/docs/canary/pages/api-reference/config/next-config-js/runtime-configuration) オプションを使用することはお勧めしません。これはスタンドアロン出力モードでは動作しないためです。代わりに [App Router のインクリメンタルアダプション](/docs/app/building-your-application/upgrading/app-router-migration)を推奨します。

### キャッシュと ISR {#caching-and-isr}

Next.js は、レスポンス、生成された静的ページ、ビルド出力、および画像、フォント、スクリプトなどのその他の静的アセットをキャッシュすることができます。

キャッシュやページの再検証（[Incremental Static Regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)を使用）は、**同じ共有キャッシュ**を使用します。デフォルトでは、このキャッシュは Next.js サーバー上のファイルシステム（ディスク）に保存されます。**これはセルフホストの際に自動的に動作します**。ページおよび App Router の両方を使用します。

キャッシュされたページやデータを永続的なストレージに保存したり、複数のコンテナやインスタンスでキャッシュを共有したりする場合は、Next.js キャッシュの場所を構成することができます。

#### 自動キャッシング {#automatic-caching}

- Next.js は `public, max-age=31536000, immutable`の`Cache-Control`ヘッダを真正の不変アセットに設定します。これを上書きすることはできません。これらの不変ファイルには SHA ハッシュがファイル名に含まれており、安全に無期限にキャッシュすることができます。たとえば、[静的画像インポート](/docs/app/building-your-application/optimizing/images#local-images)です。画像の[TTLを設定](/docs/app/api-reference/components/image#caching-behavior)することができます。
- Incremental Static Regeneration (ISR) は、`s-maxage: <getStaticProps で再検証>, stale-while-revalidate`の`Cache-Control`ヘッダを設定します。この再検証時間は[`getStaticProps` 関数](https://nextjs.org/docs/canary/pages/building-your-application/data-fetching/get-static-props)で定義され、秒単位です。`revalidate: false`を設定すると、デフォルトで1年のキャッシュ期間になります。
- ダイナミックにレンダリングされたページは、ユーザー固有のデータがキャッシュされないように`private, no-cache, no-store, max-age=0, must-revalidate`の`Cache-Control` ヘッダを設定します。これは、App Router と Pages Router の両方に適用されます。[Draft Mode](/docs/app/building-your-application/configuring/draft-mode)も含まれます。

#### 静的アセット {#static-assets}

静的アセットを別のドメインまたは CDN にホストしたい場合は、`next.config.js`で`assetPrefix`[設定](/docs/app/api-reference/config/next-config-js/assetPrefix)を使用できます。Next.js は、JavaScript または CSS ファイルを取得する際にこのアセットプレフィックスを使用します。アセットを別のドメインに分離すると、DNS および TLS 解決に追加の時間がかかるというデメリットがあります。

[`assetPrefix` について詳しく学ぶ](/docs/app/api-reference/config/next-config-js/assetPrefix)。

#### キャッシュの設定 {#configuring-caching}

デフォルトでは、生成されたキャッシュアセットはメモリ（デフォルトで50MB）とディスクに保存されます。Kubernetes などのコンテナオーケストレーションプラットフォームを使用して Next.js をホストしている場合、各ポッドはキャッシュのコピーを持ちます。ポッド間でキャッシュがデフォルトで共有されていないため、表示される古いデータを防ぐために、Next.js キャッシュを設定してキャッシュハンドラを提供し、メモリキャッシュを無効にすることができます。

セルフホストの際に ISR/データキャッシュの場所を設定するには、`next.config.js`ファイルでカスタムハンドラを設定できます：

```jsx title="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // デフォルトのメモリキャッシュを無効にする
}
```

次に、プロジェクトのルートに`cache-handler.js`を作成します。例は以下のとおりです：

```jsx title="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // これは永続ストレージなどのどこにでも保存できます
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // これは永続ストレージなどのどこにでも保存できます
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // tagsは文字列または文字列の配列です
    tags = [tags].flat()
    // キャッシュ内のすべてのエントリを反復する
    for (let [key, value] of cache) {
      // 指定されたタグが値のタグに含まれている場合、このエントリを削除する
      if (value.tags.some((tag) => tags.include(tag))) {
        cache.delete(key)
      }
    }
  }
}
```

カスタムキャッシュハンドラを使用すると、Next.js アプリケーションをホストするすべてのポッド間で一貫性を確保することができます。たとえば、[Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis)や AWS S3 など、どこにでもキャッシュされた値を保存することができます。

> **知っておくと良いこと:**
>
> - `revalidatePath`はキャッシュタグの上に位置する便利なレイヤーです。`revalidatePath`を呼び出すと、提供されたページの特別なデフォルトタグで`revalidateTag`関数が呼び出されます。

### ビルドキャッシュ {#build-cache}

Next.js は、`next build`中にアプリケーションのどのバージョンが提供されているかを識別するためのIDを生成します。同じビルドを複数のコンテナで使用し、起動する必要があります。

環境の各ステージに対してリビルドを行っている場合、コンテナ間で使用する一貫したビルドIDを生成する必要があります。`next.config.js`で`generateBuildId`コマンドを使用してください：

```jsx title="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // これは最新のgitハッシュを使用するなど、何でもかまいません
    return process.env.GIT_HASH
  },
}
```

### バージョンスキュー {#version-skew}

Next.js は、自動的に[バージョンスキュー](https://www.industrialempathy.com/posts/version-skew/)のほとんどのインスタンスを緩和し、検出された場合に新しいアセットを取得するためにアプリケーションを自動的にリロードします。たとえば、`deploymentId`の不一致がある場合、ページ間の遷移は事前にフェッチされた値を使用するのではなく、ハードなナビゲーションを実行します。

アプリケーションがリロードされると、状態がデザインされていない限り、ページナビゲーション間でアプリケーションの状態が失われる可能性があります。たとえば、URL 状態やローカルストレージを使用することで、ページをリフレッシュした後も状態を保持できます。ただし、`useState`のようなコンポーネントの状態は、ナビゲーションで失われます。

Vercel は、より古いクライアントに対して、新しいバージョンがデプロイされた後でも、前のバージョンのアセットと機能を利用可能にして、Next.js アプリケーションに追加の[スキュー保護](https://vercel.com/docs/deployments/skew-protection?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)を提供します。

各リクエストが`?dpl`クエリ文字列または`x-deployment-id`ヘッダを使用するようにするために、`next.config.js`ファイルで`deploymentId`プロパティを手動で設定できます。

<AppOnly>

### ストリーミングとサスペンス {#streaming-and-suspense}

Next.js App Router は、セルフホストの際に[ストリーミングレスポンス](/docs/app/building-your-application/routing/loading-ui-and-streaming)をサポートしています。Nginx や類似のプロキシを使用している場合は、バッファリングを無効にしてストリーミングを有効にするために設定する必要があります。

たとえば、`X-Accel-Buffering`を`no`に設定することで、Nginxでのバッファリングを無効にできます：

```js title="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

### 部分プリアレンダリング {#partial-prerendering}

[部分プリアレンダリング（実験中）](/docs/app/building-your-application/rendering/partial-prerendering)は、Next.js でデフォルトで機能し、CDN 機能ではありません。これは Node.js サーバーとして（`next start`を通じて）デプロイする場合や Docker コンテナで使用する場合に含まれます。

### CDNとの使用 {#usage-with-cdns}

Next.js アプリケーションの前に CDN を使用する場合、ダイナミックAPIがアクセスされたときにページに`Cache-Control: private`レスポンスヘッダが含まれます。これにより、結果のHTMLページが非キャッシュ可能としてマークされます。ページが完全に静的へプリアレンダリングされると、CDNでキャッシュできるように`Cache-Control: public`を含むことがあります。

静的コンポーネントとダイナミックコンポーネントのミックスが不要な場合、ルート全体を静的にして出力 HTML を CDN でキャッシュできます。この自動静的最適化は、ダイナミックAPIが使用されていない場合に`next build`を実行する際のデフォルトの動作です。

</AppOnly>

<AppOnly>

### `after` {#after}

セルフホスト時に `next start` を使用する場合、[`after`](/docs/app/api-reference/functions/after) は完全にサポートされています。

サーバーを停止する際、`SIGINT` または `SIGTERM` シグナルを送信して待機することで、適切にシャットダウンします。これにより、Next.js サーバーは `after` 内で使用される保留中のコールバック関数やプロミスの終了まで待機します。

カスタムインフラストラクチャで `after` を使用したい場合は、プロバイダーのドキュメントを確認して、`after` のサポートを確認してください。

<details id="after-serverless">
  <summary>`after` をサポートするサーバーレスプラットフォームの参照</summary>
  サーバーレスコンテキストで `after` を使用するには、レスポンスが送信された後に非同期タスクが完了するのを待つ必要があります。Next.js および Vercel では、`waitUntil(promise)` というプリミティブを使用して、すべてのプロミスが[`waitUntil`](https://vercel.com/docs/functions/functions-api-reference#waituntil)に渡されたプロミスが解決されるまでサーバーレスのコールを延長することでこれを実現します。
  
  ユーザーが `after` を実行できるようにするために、アナログ的に動作する`waitUntil`の実装を提供する必要があります。
  
  `after` が呼び出されると、Next.js は次のようにして `waitUntil` にアクセスします：
  
  ```jsx
  const RequestContext = globalThis[Symbol.for('@next/request-context')]
  const contextValue = RequestContext?.get()
  const waitUntil = context?.waitUntil
  ```
  
  これは、`globalThis[Symbol.for('@next/request-context')]` が次のようなオブジェクトを含む必要があることを意味します：
  
  ```tsx
  type NextRequestContext = {
    get(): NextRequestContextValue | undefined
  }
  
  type NextRequestContextValue = {
    waitUntil?: (promise: Promise<any>) => void
  }
  ```
  
  こちらは実装の例です：
  
  ```tsx
  import { AsyncLocalStorage } from 'node:async_hooks'
  
  const RequestContextStorage = new AsyncLocalStorage<NextRequestContextValue>()
  
  // Next.js が使用するアクセサを定義および注入する
  const RequestContext: NextRequestContext = {
    get() {
      return RequestContextStorage.getStore()
    },
  }
  globalThis[Symbol.for('@next/request-context')] = RequestContext
  
  const handler = (req, res) => {
    const contextValue = { waitUntil: YOUR_WAITUNTIL }
    // 値を提供
    return RequestContextStorage.run(contextValue, () => nextJsHandler(req, res))
  }
  ```
</details>

</AppOnly>

<PagesOnly>

## 手動適切シャットダウン {#manual-graceful-shutdowns}

セルフホストするとき、サーバが `SIGTERM` または `SIGINT` シグナルを受け取るときにコードを実行したいかもしれません。

環境変数 `NEXT_MANUAL_SIG_HANDLE` を `true` に設定し、そのシグナルのハンドラーを `_document.js` ファイルの内部で登録することができます。この環境変数は `.env` ファイルではなく `package.json` スクリプト内で直接登録する必要があります。

> **知っておくと良いこと**: マニュアルシグナルハンドリングは `next dev` では利用できません。

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js title="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('Received SIGTERM: cleaning up')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('Received SIGINT: cleaning up')
    process.exit(0)
  })
}
```

</PagesOnly>
