---
title: 'デプロイ中'
description: 'Next.js アプリをプロダクションへデプロイする方法を学びます；マネージドおよびセルフホストの両方に対応。'
---

{/* このドキュメントの内容は app router と pages router の両方で共有されます。Pages Router に特化したコンテンツを追加するには、`<PagesOnly>Content</PagesOnly>` コンポーネントを使用してください。共有コンテンツはコンポーネントで囲むべきではありません。 */}

おめでとうございます、プロダクションへの出荷の準備が整いました。

管理された [Next.js を Vercel でデプロイ](#managed-nextjs-with-vercel)することも、Node.js サーバー、Docker イメージ、または静的 HTML ファイルでセルフホストすることもできます。`next start` を使用してデプロイする場合、すべての Next.js 機能がサポートされます。

## プロダクションビルド {#production-builds}

`next build` を実行すると、プロダクション用に最適化されたアプリケーションのバージョンが生成されます。HTML、CSS、および JavaScript ファイルがページに基づいて作成されます。JavaScript は **コンパイル** され、ブラウザのバンドルは [Next.js Compiler](/docs/architecture/nextjs-compiler) を使用して **圧縮** され、最高のパフォーマンスを達成し [すべての最新ブラウザ](/docs/architecture/supported-browsers) をサポートします。

Next.js は、管理されたものおよびセルフホストされたものの標準的なデプロイ出力を生成します。これにより、どちらのデプロイ方法においてもすべての機能がサポートされることが保証されます。次のメジャーバージョンでは、この出力を [Build Output API 仕様](https://vercel.com/docs/build-output-api/v3?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) へと変換する予定です。

## 管理された Next.js を Vercel で {#managed-next-js-with-vercel}

Next.js の開発者であり保守者である [Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) は、Next.js アプリケーションのための管理されたインフラストラクチャと開発者体験プラットフォームを提供しています。

Vercel へのデプロイは設定不要で、グローバルにスケーラビリティ、可用性、パフォーマンスを向上させる追加の強化が提供されます。ただし、セルフホストでもすべての Next.js 機能がサポートされています。

[Next.js on Vercel](https://vercel.com/docs/frameworks/nextjs?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) についてもっと学びたい方や [無料でテンプレートをデプロイ](https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=docs&utm_campaign=next-website) して試してみたい方はこちらをご覧ください。

## セルフホスティング {#self-hosting}

Next.js をセルフホストする方法は3つあります：

- [Node.js サーバー](#nodejs-server)
- [Docker コンテナ](#docker-image)
- [静的エクスポート](#static-html-export)

> **🎥 視聴:** Next.js のセルフホスティングについてもっと学ぶ → [YouTube (45 分)](https://www.youtube.com/watch?v=sIVL4JMqRfc).

以下のプロバイダーでコミュニティによって維持されているデプロイの例があります：

- [Deno](https://github.com/nextjs/deploy-deno)
- [DigitalOcean](https://github.com/nextjs/deploy-digitalocean)
- [Flightcontrol](https://github.com/nextjs/deploy-flightcontrol)
- [Fly.io](https://github.com/nextjs/deploy-fly)
- [GitHub Pages](https://github.com/nextjs/deploy-github-pages)
- [Google Cloud Run](https://github.com/nextjs/deploy-google-cloud-run)
- [Railway](https://github.com/nextjs/deploy-railway)
- [Render](https://github.com/nextjs/deploy-render)
- [SST](https://github.com/nextjs/deploy-sst)

### Node.js サーバー {#node-js-server}

Next.js は Node.js をサポートする任意のホスティングプロバイダーにデプロイできます。`package.json` に `"build"` と `"start"` スクリプトがあることを確認してください：

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

次に、`npm run build` を実行してアプリケーションをビルドします。最後に、`npm run start` を実行して Node.js サーバーを起動します。このサーバーはすべての Next.js 機能をサポートしています。

### Docker イメージ {#docker-image}

Next.js は、[Docker](https://www.docker.com/) コンテナをサポートする任意のホスティングプロバイダーにデプロイできます。このアプローチは、[Kubernetes](https://kubernetes.io/) のようなコンテナオーケストレーターにデプロイする場合や、任意のクラウドプロバイダーでコンテナ内で実行する場合に使用できます。

1. [Docker をインストール](https://docs.docker.com/get-docker/) します
2. [例をクローン](https://github.com/vercel/next.js/tree/canary/examples/with-docker)（または[マルチ環境の例](https://github.com/vercel/next.js/tree/canary/examples/with-docker-multi-env)）します
3. Docker コンテナをビルド: `docker build -t nextjs-docker .`
4. コンテナを実行: `docker run -p 3000:3000 nextjs-docker`

Docker を使用した Next.js はすべての Next.js 機能をサポートしています。

### 静的 HTML エクスポート {#static-html-export}

Next.js は静的サイトまたはシングルページアプリケーション (SPA) として開始し、後でサーバーが必要な機能を任意でアップグレードすることができます。

Next.js は [静的エクスポート](/docs/app/building-your-application/deploying/static-exports) をサポートしているため、HTML/CSS/JS の静的アセットを提供できる任意の Web サーバーにデプロイおよびホスティングできます。これには AWS S3、Nginx、Apache などのツールが含まれます。

[静的エクスポート](/docs/app/building-your-application/deploying/static-exports) として実行する場合、Next.js のサーバーが必要な機能はサポートされません。[詳細を読む](/docs/app/building-your-application/deploying/static-exports#unsupported-features).

> **Good to know:**
>
> - [Server Components](/docs/app/building-your-application/rendering/server-components) は静的エクスポートを使用してサポートされます。

## 機能 {#features}

### 画像最適化 {#image-optimization}

`next/image` による [画像最適化](/docs/app/building-your-application/optimizing/images) は、`next start` を使用してデプロイする際、ゼロ設定でセルフホストに対応します。画像を最適化するための別サービスを希望する場合は、[画像ローダーの設定](/docs/app/building-your-application/optimizing/images#loaders) が可能です。

画像最適化は、`next.config.js` にカスタム画像ローダーを定義することによって [静的エクスポート](/docs/app/building-your-application/deploying/static-exports#image-optimization) と共に使用できます。注意すべき点として、画像はビルド時ではなくランタイム時に最適化されます。

> **Good to know:**
>
> - glibc ベースの Linux システムでは、画像最適化の過度のメモリ使用を防ぐために[追加設定](https://sharp.pixelplumbing.com/install#linux-memory-allocator)が必要な場合があります。
> - [最適化された画像のキャッシング動作](/docs/app/api-reference/components/image#caching-behavior) について学び、TTL を設定する方法を学ぶことができます。
> - 画像を別に最適化する場合は、[画像最適化を無効化](/docs/app/api-reference/components/image#unoptimized) しながらも `next/image` の他の利点を保持することができます。

### ミドルウェア {#middleware}

[ミドルウェア](/docs/app/building-your-application/routing/middleware) は、`next start` を使用してデプロイする際にセルフホストでゼロ設定で動作します。要求の着信アクセスが必要なため、[静的エクスポート](/docs/app/building-your-application/deploying/static-exports) の使用時にはサポートされません。

ミドルウェアは、アプリケーションのすべてのルートまたはアセットの前で実行される可能性を持つため、低レイテンシーを保証するためにすべての利用可能な Node.js API のサブセットである [ランタイム](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes) を使用します。このランタイムは「エッジ」で実行する必要はなく、単一リージョンのサーバーで動作します。ミドルウェアを複数地域で実行するには追加の設定とインフラストラクチャが必要です。

すべての Node.js API が必要なロジックを追加する（または外部パッケージを使用する）場合、[Server Component](/docs/app/building-your-application/rendering/server-components) として [layout](/docs/app/building-your-application/routing/layouts-and-templates#layouts) にこのロジックを移動できるかもしれません。例えば、[ヘッダー](/docs/app/api-reference/functions/headers) の確認や [リダイレクト](/docs/app/api-reference/functions/redirect) を行う場合です。また、`next.config.js` を介してヘッダー、クッキー、またはクエリパラメータを使用して [リダイレクト](/docs/app/api-reference/config/next-config-js/redirects#header-cookie-and-query-matching) や [書き換え](/docs/app/api-reference/config/next-config-js/rewrites#header-cookie-and-query-matching) を行うこともできます。これがうまくいかない場合は、[カスタムサーバー](https://nextjs.org/docs/canary/pages/building-your-application/configuring/custom-server) を使用することもできます。

### 環境変数 {#environment-variables}

Next.js はビルドタイムとランタイムの環境変数の両方をサポートできます。

**デフォルトでは、環境変数はサーバーでのみ利用可能です。** 環境変数をブラウザに公開するには、`NEXT_PUBLIC_` プレフィックスを付ける必要があります。ただし、これらの公開環境変数は `next build` 中に JavaScript のバンドルにインライン化されます。

<PagesOnly>

ランタイム環境変数を読み取るには、`getServerSideProps` を使用するか、[アプリケーションルーターを段階的に採用](/docs/app/building-your-application/upgrading/app-router-migration)することをお勧めします。

</PagesOnly>

<AppOnly>

動的レンダリング中にサーバーで安全に環境変数を読み取ることができます。

<Tabs>
<TabItem value="tsx" label="TypeScript">

```tsx title="app/page.ts" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies, headers, and other Dynamic APIs
  // will also opt into dynamic rendering, meaning
  // this env variable is evaluated at runtime
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
<TabItem value="jsx" label="JavaScript">

```jsx title="app/page.js" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies, headers, and other Dynamic APIs
  // will also opt into dynamic rendering, meaning
  // this env variable is evaluated at runtime
  const value = process.env.MY_VALUE
  // ...
}
```

</TabItem>
</Tabs>

</AppOnly>

これにより、異なる値の複数の環境を経て昇進可能な単一の Docker イメージを使用できます。

> **Good to know:**
>
> - [`register` 関数](/docs/app/building-your-application/optimizing/instrumentation) を使用してサーバーのスタートアップでコードを実行できます。
> - [runtimeConfig](https://nextjs.org/docs/canary/pages/api-reference/config/next-config-js/runtime-configuration) オプションの使用は、スタンドアロン出力モードと互換性がないため推奨されません。代わりに、アプリルーターを [段階的に採用](/docs/app/building-your-application/upgrading/app-router-migration)することを推奨します。

### キャッシングと ISR {#caching-and-isr}

Next.js はレスポンス、生成された静的ページ、ビルド出力、画像、フォント、スクリプトなどの他の静的アセットをキャッシュできます。

ページのキャッシングと再検証（[Incremental Static Regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration) を使用）は、**同じ共有キャッシュ** を使用します。デフォルトでは、このキャッシュは Next.js サーバー上のファイルシステム（ディスク上）に保存されます。**セルフホスティングする場合は、これが自動的に動作します。** Pages と App router の両方を使用して。

キャッシュされたページとデータを持続的にストレージに保存したり、複数のコンテナまたは Next.js アプリケーションのインスタンス間でキャッシュを共有したりしたい場合は、Next.js キャッシュの場所を設定できます。

#### 自動キャッシング {#automatic-caching}

- Next.js は、`public, max-age=31536000, immutable`の`Cache-Control`ヘッダーを本当に不変なアセットに設定します。これをオーバーライドすることはできません。これらの不変なファイルにはファイル名に SHA ハッシュが含まれているため、安全に無期限にキャッシュすることができます。例えば、[静的画像インポート](/docs/app/building-your-application/optimizing/images#local-images)です。画像の[TTLを設定](/docs/app/api-reference/components/image#caching-behavior)できます。
- Incremental Static Regeneration (ISR) は、`s-maxage: <revalidate in getStaticProps>, stale-while-revalidate`の`Cache-Control`ヘッダーを設定します。この再検証時間は、秒単位で`getStaticProps`関数内で定義されます。`revalidate: false`を設定した場合、デフォルトで 1年間のキャッシュ期間になります。
- 動的にレンダリングされたページは、`Cache-Control`ヘッダーを設定し、ユーザー固有のデータがキャッシュされないようにするために`private, no-cache, no-store, max-age=0, must-revalidate`を設定します。これにより、App Router と Pages Router の両方に適用されます。また、[Draft Mode](/docs/app/building-your-application/configuring/draft-mode)を含みます。

#### 静的アセット {#static-assets}

別のドメインまたは CDN で静的アセットをホストしたい場合、`assetPrefix` [設定](/docs/app/api-reference/config/next-config-js/assetPrefix)を`next.config.js`で使用できます。Next.js は、このアセットプリフィックスを使用してJavaScript または CSS ファイルを取得します。アセットを別のドメインに分離することは、DNS および TLS 解決に余分な時間を費やすという欠点を伴います。

[`assetPrefix`について学ぶ](/docs/app/api-reference/config/next-config-js/assetPrefix)。

#### キャッシングの設定 {#configuring-caching}

デフォルトでは、生成されたキャッシュアセットはメモリ（デフォルトで50mb）とディスクに格納されます。Next.js を Kubernetes のようなコンテナオーケストレーションプラットフォームでホスティングする場合、各ポッドにはキャッシュのコピーが存在します。デフォルトでポッド間でキャッシュが共有されないため、古いデータが表示されるのを防ぐために、Next.js キャッシュを設定してキャッシュハンドラを提供し、インメモリキャッシングを無効にできます。

ISR/データキャッシュの場所をセルフホストで設定するには、`next.config.js` ファイルにカスタムハンドラを設定できます：

```jsx title="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),

  cacheMaxMemorySize: 0, // デフォルトのインメモリキャッシングを無効化
}
```

その後、プロジェクトのルートに `cache-handler.js` を作成してください、例えば：

```jsx title="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // これは持続可能なストレージのようにどこにでも保存できます
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // これは持続可能なストレージのようにどこにでも保存できます
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // タグは文字列か文字列の配列です
    tags = [tags].flat()
    // キャッシュ内のすべてのエントリを繰り返します
    for (let [key, value] of cache) {
      // 値のタグが特定のタグを含んでいる場合、このエントリを削除
      if (value.tags.some((tag) => tags.include(tag))) {
        cache.delete(key)
      }
    }
  }
}
```

カスタムキャッシュハンドラを使用することで、Next.js アプリケーションをホスティングするすべてのポッド間で一貫性を保証することができます。たとえば、キャッシュされた値を [Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis) や AWS S3 のようにどこにでも保存できます。

> **Good to know:**
>
> - `revalidatePath` はキャッシュタグの上の便利なレイヤーです。`revalidatePath` を呼び出すと、指定されたページの特定のデフォルトタグを持つ `revalidateTag` 関数が呼び出されます。

### ビルドキャッシュ {#build-cache}

Next.js は `next build` 中に ID を生成して、どのバージョンのアプリケーションが提供されているかを識別します。同じビルドが使用され、複数のコンテナを起動する必要があります。

環境の各ステージ用に再ビルドする場合、コンテナ間で使用するために一貫したビルド ID を生成する必要があります。`next.config.js` の `generateBuildId` コマンドを使用します：

```jsx title="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // これは最新の Git ハッシュなど、何でもよいです
    return process.env.GIT_HASH
  },
}
```

### バージョンスキュー {#version-skew}

Next.js は自動的に [バージョンスキュー](https://www.industrialempathy.com/posts/version-skew/) のほとんどのインスタンスを緩和し、自動的にアプリケーションをリロードして新しいアセットを取得します。たとえば、`deploymentId` に不一致がある場合、ページ間の遷移は事前取得された値を使用せずにハードナビゲーションを行います。

アプリケーションがリロードされると、ページのナビゲーション間で持続しないように設計された場合にアプリケーションの状態が失われる可能性があります。たとえば、URL 状態やローカルストレージを使用することで、ページの再読み込み後も状態を保持できます。ただし、`useState` などのコンポーネント状態はそのようなナビゲーションで失われます。

Vercel は、新しいバージョンがデプロイされた後でも、以前のバージョンからのアセットと機能が古いクライアントに引き続き利用可能であることを保証するために [スキュー保護](https://vercel.com/docs/deployments/skew-protection?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)を提供します。

すべてのリクエストが `?dpl` クエリ文字列または `x-deployment-id` ヘッダーを使用するようにするには、`next.config.js` ファイルで `deploymentId` プロパティを手動で設定できます。

<AppOnly>

### ストリーミングとサスペンス {#streaming-and-suspense}

Next.js App Router はセルフホスト時に[ストリーミング応答](/docs/app/building-your-application/routing/loading-ui-and-streaming)をサポートします。Nginx や同様のプロキシを使用している場合、ストリーミングを有効にするためにバッファリングを無効にするように設定が必要です。

たとえば、Nginx でバッファリングを無効にするには `X-Accel-Buffering` を `no` に設定します：

```js title="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

### 部分的プレンダリング {#partial-prerendering}

[部分的プレンダリング (実験的)](/docs/app/building-your-application/rendering/partial-prerendering) は Next.js でデフォルトで動作し、CDN 機能ではありません。これには Node.js サーバーとしてのデプロイ（`next start` 経由）が含まれ、Docker コンテナで使用される場合も有効です。

### CDN での使用 {#usage-with-cdns}

Next.js アプリケーションの前に CDN を使用する場合、ページは動的APIがアクセスされたときに `Cache-Control: private` レスポンスヘッダーを含みます。これにより、結果の HTML ページがキャッシュ不可能としてマークされます。ページが完全に静的にプレンダリングされる場合は、CDN 上でページをキャッシュできるように `Cache-Control: public` を含みます。

静的および動的コンポーネントの両方を必要としない場合、ルート全体を静的にし、出力された HTML を CDN 上でキャッシュすることができます。この自動的な静的最適化は、動的APIが使用されていない場合に `next build` を実行する際のデフォルト行動です。

</AppOnly>

<AppOnly>

### `after` {#after}

[`after`](/docs/app/api-reference/functions/after) は、`next start` でのセルフホスト時に完全にサポートされています。

サーバーを停止する場合、`SIGINT` または `SIGTERM` シグナルを送信して待機することで優雅なシャットダウンを確実にしてください。これにより、Next.js サーバーは `after` 内で使用されるペンディングのコールバック関数またはプロミスの終了を待つことができます。

カスタムインフラストラクチャで `after` を使用したい場合、提供者のドキュメントで `after` のサポートを確認してください。

<details id="after-serverless">
  <summary>サーバーレスプラットフォームで `after` をサポートするためのリファレンス</summary>
  サーバーレスコンテキストでの `after` の使用は、レスポンスが送信された後に非同期タスクが終了するのを待つ必要があります。Next.js と Vercelでは、[`waitUntil`](https://vercel.com/docs/functions/functions-api-reference#waituntil) に渡されたすべてのプロミスが解決するまで、サーバーレス呼び出しの寿命を延長するプリミティブである `waitUntil(promise)` を使用してこれを実現しています。
  
  ユーザーが `after` を実行できるようにしたい場合、`waitUntil` のアナロジーに動作する独自の実装を提供する必要があります。
  
  `after`が呼び出されたとき、Next.jsは `waitUntil` にこのようにアクセスします：
  
  ```jsx
  const RequestContext = globalThis[Symbol.for('@next/request-context')]
  const contextValue = RequestContext?.get()
  const waitUntil = context?.waitUntil
  ```
  
  これは、`globalThis[Symbol.for('@next/request-context')]` がこのようなオブジェクトを含むことを期待しています：
  
  ```tsx
  type NextRequestContext = {
    get(): NextRequestContextValue | undefined
  }
  
  type NextRequestContextValue = {
    waitUntil?: (promise: Promise<any>) => void
  }
  ```
  
  実装の例を以下に示します。
  
  ```tsx
  import { AsyncLocalStorage } from 'node:async_hooks'
  
  const RequestContextStorage = new AsyncLocalStorage<NextRequestContextValue>()
  
  // next.js が使用するアクセサを定義および注入
  const RequestContext: NextRequestContext = {
    get() {
      return RequestContextStorage.getStore()
    },
  }
  
  globalThis[Symbol.for('@next/request-context')] = RequestContext
  
  const handler = (req, res) => {
    const contextValue = { waitUntil: YOUR_WAITUNTIL }
    // 値を提供
    return RequestContextStorage.run(contextValue, () => nextJsHandler(req, res))
  }
  ```
</details>

</AppOnly>

<PagesOnly>

## 手動での優雅なシャットダウン {#manual-graceful-shutdowns}

セルフホスト時には、サーバーが `SIGTERM` または `SIGINT` シグナルでシャットダウンする際にコードを実行したい場合があります。

`NEXT_MANUAL_SIG_HANDLE` 環境変数を `true` に設定し、\_document.js ファイル内でそのシグナルのハンドラを登録できます。環境変数を `.env` ファイルではなく、`package.json` スクリプト内で直接登録する必要があります。

> **Good to know**: 次の dev で手動のシグナル処理は利用できません。

```json title="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js title="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('Received SIGTERM: cleaning up')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('Received SIGINT: cleaning up')
    process.exit(0)
  })
}
```

</PagesOnly>
